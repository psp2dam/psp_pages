const Vi="modulepreload",Ki=function(e){return"/psp_pages/"+e},et={},y=function(r,n,a){if(!n||n.length===0)return r();const o=document.getElementsByTagName("link");return Promise.all(n.map(t=>{if(t=Ki(t),t in et)return;et[t]=!0;const s=t.endsWith(".css"),l=s?'[rel="stylesheet"]':"";if(!!a)for(let d=o.length-1;d>=0;d--){const u=o[d];if(u.href===t&&(!s||u.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${t}"]${l}`))return;const c=document.createElement("link");if(c.rel=s?"stylesheet":Vi,s||(c.as="script",c.crossOrigin=""),c.href=t,document.head.appendChild(c),s)return new Promise((d,u)=>{c.addEventListener("load",d),c.addEventListener("error",()=>u(new Error(`Unable to preload CSS for ${t}`)))})})).then(()=>r()).catch(t=>{const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=t,window.dispatchEvent(s),!s.defaultPrevented)throw t})};function go(e,r){const n=Object.create(null),a=e.split(",");for(let o=0;o<a.length;o++)n[a[o]]=!0;return r?o=>!!n[o.toLowerCase()]:o=>!!n[o]}const Ee={},an=[],tr=()=>{},Yi=()=>!1,$i=/^on[^a-z]/,Nn=e=>$i.test(e),fo=e=>e.startsWith("onUpdate:"),xe=Object.assign,vo=(e,r)=>{const n=e.indexOf(r);n>-1&&e.splice(n,1)},Xi=Object.prototype.hasOwnProperty,pe=(e,r)=>Xi.call(e,r),Q=Array.isArray,on=e=>Ea(e)==="[object Map]",hs=e=>Ea(e)==="[object Set]",se=e=>typeof e=="function",ve=e=>typeof e=="string",bo=e=>typeof e=="symbol",ke=e=>e!==null&&typeof e=="object",gs=e=>ke(e)&&se(e.then)&&se(e.catch),fs=Object.prototype.toString,Ea=e=>fs.call(e),Qi=e=>Ea(e).slice(8,-1),vs=e=>Ea(e)==="[object Object]",yo=e=>ve(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,jn=go(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),ka=e=>{const r=Object.create(null);return n=>r[n]||(r[n]=e(n))},Zi=/-(\w)/g,ur=ka(e=>e.replace(Zi,(r,n)=>n?n.toUpperCase():"")),el=/\B([A-Z])/g,Yr=ka(e=>e.replace(el,"-$1").toLowerCase()),Ca=ka(e=>e.charAt(0).toUpperCase()+e.slice(1)),Ma=ka(e=>e?`on${Ca(e)}`:""),_n=(e,r)=>!Object.is(e,r),Oa=(e,r)=>{for(let n=0;n<e.length;n++)e[n](r)},ca=(e,r,n)=>{Object.defineProperty(e,r,{configurable:!0,enumerable:!1,value:n})},rl=e=>{const r=parseFloat(e);return isNaN(r)?e:r},nl=e=>{const r=ve(e)?Number(e):NaN;return isNaN(r)?e:r};let rt;const Qa=()=>rt||(rt=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Fn(e){if(Q(e)){const r={};for(let n=0;n<e.length;n++){const a=e[n],o=ve(a)?sl(a):Fn(a);if(o)for(const t in o)r[t]=o[t]}return r}else{if(ve(e))return e;if(ke(e))return e}}const al=/;(?![^(]*\))/g,ol=/:([^]+)/,tl=/\/\*[^]*?\*\//g;function sl(e){const r={};return e.replace(tl,"").split(al).forEach(n=>{if(n){const a=n.split(ol);a.length>1&&(r[a[0].trim()]=a[1].trim())}}),r}function Ge(e){let r="";if(ve(e))r=e;else if(Q(e))for(let n=0;n<e.length;n++){const a=Ge(e[n]);a&&(r+=a+" ")}else if(ke(e))for(const n in e)e[n]&&(r+=n+" ");return r.trim()}const il="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",ll=go(il);function bs(e){return!!e||e===""}const _e=e=>ve(e)?e:e==null?"":Q(e)||ke(e)&&(e.toString===fs||!se(e.toString))?JSON.stringify(e,ys,2):String(e),ys=(e,r)=>r&&r.__v_isRef?ys(e,r.value):on(r)?{[`Map(${r.size})`]:[...r.entries()].reduce((n,[a,o])=>(n[`${a} =>`]=o,n),{})}:hs(r)?{[`Set(${r.size})`]:[...r.values()]}:ke(r)&&!Q(r)&&!vs(r)?String(r):r;let Ye;class cl{constructor(r=!1){this.detached=r,this._active=!0,this.effects=[],this.cleanups=[],this.parent=Ye,!r&&Ye&&(this.index=(Ye.scopes||(Ye.scopes=[])).push(this)-1)}get active(){return this._active}run(r){if(this._active){const n=Ye;try{return Ye=this,r()}finally{Ye=n}}}on(){Ye=this}off(){Ye=this.parent}stop(r){if(this._active){let n,a;for(n=0,a=this.effects.length;n<a;n++)this.effects[n].stop();for(n=0,a=this.cleanups.length;n<a;n++)this.cleanups[n]();if(this.scopes)for(n=0,a=this.scopes.length;n<a;n++)this.scopes[n].stop(!0);if(!this.detached&&this.parent&&!r){const o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.parent=void 0,this._active=!1}}}function dl(e,r=Ye){r&&r.active&&r.effects.push(e)}function Ss(){return Ye}function ul(e){Ye&&Ye.cleanups.push(e)}const So=e=>{const r=new Set(e);return r.w=0,r.n=0,r},ws=e=>(e.w&Lr)>0,Ps=e=>(e.n&Lr)>0,ml=({deps:e})=>{if(e.length)for(let r=0;r<e.length;r++)e[r].w|=Lr},pl=e=>{const{deps:r}=e;if(r.length){let n=0;for(let a=0;a<r.length;a++){const o=r[a];ws(o)&&!Ps(o)?o.delete(e):r[n++]=o,o.w&=~Lr,o.n&=~Lr}r.length=n}},da=new WeakMap;let kn=0,Lr=1;const Za=30;let ar;const Gr=Symbol(""),eo=Symbol("");class wo{constructor(r,n=null,a){this.fn=r,this.scheduler=n,this.active=!0,this.deps=[],this.parent=void 0,dl(this,a)}run(){if(!this.active)return this.fn();let r=ar,n=xr;for(;r;){if(r===this)return;r=r.parent}try{return this.parent=ar,ar=this,xr=!0,Lr=1<<++kn,kn<=Za?ml(this):nt(this),this.fn()}finally{kn<=Za&&pl(this),Lr=1<<--kn,ar=this.parent,xr=n,this.parent=void 0,this.deferStop&&this.stop()}}stop(){ar===this?this.deferStop=!0:this.active&&(nt(this),this.onStop&&this.onStop(),this.active=!1)}}function nt(e){const{deps:r}=e;if(r.length){for(let n=0;n<r.length;n++)r[n].delete(e);r.length=0}}let xr=!0;const Es=[];function gn(){Es.push(xr),xr=!1}function fn(){const e=Es.pop();xr=e===void 0?!0:e}function Ve(e,r,n){if(xr&&ar){let a=da.get(e);a||da.set(e,a=new Map);let o=a.get(n);o||a.set(n,o=So()),ks(o)}}function ks(e,r){let n=!1;kn<=Za?Ps(e)||(e.n|=Lr,n=!ws(e)):n=!e.has(ar),n&&(e.add(ar),ar.deps.push(e))}function br(e,r,n,a,o,t){const s=da.get(e);if(!s)return;let l=[];if(r==="clear")l=[...s.values()];else if(n==="length"&&Q(e)){const i=Number(a);s.forEach((c,d)=>{(d==="length"||d>=i)&&l.push(c)})}else switch(n!==void 0&&l.push(s.get(n)),r){case"add":Q(e)?yo(n)&&l.push(s.get("length")):(l.push(s.get(Gr)),on(e)&&l.push(s.get(eo)));break;case"delete":Q(e)||(l.push(s.get(Gr)),on(e)&&l.push(s.get(eo)));break;case"set":on(e)&&l.push(s.get(Gr));break}if(l.length===1)l[0]&&ro(l[0]);else{const i=[];for(const c of l)c&&i.push(...c);ro(So(i))}}function ro(e,r){const n=Q(e)?e:[...e];for(const a of n)a.computed&&at(a);for(const a of n)a.computed||at(a)}function at(e,r){(e!==ar||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}function hl(e,r){var n;return(n=da.get(e))==null?void 0:n.get(r)}const gl=go("__proto__,__v_isRef,__isVue"),Cs=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(bo)),fl=Po(),vl=Po(!1,!0),bl=Po(!0),ot=yl();function yl(){const e={};return["includes","indexOf","lastIndexOf"].forEach(r=>{e[r]=function(...n){const a=ge(this);for(let t=0,s=this.length;t<s;t++)Ve(a,"get",t+"");const o=a[r](...n);return o===-1||o===!1?a[r](...n.map(ge)):o}}),["push","pop","shift","unshift","splice"].forEach(r=>{e[r]=function(...n){gn();const a=ge(this)[r].apply(this,n);return fn(),a}}),e}function Sl(e){const r=ge(this);return Ve(r,"has",e),r.hasOwnProperty(e)}function Po(e=!1,r=!1){return function(a,o,t){if(o==="__v_isReactive")return!e;if(o==="__v_isReadonly")return e;if(o==="__v_isShallow")return r;if(o==="__v_raw"&&t===(e?r?Ml:xs:r?As:Is).get(a))return a;const s=Q(a);if(!e){if(s&&pe(ot,o))return Reflect.get(ot,o,t);if(o==="hasOwnProperty")return Sl}const l=Reflect.get(a,o,t);return(bo(o)?Cs.has(o):gl(o))||(e||Ve(a,"get",o),r)?l:Re(l)?s&&yo(o)?l:l.value:ke(l)?e?vn(l):Bn(l):l}}const wl=js(),Pl=js(!0);function js(e=!1){return function(n,a,o,t){let s=n[a];if(cn(s)&&Re(s)&&!Re(o))return!1;if(!e&&(!ua(o)&&!cn(o)&&(s=ge(s),o=ge(o)),!Q(n)&&Re(s)&&!Re(o)))return s.value=o,!0;const l=Q(n)&&yo(a)?Number(a)<n.length:pe(n,a),i=Reflect.set(n,a,o,t);return n===ge(t)&&(l?_n(o,s)&&br(n,"set",a,o):br(n,"add",a,o)),i}}function El(e,r){const n=pe(e,r);e[r];const a=Reflect.deleteProperty(e,r);return a&&n&&br(e,"delete",r,void 0),a}function kl(e,r){const n=Reflect.has(e,r);return(!bo(r)||!Cs.has(r))&&Ve(e,"has",r),n}function Cl(e){return Ve(e,"iterate",Q(e)?"length":Gr),Reflect.ownKeys(e)}const qs={get:fl,set:wl,deleteProperty:El,has:kl,ownKeys:Cl},jl={get:bl,set(e,r){return!0},deleteProperty(e,r){return!0}},ql=xe({},qs,{get:vl,set:Pl}),Eo=e=>e,ja=e=>Reflect.getPrototypeOf(e);function Kn(e,r,n=!1,a=!1){e=e.__v_raw;const o=ge(e),t=ge(r);n||(r!==t&&Ve(o,"get",r),Ve(o,"get",t));const{has:s}=ja(o),l=a?Eo:n?jo:Ln;if(s.call(o,r))return l(e.get(r));if(s.call(o,t))return l(e.get(t));e!==o&&e.get(r)}function Yn(e,r=!1){const n=this.__v_raw,a=ge(n),o=ge(e);return r||(e!==o&&Ve(a,"has",e),Ve(a,"has",o)),e===o?n.has(e):n.has(e)||n.has(o)}function $n(e,r=!1){return e=e.__v_raw,!r&&Ve(ge(e),"iterate",Gr),Reflect.get(e,"size",e)}function tt(e){e=ge(e);const r=ge(this);return ja(r).has.call(r,e)||(r.add(e),br(r,"add",e,e)),this}function st(e,r){r=ge(r);const n=ge(this),{has:a,get:o}=ja(n);let t=a.call(n,e);t||(e=ge(e),t=a.call(n,e));const s=o.call(n,e);return n.set(e,r),t?_n(r,s)&&br(n,"set",e,r):br(n,"add",e,r),this}function it(e){const r=ge(this),{has:n,get:a}=ja(r);let o=n.call(r,e);o||(e=ge(e),o=n.call(r,e)),a&&a.call(r,e);const t=r.delete(e);return o&&br(r,"delete",e,void 0),t}function lt(){const e=ge(this),r=e.size!==0,n=e.clear();return r&&br(e,"clear",void 0,void 0),n}function Xn(e,r){return function(a,o){const t=this,s=t.__v_raw,l=ge(s),i=r?Eo:e?jo:Ln;return!e&&Ve(l,"iterate",Gr),s.forEach((c,d)=>a.call(o,i(c),i(d),t))}}function Qn(e,r,n){return function(...a){const o=this.__v_raw,t=ge(o),s=on(t),l=e==="entries"||e===Symbol.iterator&&s,i=e==="keys"&&s,c=o[e](...a),d=n?Eo:r?jo:Ln;return!r&&Ve(t,"iterate",i?eo:Gr),{next(){const{value:u,done:m}=c.next();return m?{value:u,done:m}:{value:l?[d(u[0]),d(u[1])]:d(u),done:m}},[Symbol.iterator](){return this}}}}function kr(e){return function(...r){return e==="delete"?!1:this}}function Il(){const e={get(t){return Kn(this,t)},get size(){return $n(this)},has:Yn,add:tt,set:st,delete:it,clear:lt,forEach:Xn(!1,!1)},r={get(t){return Kn(this,t,!1,!0)},get size(){return $n(this)},has:Yn,add:tt,set:st,delete:it,clear:lt,forEach:Xn(!1,!0)},n={get(t){return Kn(this,t,!0)},get size(){return $n(this,!0)},has(t){return Yn.call(this,t,!0)},add:kr("add"),set:kr("set"),delete:kr("delete"),clear:kr("clear"),forEach:Xn(!0,!1)},a={get(t){return Kn(this,t,!0,!0)},get size(){return $n(this,!0)},has(t){return Yn.call(this,t,!0)},add:kr("add"),set:kr("set"),delete:kr("delete"),clear:kr("clear"),forEach:Xn(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(t=>{e[t]=Qn(t,!1,!1),n[t]=Qn(t,!0,!1),r[t]=Qn(t,!1,!0),a[t]=Qn(t,!0,!0)}),[e,n,r,a]}const[Al,xl,Tl,_l]=Il();function ko(e,r){const n=r?e?_l:Tl:e?xl:Al;return(a,o,t)=>o==="__v_isReactive"?!e:o==="__v_isReadonly"?e:o==="__v_raw"?a:Reflect.get(pe(n,o)&&o in a?n:a,o,t)}const Ll={get:ko(!1,!1)},Rl={get:ko(!1,!0)},Dl={get:ko(!0,!1)},Is=new WeakMap,As=new WeakMap,xs=new WeakMap,Ml=new WeakMap;function Ol(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function zl(e){return e.__v_skip||!Object.isExtensible(e)?0:Ol(Qi(e))}function Bn(e){return cn(e)?e:Co(e,!1,qs,Ll,Is)}function Ts(e){return Co(e,!1,ql,Rl,As)}function vn(e){return Co(e,!0,jl,Dl,xs)}function Co(e,r,n,a,o){if(!ke(e)||e.__v_raw&&!(r&&e.__v_isReactive))return e;const t=o.get(e);if(t)return t;const s=zl(e);if(s===0)return e;const l=new Proxy(e,s===2?a:n);return o.set(e,l),l}function tn(e){return cn(e)?tn(e.__v_raw):!!(e&&e.__v_isReactive)}function cn(e){return!!(e&&e.__v_isReadonly)}function ua(e){return!!(e&&e.__v_isShallow)}function _s(e){return tn(e)||cn(e)}function ge(e){const r=e&&e.__v_raw;return r?ge(r):e}function Ls(e){return ca(e,"__v_skip",!0),e}const Ln=e=>ke(e)?Bn(e):e,jo=e=>ke(e)?vn(e):e;function qo(e){xr&&ar&&(e=ge(e),ks(e.dep||(e.dep=So())))}function Io(e,r){e=ge(e);const n=e.dep;n&&ro(n)}function Re(e){return!!(e&&e.__v_isRef===!0)}function fe(e){return Rs(e,!1)}function Ao(e){return Rs(e,!0)}function Rs(e,r){return Re(e)?e:new Nl(e,r)}class Nl{constructor(r,n){this.__v_isShallow=n,this.dep=void 0,this.__v_isRef=!0,this._rawValue=n?r:ge(r),this._value=n?r:Ln(r)}get value(){return qo(this),this._value}set value(r){const n=this.__v_isShallow||ua(r)||cn(r);r=n?r:ge(r),_n(r,this._rawValue)&&(this._rawValue=r,this._value=n?r:Ln(r),Io(this))}}function re(e){return Re(e)?e.value:e}const Fl={get:(e,r,n)=>re(Reflect.get(e,r,n)),set:(e,r,n,a)=>{const o=e[r];return Re(o)&&!Re(n)?(o.value=n,!0):Reflect.set(e,r,n,a)}};function Ds(e){return tn(e)?e:new Proxy(e,Fl)}class Bl{constructor(r){this.dep=void 0,this.__v_isRef=!0;const{get:n,set:a}=r(()=>qo(this),()=>Io(this));this._get=n,this._set=a}get value(){return this._get()}set value(r){this._set(r)}}function Ul(e){return new Bl(e)}function qa(e){const r=Q(e)?new Array(e.length):{};for(const n in e)r[n]=Jl(e,n);return r}class Hl{constructor(r,n,a){this._object=r,this._key=n,this._defaultValue=a,this.__v_isRef=!0}get value(){const r=this._object[this._key];return r===void 0?this._defaultValue:r}set value(r){this._object[this._key]=r}get dep(){return hl(ge(this._object),this._key)}}function Jl(e,r,n){const a=e[r];return Re(a)?a:new Hl(e,r,n)}class Wl{constructor(r,n,a,o){this._setter=n,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new wo(r,()=>{this._dirty||(this._dirty=!0,Io(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!o,this.__v_isReadonly=a}get value(){const r=ge(this);return qo(r),(r._dirty||!r._cacheable)&&(r._dirty=!1,r._value=r.effect.run()),r._value}set value(r){this._setter(r)}}function Gl(e,r,n=!1){let a,o;const t=se(e);return t?(a=e,o=tr):(a=e.get,o=e.set),new Wl(a,o,t||!o,n)}function Tr(e,r,n,a){let o;try{o=a?e(...a):e()}catch(t){Un(t,r,n)}return o}function Ze(e,r,n,a){if(se(e)){const t=Tr(e,r,n,a);return t&&gs(t)&&t.catch(s=>{Un(s,r,n)}),t}const o=[];for(let t=0;t<e.length;t++)o.push(Ze(e[t],r,n,a));return o}function Un(e,r,n,a=!0){const o=r?r.vnode:null;if(r){let t=r.parent;const s=r.proxy,l=n;for(;t;){const c=t.ec;if(c){for(let d=0;d<c.length;d++)if(c[d](e,s,l)===!1)return}t=t.parent}const i=r.appContext.config.errorHandler;if(i){Tr(i,null,10,[e,s,l]);return}}Vl(e,n,o,a)}function Vl(e,r,n,a=!0){console.error(e)}let Rn=!1,no=!1;const Fe=[];let dr=0;const sn=[];let gr=null,Ur=0;const Ms=Promise.resolve();let xo=null;function Hn(e){const r=xo||Ms;return e?r.then(this?e.bind(this):e):r}function Kl(e){let r=dr+1,n=Fe.length;for(;r<n;){const a=r+n>>>1;Dn(Fe[a])<e?r=a+1:n=a}return r}function Ia(e){(!Fe.length||!Fe.includes(e,Rn&&e.allowRecurse?dr+1:dr))&&(e.id==null?Fe.push(e):Fe.splice(Kl(e.id),0,e),Os())}function Os(){!Rn&&!no&&(no=!0,xo=Ms.then(zs))}function Yl(e){const r=Fe.indexOf(e);r>dr&&Fe.splice(r,1)}function $l(e){Q(e)?sn.push(...e):(!gr||!gr.includes(e,e.allowRecurse?Ur+1:Ur))&&sn.push(e),Os()}function ct(e,r=Rn?dr+1:0){for(;r<Fe.length;r++){const n=Fe[r];n&&n.pre&&(Fe.splice(r,1),r--,n())}}function ma(e){if(sn.length){const r=[...new Set(sn)];if(sn.length=0,gr){gr.push(...r);return}for(gr=r,gr.sort((n,a)=>Dn(n)-Dn(a)),Ur=0;Ur<gr.length;Ur++)gr[Ur]();gr=null,Ur=0}}const Dn=e=>e.id==null?1/0:e.id,Xl=(e,r)=>{const n=Dn(e)-Dn(r);if(n===0){if(e.pre&&!r.pre)return-1;if(r.pre&&!e.pre)return 1}return n};function zs(e){no=!1,Rn=!0,Fe.sort(Xl);const r=tr;try{for(dr=0;dr<Fe.length;dr++){const n=Fe[dr];n&&n.active!==!1&&Tr(n,null,14)}}finally{dr=0,Fe.length=0,ma(),Rn=!1,xo=null,(Fe.length||sn.length)&&zs()}}function Ql(e,r,...n){if(e.isUnmounted)return;const a=e.vnode.props||Ee;let o=n;const t=r.startsWith("update:"),s=t&&r.slice(7);if(s&&s in a){const d=`${s==="modelValue"?"model":s}Modifiers`,{number:u,trim:m}=a[d]||Ee;m&&(o=n.map(f=>ve(f)?f.trim():f)),u&&(o=n.map(rl))}let l,i=a[l=Ma(r)]||a[l=Ma(ur(r))];!i&&t&&(i=a[l=Ma(Yr(r))]),i&&Ze(i,e,6,o);const c=a[l+"Once"];if(c){if(!e.emitted)e.emitted={};else if(e.emitted[l])return;e.emitted[l]=!0,Ze(c,e,6,o)}}function Ns(e,r,n=!1){const a=r.emitsCache,o=a.get(e);if(o!==void 0)return o;const t=e.emits;let s={},l=!1;if(!se(e)){const i=c=>{const d=Ns(c,r,!0);d&&(l=!0,xe(s,d))};!n&&r.mixins.length&&r.mixins.forEach(i),e.extends&&i(e.extends),e.mixins&&e.mixins.forEach(i)}return!t&&!l?(ke(e)&&a.set(e,null),null):(Q(t)?t.forEach(i=>s[i]=null):xe(s,t),ke(e)&&a.set(e,s),s)}function Aa(e,r){return!e||!Nn(r)?!1:(r=r.slice(2).replace(/Once$/,""),pe(e,r[0].toLowerCase()+r.slice(1))||pe(e,Yr(r))||pe(e,r))}let Oe=null,Fs=null;function pa(e){const r=Oe;return Oe=e,Fs=e&&e.type.__scopeId||null,r}function Me(e,r=Oe,n){if(!r||e._n)return e;const a=(...o)=>{a._d&&wt(-1);const t=pa(r);let s;try{s=e(...o)}finally{pa(t),a._d&&wt(1)}return s};return a._n=!0,a._c=!0,a._d=!0,a}function za(e){const{type:r,vnode:n,proxy:a,withProxy:o,props:t,propsOptions:[s],slots:l,attrs:i,emit:c,render:d,renderCache:u,data:m,setupState:f,ctx:w,inheritAttrs:P}=e;let k,v;const S=pa(e);try{if(n.shapeFlag&4){const A=o||a;k=nr(d.call(A,A,u,t,f,m,w)),v=i}else{const A=r;k=nr(A.length>1?A(t,{attrs:i,slots:l,emit:c}):A(t,null)),v=r.props?i:Zl(i)}}catch(A){An.length=0,Un(A,e,1),k=ne($e)}let x=k;if(v&&P!==!1){const A=Object.keys(v),{shapeFlag:G}=x;A.length&&G&7&&(s&&A.some(fo)&&(v=ec(v,s)),x=Dr(x,v))}return n.dirs&&(x=Dr(x),x.dirs=x.dirs?x.dirs.concat(n.dirs):n.dirs),n.transition&&(x.transition=n.transition),k=x,pa(S),k}const Zl=e=>{let r;for(const n in e)(n==="class"||n==="style"||Nn(n))&&((r||(r={}))[n]=e[n]);return r},ec=(e,r)=>{const n={};for(const a in e)(!fo(a)||!(a.slice(9)in r))&&(n[a]=e[a]);return n};function rc(e,r,n){const{props:a,children:o,component:t}=e,{props:s,children:l,patchFlag:i}=r,c=t.emitsOptions;if(r.dirs||r.transition)return!0;if(n&&i>=0){if(i&1024)return!0;if(i&16)return a?dt(a,s,c):!!s;if(i&8){const d=r.dynamicProps;for(let u=0;u<d.length;u++){const m=d[u];if(s[m]!==a[m]&&!Aa(c,m))return!0}}}else return(o||l)&&(!l||!l.$stable)?!0:a===s?!1:a?s?dt(a,s,c):!0:!!s;return!1}function dt(e,r,n){const a=Object.keys(r);if(a.length!==Object.keys(e).length)return!0;for(let o=0;o<a.length;o++){const t=a[o];if(r[t]!==e[t]&&!Aa(n,t))return!0}return!1}function nc({vnode:e,parent:r},n){for(;r&&r.subTree===e;)(e=r.vnode).el=n,r=r.parent}const ac=e=>e.__isSuspense;function Bs(e,r){r&&r.pendingBranch?Q(e)?r.effects.push(...e):r.effects.push(e):$l(e)}function Us(e,r){return To(e,null,r)}const Zn={};function er(e,r,n){return To(e,r,n)}function To(e,r,{immediate:n,deep:a,flush:o,onTrack:t,onTrigger:s}=Ee){var l;const i=Ss()===((l=Te)==null?void 0:l.scope)?Te:null;let c,d=!1,u=!1;if(Re(e)?(c=()=>e.value,d=ua(e)):tn(e)?(c=()=>e,a=!0):Q(e)?(u=!0,d=e.some(A=>tn(A)||ua(A)),c=()=>e.map(A=>{if(Re(A))return A.value;if(tn(A))return Wr(A);if(se(A))return Tr(A,i,2)})):se(e)?r?c=()=>Tr(e,i,2):c=()=>{if(!(i&&i.isUnmounted))return m&&m(),Ze(e,i,3,[f])}:c=tr,r&&a){const A=c;c=()=>Wr(A())}let m,f=A=>{m=S.onStop=()=>{Tr(A,i,4)}},w;if(mn)if(f=tr,r?n&&Ze(r,i,3,[c(),u?[]:void 0,f]):c(),o==="sync"){const A=Qc();w=A.__watcherHandles||(A.__watcherHandles=[])}else return tr;let P=u?new Array(e.length).fill(Zn):Zn;const k=()=>{if(S.active)if(r){const A=S.run();(a||d||(u?A.some((G,Z)=>_n(G,P[Z])):_n(A,P)))&&(m&&m(),Ze(r,i,3,[A,P===Zn?void 0:u&&P[0]===Zn?[]:P,f]),P=A)}else S.run()};k.allowRecurse=!!r;let v;o==="sync"?v=k:o==="post"?v=()=>We(k,i&&i.suspense):(k.pre=!0,i&&(k.id=i.uid),v=()=>Ia(k));const S=new wo(c,v);r?n?k():P=S.run():o==="post"?We(S.run.bind(S),i&&i.suspense):S.run();const x=()=>{S.stop(),i&&i.scope&&vo(i.scope.effects,S)};return w&&w.push(x),x}function oc(e,r,n){const a=this.proxy,o=ve(e)?e.includes(".")?Hs(a,e):()=>a[e]:e.bind(a,a);let t;se(r)?t=r:(t=r.handler,n=r);const s=Te;un(this);const l=To(o,t.bind(a),n);return s?un(s):Kr(),l}function Hs(e,r){const n=r.split(".");return()=>{let a=e;for(let o=0;o<n.length&&a;o++)a=a[n[o]];return a}}function Wr(e,r){if(!ke(e)||e.__v_skip||(r=r||new Set,r.has(e)))return e;if(r.add(e),Re(e))Wr(e.value,r);else if(Q(e))for(let n=0;n<e.length;n++)Wr(e[n],r);else if(hs(e)||on(e))e.forEach(n=>{Wr(n,r)});else if(vs(e))for(const n in e)Wr(e[n],r);return e}function ha(e,r){const n=Oe;if(n===null)return e;const a=La(n)||n.proxy,o=e.dirs||(e.dirs=[]);for(let t=0;t<r.length;t++){let[s,l,i,c=Ee]=r[t];s&&(se(s)&&(s={mounted:s,updated:s}),s.deep&&Wr(l),o.push({dir:s,instance:a,value:l,oldValue:void 0,arg:i,modifiers:c}))}return e}function cr(e,r,n,a){const o=e.dirs,t=r&&r.dirs;for(let s=0;s<o.length;s++){const l=o[s];t&&(l.oldValue=t[s].value);let i=l.dir[a];i&&(gn(),Ze(i,n,8,[e.el,l,e,r]),fn())}}function tc(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return He(()=>{e.isMounted=!0}),Wn(()=>{e.isUnmounting=!0}),e}const Xe=[Function,Array],Js={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Xe,onEnter:Xe,onAfterEnter:Xe,onEnterCancelled:Xe,onBeforeLeave:Xe,onLeave:Xe,onAfterLeave:Xe,onLeaveCancelled:Xe,onBeforeAppear:Xe,onAppear:Xe,onAfterAppear:Xe,onAppearCancelled:Xe},sc={name:"BaseTransition",props:Js,setup(e,{slots:r}){const n=Do(),a=tc();let o;return()=>{const t=r.default&&Gs(r.default(),!0);if(!t||!t.length)return;let s=t[0];if(t.length>1){for(const P of t)if(P.type!==$e){s=P;break}}const l=ge(e),{mode:i}=l;if(a.isLeaving)return Na(s);const c=ut(s);if(!c)return Na(s);const d=ao(c,l,a,n);oo(c,d);const u=n.subTree,m=u&&ut(u);let f=!1;const{getTransitionKey:w}=c.type;if(w){const P=w();o===void 0?o=P:P!==o&&(o=P,f=!0)}if(m&&m.type!==$e&&(!Hr(c,m)||f)){const P=ao(m,l,a,n);if(oo(m,P),i==="out-in")return a.isLeaving=!0,P.afterLeave=()=>{a.isLeaving=!1,n.update.active!==!1&&n.update()},Na(s);i==="in-out"&&c.type!==$e&&(P.delayLeave=(k,v,S)=>{const x=Ws(a,m);x[String(m.key)]=m,k._leaveCb=()=>{v(),k._leaveCb=void 0,delete d.delayedLeave},d.delayedLeave=S})}return s}}},ic=sc;function Ws(e,r){const{leavingVNodes:n}=e;let a=n.get(r.type);return a||(a=Object.create(null),n.set(r.type,a)),a}function ao(e,r,n,a){const{appear:o,mode:t,persisted:s=!1,onBeforeEnter:l,onEnter:i,onAfterEnter:c,onEnterCancelled:d,onBeforeLeave:u,onLeave:m,onAfterLeave:f,onLeaveCancelled:w,onBeforeAppear:P,onAppear:k,onAfterAppear:v,onAppearCancelled:S}=r,x=String(e.key),A=Ws(n,e),G=(g,J)=>{g&&Ze(g,a,9,J)},Z=(g,J)=>{const F=J[1];G(g,J),Q(g)?g.every(Y=>Y.length<=1)&&F():g.length<=1&&F()},M={mode:t,persisted:s,beforeEnter(g){let J=l;if(!n.isMounted)if(o)J=P||l;else return;g._leaveCb&&g._leaveCb(!0);const F=A[x];F&&Hr(e,F)&&F.el._leaveCb&&F.el._leaveCb(),G(J,[g])},enter(g){let J=i,F=c,Y=d;if(!n.isMounted)if(o)J=k||i,F=v||c,Y=S||d;else return;let q=!1;const L=g._enterCb=R=>{q||(q=!0,R?G(Y,[g]):G(F,[g]),M.delayedLeave&&M.delayedLeave(),g._enterCb=void 0)};J?Z(J,[g,L]):L()},leave(g,J){const F=String(e.key);if(g._enterCb&&g._enterCb(!0),n.isUnmounting)return J();G(u,[g]);let Y=!1;const q=g._leaveCb=L=>{Y||(Y=!0,J(),L?G(w,[g]):G(f,[g]),g._leaveCb=void 0,A[F]===e&&delete A[F])};A[F]=e,m?Z(m,[g,q]):q()},clone(g){return ao(g,r,n,a)}};return M}function Na(e){if(Jn(e))return e=Dr(e),e.children=null,e}function ut(e){return Jn(e)?e.children?e.children[0]:void 0:e}function oo(e,r){e.shapeFlag&6&&e.component?oo(e.component.subTree,r):e.shapeFlag&128?(e.ssContent.transition=r.clone(e.ssContent),e.ssFallback.transition=r.clone(e.ssFallback)):e.transition=r}function Gs(e,r=!1,n){let a=[],o=0;for(let t=0;t<e.length;t++){let s=e[t];const l=n==null?s.key:String(n)+String(s.key!=null?s.key:t);s.type===Pe?(s.patchFlag&128&&o++,a=a.concat(Gs(s.children,r,l))):(r||s.type!==$e)&&a.push(l!=null?Dr(s,{key:l}):s)}if(o>1)for(let t=0;t<a.length;t++)a[t].patchFlag=-2;return a}function ue(e,r){return se(e)?(()=>xe({name:e.name},r,{setup:e}))():e}const ln=e=>!!e.type.__asyncLoader;function D(e){se(e)&&(e={loader:e});const{loader:r,loadingComponent:n,errorComponent:a,delay:o=200,timeout:t,suspensible:s=!0,onError:l}=e;let i=null,c,d=0;const u=()=>(d++,i=null,m()),m=()=>{let f;return i||(f=i=r().catch(w=>{if(w=w instanceof Error?w:new Error(String(w)),l)return new Promise((P,k)=>{l(w,()=>P(u()),()=>k(w),d+1)});throw w}).then(w=>f!==i&&i?i:(w&&(w.__esModule||w[Symbol.toStringTag]==="Module")&&(w=w.default),c=w,w)))};return ue({name:"AsyncComponentWrapper",__asyncLoader:m,get __asyncResolved(){return c},setup(){const f=Te;if(c)return()=>Fa(c,f);const w=S=>{i=null,Un(S,f,13,!a)};if(s&&f.suspense||mn)return m().then(S=>()=>Fa(S,f)).catch(S=>(w(S),()=>a?ne(a,{error:S}):null));const P=fe(!1),k=fe(),v=fe(!!o);return o&&setTimeout(()=>{v.value=!1},o),t!=null&&setTimeout(()=>{if(!P.value&&!k.value){const S=new Error(`Async component timed out after ${t}ms.`);w(S),k.value=S}},t),m().then(()=>{P.value=!0,f.parent&&Jn(f.parent.vnode)&&Ia(f.parent.update)}).catch(S=>{w(S),k.value=S}),()=>{if(P.value&&c)return Fa(c,f);if(k.value&&a)return ne(a,{error:k.value});if(n&&!v.value)return ne(n)}}})}function Fa(e,r){const{ref:n,props:a,children:o,ce:t}=r.vnode,s=ne(e,a,o);return s.ref=n,s.ce=t,delete r.vnode.ce,s}const Jn=e=>e.type.__isKeepAlive;function lc(e,r){Vs(e,"a",r)}function cc(e,r){Vs(e,"da",r)}function Vs(e,r,n=Te){const a=e.__wdc||(e.__wdc=()=>{let o=n;for(;o;){if(o.isDeactivated)return;o=o.parent}return e()});if(xa(r,a,n),n){let o=n.parent;for(;o&&o.parent;)Jn(o.parent.vnode)&&dc(a,r,n,o),o=o.parent}}function dc(e,r,n,a){const o=xa(r,e,a,!0);Ta(()=>{vo(a[r],o)},n)}function xa(e,r,n=Te,a=!1){if(n){const o=n[e]||(n[e]=[]),t=r.__weh||(r.__weh=(...s)=>{if(n.isUnmounted)return;gn(),un(n);const l=Ze(r,n,e,s);return Kr(),fn(),l});return a?o.unshift(t):o.push(t),t}}const Sr=e=>(r,n=Te)=>(!mn||e==="sp")&&xa(e,(...a)=>r(...a),n),uc=Sr("bm"),He=Sr("m"),mc=Sr("bu"),pc=Sr("u"),Wn=Sr("bum"),Ta=Sr("um"),hc=Sr("sp"),gc=Sr("rtg"),fc=Sr("rtc");function vc(e,r=Te){xa("ec",e,r)}const Ks="components";function yr(e,r){return yc(Ks,e,!0,r)||e}const bc=Symbol.for("v-ndc");function yc(e,r,n=!0,a=!1){const o=Oe||Te;if(o){const t=o.type;if(e===Ks){const l=Yc(t,!1);if(l&&(l===r||l===ur(r)||l===Ca(ur(r))))return t}const s=mt(o[e]||t[e],r)||mt(o.appContext[e],r);return!s&&a?t:s}}function mt(e,r){return e&&(e[r]||e[ur(r)]||e[Ca(ur(r))])}function Rr(e,r,n,a){let o;const t=n&&n[a];if(Q(e)||ve(e)){o=new Array(e.length);for(let s=0,l=e.length;s<l;s++)o[s]=r(e[s],s,void 0,t&&t[s])}else if(typeof e=="number"){o=new Array(e);for(let s=0;s<e;s++)o[s]=r(s+1,s,void 0,t&&t[s])}else if(ke(e))if(e[Symbol.iterator])o=Array.from(e,(s,l)=>r(s,l,void 0,t&&t[l]));else{const s=Object.keys(e);o=new Array(s.length);for(let l=0,i=s.length;l<i;l++){const c=s[l];o[l]=r(e[c],c,l,t&&t[l])}}else o=[];return n&&(n[a]=o),o}function we(e,r,n={},a,o){if(Oe.isCE||Oe.parent&&ln(Oe.parent)&&Oe.parent.isCE)return r!=="default"&&(n.name=r),ne("slot",n,a&&a());let t=e[r];t&&t._c&&(t._d=!1),U();const s=t&&Ys(t(n)),l=Ae(Pe,{key:n.key||s&&s.key||`_${r}`},s||(a?a():[]),s&&e._===1?64:-2);return!o&&l.scopeId&&(l.slotScopeIds=[l.scopeId+"-s"]),t&&t._c&&(t._d=!0),l}function Ys(e){return e.some(r=>ba(r)?!(r.type===$e||r.type===Pe&&!Ys(r.children)):!0)?e:null}const to=e=>e?si(e)?La(e)||e.proxy:to(e.parent):null,qn=xe(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>to(e.parent),$root:e=>to(e.root),$emit:e=>e.emit,$options:e=>_o(e),$forceUpdate:e=>e.f||(e.f=()=>Ia(e.update)),$nextTick:e=>e.n||(e.n=Hn.bind(e.proxy)),$watch:e=>oc.bind(e)}),Ba=(e,r)=>e!==Ee&&!e.__isScriptSetup&&pe(e,r),Sc={get({_:e},r){const{ctx:n,setupState:a,data:o,props:t,accessCache:s,type:l,appContext:i}=e;let c;if(r[0]!=="$"){const f=s[r];if(f!==void 0)switch(f){case 1:return a[r];case 2:return o[r];case 4:return n[r];case 3:return t[r]}else{if(Ba(a,r))return s[r]=1,a[r];if(o!==Ee&&pe(o,r))return s[r]=2,o[r];if((c=e.propsOptions[0])&&pe(c,r))return s[r]=3,t[r];if(n!==Ee&&pe(n,r))return s[r]=4,n[r];so&&(s[r]=0)}}const d=qn[r];let u,m;if(d)return r==="$attrs"&&Ve(e,"get",r),d(e);if((u=l.__cssModules)&&(u=u[r]))return u;if(n!==Ee&&pe(n,r))return s[r]=4,n[r];if(m=i.config.globalProperties,pe(m,r))return m[r]},set({_:e},r,n){const{data:a,setupState:o,ctx:t}=e;return Ba(o,r)?(o[r]=n,!0):a!==Ee&&pe(a,r)?(a[r]=n,!0):pe(e.props,r)||r[0]==="$"&&r.slice(1)in e?!1:(t[r]=n,!0)},has({_:{data:e,setupState:r,accessCache:n,ctx:a,appContext:o,propsOptions:t}},s){let l;return!!n[s]||e!==Ee&&pe(e,s)||Ba(r,s)||(l=t[0])&&pe(l,s)||pe(a,s)||pe(qn,s)||pe(o.config.globalProperties,s)},defineProperty(e,r,n){return n.get!=null?e._.accessCache[r]=0:pe(n,"value")&&this.set(e,r,n.value,null),Reflect.defineProperty(e,r,n)}};function pt(e){return Q(e)?e.reduce((r,n)=>(r[n]=null,r),{}):e}let so=!0;function wc(e){const r=_o(e),n=e.proxy,a=e.ctx;so=!1,r.beforeCreate&&ht(r.beforeCreate,e,"bc");const{data:o,computed:t,methods:s,watch:l,provide:i,inject:c,created:d,beforeMount:u,mounted:m,beforeUpdate:f,updated:w,activated:P,deactivated:k,beforeDestroy:v,beforeUnmount:S,destroyed:x,unmounted:A,render:G,renderTracked:Z,renderTriggered:M,errorCaptured:g,serverPrefetch:J,expose:F,inheritAttrs:Y,components:q,directives:L,filters:R}=r;if(c&&Pc(c,a,null),s)for(const oe in s){const te=s[oe];se(te)&&(a[oe]=te.bind(n))}if(o){const oe=o.call(n,n);ke(oe)&&(e.data=Bn(oe))}if(so=!0,t)for(const oe in t){const te=t[oe],ze=se(te)?te.bind(n,n):se(te.get)?te.get.bind(n,n):tr,De=!se(te)&&se(te.set)?te.set.bind(n):tr,Je=N({get:ze,set:De});Object.defineProperty(a,oe,{enumerable:!0,configurable:!0,get:()=>Je.value,set:Ne=>Je.value=Ne})}if(l)for(const oe in l)$s(l[oe],a,n,oe);if(i){const oe=se(i)?i.call(n):i;Reflect.ownKeys(oe).forEach(te=>{Vr(te,oe[te])})}d&&ht(d,e,"c");function W(oe,te){Q(te)?te.forEach(ze=>oe(ze.bind(n))):te&&oe(te.bind(n))}if(W(uc,u),W(He,m),W(mc,f),W(pc,w),W(lc,P),W(cc,k),W(vc,g),W(fc,Z),W(gc,M),W(Wn,S),W(Ta,A),W(hc,J),Q(F))if(F.length){const oe=e.exposed||(e.exposed={});F.forEach(te=>{Object.defineProperty(oe,te,{get:()=>n[te],set:ze=>n[te]=ze})})}else e.exposed||(e.exposed={});G&&e.render===tr&&(e.render=G),Y!=null&&(e.inheritAttrs=Y),q&&(e.components=q),L&&(e.directives=L)}function Pc(e,r,n=tr){Q(e)&&(e=io(e));for(const a in e){const o=e[a];let t;ke(o)?"default"in o?t=qe(o.from||a,o.default,!0):t=qe(o.from||a):t=qe(o),Re(t)?Object.defineProperty(r,a,{enumerable:!0,configurable:!0,get:()=>t.value,set:s=>t.value=s}):r[a]=t}}function ht(e,r,n){Ze(Q(e)?e.map(a=>a.bind(r.proxy)):e.bind(r.proxy),r,n)}function $s(e,r,n,a){const o=a.includes(".")?Hs(n,a):()=>n[a];if(ve(e)){const t=r[e];se(t)&&er(o,t)}else if(se(e))er(o,e.bind(n));else if(ke(e))if(Q(e))e.forEach(t=>$s(t,r,n,a));else{const t=se(e.handler)?e.handler.bind(n):r[e.handler];se(t)&&er(o,t,e)}}function _o(e){const r=e.type,{mixins:n,extends:a}=r,{mixins:o,optionsCache:t,config:{optionMergeStrategies:s}}=e.appContext,l=t.get(r);let i;return l?i=l:!o.length&&!n&&!a?i=r:(i={},o.length&&o.forEach(c=>ga(i,c,s,!0)),ga(i,r,s)),ke(r)&&t.set(r,i),i}function ga(e,r,n,a=!1){const{mixins:o,extends:t}=r;t&&ga(e,t,n,!0),o&&o.forEach(s=>ga(e,s,n,!0));for(const s in r)if(!(a&&s==="expose")){const l=Ec[s]||n&&n[s];e[s]=l?l(e[s],r[s]):r[s]}return e}const Ec={data:gt,props:ft,emits:ft,methods:Cn,computed:Cn,beforeCreate:Be,created:Be,beforeMount:Be,mounted:Be,beforeUpdate:Be,updated:Be,beforeDestroy:Be,beforeUnmount:Be,destroyed:Be,unmounted:Be,activated:Be,deactivated:Be,errorCaptured:Be,serverPrefetch:Be,components:Cn,directives:Cn,watch:Cc,provide:gt,inject:kc};function gt(e,r){return r?e?function(){return xe(se(e)?e.call(this,this):e,se(r)?r.call(this,this):r)}:r:e}function kc(e,r){return Cn(io(e),io(r))}function io(e){if(Q(e)){const r={};for(let n=0;n<e.length;n++)r[e[n]]=e[n];return r}return e}function Be(e,r){return e?[...new Set([].concat(e,r))]:r}function Cn(e,r){return e?xe(Object.create(null),e,r):r}function ft(e,r){return e?Q(e)&&Q(r)?[...new Set([...e,...r])]:xe(Object.create(null),pt(e),pt(r??{})):r}function Cc(e,r){if(!e)return r;if(!r)return e;const n=xe(Object.create(null),e);for(const a in r)n[a]=Be(e[a],r[a]);return n}function Xs(){return{app:null,config:{isNativeTag:Yi,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let jc=0;function qc(e,r){return function(a,o=null){se(a)||(a=xe({},a)),o!=null&&!ke(o)&&(o=null);const t=Xs(),s=new Set;let l=!1;const i=t.app={_uid:jc++,_component:a,_props:o,_container:null,_context:t,_instance:null,version:Zc,get config(){return t.config},set config(c){},use(c,...d){return s.has(c)||(c&&se(c.install)?(s.add(c),c.install(i,...d)):se(c)&&(s.add(c),c(i,...d))),i},mixin(c){return t.mixins.includes(c)||t.mixins.push(c),i},component(c,d){return d?(t.components[c]=d,i):t.components[c]},directive(c,d){return d?(t.directives[c]=d,i):t.directives[c]},mount(c,d,u){if(!l){const m=ne(a,o);return m.appContext=t,d&&r?r(m,c):e(m,c,u),l=!0,i._container=c,c.__vue_app__=i,La(m.component)||m.component.proxy}},unmount(){l&&(e(null,i._container),delete i._container.__vue_app__)},provide(c,d){return t.provides[c]=d,i},runWithContext(c){fa=i;try{return c()}finally{fa=null}}};return i}}let fa=null;function Vr(e,r){if(Te){let n=Te.provides;const a=Te.parent&&Te.parent.provides;a===n&&(n=Te.provides=Object.create(a)),n[e]=r}}function qe(e,r,n=!1){const a=Te||Oe;if(a||fa){const o=a?a.parent==null?a.vnode.appContext&&a.vnode.appContext.provides:a.parent.provides:fa._context.provides;if(o&&e in o)return o[e];if(arguments.length>1)return n&&se(r)?r.call(a&&a.proxy):r}}function Ic(e,r,n,a=!1){const o={},t={};ca(t,_a,1),e.propsDefaults=Object.create(null),Qs(e,r,o,t);for(const s in e.propsOptions[0])s in o||(o[s]=void 0);n?e.props=a?o:Ts(o):e.type.props?e.props=o:e.props=t,e.attrs=t}function Ac(e,r,n,a){const{props:o,attrs:t,vnode:{patchFlag:s}}=e,l=ge(o),[i]=e.propsOptions;let c=!1;if((a||s>0)&&!(s&16)){if(s&8){const d=e.vnode.dynamicProps;for(let u=0;u<d.length;u++){let m=d[u];if(Aa(e.emitsOptions,m))continue;const f=r[m];if(i)if(pe(t,m))f!==t[m]&&(t[m]=f,c=!0);else{const w=ur(m);o[w]=lo(i,l,w,f,e,!1)}else f!==t[m]&&(t[m]=f,c=!0)}}}else{Qs(e,r,o,t)&&(c=!0);let d;for(const u in l)(!r||!pe(r,u)&&((d=Yr(u))===u||!pe(r,d)))&&(i?n&&(n[u]!==void 0||n[d]!==void 0)&&(o[u]=lo(i,l,u,void 0,e,!0)):delete o[u]);if(t!==l)for(const u in t)(!r||!pe(r,u))&&(delete t[u],c=!0)}c&&br(e,"set","$attrs")}function Qs(e,r,n,a){const[o,t]=e.propsOptions;let s=!1,l;if(r)for(let i in r){if(jn(i))continue;const c=r[i];let d;o&&pe(o,d=ur(i))?!t||!t.includes(d)?n[d]=c:(l||(l={}))[d]=c:Aa(e.emitsOptions,i)||(!(i in a)||c!==a[i])&&(a[i]=c,s=!0)}if(t){const i=ge(n),c=l||Ee;for(let d=0;d<t.length;d++){const u=t[d];n[u]=lo(o,i,u,c[u],e,!pe(c,u))}}return s}function lo(e,r,n,a,o,t){const s=e[n];if(s!=null){const l=pe(s,"default");if(l&&a===void 0){const i=s.default;if(s.type!==Function&&!s.skipFactory&&se(i)){const{propsDefaults:c}=o;n in c?a=c[n]:(un(o),a=c[n]=i.call(null,r),Kr())}else a=i}s[0]&&(t&&!l?a=!1:s[1]&&(a===""||a===Yr(n))&&(a=!0))}return a}function Zs(e,r,n=!1){const a=r.propsCache,o=a.get(e);if(o)return o;const t=e.props,s={},l=[];let i=!1;if(!se(e)){const d=u=>{i=!0;const[m,f]=Zs(u,r,!0);xe(s,m),f&&l.push(...f)};!n&&r.mixins.length&&r.mixins.forEach(d),e.extends&&d(e.extends),e.mixins&&e.mixins.forEach(d)}if(!t&&!i)return ke(e)&&a.set(e,an),an;if(Q(t))for(let d=0;d<t.length;d++){const u=ur(t[d]);vt(u)&&(s[u]=Ee)}else if(t)for(const d in t){const u=ur(d);if(vt(u)){const m=t[d],f=s[u]=Q(m)||se(m)?{type:m}:xe({},m);if(f){const w=St(Boolean,f.type),P=St(String,f.type);f[0]=w>-1,f[1]=P<0||w<P,(w>-1||pe(f,"default"))&&l.push(u)}}}const c=[s,l];return ke(e)&&a.set(e,c),c}function vt(e){return e[0]!=="$"}function bt(e){const r=e&&e.toString().match(/^\s*(function|class) (\w+)/);return r?r[2]:e===null?"null":""}function yt(e,r){return bt(e)===bt(r)}function St(e,r){return Q(r)?r.findIndex(n=>yt(n,e)):se(r)&&yt(r,e)?0:-1}const ei=e=>e[0]==="_"||e==="$stable",Lo=e=>Q(e)?e.map(nr):[nr(e)],xc=(e,r,n)=>{if(r._n)return r;const a=Me((...o)=>Lo(r(...o)),n);return a._c=!1,a},ri=(e,r,n)=>{const a=e._ctx;for(const o in e){if(ei(o))continue;const t=e[o];if(se(t))r[o]=xc(o,t,a);else if(t!=null){const s=Lo(t);r[o]=()=>s}}},ni=(e,r)=>{const n=Lo(r);e.slots.default=()=>n},Tc=(e,r)=>{if(e.vnode.shapeFlag&32){const n=r._;n?(e.slots=ge(r),ca(r,"_",n)):ri(r,e.slots={})}else e.slots={},r&&ni(e,r);ca(e.slots,_a,1)},_c=(e,r,n)=>{const{vnode:a,slots:o}=e;let t=!0,s=Ee;if(a.shapeFlag&32){const l=r._;l?n&&l===1?t=!1:(xe(o,r),!n&&l===1&&delete o._):(t=!r.$stable,ri(r,o)),s=r}else r&&(ni(e,r),s={default:1});if(t)for(const l in o)!ei(l)&&!(l in s)&&delete o[l]};function va(e,r,n,a,o=!1){if(Q(e)){e.forEach((m,f)=>va(m,r&&(Q(r)?r[f]:r),n,a,o));return}if(ln(a)&&!o)return;const t=a.shapeFlag&4?La(a.component)||a.component.proxy:a.el,s=o?null:t,{i:l,r:i}=e,c=r&&r.r,d=l.refs===Ee?l.refs={}:l.refs,u=l.setupState;if(c!=null&&c!==i&&(ve(c)?(d[c]=null,pe(u,c)&&(u[c]=null)):Re(c)&&(c.value=null)),se(i))Tr(i,l,12,[s,d]);else{const m=ve(i),f=Re(i);if(m||f){const w=()=>{if(e.f){const P=m?pe(u,i)?u[i]:d[i]:i.value;o?Q(P)&&vo(P,t):Q(P)?P.includes(t)||P.push(t):m?(d[i]=[t],pe(u,i)&&(u[i]=d[i])):(i.value=[t],e.k&&(d[e.k]=i.value))}else m?(d[i]=s,pe(u,i)&&(u[i]=s)):f&&(i.value=s,e.k&&(d[e.k]=s))};s?(w.id=-1,We(w,n)):w()}}}let Cr=!1;const ea=e=>/svg/.test(e.namespaceURI)&&e.tagName!=="foreignObject",ra=e=>e.nodeType===8;function Lc(e){const{mt:r,p:n,o:{patchProp:a,createText:o,nextSibling:t,parentNode:s,remove:l,insert:i,createComment:c}}=e,d=(v,S)=>{if(!S.hasChildNodes()){n(null,v,S),ma(),S._vnode=v;return}Cr=!1,u(S.firstChild,v,null,null,null),ma(),S._vnode=v,Cr&&console.error("Hydration completed but contains mismatches.")},u=(v,S,x,A,G,Z=!1)=>{const M=ra(v)&&v.data==="[",g=()=>P(v,S,x,A,G,M),{type:J,ref:F,shapeFlag:Y,patchFlag:q}=S;let L=v.nodeType;S.el=v,q===-2&&(Z=!1,S.dynamicChildren=null);let R=null;switch(J){case dn:L!==3?S.children===""?(i(S.el=o(""),s(v),v),R=v):R=g():(v.data!==S.children&&(Cr=!0,v.data=S.children),R=t(v));break;case $e:L!==8||M?R=g():R=t(v);break;case In:if(M&&(v=t(v),L=v.nodeType),L===1||L===3){R=v;const ie=!S.children.length;for(let W=0;W<S.staticCount;W++)ie&&(S.children+=R.nodeType===1?R.outerHTML:R.data),W===S.staticCount-1&&(S.anchor=R),R=t(R);return M?t(R):R}else g();break;case Pe:M?R=w(v,S,x,A,G,Z):R=g();break;default:if(Y&1)L!==1||S.type.toLowerCase()!==v.tagName.toLowerCase()?R=g():R=m(v,S,x,A,G,Z);else if(Y&6){S.slotScopeIds=G;const ie=s(v);if(r(S,ie,null,x,A,ea(ie),Z),R=M?k(v):t(v),R&&ra(R)&&R.data==="teleport end"&&(R=t(R)),ln(S)){let W;M?(W=ne(Pe),W.anchor=R?R.previousSibling:ie.lastChild):W=v.nodeType===3?Mr(""):ne("div"),W.el=v,S.component.subTree=W}}else Y&64?L!==8?R=g():R=S.type.hydrate(v,S,x,A,G,Z,e,f):Y&128&&(R=S.type.hydrate(v,S,x,A,ea(s(v)),G,Z,e,u))}return F!=null&&va(F,null,A,S),R},m=(v,S,x,A,G,Z)=>{Z=Z||!!S.dynamicChildren;const{type:M,props:g,patchFlag:J,shapeFlag:F,dirs:Y}=S,q=M==="input"&&Y||M==="option";if(q||J!==-1){if(Y&&cr(S,null,x,"created"),g)if(q||!Z||J&48)for(const R in g)(q&&R.endsWith("value")||Nn(R)&&!jn(R))&&a(v,R,null,g[R],!1,void 0,x);else g.onClick&&a(v,"onClick",null,g.onClick,!1,void 0,x);let L;if((L=g&&g.onVnodeBeforeMount)&&Qe(L,x,S),Y&&cr(S,null,x,"beforeMount"),((L=g&&g.onVnodeMounted)||Y)&&Bs(()=>{L&&Qe(L,x,S),Y&&cr(S,null,x,"mounted")},A),F&16&&!(g&&(g.innerHTML||g.textContent))){let R=f(v.firstChild,S,v,x,A,G,Z);for(;R;){Cr=!0;const ie=R;R=R.nextSibling,l(ie)}}else F&8&&v.textContent!==S.children&&(Cr=!0,v.textContent=S.children)}return v.nextSibling},f=(v,S,x,A,G,Z,M)=>{M=M||!!S.dynamicChildren;const g=S.children,J=g.length;for(let F=0;F<J;F++){const Y=M?g[F]:g[F]=nr(g[F]);if(v)v=u(v,Y,A,G,Z,M);else{if(Y.type===dn&&!Y.children)continue;Cr=!0,n(null,Y,x,null,A,G,ea(x),Z)}}return v},w=(v,S,x,A,G,Z)=>{const{slotScopeIds:M}=S;M&&(G=G?G.concat(M):M);const g=s(v),J=f(t(v),S,g,x,A,G,Z);return J&&ra(J)&&J.data==="]"?t(S.anchor=J):(Cr=!0,i(S.anchor=c("]"),g,J),J)},P=(v,S,x,A,G,Z)=>{if(Cr=!0,S.el=null,Z){const J=k(v);for(;;){const F=t(v);if(F&&F!==J)l(F);else break}}const M=t(v),g=s(v);return l(v),n(null,S,g,M,x,A,ea(g),G),M},k=v=>{let S=0;for(;v;)if(v=t(v),v&&ra(v)&&(v.data==="["&&S++,v.data==="]")){if(S===0)return t(v);S--}return v};return[d,u]}const We=Bs;function Rc(e){return Dc(e,Lc)}function Dc(e,r){const n=Qa();n.__VUE__=!0;const{insert:a,remove:o,patchProp:t,createElement:s,createText:l,createComment:i,setText:c,setElementText:d,parentNode:u,nextSibling:m,setScopeId:f=tr,insertStaticContent:w}=e,P=(p,h,b,E=null,j=null,I=null,B=!1,_=null,z=!!h.dynamicChildren)=>{if(p===h)return;p&&!Hr(p,h)&&(E=C(p),Ne(p,j,I,!0),p=null),h.patchFlag===-2&&(z=!1,h.dynamicChildren=null);const{type:T,ref:$,shapeFlag:V}=h;switch(T){case dn:k(p,h,b,E);break;case $e:v(p,h,b,E);break;case In:p==null&&S(h,b,E,B);break;case Pe:q(p,h,b,E,j,I,B,_,z);break;default:V&1?G(p,h,b,E,j,I,B,_,z):V&6?L(p,h,b,E,j,I,B,_,z):(V&64||V&128)&&T.process(p,h,b,E,j,I,B,_,z,O)}$!=null&&j&&va($,p&&p.ref,I,h||p,!h)},k=(p,h,b,E)=>{if(p==null)a(h.el=l(h.children),b,E);else{const j=h.el=p.el;h.children!==p.children&&c(j,h.children)}},v=(p,h,b,E)=>{p==null?a(h.el=i(h.children||""),b,E):h.el=p.el},S=(p,h,b,E)=>{[p.el,p.anchor]=w(p.children,h,b,E,p.el,p.anchor)},x=({el:p,anchor:h},b,E)=>{let j;for(;p&&p!==h;)j=m(p),a(p,b,E),p=j;a(h,b,E)},A=({el:p,anchor:h})=>{let b;for(;p&&p!==h;)b=m(p),o(p),p=b;o(h)},G=(p,h,b,E,j,I,B,_,z)=>{B=B||h.type==="svg",p==null?Z(h,b,E,j,I,B,_,z):J(p,h,j,I,B,_,z)},Z=(p,h,b,E,j,I,B,_)=>{let z,T;const{type:$,props:V,shapeFlag:X,transition:ae,dirs:le}=p;if(z=p.el=s(p.type,I,V&&V.is,V),X&8?d(z,p.children):X&16&&g(p.children,z,null,E,j,I&&$!=="foreignObject",B,_),le&&cr(p,null,E,"created"),M(z,p,p.scopeId,B,E),V){for(const ye in V)ye!=="value"&&!jn(ye)&&t(z,ye,null,V[ye],I,p.children,E,j,Le);"value"in V&&t(z,"value",null,V.value),(T=V.onVnodeBeforeMount)&&Qe(T,E,p)}le&&cr(p,null,E,"beforeMount");const Se=(!j||j&&!j.pendingBranch)&&ae&&!ae.persisted;Se&&ae.beforeEnter(z),a(z,h,b),((T=V&&V.onVnodeMounted)||Se||le)&&We(()=>{T&&Qe(T,E,p),Se&&ae.enter(z),le&&cr(p,null,E,"mounted")},j)},M=(p,h,b,E,j)=>{if(b&&f(p,b),E)for(let I=0;I<E.length;I++)f(p,E[I]);if(j){let I=j.subTree;if(h===I){const B=j.vnode;M(p,B,B.scopeId,B.slotScopeIds,j.parent)}}},g=(p,h,b,E,j,I,B,_,z=0)=>{for(let T=z;T<p.length;T++){const $=p[T]=_?Ir(p[T]):nr(p[T]);P(null,$,h,b,E,j,I,B,_)}},J=(p,h,b,E,j,I,B)=>{const _=h.el=p.el;let{patchFlag:z,dynamicChildren:T,dirs:$}=h;z|=p.patchFlag&16;const V=p.props||Ee,X=h.props||Ee;let ae;b&&zr(b,!1),(ae=X.onVnodeBeforeUpdate)&&Qe(ae,b,h,p),$&&cr(h,p,b,"beforeUpdate"),b&&zr(b,!0);const le=j&&h.type!=="foreignObject";if(T?F(p.dynamicChildren,T,_,b,E,le,I):B||te(p,h,_,null,b,E,le,I,!1),z>0){if(z&16)Y(_,h,V,X,b,E,j);else if(z&2&&V.class!==X.class&&t(_,"class",null,X.class,j),z&4&&t(_,"style",V.style,X.style,j),z&8){const Se=h.dynamicProps;for(let ye=0;ye<Se.length;ye++){const Ie=Se[ye],rr=V[Ie],Qr=X[Ie];(Qr!==rr||Ie==="value")&&t(_,Ie,rr,Qr,j,p.children,b,E,Le)}}z&1&&p.children!==h.children&&d(_,h.children)}else!B&&T==null&&Y(_,h,V,X,b,E,j);((ae=X.onVnodeUpdated)||$)&&We(()=>{ae&&Qe(ae,b,h,p),$&&cr(h,p,b,"updated")},E)},F=(p,h,b,E,j,I,B)=>{for(let _=0;_<h.length;_++){const z=p[_],T=h[_],$=z.el&&(z.type===Pe||!Hr(z,T)||z.shapeFlag&70)?u(z.el):b;P(z,T,$,null,E,j,I,B,!0)}},Y=(p,h,b,E,j,I,B)=>{if(b!==E){if(b!==Ee)for(const _ in b)!jn(_)&&!(_ in E)&&t(p,_,b[_],null,B,h.children,j,I,Le);for(const _ in E){if(jn(_))continue;const z=E[_],T=b[_];z!==T&&_!=="value"&&t(p,_,T,z,B,h.children,j,I,Le)}"value"in E&&t(p,"value",b.value,E.value)}},q=(p,h,b,E,j,I,B,_,z)=>{const T=h.el=p?p.el:l(""),$=h.anchor=p?p.anchor:l("");let{patchFlag:V,dynamicChildren:X,slotScopeIds:ae}=h;ae&&(_=_?_.concat(ae):ae),p==null?(a(T,b,E),a($,b,E),g(h.children,b,$,j,I,B,_,z)):V>0&&V&64&&X&&p.dynamicChildren?(F(p.dynamicChildren,X,b,j,I,B,_),(h.key!=null||j&&h===j.subTree)&&ai(p,h,!0)):te(p,h,b,$,j,I,B,_,z)},L=(p,h,b,E,j,I,B,_,z)=>{h.slotScopeIds=_,p==null?h.shapeFlag&512?j.ctx.activate(h,b,E,B,z):R(h,b,E,j,I,B,z):ie(p,h,z)},R=(p,h,b,E,j,I,B)=>{const _=p.component=Jc(p,E,j);if(Jn(p)&&(_.ctx.renderer=O),Wc(_),_.asyncDep){if(j&&j.registerDep(_,W),!p.el){const z=_.subTree=ne($e);v(null,z,h,b)}return}W(_,p,h,b,j,I,B)},ie=(p,h,b)=>{const E=h.component=p.component;if(rc(p,h,b))if(E.asyncDep&&!E.asyncResolved){oe(E,h,b);return}else E.next=h,Yl(E.update),E.update();else h.el=p.el,E.vnode=h},W=(p,h,b,E,j,I,B)=>{const _=()=>{if(p.isMounted){let{next:$,bu:V,u:X,parent:ae,vnode:le}=p,Se=$,ye;zr(p,!1),$?($.el=le.el,oe(p,$,B)):$=le,V&&Oa(V),(ye=$.props&&$.props.onVnodeBeforeUpdate)&&Qe(ye,ae,$,le),zr(p,!0);const Ie=za(p),rr=p.subTree;p.subTree=Ie,P(rr,Ie,u(rr.el),C(rr),p,j,I),$.el=Ie.el,Se===null&&nc(p,Ie.el),X&&We(X,j),(ye=$.props&&$.props.onVnodeUpdated)&&We(()=>Qe(ye,ae,$,le),j)}else{let $;const{el:V,props:X}=h,{bm:ae,m:le,parent:Se}=p,ye=ln(h);if(zr(p,!1),ae&&Oa(ae),!ye&&($=X&&X.onVnodeBeforeMount)&&Qe($,Se,h),zr(p,!0),V&&de){const Ie=()=>{p.subTree=za(p),de(V,p.subTree,p,j,null)};ye?h.type.__asyncLoader().then(()=>!p.isUnmounted&&Ie()):Ie()}else{const Ie=p.subTree=za(p);P(null,Ie,b,E,p,j,I),h.el=Ie.el}if(le&&We(le,j),!ye&&($=X&&X.onVnodeMounted)){const Ie=h;We(()=>Qe($,Se,Ie),j)}(h.shapeFlag&256||Se&&ln(Se.vnode)&&Se.vnode.shapeFlag&256)&&p.a&&We(p.a,j),p.isMounted=!0,h=b=E=null}},z=p.effect=new wo(_,()=>Ia(T),p.scope),T=p.update=()=>z.run();T.id=p.uid,zr(p,!0),T()},oe=(p,h,b)=>{h.component=p;const E=p.vnode.props;p.vnode=h,p.next=null,Ac(p,h.props,E,b),_c(p,h.children,b),gn(),ct(),fn()},te=(p,h,b,E,j,I,B,_,z=!1)=>{const T=p&&p.children,$=p?p.shapeFlag:0,V=h.children,{patchFlag:X,shapeFlag:ae}=h;if(X>0){if(X&128){De(T,V,b,E,j,I,B,_,z);return}else if(X&256){ze(T,V,b,E,j,I,B,_,z);return}}ae&8?($&16&&Le(T,j,I),V!==T&&d(b,V)):$&16?ae&16?De(T,V,b,E,j,I,B,_,z):Le(T,j,I,!0):($&8&&d(b,""),ae&16&&g(V,b,E,j,I,B,_,z))},ze=(p,h,b,E,j,I,B,_,z)=>{p=p||an,h=h||an;const T=p.length,$=h.length,V=Math.min(T,$);let X;for(X=0;X<V;X++){const ae=h[X]=z?Ir(h[X]):nr(h[X]);P(p[X],ae,b,null,j,I,B,_,z)}T>$?Le(p,j,I,!0,!1,V):g(h,b,E,j,I,B,_,z,V)},De=(p,h,b,E,j,I,B,_,z)=>{let T=0;const $=h.length;let V=p.length-1,X=$-1;for(;T<=V&&T<=X;){const ae=p[T],le=h[T]=z?Ir(h[T]):nr(h[T]);if(Hr(ae,le))P(ae,le,b,null,j,I,B,_,z);else break;T++}for(;T<=V&&T<=X;){const ae=p[V],le=h[X]=z?Ir(h[X]):nr(h[X]);if(Hr(ae,le))P(ae,le,b,null,j,I,B,_,z);else break;V--,X--}if(T>V){if(T<=X){const ae=X+1,le=ae<$?h[ae].el:E;for(;T<=X;)P(null,h[T]=z?Ir(h[T]):nr(h[T]),b,le,j,I,B,_,z),T++}}else if(T>X)for(;T<=V;)Ne(p[T],j,I,!0),T++;else{const ae=T,le=T,Se=new Map;for(T=le;T<=X;T++){const Ke=h[T]=z?Ir(h[T]):nr(h[T]);Ke.key!=null&&Se.set(Ke.key,T)}let ye,Ie=0;const rr=X-le+1;let Qr=!1,Xo=0;const yn=new Array(rr);for(T=0;T<rr;T++)yn[T]=0;for(T=ae;T<=V;T++){const Ke=p[T];if(Ie>=rr){Ne(Ke,j,I,!0);continue}let lr;if(Ke.key!=null)lr=Se.get(Ke.key);else for(ye=le;ye<=X;ye++)if(yn[ye-le]===0&&Hr(Ke,h[ye])){lr=ye;break}lr===void 0?Ne(Ke,j,I,!0):(yn[lr-le]=T+1,lr>=Xo?Xo=lr:Qr=!0,P(Ke,h[lr],b,null,j,I,B,_,z),Ie++)}const Qo=Qr?Mc(yn):an;for(ye=Qo.length-1,T=rr-1;T>=0;T--){const Ke=le+T,lr=h[Ke],Zo=Ke+1<$?h[Ke+1].el:E;yn[T]===0?P(null,lr,b,Zo,j,I,B,_,z):Qr&&(ye<0||T!==Qo[ye]?Je(lr,b,Zo,2):ye--)}}},Je=(p,h,b,E,j=null)=>{const{el:I,type:B,transition:_,children:z,shapeFlag:T}=p;if(T&6){Je(p.component.subTree,h,b,E);return}if(T&128){p.suspense.move(h,b,E);return}if(T&64){B.move(p,h,b,O);return}if(B===Pe){a(I,h,b);for(let V=0;V<z.length;V++)Je(z[V],h,b,E);a(p.anchor,h,b);return}if(B===In){x(p,h,b);return}if(E!==2&&T&1&&_)if(E===0)_.beforeEnter(I),a(I,h,b),We(()=>_.enter(I),j);else{const{leave:V,delayLeave:X,afterLeave:ae}=_,le=()=>a(I,h,b),Se=()=>{V(I,()=>{le(),ae&&ae()})};X?X(I,le,Se):Se()}else a(I,h,b)},Ne=(p,h,b,E=!1,j=!1)=>{const{type:I,props:B,ref:_,children:z,dynamicChildren:T,shapeFlag:$,patchFlag:V,dirs:X}=p;if(_!=null&&va(_,null,b,p,!0),$&256){h.ctx.deactivate(p);return}const ae=$&1&&X,le=!ln(p);let Se;if(le&&(Se=B&&B.onVnodeBeforeUnmount)&&Qe(Se,h,p),$&6)ir(p.component,b,E);else{if($&128){p.suspense.unmount(b,E);return}ae&&cr(p,null,h,"beforeUnmount"),$&64?p.type.remove(p,h,b,j,O,E):T&&(I!==Pe||V>0&&V&64)?Le(T,h,b,!1,!0):(I===Pe&&V&384||!j&&$&16)&&Le(z,h,b),E&&Pr(p)}(le&&(Se=B&&B.onVnodeUnmounted)||ae)&&We(()=>{Se&&Qe(Se,h,p),ae&&cr(p,null,h,"unmounted")},b)},Pr=p=>{const{type:h,el:b,anchor:E,transition:j}=p;if(h===Pe){Er(b,E);return}if(h===In){A(p);return}const I=()=>{o(b),j&&!j.persisted&&j.afterLeave&&j.afterLeave()};if(p.shapeFlag&1&&j&&!j.persisted){const{leave:B,delayLeave:_}=j,z=()=>B(b,I);_?_(p.el,I,z):z()}else I()},Er=(p,h)=>{let b;for(;p!==h;)b=m(p),o(p),p=b;o(h)},ir=(p,h,b)=>{const{bum:E,scope:j,update:I,subTree:B,um:_}=p;E&&Oa(E),j.stop(),I&&(I.active=!1,Ne(B,p,h,b)),_&&We(_,h),We(()=>{p.isUnmounted=!0},h),h&&h.pendingBranch&&!h.isUnmounted&&p.asyncDep&&!p.asyncResolved&&p.suspenseId===h.pendingId&&(h.deps--,h.deps===0&&h.resolve())},Le=(p,h,b,E=!1,j=!1,I=0)=>{for(let B=I;B<p.length;B++)Ne(p[B],h,b,E,j)},C=p=>p.shapeFlag&6?C(p.component.subTree):p.shapeFlag&128?p.suspense.next():m(p.anchor||p.el),H=(p,h,b)=>{p==null?h._vnode&&Ne(h._vnode,null,null,!0):P(h._vnode||null,p,h,null,null,null,b),ct(),ma(),h._vnode=p},O={p:P,um:Ne,m:Je,r:Pr,mt:R,mc:g,pc:te,pbc:F,n:C,o:e};let K,de;return r&&([K,de]=r(O)),{render:H,hydrate:K,createApp:qc(H,K)}}function zr({effect:e,update:r},n){e.allowRecurse=r.allowRecurse=n}function ai(e,r,n=!1){const a=e.children,o=r.children;if(Q(a)&&Q(o))for(let t=0;t<a.length;t++){const s=a[t];let l=o[t];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=o[t]=Ir(o[t]),l.el=s.el),n||ai(s,l)),l.type===dn&&(l.el=s.el)}}function Mc(e){const r=e.slice(),n=[0];let a,o,t,s,l;const i=e.length;for(a=0;a<i;a++){const c=e[a];if(c!==0){if(o=n[n.length-1],e[o]<c){r[a]=o,n.push(a);continue}for(t=0,s=n.length-1;t<s;)l=t+s>>1,e[n[l]]<c?t=l+1:s=l;c<e[n[t]]&&(t>0&&(r[a]=n[t-1]),n[t]=a)}}for(t=n.length,s=n[t-1];t-- >0;)n[t]=s,s=r[s];return n}const Oc=e=>e.__isTeleport,Pe=Symbol.for("v-fgt"),dn=Symbol.for("v-txt"),$e=Symbol.for("v-cmt"),In=Symbol.for("v-stc"),An=[];let or=null;function U(e=!1){An.push(or=e?null:[])}function zc(){An.pop(),or=An[An.length-1]||null}let Mn=1;function wt(e){Mn+=e}function oi(e){return e.dynamicChildren=Mn>0?or||an:null,zc(),Mn>0&&or&&or.push(e),e}function ee(e,r,n,a,o,t){return oi(he(e,r,n,a,o,t,!0))}function Ae(e,r,n,a,o){return oi(ne(e,r,n,a,o,!0))}function ba(e){return e?e.__v_isVNode===!0:!1}function Hr(e,r){return e.type===r.type&&e.key===r.key}const _a="__vInternal",ti=({key:e})=>e??null,ia=({ref:e,ref_key:r,ref_for:n})=>(typeof e=="number"&&(e=""+e),e!=null?ve(e)||Re(e)||se(e)?{i:Oe,r:e,k:r,f:!!n}:e:null);function he(e,r=null,n=null,a=0,o=null,t=e===Pe?0:1,s=!1,l=!1){const i={__v_isVNode:!0,__v_skip:!0,type:e,props:r,key:r&&ti(r),ref:r&&ia(r),scopeId:Fs,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:t,patchFlag:a,dynamicProps:o,dynamicChildren:null,appContext:null,ctx:Oe};return l?(Ro(i,n),t&128&&e.normalize(i)):n&&(i.shapeFlag|=ve(n)?8:16),Mn>0&&!s&&or&&(i.patchFlag>0||t&6)&&i.patchFlag!==32&&or.push(i),i}const ne=Nc;function Nc(e,r=null,n=null,a=0,o=null,t=!1){if((!e||e===bc)&&(e=$e),ba(e)){const l=Dr(e,r,!0);return n&&Ro(l,n),Mn>0&&!t&&or&&(l.shapeFlag&6?or[or.indexOf(e)]=l:or.push(l)),l.patchFlag|=-2,l}if($c(e)&&(e=e.__vccOpts),r){r=Fc(r);let{class:l,style:i}=r;l&&!ve(l)&&(r.class=Ge(l)),ke(i)&&(_s(i)&&!Q(i)&&(i=xe({},i)),r.style=Fn(i))}const s=ve(e)?1:ac(e)?128:Oc(e)?64:ke(e)?4:se(e)?2:0;return he(e,r,n,a,o,s,t,!0)}function Fc(e){return e?_s(e)||_a in e?xe({},e):e:null}function Dr(e,r,n=!1){const{props:a,ref:o,patchFlag:t,children:s}=e,l=r?co(a||{},r):a;return{__v_isVNode:!0,__v_skip:!0,type:e.type,props:l,key:l&&ti(l),ref:r&&r.ref?n&&o?Q(o)?o.concat(ia(r)):[o,ia(r)]:ia(r):o,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:s,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:r&&e.type!==Pe?t===-1?16:t|16:t,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Dr(e.ssContent),ssFallback:e.ssFallback&&Dr(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce}}function Mr(e=" ",r=0){return ne(dn,null,e,r)}function Bc(e,r){const n=ne(In,null,e);return n.staticCount=r,n}function je(e="",r=!1){return r?(U(),Ae($e,null,e)):ne($e,null,e)}function nr(e){return e==null||typeof e=="boolean"?ne($e):Q(e)?ne(Pe,null,e.slice()):typeof e=="object"?Ir(e):ne(dn,null,String(e))}function Ir(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Dr(e)}function Ro(e,r){let n=0;const{shapeFlag:a}=e;if(r==null)r=null;else if(Q(r))n=16;else if(typeof r=="object")if(a&65){const o=r.default;o&&(o._c&&(o._d=!1),Ro(e,o()),o._c&&(o._d=!0));return}else{n=32;const o=r._;!o&&!(_a in r)?r._ctx=Oe:o===3&&Oe&&(Oe.slots._===1?r._=1:(r._=2,e.patchFlag|=1024))}else se(r)?(r={default:r,_ctx:Oe},n=32):(r=String(r),a&64?(n=16,r=[Mr(r)]):n=8);e.children=r,e.shapeFlag|=n}function co(...e){const r={};for(let n=0;n<e.length;n++){const a=e[n];for(const o in a)if(o==="class")r.class!==a.class&&(r.class=Ge([r.class,a.class]));else if(o==="style")r.style=Fn([r.style,a.style]);else if(Nn(o)){const t=r[o],s=a[o];s&&t!==s&&!(Q(t)&&t.includes(s))&&(r[o]=t?[].concat(t,s):s)}else o!==""&&(r[o]=a[o])}return r}function Qe(e,r,n,a=null){Ze(e,r,7,[n,a])}const Uc=Xs();let Hc=0;function Jc(e,r,n){const a=e.type,o=(r?r.appContext:e.appContext)||Uc,t={uid:Hc++,vnode:e,type:a,parent:r,appContext:o,root:null,next:null,subTree:null,effect:null,update:null,scope:new cl(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:r?r.provides:Object.create(o.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Zs(a,o),emitsOptions:Ns(a,o),emit:null,emitted:null,propsDefaults:Ee,inheritAttrs:a.inheritAttrs,ctx:Ee,data:Ee,props:Ee,attrs:Ee,slots:Ee,refs:Ee,setupState:Ee,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return t.ctx={_:t},t.root=r?r.root:t,t.emit=Ql.bind(null,t),e.ce&&e.ce(t),t}let Te=null;const Do=()=>Te||Oe;let Mo,Zr,Pt="__VUE_INSTANCE_SETTERS__";(Zr=Qa()[Pt])||(Zr=Qa()[Pt]=[]),Zr.push(e=>Te=e),Mo=e=>{Zr.length>1?Zr.forEach(r=>r(e)):Zr[0](e)};const un=e=>{Mo(e),e.scope.on()},Kr=()=>{Te&&Te.scope.off(),Mo(null)};function si(e){return e.vnode.shapeFlag&4}let mn=!1;function Wc(e,r=!1){mn=r;const{props:n,children:a}=e.vnode,o=si(e);Ic(e,n,o,r),Tc(e,a);const t=o?Gc(e,r):void 0;return mn=!1,t}function Gc(e,r){const n=e.type;e.accessCache=Object.create(null),e.proxy=Ls(new Proxy(e.ctx,Sc));const{setup:a}=n;if(a){const o=e.setupContext=a.length>1?Kc(e):null;un(e),gn();const t=Tr(a,e,0,[e.props,o]);if(fn(),Kr(),gs(t)){if(t.then(Kr,Kr),r)return t.then(s=>{Et(e,s,r)}).catch(s=>{Un(s,e,0)});e.asyncDep=t}else Et(e,t,r)}else ii(e,r)}function Et(e,r,n){se(r)?e.type.__ssrInlineRender?e.ssrRender=r:e.render=r:ke(r)&&(e.setupState=Ds(r)),ii(e,n)}let kt;function ii(e,r,n){const a=e.type;if(!e.render){if(!r&&kt&&!a.render){const o=a.template||_o(e).template;if(o){const{isCustomElement:t,compilerOptions:s}=e.appContext.config,{delimiters:l,compilerOptions:i}=a,c=xe(xe({isCustomElement:t,delimiters:l},s),i);a.render=kt(o,c)}}e.render=a.render||tr}un(e),gn(),wc(e),fn(),Kr()}function Vc(e){return e.attrsProxy||(e.attrsProxy=new Proxy(e.attrs,{get(r,n){return Ve(e,"get","$attrs"),r[n]}}))}function Kc(e){const r=n=>{e.exposed=n||{}};return{get attrs(){return Vc(e)},slots:e.slots,emit:e.emit,expose:r}}function La(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(Ds(Ls(e.exposed)),{get(r,n){if(n in r)return r[n];if(n in qn)return qn[n](e)},has(r,n){return n in r||n in qn}}))}function Yc(e,r=!0){return se(e)?e.displayName||e.name:e.name||r&&e.__name}function $c(e){return se(e)&&"__vccOpts"in e}const N=(e,r)=>Gl(e,r,mn);function ce(e,r,n){const a=arguments.length;return a===2?ke(r)&&!Q(r)?ba(r)?ne(e,null,[r]):ne(e,r):ne(e,null,r):(a>3?n=Array.prototype.slice.call(arguments,2):a===3&&ba(n)&&(n=[n]),ne(e,r,n))}const Xc=Symbol.for("v-scx"),Qc=()=>qe(Xc),Zc="3.3.4",ed="http://www.w3.org/2000/svg",Jr=typeof document<"u"?document:null,Ct=Jr&&Jr.createElement("template"),rd={insert:(e,r,n)=>{r.insertBefore(e,n||null)},remove:e=>{const r=e.parentNode;r&&r.removeChild(e)},createElement:(e,r,n,a)=>{const o=r?Jr.createElementNS(ed,e):Jr.createElement(e,n?{is:n}:void 0);return e==="select"&&a&&a.multiple!=null&&o.setAttribute("multiple",a.multiple),o},createText:e=>Jr.createTextNode(e),createComment:e=>Jr.createComment(e),setText:(e,r)=>{e.nodeValue=r},setElementText:(e,r)=>{e.textContent=r},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Jr.querySelector(e),setScopeId(e,r){e.setAttribute(r,"")},insertStaticContent(e,r,n,a,o,t){const s=n?n.previousSibling:r.lastChild;if(o&&(o===t||o.nextSibling))for(;r.insertBefore(o.cloneNode(!0),n),!(o===t||!(o=o.nextSibling)););else{Ct.innerHTML=a?`<svg>${e}</svg>`:e;const l=Ct.content;if(a){const i=l.firstChild;for(;i.firstChild;)l.appendChild(i.firstChild);l.removeChild(i)}r.insertBefore(l,n)}return[s?s.nextSibling:r.firstChild,n?n.previousSibling:r.lastChild]}};function nd(e,r,n){const a=e._vtc;a&&(r=(r?[r,...a]:[...a]).join(" ")),r==null?e.removeAttribute("class"):n?e.setAttribute("class",r):e.className=r}function ad(e,r,n){const a=e.style,o=ve(n);if(n&&!o){if(r&&!ve(r))for(const t in r)n[t]==null&&uo(a,t,"");for(const t in n)uo(a,t,n[t])}else{const t=a.display;o?r!==n&&(a.cssText=n):r&&e.removeAttribute("style"),"_vod"in e&&(a.display=t)}}const jt=/\s*!important$/;function uo(e,r,n){if(Q(n))n.forEach(a=>uo(e,r,a));else if(n==null&&(n=""),r.startsWith("--"))e.setProperty(r,n);else{const a=od(e,r);jt.test(n)?e.setProperty(Yr(a),n.replace(jt,""),"important"):e[a]=n}}const qt=["Webkit","Moz","ms"],Ua={};function od(e,r){const n=Ua[r];if(n)return n;let a=ur(r);if(a!=="filter"&&a in e)return Ua[r]=a;a=Ca(a);for(let o=0;o<qt.length;o++){const t=qt[o]+a;if(t in e)return Ua[r]=t}return r}const It="http://www.w3.org/1999/xlink";function td(e,r,n,a,o){if(a&&r.startsWith("xlink:"))n==null?e.removeAttributeNS(It,r.slice(6,r.length)):e.setAttributeNS(It,r,n);else{const t=ll(r);n==null||t&&!bs(n)?e.removeAttribute(r):e.setAttribute(r,t?"":n)}}function sd(e,r,n,a,o,t,s){if(r==="innerHTML"||r==="textContent"){a&&s(a,o,t),e[r]=n??"";return}const l=e.tagName;if(r==="value"&&l!=="PROGRESS"&&!l.includes("-")){e._value=n;const c=l==="OPTION"?e.getAttribute("value"):e.value,d=n??"";c!==d&&(e.value=d),n==null&&e.removeAttribute(r);return}let i=!1;if(n===""||n==null){const c=typeof e[r];c==="boolean"?n=bs(n):n==null&&c==="string"?(n="",i=!0):c==="number"&&(n=0,i=!0)}try{e[r]=n}catch{}i&&e.removeAttribute(r)}function id(e,r,n,a){e.addEventListener(r,n,a)}function ld(e,r,n,a){e.removeEventListener(r,n,a)}function cd(e,r,n,a,o=null){const t=e._vei||(e._vei={}),s=t[r];if(a&&s)s.value=a;else{const[l,i]=dd(r);if(a){const c=t[r]=pd(a,o);id(e,l,c,i)}else s&&(ld(e,l,s,i),t[r]=void 0)}}const At=/(?:Once|Passive|Capture)$/;function dd(e){let r;if(At.test(e)){r={};let a;for(;a=e.match(At);)e=e.slice(0,e.length-a[0].length),r[a[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):Yr(e.slice(2)),r]}let Ha=0;const ud=Promise.resolve(),md=()=>Ha||(ud.then(()=>Ha=0),Ha=Date.now());function pd(e,r){const n=a=>{if(!a._vts)a._vts=Date.now();else if(a._vts<=n.attached)return;Ze(hd(a,n.value),r,5,[a])};return n.value=e,n.attached=md(),n}function hd(e,r){if(Q(r)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},r.map(a=>o=>!o._stopped&&a&&a(o))}else return r}const xt=/^on[a-z]/,gd=(e,r,n,a,o=!1,t,s,l,i)=>{r==="class"?nd(e,a,o):r==="style"?ad(e,n,a):Nn(r)?fo(r)||cd(e,r,n,a,s):(r[0]==="."?(r=r.slice(1),!0):r[0]==="^"?(r=r.slice(1),!1):fd(e,r,a,o))?sd(e,r,a,t,s,l,i):(r==="true-value"?e._trueValue=a:r==="false-value"&&(e._falseValue=a),td(e,r,a,o))};function fd(e,r,n,a){return a?!!(r==="innerHTML"||r==="textContent"||r in e&&xt.test(r)&&se(n)):r==="spellcheck"||r==="draggable"||r==="translate"||r==="form"||r==="list"&&e.tagName==="INPUT"||r==="type"&&e.tagName==="TEXTAREA"||xt.test(r)&&ve(n)?!1:r in e}const jr="transition",Sn="animation",Gn=(e,{slots:r})=>ce(ic,vd(e),r);Gn.displayName="Transition";const li={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};Gn.props=xe({},Js,li);const Nr=(e,r=[])=>{Q(e)?e.forEach(n=>n(...r)):e&&e(...r)},Tt=e=>e?Q(e)?e.some(r=>r.length>1):e.length>1:!1;function vd(e){const r={};for(const q in e)q in li||(r[q]=e[q]);if(e.css===!1)return r;const{name:n="v",type:a,duration:o,enterFromClass:t=`${n}-enter-from`,enterActiveClass:s=`${n}-enter-active`,enterToClass:l=`${n}-enter-to`,appearFromClass:i=t,appearActiveClass:c=s,appearToClass:d=l,leaveFromClass:u=`${n}-leave-from`,leaveActiveClass:m=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=e,w=bd(o),P=w&&w[0],k=w&&w[1],{onBeforeEnter:v,onEnter:S,onEnterCancelled:x,onLeave:A,onLeaveCancelled:G,onBeforeAppear:Z=v,onAppear:M=S,onAppearCancelled:g=x}=r,J=(q,L,R)=>{Fr(q,L?d:l),Fr(q,L?c:s),R&&R()},F=(q,L)=>{q._isLeaving=!1,Fr(q,u),Fr(q,f),Fr(q,m),L&&L()},Y=q=>(L,R)=>{const ie=q?M:S,W=()=>J(L,q,R);Nr(ie,[L,W]),_t(()=>{Fr(L,q?i:t),qr(L,q?d:l),Tt(ie)||Lt(L,a,P,W)})};return xe(r,{onBeforeEnter(q){Nr(v,[q]),qr(q,t),qr(q,s)},onBeforeAppear(q){Nr(Z,[q]),qr(q,i),qr(q,c)},onEnter:Y(!1),onAppear:Y(!0),onLeave(q,L){q._isLeaving=!0;const R=()=>F(q,L);qr(q,u),wd(),qr(q,m),_t(()=>{q._isLeaving&&(Fr(q,u),qr(q,f),Tt(A)||Lt(q,a,k,R))}),Nr(A,[q,R])},onEnterCancelled(q){J(q,!1),Nr(x,[q])},onAppearCancelled(q){J(q,!0),Nr(g,[q])},onLeaveCancelled(q){F(q),Nr(G,[q])}})}function bd(e){if(e==null)return null;if(ke(e))return[Ja(e.enter),Ja(e.leave)];{const r=Ja(e);return[r,r]}}function Ja(e){return nl(e)}function qr(e,r){r.split(/\s+/).forEach(n=>n&&e.classList.add(n)),(e._vtc||(e._vtc=new Set)).add(r)}function Fr(e,r){r.split(/\s+/).forEach(a=>a&&e.classList.remove(a));const{_vtc:n}=e;n&&(n.delete(r),n.size||(e._vtc=void 0))}function _t(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let yd=0;function Lt(e,r,n,a){const o=e._endId=++yd,t=()=>{o===e._endId&&a()};if(n)return setTimeout(t,n);const{type:s,timeout:l,propCount:i}=Sd(e,r);if(!s)return a();const c=s+"end";let d=0;const u=()=>{e.removeEventListener(c,m),t()},m=f=>{f.target===e&&++d>=i&&u()};setTimeout(()=>{d<i&&u()},l+1),e.addEventListener(c,m)}function Sd(e,r){const n=window.getComputedStyle(e),a=w=>(n[w]||"").split(", "),o=a(`${jr}Delay`),t=a(`${jr}Duration`),s=Rt(o,t),l=a(`${Sn}Delay`),i=a(`${Sn}Duration`),c=Rt(l,i);let d=null,u=0,m=0;r===jr?s>0&&(d=jr,u=s,m=t.length):r===Sn?c>0&&(d=Sn,u=c,m=i.length):(u=Math.max(s,c),d=u>0?s>c?jr:Sn:null,m=d?d===jr?t.length:i.length:0);const f=d===jr&&/\b(transform|all)(,|$)/.test(a(`${jr}Property`).toString());return{type:d,timeout:u,propCount:m,hasTransform:f}}function Rt(e,r){for(;e.length<r.length;)e=e.concat(e);return Math.max(...r.map((n,a)=>Dt(n)+Dt(e[a])))}function Dt(e){return Number(e.slice(0,-1).replace(",","."))*1e3}function wd(){return document.body.offsetHeight}const Pd={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},Ed=(e,r)=>n=>{if(!("key"in n))return;const a=Yr(n.key);if(r.some(o=>o===a||Pd[o]===a))return e(n)},ya={beforeMount(e,{value:r},{transition:n}){e._vod=e.style.display==="none"?"":e.style.display,n&&r?n.beforeEnter(e):wn(e,r)},mounted(e,{value:r},{transition:n}){n&&r&&n.enter(e)},updated(e,{value:r,oldValue:n},{transition:a}){!r!=!n&&(a?r?(a.beforeEnter(e),wn(e,!0),a.enter(e)):a.leave(e,()=>{wn(e,!1)}):wn(e,r))},beforeUnmount(e,{value:r}){wn(e,r)}};function wn(e,r){e.style.display=r?e._vod:"none"}const kd=xe({patchProp:gd},rd);let Wa,Mt=!1;function Cd(){return Wa=Mt?Wa:Rc(kd),Mt=!0,Wa}const jd=(...e)=>{const r=Cd().createApp(...e),{mount:n}=r;return r.mount=a=>{const o=qd(a);if(o)return n(o,!0,o instanceof SVGElement)},r};function qd(e){return ve(e)?document.querySelector(e):e}const Id={"v-8daa1a0e":()=>y(()=>import("./index.html-f133f0c9.js"),[]).then(({data:e})=>e),"v-705d1b76":()=>y(()=>import("./test_page.html-dd9bfa0c.js"),[]).then(({data:e})=>e),"v-2d0a870d":()=>y(()=>import("./index.html-ad205d14.js"),[]).then(({data:e})=>e),"v-2d0a87a8":()=>y(()=>import("./index.html-1ed2bcbc.js"),[]).then(({data:e})=>e),"v-5aa74f15":()=>y(()=>import("./concurrency.html-cea8977e.js"),[]).then(({data:e})=>e),"v-b73e5022":()=>y(()=>import("./index.html-19fea898.js"),[]).then(({data:e})=>e),"v-4b0532d0":()=>y(()=>import("./operatingsystem.html-6c654d81.js"),[]).then(({data:e})=>e),"v-3f423939":()=>y(()=>import("./process.html-68032138.js"),[]).then(({data:e})=>e),"v-0532b77b":()=>y(()=>import("./console_annex.html-f30139a8.js"),[]).then(({data:e})=>e),"v-8100edac":()=>y(()=>import("./curl_annex.html-e84ae368.js"),[]).then(({data:e})=>e),"v-b73e4fe4":()=>y(()=>import("./index.html-5f3d69e7.js"),[]).then(({data:e})=>e),"v-74406b7a":()=>y(()=>import("./iostreams.html-140df912.js"),[]).then(({data:e})=>e),"v-ecf5776a":()=>y(()=>import("./ipc.html-0ef38476.js"),[]).then(({data:e})=>e),"v-348bab3f":()=>y(()=>import("./processbuilder.html-40adaec1.js"),[]).then(({data:e})=>e),"v-1daecb0f":()=>y(()=>import("./runtime.html-2b8c591d.js"),[]).then(({data:e})=>e),"v-5bb12cb4":()=>y(()=>import("./alternatives.html-f009a03f.js"),[]).then(({data:e})=>e),"v-10f2297a":()=>y(()=>import("./arraylist_annex.html-3e0b1784.js"),[]).then(({data:e})=>e),"v-737de6d4":()=>y(()=>import("./debugger_annex.html-018103fd.js"),[]).then(({data:e})=>e),"v-3714d943":()=>y(()=>import("./hashmap_annex.html-53e5f82a.js"),[]).then(({data:e})=>e),"v-b73e4fa6":()=>y(()=>import("./index.html-0431a5b4.js"),[]).then(({data:e})=>e),"v-30e3afd6":()=>y(()=>import("./producer-consumer.html-2a4cbf44.js"),[]).then(({data:e})=>e),"v-27271e62":()=>y(()=>import("./runnable.html-3c85a447.js"),[]).then(({data:e})=>e),"v-1dbfca26":()=>y(()=>import("./synchronization.html-3c3f8e9a.js"),[]).then(({data:e})=>e),"v-b73e4f68":()=>y(()=>import("./index.html-67e08c72.js"),[]).then(({data:e})=>e),"v-14f705b1":()=>y(()=>import("./sockets-tcp.html-5b25a688.js"),[]).then(({data:e})=>e),"v-9c83245e":()=>y(()=>import("./sockets-udp.html-bd9f199f.js"),[]).then(({data:e})=>e),"v-17f557b3":()=>y(()=>import("./stateful-protocols.html-3fd4c7da.js"),[]).then(({data:e})=>e),"v-de8e734c":()=>y(()=>import("./tcp-ip.html-bc436d60.js"),[]).then(({data:e})=>e),"v-1885fe22":()=>y(()=>import("./ftp.html-09d58d22.js"),[]).then(({data:e})=>e),"v-71b551b1":()=>y(()=>import("./gmail_annex.html-26fccf52.js"),[]).then(({data:e})=>e),"v-b73e4f2a":()=>y(()=>import("./index.html-37bf6cea.js"),[]).then(({data:e})=>e),"v-44aca577":()=>y(()=>import("./mail.html-698e276d.js"),[]).then(({data:e})=>e),"v-7768b66a":()=>y(()=>import("./urls.html-3dc9aa78.js"),[]).then(({data:e})=>e),"v-6e11e1d8":()=>y(()=>import("./asymmetric-keys.html-e727e87b.js"),[]).then(({data:e})=>e),"v-4e4467f3":()=>y(()=>import("./hash-functions.html-94dfd17b.js"),[]).then(({data:e})=>e),"v-b73e4eec":()=>y(()=>import("./index.html-57957c4e.js"),[]).then(({data:e})=>e),"v-6fa59714":()=>y(()=>import("./jsse.html-0ed7504b.js"),[]).then(({data:e})=>e),"v-2c8673f4":()=>y(()=>import("./log4j_annex.html-a22ab4e6.js"),[]).then(({data:e})=>e),"v-2e9c294f":()=>y(()=>import("./security.html-ad09f3a7.js"),[]).then(({data:e})=>e),"v-0b29848c":()=>y(()=>import("./symmetric-key.html-b6694a4a.js"),[]).then(({data:e})=>e),"v-46af1970":()=>y(()=>import("./concurrency.html-4ae60790.js"),[]).then(({data:e})=>e),"v-a8728f6c":()=>y(()=>import("./index.html-448dd084.js"),[]).then(({data:e})=>e),"v-e2dae91a":()=>y(()=>import("./operatingsystem.html-a3343488.js"),[]).then(({data:e})=>e),"v-75292dd8":()=>y(()=>import("./process.html-ab2b48f9.js"),[]).then(({data:e})=>e),"v-0e715716":()=>y(()=>import("./console_annex.html-23e5de55.js"),[]).then(({data:e})=>e),"v-3277876f":()=>y(()=>import("./curl_annex.html-c4d00569.js"),[]).then(({data:e})=>e),"v-a8728f2e":()=>y(()=>import("./index.html-eacea1db.js"),[]).then(({data:e})=>e),"v-14dd1095":()=>y(()=>import("./iostreams.html-7a9eae09.js"),[]).then(({data:e})=>e),"v-1d42ccb4":()=>y(()=>import("./ipc.html-356ca3e1.js"),[]).then(({data:e})=>e),"v-5320ff04":()=>y(()=>import("./processbuilder.html-974cf72f.js"),[]).then(({data:e})=>e),"v-b8500a2c":()=>y(()=>import("./runtime.html-b3314bfe.js"),[]).then(({data:e})=>e),"v-6718eaab":()=>y(()=>import("./alternatives.html-eea36f39.js"),[]).then(({data:e})=>e),"v-75f16356":()=>y(()=>import("./arraylist_annex.html-5ecf0008.js"),[]).then(({data:e})=>e),"v-36533f4a":()=>y(()=>import("./debugger_annex.html-adce6756.js"),[]).then(({data:e})=>e),"v-405378de":()=>y(()=>import("./hashmap_annex.html-9f09e7a7.js"),[]).then(({data:e})=>e),"v-a8728ef0":()=>y(()=>import("./index.html-8ed0d755.js"),[]).then(({data:e})=>e),"v-2a24fba0":()=>y(()=>import("./producer-consumer.html-16c718ae.js"),[]).then(({data:e})=>e),"v-2b693c54":()=>y(()=>import("./runnable.html-ad558aac.js"),[]).then(({data:e})=>e),"v-5c5621fe":()=>y(()=>import("./synchronization.html-01f361a1.js"),[]).then(({data:e})=>e),"v-a8728eb2":()=>y(()=>import("./index.html-facd1414.js"),[]).then(({data:e})=>e),"v-00fed00c":()=>y(()=>import("./sockets-tcp.html-09501448.js"),[]).then(({data:e})=>e),"v-c4738fa8":()=>y(()=>import("./sockets-udp.html-b60d9320.js"),[]).then(({data:e})=>e),"v-fefd7e10":()=>y(()=>import("./stateful-protocols.html-4718b1d1.js"),[]).then(({data:e})=>e),"v-d5e6a1c2":()=>y(()=>import("./tcp-ip.html-a6d36f4c.js"),[]).then(({data:e})=>e),"v-ff415906":()=>y(()=>import("./ftp.html-645107b0.js"),[]).then(({data:e})=>e),"v-5dbd1c0c":()=>y(()=>import("./gmail_annex.html-3289abd5.js"),[]).then(({data:e})=>e),"v-a8728e74":()=>y(()=>import("./index.html-439589b4.js"),[]).then(({data:e})=>e),"v-50040908":()=>y(()=>import("./mail.html-b599082c.js"),[]).then(({data:e})=>e),"v-0aba0c6f":()=>y(()=>import("./urls.html-fe972418.js"),[]).then(({data:e})=>e),"v-222706b3":()=>y(()=>import("./asymmetric-keys.html-e4a841cb.js"),[]).then(({data:e})=>e),"v-6cd9bbb8":()=>y(()=>import("./hash-functions.html-73ecb3c4.js"),[]).then(({data:e})=>e),"v-a8728e36":()=>y(()=>import("./index.html-6ccfa24f.js"),[]).then(({data:e})=>e),"v-02f6ed19":()=>y(()=>import("./jsse.html-61571fe3.js"),[]).then(({data:e})=>e),"v-188e3e4f":()=>y(()=>import("./log4j_annex.html-a7339c1a.js"),[]).then(({data:e})=>e),"v-6d98f4d4":()=>y(()=>import("./security.html-bc737f6b.js"),[]).then(({data:e})=>e),"v-03a9dd55":()=>y(()=>import("./symmetric-key.html-96f1b884.js"),[]).then(({data:e})=>e),"v-3706649a":()=>y(()=>import("./404.html-60b35caa.js"),[]).then(({data:e})=>e)},Ad=JSON.parse('{"base":"/psp_pages/","lang":"en-US","title":"PSP","description":"PSP, CFGS DAM, FP, Programacion, Java, IES Doctor Balmis","head":[["meta",{"name":"theme-color","content":"#3eaf7c"}],["meta",{"name":"apple-mobile-web-app-capable","content":"yes"}],["meta",{"name":"apple-mobile-web-app-status-bar-style","content":"black"}],["link",{"rel":"icon","href":"/psp_pages/psp_favicon.png"}]],"locales":{"/en/":{"lang":"en-US","title":"Process and Service Programming","description":"2nd DAM PSP Module"},"/es/":{"lang":"es-ES","title":"Programacin de Servicios y Procesos","description":"Mdulo PSP de 2 DAM"}}}');var xd=([e,r,n])=>e==="meta"&&r.name?`${e}.${r.name}`:["title","base"].includes(e)?e:e==="template"&&r.id?`${e}.${r.id}`:JSON.stringify([e,r,n]),Td=e=>{const r=new Set,n=[];return e.forEach(a=>{const o=xd(a);r.has(o)||(r.add(o),n.push(a))}),n},Vn=e=>/^(https?:)?\/\//.test(e),_d=e=>/^mailto:/.test(e),Ld=e=>/^tel:/.test(e),Oo=e=>Object.prototype.toString.call(e)==="[object Object]",ci=e=>e[e.length-1]==="/"?e.slice(0,-1):e,di=e=>e[0]==="/"?e.slice(1):e,ui=(e,r)=>{const n=Object.keys(e).sort((a,o)=>{const t=o.split("/").length-a.split("/").length;return t!==0?t:o.length-a.length});for(const a of n)if(r.startsWith(a))return a;return"/"};const mi={"v-8daa1a0e":D(()=>y(()=>import("./index.html-a7f2d0d6.js"),[])),"v-705d1b76":D(()=>y(()=>import("./test_page.html-b5188f9a.js"),[])),"v-2d0a870d":D(()=>y(()=>import("./index.html-57727aac.js"),[])),"v-2d0a87a8":D(()=>y(()=>import("./index.html-681e5872.js"),[])),"v-5aa74f15":D(()=>y(()=>import("./concurrency.html-72f85e43.js"),["assets/concurrency.html-72f85e43.js","assets/gantt_parallel-4671b441.js"])),"v-b73e5022":D(()=>y(()=>import("./index.html-b9d3ba67.js"),[])),"v-4b0532d0":D(()=>y(()=>import("./operatingsystem.html-5996df94.js"),["assets/operatingsystem.html-5996df94.js","assets/roundrobin-3-a33bd40e.js"])),"v-3f423939":D(()=>y(()=>import("./process.html-f6633a9d.js"),["assets/process.html-f6633a9d.js","assets/threads_vs_process-2faff9a6.js"])),"v-0532b77b":D(()=>y(()=>import("./console_annex.html-654c101b.js"),[])),"v-8100edac":D(()=>y(()=>import("./curl_annex.html-0fb8ef48.js"),[])),"v-b73e4fe4":D(()=>y(()=>import("./index.html-0c1b2174.js"),[])),"v-74406b7a":D(()=>y(()=>import("./iostreams.html-40343e1e.js"),["assets/iostreams.html-40343e1e.js","assets/Java_Stream_Readers_BufferedReaders-a3f2ee86.js"])),"v-ecf5776a":D(()=>y(()=>import("./ipc.html-923db1b6.js"),[])),"v-348bab3f":D(()=>y(()=>import("./processbuilder.html-e98762dc.js"),["assets/processbuilder.html-e98762dc.js","assets/comandotree-12a93745.js"])),"v-1daecb0f":D(()=>y(()=>import("./runtime.html-d6c6e1ab.js"),[])),"v-5bb12cb4":D(()=>y(()=>import("./alternatives.html-d3ad2b7b.js"),[])),"v-10f2297a":D(()=>y(()=>import("./arraylist_annex.html-88db9d47.js"),["assets/arraylist_annex.html-88db9d47.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-737de6d4":D(()=>y(()=>import("./debugger_annex.html-8644410a.js"),["assets/debugger_annex.html-8644410a.js","assets/NetbeansDebug5-6a6c582c.js"])),"v-3714d943":D(()=>y(()=>import("./hashmap_annex.html-e2fa31e9.js"),["assets/hashmap_annex.html-e2fa31e9.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-b73e4fa6":D(()=>y(()=>import("./index.html-8c1212d1.js"),[])),"v-30e3afd6":D(()=>y(()=>import("./producer-consumer.html-ae684fa2.js"),["assets/producer-consumer.html-ae684fa2.js","assets/ProducerConsumer-a4b1ac79.js"])),"v-27271e62":D(()=>y(()=>import("./runnable.html-499662b9.js"),[])),"v-1dbfca26":D(()=>y(()=>import("./synchronization.html-6c7e048a.js"),["assets/synchronization.html-6c7e048a.js","assets/Monitor_queues-4b4465b3.js"])),"v-b73e4f68":D(()=>y(()=>import("./index.html-07ee21e9.js"),[])),"v-14f705b1":D(()=>y(()=>import("./sockets-tcp.html-616da690.js"),["assets/sockets-tcp.html-616da690.js","assets/multithread_server_sequence-89666c43.js"])),"v-9c83245e":D(()=>y(()=>import("./sockets-udp.html-125fa1a3.js"),["assets/sockets-udp.html-125fa1a3.js","assets/udp_process-df2d3e58.js"])),"v-17f557b3":D(()=>y(()=>import("./stateful-protocols.html-4dd222bd.js"),["assets/stateful-protocols.html-4dd222bd.js","assets/client_sample_state_protocol-61e731a5.js"])),"v-de8e734c":D(()=>y(()=>import("./tcp-ip.html-c9b9e5dc.js"),["assets/tcp-ip.html-c9b9e5dc.js","assets/5-Graphic-UDP-Vs-TCP-be6b3666.js"])),"v-1885fe22":D(()=>y(()=>import("./ftp.html-867925f6.js"),["assets/ftp.html-867925f6.js","assets/FileZilla-Server-Interface-aa9c48b2.js"])),"v-71b551b1":D(()=>y(()=>import("./gmail_annex.html-0cb88db1.js"),["assets/gmail_annex.html-0cb88db1.js","assets/Google-Settings-2.3-2c14aa8a.js"])),"v-b73e4f2a":D(()=>y(()=>import("./index.html-ac2671b2.js"),[])),"v-44aca577":D(()=>y(()=>import("./mail.html-5da62f21.js"),["assets/mail.html-5da62f21.js","assets/e-mail_multipart_structure-37b2dbb2.js"])),"v-7768b66a":D(()=>y(()=>import("./urls.html-2d67b491.js"),[])),"v-6e11e1d8":D(()=>y(()=>import("./asymmetric-keys.html-a4a3c720.js"),["assets/asymmetric-keys.html-a4a3c720.js","assets/digital-signature-sign-verify-148d6b7b.js"])),"v-4e4467f3":D(()=>y(()=>import("./hash-functions.html-4ea3094e.js"),[])),"v-b73e4eec":D(()=>y(()=>import("./index.html-4448e1b6.js"),[])),"v-6fa59714":D(()=>y(()=>import("./jsse.html-55703244.js"),["assets/jsse.html-55703244.js","assets/VM_Options-afb4ac41.js"])),"v-2c8673f4":D(()=>y(()=>import("./log4j_annex.html-267859f5.js"),[])),"v-2e9c294f":D(()=>y(()=>import("./security.html-cb766253.js"),[])),"v-0b29848c":D(()=>y(()=>import("./symmetric-key.html-e1153fc5.js"),["assets/symmetric-key.html-e1153fc5.js","assets/symmetric-encryption-primitive-db389e98.js"])),"v-46af1970":D(()=>y(()=>import("./concurrency.html-dfcecdda.js"),["assets/concurrency.html-dfcecdda.js","assets/gantt_parallel-4671b441.js"])),"v-a8728f6c":D(()=>y(()=>import("./index.html-0c5ae1bd.js"),[])),"v-e2dae91a":D(()=>y(()=>import("./operatingsystem.html-f7611290.js"),["assets/operatingsystem.html-f7611290.js","assets/roundrobin-3-a33bd40e.js"])),"v-75292dd8":D(()=>y(()=>import("./process.html-77616cf4.js"),["assets/process.html-77616cf4.js","assets/threads_vs_process-2faff9a6.js"])),"v-0e715716":D(()=>y(()=>import("./console_annex.html-ebcb4c10.js"),[])),"v-3277876f":D(()=>y(()=>import("./curl_annex.html-23096a08.js"),[])),"v-a8728f2e":D(()=>y(()=>import("./index.html-7c00552c.js"),[])),"v-14dd1095":D(()=>y(()=>import("./iostreams.html-f6a0241d.js"),["assets/iostreams.html-f6a0241d.js","assets/Java_Stream_Readers_BufferedReaders-a3f2ee86.js"])),"v-1d42ccb4":D(()=>y(()=>import("./ipc.html-ca2c059b.js"),[])),"v-5320ff04":D(()=>y(()=>import("./processbuilder.html-8f459073.js"),["assets/processbuilder.html-8f459073.js","assets/comandotree-12a93745.js"])),"v-b8500a2c":D(()=>y(()=>import("./runtime.html-d39696e5.js"),[])),"v-6718eaab":D(()=>y(()=>import("./alternatives.html-ce700925.js"),[])),"v-75f16356":D(()=>y(()=>import("./arraylist_annex.html-8f8c2b84.js"),["assets/arraylist_annex.html-8f8c2b84.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-36533f4a":D(()=>y(()=>import("./debugger_annex.html-eb645595.js"),["assets/debugger_annex.html-eb645595.js","assets/NetbeansDebug5-6a6c582c.js"])),"v-405378de":D(()=>y(()=>import("./hashmap_annex.html-923a1610.js"),["assets/hashmap_annex.html-923a1610.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-a8728ef0":D(()=>y(()=>import("./index.html-cb0b1dd5.js"),[])),"v-2a24fba0":D(()=>y(()=>import("./producer-consumer.html-7a1fa36b.js"),["assets/producer-consumer.html-7a1fa36b.js","assets/ProducerConsumer-a4b1ac79.js"])),"v-2b693c54":D(()=>y(()=>import("./runnable.html-851465c9.js"),[])),"v-5c5621fe":D(()=>y(()=>import("./synchronization.html-b24e5645.js"),["assets/synchronization.html-b24e5645.js","assets/Monitor_queues-4b4465b3.js"])),"v-a8728eb2":D(()=>y(()=>import("./index.html-8a9c60b7.js"),[])),"v-00fed00c":D(()=>y(()=>import("./sockets-tcp.html-c8dac399.js"),["assets/sockets-tcp.html-c8dac399.js","assets/multithread_server_sequence-89666c43.js"])),"v-c4738fa8":D(()=>y(()=>import("./sockets-udp.html-62f8dc45.js"),["assets/sockets-udp.html-62f8dc45.js","assets/udp_process-df2d3e58.js"])),"v-fefd7e10":D(()=>y(()=>import("./stateful-protocols.html-62e943fd.js"),["assets/stateful-protocols.html-62e943fd.js","assets/client_sample_state_protocol-61e731a5.js"])),"v-d5e6a1c2":D(()=>y(()=>import("./tcp-ip.html-0d9d339b.js"),["assets/tcp-ip.html-0d9d339b.js","assets/5-Graphic-UDP-Vs-TCP-be6b3666.js"])),"v-ff415906":D(()=>y(()=>import("./ftp.html-28f83b18.js"),["assets/ftp.html-28f83b18.js","assets/FileZilla-Server-Interface-aa9c48b2.js"])),"v-5dbd1c0c":D(()=>y(()=>import("./gmail_annex.html-46d7dbc7.js"),["assets/gmail_annex.html-46d7dbc7.js","assets/Google-Settings-2.3-2c14aa8a.js"])),"v-a8728e74":D(()=>y(()=>import("./index.html-9f128b60.js"),[])),"v-50040908":D(()=>y(()=>import("./mail.html-a4a5e753.js"),["assets/mail.html-a4a5e753.js","assets/e-mail_multipart_structure-37b2dbb2.js"])),"v-0aba0c6f":D(()=>y(()=>import("./urls.html-3e351ccb.js"),[])),"v-222706b3":D(()=>y(()=>import("./asymmetric-keys.html-918475a3.js"),["assets/asymmetric-keys.html-918475a3.js","assets/digital-signature-sign-verify-148d6b7b.js"])),"v-6cd9bbb8":D(()=>y(()=>import("./hash-functions.html-1af4117e.js"),[])),"v-a8728e36":D(()=>y(()=>import("./index.html-7bdf5a65.js"),[])),"v-02f6ed19":D(()=>y(()=>import("./jsse.html-10432f89.js"),["assets/jsse.html-10432f89.js","assets/VM_Options-afb4ac41.js"])),"v-188e3e4f":D(()=>y(()=>import("./log4j_annex.html-79b5da0e.js"),[])),"v-6d98f4d4":D(()=>y(()=>import("./security.html-bde759c7.js"),[])),"v-03a9dd55":D(()=>y(()=>import("./symmetric-key.html-853d8bcf.js"),["assets/symmetric-key.html-853d8bcf.js","assets/symmetric-encryption-primitive-db389e98.js"])),"v-3706649a":D(()=>y(()=>import("./404.html-59108678.js"),[]))};var Rd=Symbol(""),pi=Symbol(""),Dd=vn({key:"",path:"",title:"",lang:"",frontmatter:{},headers:[]}),_r=()=>{const e=qe(pi);if(!e)throw new Error("pageData() is called without provider.");return e},hi=Symbol(""),fr=()=>{const e=qe(hi);if(!e)throw new Error("usePageFrontmatter() is called without provider.");return e},gi=Symbol(""),Md=()=>{const e=qe(gi);if(!e)throw new Error("usePageHead() is called without provider.");return e},Od=Symbol(""),fi=Symbol(""),zd=()=>{const e=qe(fi);if(!e)throw new Error("usePageLang() is called without provider.");return e},vi=Symbol(""),Nd=()=>{const e=qe(vi);if(!e)throw new Error("usePageLayout() is called without provider.");return e},Fd=fe(Id),zo=Symbol(""),bn=()=>{const e=qe(zo);if(!e)throw new Error("useRouteLocale() is called without provider.");return e},nn=fe(Ad),bi=()=>nn,yi=Symbol(""),No=()=>{const e=qe(yi);if(!e)throw new Error("useSiteLocaleData() is called without provider.");return e},Bd=Symbol(""),Ud="Layout",Hd="NotFound",pr=Bn({resolveLayouts:e=>e.reduce((r,n)=>({...r,...n.layouts}),{}),resolvePageData:async e=>{const r=Fd.value[e];return await(r==null?void 0:r())??Dd},resolvePageFrontmatter:e=>e.frontmatter,resolvePageHead:(e,r,n)=>{const a=ve(r.description)?r.description:n.description,o=[...Q(r.head)?r.head:[],...n.head,["title",{},e],["meta",{name:"description",content:a}]];return Td(o)},resolvePageHeadTitle:(e,r)=>[e.title,r.title].filter(n=>!!n).join(" | "),resolvePageLang:(e,r)=>e.lang||r.lang||"en-US",resolvePageLayout:(e,r)=>{let n;if(e.path){const a=e.frontmatter.layout;ve(a)?n=a:n=Ud}else n=Hd;return r[n]},resolveRouteLocale:(e,r)=>ui(e,r),resolveSiteLocaleData:(e,r)=>({...e,...e.locales[r]})}),Fo=ue({name:"ClientOnly",setup(e,r){const n=fe(!1);return He(()=>{n.value=!0}),()=>{var a,o;return n.value?(o=(a=r.slots).default)==null?void 0:o.call(a):null}}}),Jd=ue({name:"Content",props:{pageKey:{type:String,required:!1,default:""}},setup(e){const r=_r(),n=N(()=>mi[e.pageKey||r.value.key]);return()=>n.value?ce(n.value):ce("div","404 Not Found")}}),wr=(e={})=>e,Bo=e=>Vn(e)?e:`/psp_pages/${di(e)}`;function Si(e,r,n){var a,o,t;r===void 0&&(r=50),n===void 0&&(n={});var s=(a=n.isImmediate)!=null&&a,l=(o=n.callback)!=null&&o,i=n.maxWait,c=Date.now(),d=[];function u(){if(i!==void 0){var f=Date.now()-c;if(f+r>=i)return i-f}return r}var m=function(){var f=[].slice.call(arguments),w=this;return new Promise(function(P,k){var v=s&&t===void 0;if(t!==void 0&&clearTimeout(t),t=setTimeout(function(){if(t=void 0,c=Date.now(),!s){var x=e.apply(w,f);l&&l(x),d.forEach(function(A){return(0,A.resolve)(x)}),d=[]}},u()),v){var S=e.apply(w,f);return l&&l(S),P(S)}d.push({resolve:P,reject:k})})};return m.cancel=function(f){t!==void 0&&clearTimeout(t),d.forEach(function(w){return(0,w.reject)(f)}),d=[]},m}/*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */const rn=typeof window<"u";function Wd(e){return e.__esModule||e[Symbol.toStringTag]==="Module"}const be=Object.assign;function Ga(e,r){const n={};for(const a in r){const o=r[a];n[a]=sr(o)?o.map(e):e(o)}return n}const xn=()=>{},sr=Array.isArray,Gd=/\/$/,Vd=e=>e.replace(Gd,"");function Va(e,r,n="/"){let a,o={},t="",s="";const l=r.indexOf("#");let i=r.indexOf("?");return l<i&&l>=0&&(i=-1),i>-1&&(a=r.slice(0,i),t=r.slice(i+1,l>-1?l:r.length),o=e(t)),l>-1&&(a=a||r.slice(0,l),s=r.slice(l,r.length)),a=Xd(a??r,n),{fullPath:a+(t&&"?")+t+s,path:a,query:o,hash:s}}function Kd(e,r){const n=r.query?e(r.query):"";return r.path+(n&&"?")+n+(r.hash||"")}function Ot(e,r){return!r||!e.toLowerCase().startsWith(r.toLowerCase())?e:e.slice(r.length)||"/"}function Yd(e,r,n){const a=r.matched.length-1,o=n.matched.length-1;return a>-1&&a===o&&pn(r.matched[a],n.matched[o])&&wi(r.params,n.params)&&e(r.query)===e(n.query)&&r.hash===n.hash}function pn(e,r){return(e.aliasOf||e)===(r.aliasOf||r)}function wi(e,r){if(Object.keys(e).length!==Object.keys(r).length)return!1;for(const n in e)if(!$d(e[n],r[n]))return!1;return!0}function $d(e,r){return sr(e)?zt(e,r):sr(r)?zt(r,e):e===r}function zt(e,r){return sr(r)?e.length===r.length&&e.every((n,a)=>n===r[a]):e.length===1&&e[0]===r}function Xd(e,r){if(e.startsWith("/"))return e;if(!e)return r;const n=r.split("/"),a=e.split("/"),o=a[a.length-1];(o===".."||o===".")&&a.push("");let t=n.length-1,s,l;for(s=0;s<a.length;s++)if(l=a[s],l!==".")if(l==="..")t>1&&t--;else break;return n.slice(0,t).join("/")+"/"+a.slice(s-(s===a.length?1:0)).join("/")}var On;(function(e){e.pop="pop",e.push="push"})(On||(On={}));var Tn;(function(e){e.back="back",e.forward="forward",e.unknown=""})(Tn||(Tn={}));function Qd(e){if(!e)if(rn){const r=document.querySelector("base");e=r&&r.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),Vd(e)}const Zd=/^[^#]+#/;function eu(e,r){return e.replace(Zd,"#")+r}function ru(e,r){const n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{behavior:r.behavior,left:a.left-n.left-(r.left||0),top:a.top-n.top-(r.top||0)}}const Ra=()=>({left:window.pageXOffset,top:window.pageYOffset});function nu(e){let r;if("el"in e){const n=e.el,a=typeof n=="string"&&n.startsWith("#"),o=typeof n=="string"?a?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!o)return;r=ru(o,e)}else r=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(r):window.scrollTo(r.left!=null?r.left:window.pageXOffset,r.top!=null?r.top:window.pageYOffset)}function Nt(e,r){return(history.state?history.state.position-r:-1)+e}const mo=new Map;function au(e,r){mo.set(e,r)}function ou(e){const r=mo.get(e);return mo.delete(e),r}let tu=()=>location.protocol+"//"+location.host;function Pi(e,r){const{pathname:n,search:a,hash:o}=r,t=e.indexOf("#");if(t>-1){let l=o.includes(e.slice(t))?e.slice(t).length:1,i=o.slice(l);return i[0]!=="/"&&(i="/"+i),Ot(i,"")}return Ot(n,e)+a+o}function su(e,r,n,a){let o=[],t=[],s=null;const l=({state:m})=>{const f=Pi(e,location),w=n.value,P=r.value;let k=0;if(m){if(n.value=f,r.value=m,s&&s===w){s=null;return}k=P?m.position-P.position:0}else a(f);o.forEach(v=>{v(n.value,w,{delta:k,type:On.pop,direction:k?k>0?Tn.forward:Tn.back:Tn.unknown})})};function i(){s=n.value}function c(m){o.push(m);const f=()=>{const w=o.indexOf(m);w>-1&&o.splice(w,1)};return t.push(f),f}function d(){const{history:m}=window;m.state&&m.replaceState(be({},m.state,{scroll:Ra()}),"")}function u(){for(const m of t)m();t=[],window.removeEventListener("popstate",l),window.removeEventListener("beforeunload",d)}return window.addEventListener("popstate",l),window.addEventListener("beforeunload",d,{passive:!0}),{pauseListeners:i,listen:c,destroy:u}}function Ft(e,r,n,a=!1,o=!1){return{back:e,current:r,forward:n,replaced:a,position:window.history.length,scroll:o?Ra():null}}function iu(e){const{history:r,location:n}=window,a={value:Pi(e,n)},o={value:r.state};o.value||t(a.value,{back:null,current:a.value,forward:null,position:r.length-1,replaced:!0,scroll:null},!0);function t(i,c,d){const u=e.indexOf("#"),m=u>-1?(n.host&&document.querySelector("base")?e:e.slice(u))+i:tu()+e+i;try{r[d?"replaceState":"pushState"](c,"",m),o.value=c}catch(f){console.error(f),n[d?"replace":"assign"](m)}}function s(i,c){const d=be({},r.state,Ft(o.value.back,i,o.value.forward,!0),c,{position:o.value.position});t(i,d,!0),a.value=i}function l(i,c){const d=be({},o.value,r.state,{forward:i,scroll:Ra()});t(d.current,d,!0);const u=be({},Ft(a.value,i,null),{position:d.position+1},c);t(i,u,!1),a.value=i}return{location:a,state:o,push:l,replace:s}}function lu(e){e=Qd(e);const r=iu(e),n=su(e,r.state,r.location,r.replace);function a(t,s=!0){s||n.pauseListeners(),history.go(t)}const o=be({location:"",base:e,go:a,createHref:eu.bind(null,e)},r,n);return Object.defineProperty(o,"location",{enumerable:!0,get:()=>r.location.value}),Object.defineProperty(o,"state",{enumerable:!0,get:()=>r.state.value}),o}function cu(e){return typeof e=="string"||e&&typeof e=="object"}function Ei(e){return typeof e=="string"||typeof e=="symbol"}const hr={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},ki=Symbol("");var Bt;(function(e){e[e.aborted=4]="aborted",e[e.cancelled=8]="cancelled",e[e.duplicated=16]="duplicated"})(Bt||(Bt={}));function hn(e,r){return be(new Error,{type:e,[ki]:!0},r)}function mr(e,r){return e instanceof Error&&ki in e&&(r==null||!!(e.type&r))}const Ut="[^/]+?",du={sensitive:!1,strict:!1,start:!0,end:!0},uu=/[.+*?^${}()[\]/\\]/g;function mu(e,r){const n=be({},du,r),a=[];let o=n.start?"^":"";const t=[];for(const c of e){const d=c.length?[]:[90];n.strict&&!c.length&&(o+="/");for(let u=0;u<c.length;u++){const m=c[u];let f=40+(n.sensitive?.25:0);if(m.type===0)u||(o+="/"),o+=m.value.replace(uu,"\\$&"),f+=40;else if(m.type===1){const{value:w,repeatable:P,optional:k,regexp:v}=m;t.push({name:w,repeatable:P,optional:k});const S=v||Ut;if(S!==Ut){f+=10;try{new RegExp(`(${S})`)}catch(A){throw new Error(`Invalid custom RegExp for param "${w}" (${S}): `+A.message)}}let x=P?`((?:${S})(?:/(?:${S}))*)`:`(${S})`;u||(x=k&&c.length<2?`(?:/${x})`:"/"+x),k&&(x+="?"),o+=x,f+=20,k&&(f+=-8),P&&(f+=-20),S===".*"&&(f+=-50)}d.push(f)}a.push(d)}if(n.strict&&n.end){const c=a.length-1;a[c][a[c].length-1]+=.7000000000000001}n.strict||(o+="/?"),n.end?o+="$":n.strict&&(o+="(?:/|$)");const s=new RegExp(o,n.sensitive?"":"i");function l(c){const d=c.match(s),u={};if(!d)return null;for(let m=1;m<d.length;m++){const f=d[m]||"",w=t[m-1];u[w.name]=f&&w.repeatable?f.split("/"):f}return u}function i(c){let d="",u=!1;for(const m of e){(!u||!d.endsWith("/"))&&(d+="/"),u=!1;for(const f of m)if(f.type===0)d+=f.value;else if(f.type===1){const{value:w,repeatable:P,optional:k}=f,v=w in c?c[w]:"";if(sr(v)&&!P)throw new Error(`Provided param "${w}" is an array but it is not repeatable (* or + modifiers)`);const S=sr(v)?v.join("/"):v;if(!S)if(k)m.length<2&&(d.endsWith("/")?d=d.slice(0,-1):u=!0);else throw new Error(`Missing required param "${w}"`);d+=S}}return d||"/"}return{re:s,score:a,keys:t,parse:l,stringify:i}}function pu(e,r){let n=0;for(;n<e.length&&n<r.length;){const a=r[n]-e[n];if(a)return a;n++}return e.length<r.length?e.length===1&&e[0]===40+40?-1:1:e.length>r.length?r.length===1&&r[0]===40+40?1:-1:0}function hu(e,r){let n=0;const a=e.score,o=r.score;for(;n<a.length&&n<o.length;){const t=pu(a[n],o[n]);if(t)return t;n++}if(Math.abs(o.length-a.length)===1){if(Ht(a))return 1;if(Ht(o))return-1}return o.length-a.length}function Ht(e){const r=e[e.length-1];return e.length>0&&r[r.length-1]<0}const gu={type:0,value:""},fu=/[a-zA-Z0-9_]/;function vu(e){if(!e)return[[]];if(e==="/")return[[gu]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function r(f){throw new Error(`ERR (${n})/"${c}": ${f}`)}let n=0,a=n;const o=[];let t;function s(){t&&o.push(t),t=[]}let l=0,i,c="",d="";function u(){c&&(n===0?t.push({type:0,value:c}):n===1||n===2||n===3?(t.length>1&&(i==="*"||i==="+")&&r(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),t.push({type:1,value:c,regexp:d,repeatable:i==="*"||i==="+",optional:i==="*"||i==="?"})):r("Invalid state to consume buffer"),c="")}function m(){c+=i}for(;l<e.length;){if(i=e[l++],i==="\\"&&n!==2){a=n,n=4;continue}switch(n){case 0:i==="/"?(c&&u(),s()):i===":"?(u(),n=1):m();break;case 4:m(),n=a;break;case 1:i==="("?n=2:fu.test(i)?m():(u(),n=0,i!=="*"&&i!=="?"&&i!=="+"&&l--);break;case 2:i===")"?d[d.length-1]=="\\"?d=d.slice(0,-1)+i:n=3:d+=i;break;case 3:u(),n=0,i!=="*"&&i!=="?"&&i!=="+"&&l--,d="";break;default:r("Unknown state");break}}return n===2&&r(`Unfinished custom RegExp for param "${c}"`),u(),s(),o}function bu(e,r,n){const a=mu(vu(e.path),n),o=be(a,{record:e,parent:r,children:[],alias:[]});return r&&!o.record.aliasOf==!r.record.aliasOf&&r.children.push(o),o}function yu(e,r){const n=[],a=new Map;r=Gt({strict:!1,end:!0,sensitive:!1},r);function o(d){return a.get(d)}function t(d,u,m){const f=!m,w=Su(d);w.aliasOf=m&&m.record;const P=Gt(r,d),k=[w];if("alias"in d){const x=typeof d.alias=="string"?[d.alias]:d.alias;for(const A of x)k.push(be({},w,{components:m?m.record.components:w.components,path:A,aliasOf:m?m.record:w}))}let v,S;for(const x of k){const{path:A}=x;if(u&&A[0]!=="/"){const G=u.record.path,Z=G[G.length-1]==="/"?"":"/";x.path=u.record.path+(A&&Z+A)}if(v=bu(x,u,P),m?m.alias.push(v):(S=S||v,S!==v&&S.alias.push(v),f&&d.name&&!Wt(v)&&s(d.name)),w.children){const G=w.children;for(let Z=0;Z<G.length;Z++)t(G[Z],v,m&&m.children[Z])}m=m||v,(v.record.components&&Object.keys(v.record.components).length||v.record.name||v.record.redirect)&&i(v)}return S?()=>{s(S)}:xn}function s(d){if(Ei(d)){const u=a.get(d);u&&(a.delete(d),n.splice(n.indexOf(u),1),u.children.forEach(s),u.alias.forEach(s))}else{const u=n.indexOf(d);u>-1&&(n.splice(u,1),d.record.name&&a.delete(d.record.name),d.children.forEach(s),d.alias.forEach(s))}}function l(){return n}function i(d){let u=0;for(;u<n.length&&hu(d,n[u])>=0&&(d.record.path!==n[u].record.path||!Ci(d,n[u]));)u++;n.splice(u,0,d),d.record.name&&!Wt(d)&&a.set(d.record.name,d)}function c(d,u){let m,f={},w,P;if("name"in d&&d.name){if(m=a.get(d.name),!m)throw hn(1,{location:d});P=m.record.name,f=be(Jt(u.params,m.keys.filter(S=>!S.optional).map(S=>S.name)),d.params&&Jt(d.params,m.keys.map(S=>S.name))),w=m.stringify(f)}else if("path"in d)w=d.path,m=n.find(S=>S.re.test(w)),m&&(f=m.parse(w),P=m.record.name);else{if(m=u.name?a.get(u.name):n.find(S=>S.re.test(u.path)),!m)throw hn(1,{location:d,currentLocation:u});P=m.record.name,f=be({},u.params,d.params),w=m.stringify(f)}const k=[];let v=m;for(;v;)k.unshift(v.record),v=v.parent;return{name:P,path:w,params:f,matched:k,meta:Pu(k)}}return e.forEach(d=>t(d)),{addRoute:t,resolve:c,removeRoute:s,getRoutes:l,getRecordMatcher:o}}function Jt(e,r){const n={};for(const a of r)a in e&&(n[a]=e[a]);return n}function Su(e){return{path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:void 0,beforeEnter:e.beforeEnter,props:wu(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}}}function wu(e){const r={},n=e.props||!1;if("component"in e)r.default=n;else for(const a in e.components)r[a]=typeof n=="object"?n[a]:n;return r}function Wt(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function Pu(e){return e.reduce((r,n)=>be(r,n.meta),{})}function Gt(e,r){const n={};for(const a in e)n[a]=a in r?r[a]:e[a];return n}function Ci(e,r){return r.children.some(n=>n===e||Ci(e,n))}const ji=/#/g,Eu=/&/g,ku=/\//g,Cu=/=/g,ju=/\?/g,qi=/\+/g,qu=/%5B/g,Iu=/%5D/g,Ii=/%5E/g,Au=/%60/g,Ai=/%7B/g,xu=/%7C/g,xi=/%7D/g,Tu=/%20/g;function Uo(e){return encodeURI(""+e).replace(xu,"|").replace(qu,"[").replace(Iu,"]")}function _u(e){return Uo(e).replace(Ai,"{").replace(xi,"}").replace(Ii,"^")}function po(e){return Uo(e).replace(qi,"%2B").replace(Tu,"+").replace(ji,"%23").replace(Eu,"%26").replace(Au,"`").replace(Ai,"{").replace(xi,"}").replace(Ii,"^")}function Lu(e){return po(e).replace(Cu,"%3D")}function Ru(e){return Uo(e).replace(ji,"%23").replace(ju,"%3F")}function Du(e){return e==null?"":Ru(e).replace(ku,"%2F")}function Sa(e){try{return decodeURIComponent(""+e)}catch{}return""+e}function Mu(e){const r={};if(e===""||e==="?")return r;const a=(e[0]==="?"?e.slice(1):e).split("&");for(let o=0;o<a.length;++o){const t=a[o].replace(qi," "),s=t.indexOf("="),l=Sa(s<0?t:t.slice(0,s)),i=s<0?null:Sa(t.slice(s+1));if(l in r){let c=r[l];sr(c)||(c=r[l]=[c]),c.push(i)}else r[l]=i}return r}function Vt(e){let r="";for(let n in e){const a=e[n];if(n=Lu(n),a==null){a!==void 0&&(r+=(r.length?"&":"")+n);continue}(sr(a)?a.map(t=>t&&po(t)):[a&&po(a)]).forEach(t=>{t!==void 0&&(r+=(r.length?"&":"")+n,t!=null&&(r+="="+t))})}return r}function Ou(e){const r={};for(const n in e){const a=e[n];a!==void 0&&(r[n]=sr(a)?a.map(o=>o==null?null:""+o):a==null?a:""+a)}return r}const zu=Symbol(""),Kt=Symbol(""),Da=Symbol(""),Ho=Symbol(""),ho=Symbol("");function Pn(){let e=[];function r(a){return e.push(a),()=>{const o=e.indexOf(a);o>-1&&e.splice(o,1)}}function n(){e=[]}return{add:r,list:()=>e.slice(),reset:n}}function Ar(e,r,n,a,o){const t=a&&(a.enterCallbacks[o]=a.enterCallbacks[o]||[]);return()=>new Promise((s,l)=>{const i=u=>{u===!1?l(hn(4,{from:n,to:r})):u instanceof Error?l(u):cu(u)?l(hn(2,{from:r,to:u})):(t&&a.enterCallbacks[o]===t&&typeof u=="function"&&t.push(u),s())},c=e.call(a&&a.instances[o],r,n,i);let d=Promise.resolve(c);e.length<3&&(d=d.then(i)),d.catch(u=>l(u))})}function Ka(e,r,n,a){const o=[];for(const t of e)for(const s in t.components){let l=t.components[s];if(!(r!=="beforeRouteEnter"&&!t.instances[s]))if(Nu(l)){const c=(l.__vccOpts||l)[r];c&&o.push(Ar(c,n,a,t,s))}else{let i=l();o.push(()=>i.then(c=>{if(!c)return Promise.reject(new Error(`Couldn't resolve component "${s}" at "${t.path}"`));const d=Wd(c)?c.default:c;t.components[s]=d;const m=(d.__vccOpts||d)[r];return m&&Ar(m,n,a,t,s)()}))}}return o}function Nu(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function Yt(e){const r=qe(Da),n=qe(Ho),a=N(()=>r.resolve(re(e.to))),o=N(()=>{const{matched:i}=a.value,{length:c}=i,d=i[c-1],u=n.matched;if(!d||!u.length)return-1;const m=u.findIndex(pn.bind(null,d));if(m>-1)return m;const f=$t(i[c-2]);return c>1&&$t(d)===f&&u[u.length-1].path!==f?u.findIndex(pn.bind(null,i[c-2])):m}),t=N(()=>o.value>-1&&Hu(n.params,a.value.params)),s=N(()=>o.value>-1&&o.value===n.matched.length-1&&wi(n.params,a.value.params));function l(i={}){return Uu(i)?r[re(e.replace)?"replace":"push"](re(e.to)).catch(xn):Promise.resolve()}return{route:a,href:N(()=>a.value.href),isActive:t,isExactActive:s,navigate:l}}const Fu=ue({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:Yt,setup(e,{slots:r}){const n=Bn(Yt(e)),{options:a}=qe(Da),o=N(()=>({[Xt(e.activeClass,a.linkActiveClass,"router-link-active")]:n.isActive,[Xt(e.exactActiveClass,a.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive}));return()=>{const t=r.default&&r.default(n);return e.custom?t:ce("a",{"aria-current":n.isExactActive?e.ariaCurrentValue:null,href:n.href,onClick:n.navigate,class:o.value},t)}}}),Bu=Fu;function Uu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const r=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(r))return}return e.preventDefault&&e.preventDefault(),!0}}function Hu(e,r){for(const n in r){const a=r[n],o=e[n];if(typeof a=="string"){if(a!==o)return!1}else if(!sr(o)||o.length!==a.length||a.some((t,s)=>t!==o[s]))return!1}return!0}function $t(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const Xt=(e,r,n)=>e??r??n,Ju=ue({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:r,slots:n}){const a=qe(ho),o=N(()=>e.route||a.value),t=qe(Kt,0),s=N(()=>{let c=re(t);const{matched:d}=o.value;let u;for(;(u=d[c])&&!u.components;)c++;return c}),l=N(()=>o.value.matched[s.value]);Vr(Kt,N(()=>s.value+1)),Vr(zu,l),Vr(ho,o);const i=fe();return er(()=>[i.value,l.value,e.name],([c,d,u],[m,f,w])=>{d&&(d.instances[u]=c,f&&f!==d&&c&&c===m&&(d.leaveGuards.size||(d.leaveGuards=f.leaveGuards),d.updateGuards.size||(d.updateGuards=f.updateGuards))),c&&d&&(!f||!pn(d,f)||!m)&&(d.enterCallbacks[u]||[]).forEach(P=>P(c))},{flush:"post"}),()=>{const c=o.value,d=e.name,u=l.value,m=u&&u.components[d];if(!m)return Qt(n.default,{Component:m,route:c});const f=u.props[d],w=f?f===!0?c.params:typeof f=="function"?f(c):f:null,k=ce(m,be({},w,r,{onVnodeUnmounted:v=>{v.component.isUnmounted&&(u.instances[d]=null)},ref:i}));return Qt(n.default,{Component:k,route:c})||k}}});function Qt(e,r){if(!e)return null;const n=e(r);return n.length===1?n[0]:n}const Ti=Ju;function Wu(e){const r=yu(e.routes,e),n=e.parseQuery||Mu,a=e.stringifyQuery||Vt,o=e.history,t=Pn(),s=Pn(),l=Pn(),i=Ao(hr);let c=hr;rn&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const d=Ga.bind(null,C=>""+C),u=Ga.bind(null,Du),m=Ga.bind(null,Sa);function f(C,H){let O,K;return Ei(C)?(O=r.getRecordMatcher(C),K=H):K=C,r.addRoute(K,O)}function w(C){const H=r.getRecordMatcher(C);H&&r.removeRoute(H)}function P(){return r.getRoutes().map(C=>C.record)}function k(C){return!!r.getRecordMatcher(C)}function v(C,H){if(H=be({},H||i.value),typeof C=="string"){const b=Va(n,C,H.path),E=r.resolve({path:b.path},H),j=o.createHref(b.fullPath);return be(b,E,{params:m(E.params),hash:Sa(b.hash),redirectedFrom:void 0,href:j})}let O;if("path"in C)O=be({},C,{path:Va(n,C.path,H.path).path});else{const b=be({},C.params);for(const E in b)b[E]==null&&delete b[E];O=be({},C,{params:u(b)}),H.params=u(H.params)}const K=r.resolve(O,H),de=C.hash||"";K.params=d(m(K.params));const p=Kd(a,be({},C,{hash:_u(de),path:K.path})),h=o.createHref(p);return be({fullPath:p,hash:de,query:a===Vt?Ou(C.query):C.query||{}},K,{redirectedFrom:void 0,href:h})}function S(C){return typeof C=="string"?Va(n,C,i.value.path):be({},C)}function x(C,H){if(c!==C)return hn(8,{from:H,to:C})}function A(C){return M(C)}function G(C){return A(be(S(C),{replace:!0}))}function Z(C){const H=C.matched[C.matched.length-1];if(H&&H.redirect){const{redirect:O}=H;let K=typeof O=="function"?O(C):O;return typeof K=="string"&&(K=K.includes("?")||K.includes("#")?K=S(K):{path:K},K.params={}),be({query:C.query,hash:C.hash,params:"path"in K?{}:C.params},K)}}function M(C,H){const O=c=v(C),K=i.value,de=C.state,p=C.force,h=C.replace===!0,b=Z(O);if(b)return M(be(S(b),{state:typeof b=="object"?be({},de,b.state):de,force:p,replace:h}),H||O);const E=O;E.redirectedFrom=H;let j;return!p&&Yd(a,K,O)&&(j=hn(16,{to:E,from:K}),Je(K,K,!0,!1)),(j?Promise.resolve(j):F(E,K)).catch(I=>mr(I)?mr(I,2)?I:De(I):te(I,E,K)).then(I=>{if(I){if(mr(I,2))return M(be({replace:h},S(I.to),{state:typeof I.to=="object"?be({},de,I.to.state):de,force:p}),H||E)}else I=q(E,K,!0,h,de);return Y(E,K,I),I})}function g(C,H){const O=x(C,H);return O?Promise.reject(O):Promise.resolve()}function J(C){const H=Er.values().next().value;return H&&typeof H.runWithContext=="function"?H.runWithContext(C):C()}function F(C,H){let O;const[K,de,p]=Gu(C,H);O=Ka(K.reverse(),"beforeRouteLeave",C,H);for(const b of K)b.leaveGuards.forEach(E=>{O.push(Ar(E,C,H))});const h=g.bind(null,C,H);return O.push(h),Le(O).then(()=>{O=[];for(const b of t.list())O.push(Ar(b,C,H));return O.push(h),Le(O)}).then(()=>{O=Ka(de,"beforeRouteUpdate",C,H);for(const b of de)b.updateGuards.forEach(E=>{O.push(Ar(E,C,H))});return O.push(h),Le(O)}).then(()=>{O=[];for(const b of p)if(b.beforeEnter)if(sr(b.beforeEnter))for(const E of b.beforeEnter)O.push(Ar(E,C,H));else O.push(Ar(b.beforeEnter,C,H));return O.push(h),Le(O)}).then(()=>(C.matched.forEach(b=>b.enterCallbacks={}),O=Ka(p,"beforeRouteEnter",C,H),O.push(h),Le(O))).then(()=>{O=[];for(const b of s.list())O.push(Ar(b,C,H));return O.push(h),Le(O)}).catch(b=>mr(b,8)?b:Promise.reject(b))}function Y(C,H,O){l.list().forEach(K=>J(()=>K(C,H,O)))}function q(C,H,O,K,de){const p=x(C,H);if(p)return p;const h=H===hr,b=rn?history.state:{};O&&(K||h?o.replace(C.fullPath,be({scroll:h&&b&&b.scroll},de)):o.push(C.fullPath,de)),i.value=C,Je(C,H,O,h),De()}let L;function R(){L||(L=o.listen((C,H,O)=>{if(!ir.listening)return;const K=v(C),de=Z(K);if(de){M(be(de,{replace:!0}),K).catch(xn);return}c=K;const p=i.value;rn&&au(Nt(p.fullPath,O.delta),Ra()),F(K,p).catch(h=>mr(h,12)?h:mr(h,2)?(M(h.to,K).then(b=>{mr(b,20)&&!O.delta&&O.type===On.pop&&o.go(-1,!1)}).catch(xn),Promise.reject()):(O.delta&&o.go(-O.delta,!1),te(h,K,p))).then(h=>{h=h||q(K,p,!1),h&&(O.delta&&!mr(h,8)?o.go(-O.delta,!1):O.type===On.pop&&mr(h,20)&&o.go(-1,!1)),Y(K,p,h)}).catch(xn)}))}let ie=Pn(),W=Pn(),oe;function te(C,H,O){De(C);const K=W.list();return K.length?K.forEach(de=>de(C,H,O)):console.error(C),Promise.reject(C)}function ze(){return oe&&i.value!==hr?Promise.resolve():new Promise((C,H)=>{ie.add([C,H])})}function De(C){return oe||(oe=!C,R(),ie.list().forEach(([H,O])=>C?O(C):H()),ie.reset()),C}function Je(C,H,O,K){const{scrollBehavior:de}=e;if(!rn||!de)return Promise.resolve();const p=!O&&ou(Nt(C.fullPath,0))||(K||!O)&&history.state&&history.state.scroll||null;return Hn().then(()=>de(C,H,p)).then(h=>h&&nu(h)).catch(h=>te(h,C,H))}const Ne=C=>o.go(C);let Pr;const Er=new Set,ir={currentRoute:i,listening:!0,addRoute:f,removeRoute:w,hasRoute:k,getRoutes:P,resolve:v,options:e,push:A,replace:G,go:Ne,back:()=>Ne(-1),forward:()=>Ne(1),beforeEach:t.add,beforeResolve:s.add,afterEach:l.add,onError:W.add,isReady:ze,install(C){const H=this;C.component("RouterLink",Bu),C.component("RouterView",Ti),C.config.globalProperties.$router=H,Object.defineProperty(C.config.globalProperties,"$route",{enumerable:!0,get:()=>re(i)}),rn&&!Pr&&i.value===hr&&(Pr=!0,A(o.location).catch(de=>{}));const O={};for(const de in hr)Object.defineProperty(O,de,{get:()=>i.value[de],enumerable:!0});C.provide(Da,H),C.provide(Ho,Ts(O)),C.provide(ho,i);const K=C.unmount;Er.add(C),C.unmount=function(){Er.delete(C),Er.size<1&&(c=hr,L&&L(),L=null,i.value=hr,Pr=!1,oe=!1),K()}}};function Le(C){return C.reduce((H,O)=>H.then(()=>J(O)),Promise.resolve())}return ir}function Gu(e,r){const n=[],a=[],o=[],t=Math.max(r.matched.length,e.matched.length);for(let s=0;s<t;s++){const l=r.matched[s];l&&(e.matched.find(c=>pn(c,l))?a.push(l):n.push(l));const i=e.matched[s];i&&(r.matched.find(c=>pn(c,i))||o.push(i))}return[n,a,o]}function $r(){return qe(Da)}function Xr(){return qe(Ho)}const Vu=({headerLinkSelector:e,headerAnchorSelector:r,delay:n,offset:a=5})=>{const o=$r(),s=Si(()=>{var P,k;const l=Math.max(window.scrollY,document.documentElement.scrollTop,document.body.scrollTop);if(Math.abs(l-0)<a){Zt(o,"");return}const c=window.innerHeight+l,d=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),u=Math.abs(d-c)<a,m=Array.from(document.querySelectorAll(e)),w=Array.from(document.querySelectorAll(r)).filter(v=>m.some(S=>S.hash===v.hash));for(let v=0;v<w.length;v++){const S=w[v],x=w[v+1],A=l>=(((P=S.parentElement)==null?void 0:P.offsetTop)??0)-a,G=!x||l<(((k=x.parentElement)==null?void 0:k.offsetTop)??0)-a;if(!(A&&G))continue;const M=decodeURIComponent(o.currentRoute.value.hash),g=decodeURIComponent(S.hash);if(M===g)return;if(u){for(let J=v+1;J<w.length;J++)if(M===decodeURIComponent(w[J].hash))return}Zt(o,g);return}},n);He(()=>{window.addEventListener("scroll",s)}),Wn(()=>{window.removeEventListener("scroll",s)})},Zt=async(e,r)=>{const{scrollBehavior:n}=e.options;e.options.scrollBehavior=void 0,await e.replace({query:e.currentRoute.value.query,hash:r}).finally(()=>e.options.scrollBehavior=n)},Ku="a.sidebar-item",Yu=".header-anchor",$u=300,Xu=5,Qu=wr({setup(){Vu({headerLinkSelector:Ku,headerAnchorSelector:Yu,delay:$u,offset:Xu})}}),es=()=>window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,Zu=()=>window.scrollTo({top:0,behavior:"smooth"});const em=ue({name:"BackToTop",setup(){const e=fe(0),r=N(()=>e.value>300),n=Si(()=>{e.value=es()},100);He(()=>{e.value=es(),window.addEventListener("scroll",()=>n())});const a=ce("div",{class:"back-to-top",onClick:Zu});return()=>ce(Gn,{name:"back-to-top"},()=>r.value?a:null)}}),rm=wr({rootComponents:[em]});const nm=ce("svg",{class:"external-link-icon",xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"},[ce("path",{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}),ce("polygon",{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"})]),am=ue({name:"ExternalLinkIcon",props:{locales:{type:Object,required:!1,default:()=>({})}},setup(e){const r=bn(),n=N(()=>e.locales[r.value]??{openInNewWindow:"open in new window"});return()=>ce("span",[nm,ce("span",{class:"external-link-icon-sr-only"},n.value.openInNewWindow)])}}),om={"/en/":{openInNewWindow:"Open in new window"},"/es/":{openInNewWindow:"Abrir en una ventana nueva"},"/":{openInNewWindow:"open in new window"}},tm=wr({enhance({app:e}){e.component("ExternalLinkIcon",ce(am,{locales:om}))}});/**
 * NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT
 */const me={settings:{minimum:.08,easing:"ease",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,barSelector:'[role="bar"]',parent:"body",template:'<div class="bar" role="bar"></div>'},status:null,set:e=>{const r=me.isStarted();e=Ya(e,me.settings.minimum,1),me.status=e===1?null:e;const n=me.render(!r),a=n.querySelector(me.settings.barSelector),o=me.settings.speed,t=me.settings.easing;return n.offsetWidth,sm(s=>{na(a,{transform:"translate3d("+rs(e)+"%,0,0)",transition:"all "+o+"ms "+t}),e===1?(na(n,{transition:"none",opacity:"1"}),n.offsetWidth,setTimeout(function(){na(n,{transition:"all "+o+"ms linear",opacity:"0"}),setTimeout(function(){me.remove(),s()},o)},o)):setTimeout(()=>s(),o)}),me},isStarted:()=>typeof me.status=="number",start:()=>{me.status||me.set(0);const e=()=>{setTimeout(()=>{me.status&&(me.trickle(),e())},me.settings.trickleSpeed)};return me.settings.trickle&&e(),me},done:e=>!e&&!me.status?me:me.inc(.3+.5*Math.random()).set(1),inc:e=>{let r=me.status;return r?(typeof e!="number"&&(e=(1-r)*Ya(Math.random()*r,.1,.95)),r=Ya(r+e,0,.994),me.set(r)):me.start()},trickle:()=>me.inc(Math.random()*me.settings.trickleRate),render:e=>{if(me.isRendered())return document.getElementById("nprogress");ns(document.documentElement,"nprogress-busy");const r=document.createElement("div");r.id="nprogress",r.innerHTML=me.settings.template;const n=r.querySelector(me.settings.barSelector),a=e?"-100":rs(me.status||0),o=document.querySelector(me.settings.parent);return na(n,{transition:"all 0 linear",transform:"translate3d("+a+"%,0,0)"}),o!==document.body&&ns(o,"nprogress-custom-parent"),o==null||o.appendChild(r),r},remove:()=>{as(document.documentElement,"nprogress-busy"),as(document.querySelector(me.settings.parent),"nprogress-custom-parent");const e=document.getElementById("nprogress");e&&im(e)},isRendered:()=>!!document.getElementById("nprogress")},Ya=(e,r,n)=>e<r?r:e>n?n:e,rs=e=>(-1+e)*100,sm=function(){const e=[];function r(){const n=e.shift();n&&n(r)}return function(n){e.push(n),e.length===1&&r()}}(),na=function(){const e=["Webkit","O","Moz","ms"],r={};function n(s){return s.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(l,i){return i.toUpperCase()})}function a(s){const l=document.body.style;if(s in l)return s;let i=e.length;const c=s.charAt(0).toUpperCase()+s.slice(1);let d;for(;i--;)if(d=e[i]+c,d in l)return d;return s}function o(s){return s=n(s),r[s]??(r[s]=a(s))}function t(s,l,i){l=o(l),s.style[l]=i}return function(s,l){for(const i in l){const c=l[i];c!==void 0&&Object.prototype.hasOwnProperty.call(l,i)&&t(s,i,c)}}}(),_i=(e,r)=>(typeof e=="string"?e:Jo(e)).indexOf(" "+r+" ")>=0,ns=(e,r)=>{const n=Jo(e),a=n+r;_i(n,r)||(e.className=a.substring(1))},as=(e,r)=>{const n=Jo(e);if(!_i(e,r))return;const a=n.replace(" "+r+" "," ");e.className=a.substring(1,a.length-1)},Jo=e=>(" "+(e.className||"")+" ").replace(/\s+/gi," "),im=e=>{e&&e.parentNode&&e.parentNode.removeChild(e)};const lm=()=>{He(()=>{const e=$r(),r=new Set;r.add(e.currentRoute.value.path),e.beforeEach(n=>{r.has(n.path)||me.start()}),e.afterEach(n=>{r.add(n.path),me.done()})})},cm=wr({setup(){lm()}}),dm=JSON.parse(`{"logo":"/LogoIES.png","repo":"psp2dam/psp_sources2022","repoLabel":"GitHub","editLink":true,"docsRepo":"https://github.com/psp2dam/psp_sources2022","docsBranch":"main","docsDir":"docs","lastUpdated":true,"sidebarDepth":2,"locales":{"/en/":{"home":"/en/","selectLanguageText":"Languages","selectLanguageName":"English","selectLanguageAriaLabel":"Languages","editLink":false,"editLinkText":"Help us improve this page on GitHub!","lastUpdatedText":"Last updated","notFound":["Resource not found in the site"],"backToHome":"Back to home","openInNewWindow":"Open in new window","toggleSidebar":"Show/Hide","serviceWorker":{"updatePopup":{"message":"New content is available.","buttonText":"Refresh"}},"navbar":[{"text":"Aules FP","link":"https://aules.edu.gva.es/fp/"},{"text":"Course Index","children":[{"text":"Unit 1 - Introduction to concurrent programming","link":"/en/unit1/"},{"text":"Unit 2 - Process programming in Java","link":"/en/unit2/"},{"text":"Unit 3 - Multithread programming in Java","link":"/en/unit3/"},{"text":"Unit 4 - Network programming in Java","link":"/en/unit4/"},{"text":"Unit 5 - Network services","link":"/en/unit5/"},{"text":"Unit 6 - Secure programming techniques","link":"/en/unit6/"}]}],"sidebar":{"/en/":[{"text":"PSP > Home","link":"/en/README.md","children":[]}],"/en/unit1/":[{"isGroup":true,"text":"Unit 1 - Introduction to concurrent programming","children":["index.md","process.md","concurrency.md","operatingsystem.md"]}],"/en/unit2/":[{"isGroup":true,"text":"Unit 2 - Process Programming in Java","children":["index.md","ipc.md","processbuilder.md","iostreams.md","console_annex.md","curl_annex.md"]}],"/en/unit3/":[{"isGroup":true,"text":"Unit 3 - Multithread Programming in Java","children":["index.md","runnable.md","synchronization.md","producer-consumer.md","alternatives.md","debugger_annex.md"]}],"/en/unit4/":[{"isGroup":true,"text":"Unit 4 - Network Programming in Java","children":["index.md","tcp-ip.md","sockets-tcp.md","sockets-udp.md","stateful-protocols.md"]}],"/en/unit5/":[{"isGroup":true,"text":"Unit 5 - Network Services","children":["index.md","mail.md","ftp.md","gmail_annex.md"]}],"/en/unit6/":[{"isGroup":true,"text":"Unit 6 - Secure programming techniques","children":["index.md","security.md","hash-functions.md","symmetric-key.md","asymmetric-keys.md","jsse.md","log4j_annex.md"]}]}},"/es/":{"home":"/es/","selectLanguageText":"Idioma","selectLanguageName":"Castellano","selectLanguageAriaLabel":"Idioma","editLink":false,"editLinkText":"Aydanos a mejorar esta pgina en GitHub!","lastUpdatedText":"ltima actualizacin","contributorsText":"Editores","notFound":["No se ha encontrado el recurso solicitado"],"backToHome":"Inicio","openInNewWindow":"Abrir en una ventana nueva","toggleSidebar":"Mostrar/Ocultar","navbar":[{"text":"Aules FP Semi","link":"https://aules.edu.gva.es/semipresencial/"},{"text":"Contenido del curso","children":[{"text":"Tema 1 - Introduccin a la programacin concurrente","link":"/es/unit1/"},{"text":"Tema 2 - Programacin de procesos en Java","link":"/es/unit2/"},{"text":"Tema 3 - Programacin multihilo en Java","link":"/es/unit3/"},{"text":"Tema 4 - Programacin en red en Java","link":"/es/unit4/"},{"text":"Tema 5 - Servicios en red","link":"/es/unit5/"},{"text":"Tema 6 - Tcnicas de programacin segura","link":"/es/unit6/"}]}],"sidebar":{"/es/":[{"text":"PSP > Inicio","link":"/es/README.md","children":[]}],"/es/unit1/":[{"isGroup":true,"text":"Tema 1 - Introduccin a la programacin concurrente","children":["index.md","process.md","concurrency.md","operatingsystem.md"]}],"/es/unit2/":[{"isGroup":true,"text":"Tema 2 - Programacin de procesos en Java","children":["index.md","ipc.md","processbuilder.md","iostreams.md","console_annex.md","curl_annex.md"]}],"/es/unit3/":[{"isGroup":true,"text":"Tema 3 - Programacin multihilo en Java","children":["index.md","runnable.md","synchronization.md","producer-consumer.md","alternatives.md","debugger_annex.md"]}],"/es/unit4/":[{"isGroup":true,"text":"Tema 4 - Programacin en red en Java","children":["index.md","tcp-ip.md","sockets-tcp.md","sockets-udp.md","stateful-protocols.md"]}],"/es/unit5/":[{"isGroup":true,"text":"Tema 5 - Servicios en red","children":["index.md","mail.md","ftp.md","gmail_annex.md"]}],"/es/unit6/":[{"isGroup":true,"text":"Tema 6 - Tcnicas de programacin segura","children":["index.md","security.md","hash-functions.md","symmetric-key.md","asymmetric-keys.md","jsse.md","log4j_annex.md"]}]}},"/":{"selectLanguageName":"English"}},"colorMode":"auto","colorModeSwitch":true,"navbar":[],"selectLanguageText":"Languages","selectLanguageAriaLabel":"Select language","sidebar":"auto","editLinkText":"Edit this page","lastUpdatedText":"Last Updated","contributors":true,"contributorsText":"Contributors","notFound":["There's nothing here.","How did we get here?","That's a Four-Oh-Four.","Looks like we've got some broken links."],"backToHome":"Take me home","openInNewWindow":"open in new window","toggleColorMode":"toggle color mode","toggleSidebar":"toggle sidebar"}`),um=fe(dm),Li=()=>um,Ri=Symbol(""),mm=()=>{const e=qe(Ri);if(!e)throw new Error("useThemeLocaleData() is called without provider.");return e},pm=(e,r)=>{const{locales:n,...a}=e;return{...a,...n==null?void 0:n[r]}},hm=wr({enhance({app:e}){const r=Li(),n=e._context.provides[zo],a=N(()=>pm(r.value,n.value));e.provide(Ri,a),Object.defineProperties(e.config.globalProperties,{$theme:{get(){return r.value}},$themeLocale:{get(){return a.value}}})}}),gm=ue({__name:"Badge",props:{type:{type:String,required:!1,default:"tip"},text:{type:String,required:!1,default:""},vertical:{type:String,required:!1,default:void 0}},setup(e){return(r,n)=>(U(),ee("span",{class:Ge(["badge",e.type]),style:Fn({verticalAlign:e.vertical})},[we(r.$slots,"default",{},()=>[Mr(_e(e.text),1)])],6))}}),Ce=(e,r)=>{const n=e.__vccOpts||e;for(const[a,o]of r)n[a]=o;return n},fm=Ce(gm,[["__file","Badge.vue"]]),vm=ue({name:"CodeGroup",slots:Object,setup(e,{slots:r}){const n=fe(-1),a=fe([]),o=(l=n.value)=>{l<a.value.length-1?n.value=l+1:n.value=0,a.value[n.value].focus()},t=(l=n.value)=>{l>0?n.value=l-1:n.value=a.value.length-1,a.value[n.value].focus()},s=(l,i)=>{l.key===" "||l.key==="Enter"?(l.preventDefault(),n.value=i):l.key==="ArrowRight"?(l.preventDefault(),o(i)):l.key==="ArrowLeft"&&(l.preventDefault(),t(i))};return()=>{var i;const l=(((i=r.default)==null?void 0:i.call(r))||[]).filter(c=>c.type.name==="CodeGroupItem").map(c=>(c.props===null&&(c.props={}),c));return l.length===0?null:(n.value<0||n.value>l.length-1?(n.value=l.findIndex(c=>c.props.active===""||c.props.active===!0),n.value===-1&&(n.value=0)):l.forEach((c,d)=>{c.props.active=d===n.value}),ce("div",{class:"code-group"},[ce("div",{class:"code-group__nav"},ce("ul",{class:"code-group__ul"},l.map((c,d)=>{const u=d===n.value;return ce("li",{class:"code-group__li"},ce("button",{ref:m=>{m&&(a.value[d]=m)},class:{"code-group__nav-tab":!0,"code-group__nav-tab-active":u},ariaPressed:u,ariaExpanded:u,onClick:()=>n.value=d,onKeydown:m=>s(m,d)},c.props.title))}))),l]))}}}),bm=["aria-selected"],ym=ue({name:"CodeGroupItem"}),Sm=ue({...ym,props:{title:{type:String,required:!0},active:{type:Boolean,required:!1,default:!1}},setup(e){return(r,n)=>(U(),ee("div",{class:Ge(["code-group-item",{"code-group-item__active":e.active}]),"aria-selected":e.active},[we(r.$slots,"default")],10,bm))}}),wm=Ce(Sm,[["__file","CodeGroupItem.vue"]]);function os(e,r){var n;const a=Ao();return Us(()=>{a.value=e()},{...r,flush:(n=r==null?void 0:r.flush)!=null?n:"sync"}),vn(a)}function Pm(e,r){let n,a,o;const t=fe(!0),s=()=>{t.value=!0,o()};er(e,s,{flush:"sync"});const l=typeof r=="function"?r:r.get,i=typeof r=="function"?void 0:r.set,c=Ul((d,u)=>(a=d,o=u,{get(){return t.value&&(n=l(),t.value=!1),a(),n},set(m){i==null||i(m)}}));return Object.isExtensible(c)&&(c.trigger=s),c}function Wo(e){return Ss()?(ul(e),!0):!1}function Or(e){return typeof e=="function"?e():re(e)}const Go=typeof window<"u"&&typeof document<"u",Em=Object.prototype.toString,km=e=>Em.call(e)==="[object Object]",Cm=()=>{};function jm(e,r){function n(...a){return new Promise((o,t)=>{Promise.resolve(e(()=>r.apply(this,a),{fn:r,thisArg:this,args:a})).then(o).catch(t)})}return n}const Di=e=>e();function qm(e=Di){const r=fe(!0);function n(){r.value=!1}function a(){r.value=!0}const o=(...t)=>{r.value&&e(...t)};return{isActive:vn(r),pause:n,resume:a,eventFilter:o}}function Im(e,r,n={}){const{eventFilter:a=Di,...o}=n;return er(e,jm(a,r),o)}function Am(e,r,n={}){const{eventFilter:a,...o}=n,{eventFilter:t,pause:s,resume:l,isActive:i}=qm(a);return{stop:Im(e,r,{...o,eventFilter:t}),pause:s,resume:l,isActive:i}}function xm(e,r,n={}){const{immediate:a=!0}=n,o=fe(!1);let t=null;function s(){t&&(clearTimeout(t),t=null)}function l(){o.value=!1,s()}function i(...c){s(),o.value=!0,t=setTimeout(()=>{o.value=!1,t=null,e(...c)},Or(r))}return a&&(o.value=!0,Go&&i()),Wo(l),{isPending:vn(o),start:i,stop:l}}function Tm(e=!1,r={}){const{truthyValue:n=!0,falsyValue:a=!1}=r,o=Re(e),t=fe(e);function s(l){if(arguments.length)return t.value=l,t.value;{const i=Or(n);return t.value=t.value===i?Or(a):i,t.value}}return o?s:[t,s]}function _m(e){var r;const n=Or(e);return(r=n==null?void 0:n.$el)!=null?r:n}const wa=Go?window:void 0,Lm=Go?window.navigator:void 0;function Pa(...e){let r,n,a,o;if(typeof e[0]=="string"||Array.isArray(e[0])?([n,a,o]=e,r=wa):[r,n,a,o]=e,!r)return Cm;Array.isArray(n)||(n=[n]),Array.isArray(a)||(a=[a]);const t=[],s=()=>{t.forEach(d=>d()),t.length=0},l=(d,u,m,f)=>(d.addEventListener(u,m,f),()=>d.removeEventListener(u,m,f)),i=er(()=>[_m(r),Or(o)],([d,u])=>{if(s(),!d)return;const m=km(u)?{...u}:u;t.push(...n.flatMap(f=>a.map(w=>l(d,f,w,m))))},{immediate:!0,flush:"post"}),c=()=>{i(),s()};return Wo(c),c}function Rm(){const e=fe(!1);return Do()&&He(()=>{e.value=!0}),e}function Mi(e){const r=Rm();return N(()=>(r.value,!!e()))}function Dm(e,r={}){const{window:n=wa}=r,a=Mi(()=>n&&"matchMedia"in n&&typeof n.matchMedia=="function");let o;const t=fe(!1),s=c=>{t.value=c.matches},l=()=>{o&&("removeEventListener"in o?o.removeEventListener("change",s):o.removeListener(s))},i=Us(()=>{a.value&&(l(),o=n.matchMedia(Or(e)),"addEventListener"in o?o.addEventListener("change",s):o.addListener(s),t.value=o.matches)});return Wo(()=>{i(),l(),o=void 0}),t}function Mm(e={}){const{navigator:r=Lm,read:n=!1,source:a,copiedDuring:o=1500,legacy:t=!1}=e,s=Mi(()=>r&&"clipboard"in r),l=N(()=>s.value||t),i=fe(""),c=fe(!1),d=xm(()=>c.value=!1,o);function u(){s.value?r.clipboard.readText().then(P=>{i.value=P}):i.value=w()}l.value&&n&&Pa(["copy","cut"],u);async function m(P=Or(a)){l.value&&P!=null&&(s.value?await r.clipboard.writeText(P):f(P),i.value=P,c.value=!0,d.start())}function f(P){const k=document.createElement("textarea");k.value=P??"",k.style.position="absolute",k.style.opacity="0",document.body.appendChild(k),k.select(),document.execCommand("copy"),k.remove()}function w(){var P,k,v;return(v=(k=(P=document==null?void 0:document.getSelection)==null?void 0:P.call(document))==null?void 0:k.toString())!=null?v:""}return{isSupported:l,text:i,copied:c,copy:m}}const aa=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},oa="__vueuse_ssr_handlers__",Om=zm();function zm(){return oa in aa||(aa[oa]=aa[oa]||{}),aa[oa]}function Nm(e,r){return Om[e]||r}function Fm(e){return e==null?"any":e instanceof Set?"set":e instanceof Map?"map":e instanceof Date?"date":typeof e=="boolean"?"boolean":typeof e=="string"?"string":typeof e=="object"?"object":Number.isNaN(e)?"any":"number"}const Bm={boolean:{read:e=>e==="true",write:e=>String(e)},object:{read:e=>JSON.parse(e),write:e=>JSON.stringify(e)},number:{read:e=>Number.parseFloat(e),write:e=>String(e)},any:{read:e=>e,write:e=>String(e)},string:{read:e=>e,write:e=>String(e)},map:{read:e=>new Map(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e.entries()))},set:{read:e=>new Set(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e))},date:{read:e=>new Date(e),write:e=>e.toISOString()}},ts="vueuse-storage";function Um(e,r,n,a={}){var o;const{flush:t="pre",deep:s=!0,listenToStorageChanges:l=!0,writeDefaults:i=!0,mergeDefaults:c=!1,shallow:d,window:u=wa,eventFilter:m,onError:f=g=>{console.error(g)}}=a,w=(d?Ao:fe)(r);if(!n)try{n=Nm("getDefaultStorage",()=>{var g;return(g=wa)==null?void 0:g.localStorage})()}catch(g){f(g)}if(!n)return w;const P=Or(r),k=Fm(P),v=(o=a.serializer)!=null?o:Bm[k],{pause:S,resume:x}=Am(w,()=>A(w.value),{flush:t,deep:s,eventFilter:m});return u&&l&&(Pa(u,"storage",M),Pa(u,ts,Z)),M(),w;function A(g){try{if(g==null)n.removeItem(e);else{const J=v.write(g),F=n.getItem(e);F!==J&&(n.setItem(e,J),u&&u.dispatchEvent(new CustomEvent(ts,{detail:{key:e,oldValue:F,newValue:J,storageArea:n}})))}}catch(J){f(J)}}function G(g){const J=g?g.newValue:n.getItem(e);if(J==null)return i&&P!==null&&n.setItem(e,v.write(P)),P;if(!g&&c){const F=v.read(J);return typeof c=="function"?c(F,P):k==="object"&&!Array.isArray(F)?{...P,...F}:F}else return typeof J!="string"?J:v.read(J)}function Z(g){M(g.detail)}function M(g){if(!(g&&g.storageArea!==n)){if(g&&g.key==null){w.value=P;return}if(!(g&&g.key!==e)){S();try{(g==null?void 0:g.newValue)!==v.write(w.value)&&(w.value=G(g))}catch(J){f(J)}finally{g?Hn(x):x()}}}}}function Hm(e){return Dm("(prefers-color-scheme: dark)",e)}const Jm=()=>Li(),Ue=()=>mm(),Oi=Symbol(""),Vo=()=>{const e=qe(Oi);if(!e)throw new Error("useDarkMode() is called without provider.");return e},Wm=()=>{const e=Ue(),r=Hm(),n=Um("vuepress-color-scheme",e.value.colorMode),a=N({get(){return e.value.colorModeSwitch?n.value==="auto"?r.value:n.value==="dark":e.value.colorMode==="dark"},set(o){o===r.value?n.value="auto":n.value=o?"dark":"light"}});Vr(Oi,a),Gm(a)},Gm=e=>{const r=(n=e.value)=>{const a=window==null?void 0:window.document.querySelector("html");a==null||a.classList.toggle("dark",n)};He(()=>{er(e,r,{immediate:!0})}),Ta(()=>r())},zi=(...e)=>{const n=$r().resolve(...e),a=n.matched[n.matched.length-1];if(!(a!=null&&a.redirect))return n;const{redirect:o}=a,t=se(o)?o(n):o,s=ve(t)?{path:t}:t;return zi({hash:n.hash,query:n.query,params:n.params,...s})},Ko=e=>{const r=zi(encodeURI(e));return{text:r.meta.title||e,link:r.name==="404"?e:r.fullPath}};let $a=null,En=null;const Vm={wait:()=>$a,pending:()=>{$a=new Promise(e=>En=e)},resolve:()=>{En==null||En(),$a=null,En=null}},Ni=()=>Vm,Fi=Symbol("sidebarItems"),Yo=()=>{const e=qe(Fi);if(!e)throw new Error("useSidebarItems() is called without provider.");return e},Km=()=>{const e=Ue(),r=fr(),n=N(()=>Ym(r.value,e.value));Vr(Fi,n)},Ym=(e,r)=>{const n=e.sidebar??r.sidebar??"auto",a=e.sidebarDepth??r.sidebarDepth??2;return e.home||n===!1?[]:n==="auto"?Xm(a):Q(n)?Bi(n,a):Oo(n)?Qm(n,a):[]},$m=(e,r)=>({text:e.title,link:e.link,children:$o(e.children,r)}),$o=(e,r)=>r>0?e.map(n=>$m(n,r-1)):[],Xm=e=>{const r=_r();return[{text:r.value.title,children:$o(r.value.headers,e)}]},Bi=(e,r)=>{const n=Xr(),a=_r(),o=t=>{var l;let s;if(ve(t)?s=Ko(t):s=t,s.children)return{...s,children:s.children.map(i=>o(i))};if(s.link===n.path){const i=((l=a.value.headers[0])==null?void 0:l.level)===1?a.value.headers[0].children:a.value.headers;return{...s,children:$o(i,r)}}return s};return e.map(t=>o(t))},Qm=(e,r)=>{const n=Xr(),a=ui(e,n.path),o=e[a]??[];return Bi(o,r)},Zm="2048px",ep={mobile:Zm};var zn;(function(e){e.MOBILE="mobile"})(zn||(zn={}));var ps;const rp={[zn.MOBILE]:Number.parseInt((ps=ep.mobile)==null?void 0:ps.replace("px",""),10)},Ui=(e,r)=>{const n=rp[e];Number.isInteger(n)&&He(()=>{r(n),window.addEventListener("resize",()=>r(n),!1),window.addEventListener("orientationchange",()=>r(n),!1)})},np={},ap={class:"theme-default-content"};function op(e,r){const n=yr("Content");return U(),ee("div",ap,[ne(n)])}const tp=Ce(np,[["render",op],["__file","HomeContent.vue"]]),sp={key:0,class:"features"},ip=ue({__name:"HomeFeatures",setup(e){const r=fr(),n=N(()=>Q(r.value.features)?r.value.features:[]);return(a,o)=>n.value.length?(U(),ee("div",sp,[(U(!0),ee(Pe,null,Rr(n.value,t=>(U(),ee("div",{key:t.title,class:"feature"},[he("h2",null,_e(t.title),1),he("p",null,_e(t.details),1)]))),128))])):je("v-if",!0)}}),lp=Ce(ip,[["__file","HomeFeatures.vue"]]),cp=["innerHTML"],dp=["textContent"],up=ue({__name:"HomeFooter",setup(e){const r=fr(),n=N(()=>r.value.footer),a=N(()=>r.value.footerHtml);return(o,t)=>n.value?(U(),ee(Pe,{key:0},[je(" eslint-disable-next-line vue/no-v-html "),a.value?(U(),ee("div",{key:0,class:"footer",innerHTML:n.value},null,8,cp)):(U(),ee("div",{key:1,class:"footer",textContent:_e(n.value)},null,8,dp))],64)):je("v-if",!0)}}),mp=Ce(up,[["__file","HomeFooter.vue"]]),pp=["href","rel","target","aria-label"],hp=ue({inheritAttrs:!1}),gp=ue({...hp,__name:"AutoLink",props:{item:{type:Object,required:!0}},setup(e){const r=e,n=Xr(),a=bi(),{item:o}=qa(r),t=N(()=>Vn(o.value.link)),s=N(()=>_d(o.value.link)||Ld(o.value.link)),l=N(()=>{if(!s.value){if(o.value.target)return o.value.target;if(t.value)return"_blank"}}),i=N(()=>l.value==="_blank"),c=N(()=>!t.value&&!s.value&&!i.value),d=N(()=>{if(!s.value){if(o.value.rel)return o.value.rel;if(i.value)return"noopener noreferrer"}}),u=N(()=>o.value.ariaLabel||o.value.text),m=N(()=>{const P=Object.keys(a.value.locales);return P.length?!P.some(k=>k===o.value.link):o.value.link!=="/"}),f=N(()=>m.value?n.path.startsWith(o.value.link):!1),w=N(()=>c.value?o.value.activeMatch?new RegExp(o.value.activeMatch).test(n.path):f.value:!1);return(P,k)=>{const v=yr("RouterLink"),S=yr("AutoLinkExternalIcon");return c.value?(U(),Ae(v,co({key:0,class:{"router-link-active":w.value},to:re(o).link,"aria-label":u.value},P.$attrs),{default:Me(()=>[we(P.$slots,"before"),Mr(" "+_e(re(o).text)+" ",1),we(P.$slots,"after")]),_:3},16,["class","to","aria-label"])):(U(),ee("a",co({key:1,class:"external-link",href:re(o).link,rel:d.value,target:l.value,"aria-label":u.value},P.$attrs),[we(P.$slots,"before"),Mr(" "+_e(re(o).text)+" ",1),i.value?(U(),Ae(S,{key:0})):je("v-if",!0),we(P.$slots,"after")],16,pp))}}}),vr=Ce(gp,[["__file","AutoLink.vue"]]),fp={class:"hero"},vp={key:0,id:"main-title"},bp={key:1,class:"description"},yp={key:2,class:"actions"},Sp=ue({__name:"HomeHero",setup(e){const r=fr(),n=No(),a=Vo(),o=N(()=>a.value&&r.value.heroImageDark!==void 0?r.value.heroImageDark:r.value.heroImage),t=N(()=>r.value.heroAlt||l.value||"hero"),s=N(()=>r.value.heroHeight||280),l=N(()=>r.value.heroText===null?null:r.value.heroText||n.value.title||"Hello"),i=N(()=>r.value.tagline===null?null:r.value.tagline||n.value.description||"Welcome to your VuePress site"),c=N(()=>Q(r.value.actions)?r.value.actions.map(({text:u,link:m,type:f="primary"})=>({text:u,link:m,type:f})):[]),d=()=>{if(!o.value)return null;const u=ce("img",{src:Bo(o.value),alt:t.value,height:s.value});return r.value.heroImageDark===void 0?u:ce(Fo,()=>u)};return(u,m)=>(U(),ee("header",fp,[ne(d),l.value?(U(),ee("h1",vp,_e(l.value),1)):je("v-if",!0),i.value?(U(),ee("p",bp,_e(i.value),1)):je("v-if",!0),c.value.length?(U(),ee("p",yp,[(U(!0),ee(Pe,null,Rr(c.value,f=>(U(),Ae(vr,{key:f.text,class:Ge(["action-button",[f.type]]),item:f},null,8,["class","item"]))),128))])):je("v-if",!0)]))}}),wp=Ce(Sp,[["__file","HomeHero.vue"]]),Pp={class:"home"},Ep=ue({__name:"Home",setup(e){return(r,n)=>(U(),ee("main",Pp,[ne(wp),ne(lp),ne(tp),ne(mp)]))}}),kp=Ce(Ep,[["__file","Home.vue"]]),Cp=ue({__name:"NavbarBrand",setup(e){const r=bn(),n=No(),a=Ue(),o=Vo(),t=N(()=>a.value.home||r.value),s=N(()=>n.value.title),l=N(()=>o.value&&a.value.logoDark!==void 0?a.value.logoDark:a.value.logo),i=()=>{if(!l.value)return null;const c=ce("img",{class:"logo",src:Bo(l.value),alt:s.value});return a.value.logoDark===void 0?c:ce(Fo,()=>c)};return(c,d)=>{const u=yr("RouterLink");return U(),Ae(u,{to:t.value},{default:Me(()=>[ne(i),s.value?(U(),ee("span",{key:0,class:Ge(["site-name",{"can-hide":l.value}])},_e(s.value),3)):je("v-if",!0)]),_:1},8,["to"])}}}),jp=Ce(Cp,[["__file","NavbarBrand.vue"]]),qp=ue({__name:"DropdownTransition",setup(e){const r=a=>{a.style.height=a.scrollHeight+"px"},n=a=>{a.style.height=""};return(a,o)=>(U(),Ae(Gn,{name:"dropdown",onEnter:r,onAfterEnter:n,onBeforeLeave:r},{default:Me(()=>[we(a.$slots,"default")]),_:3}))}}),Hi=Ce(qp,[["__file","DropdownTransition.vue"]]),Ip=["aria-label"],Ap={class:"title"},xp=he("span",{class:"arrow down"},null,-1),Tp=["aria-label"],_p={class:"title"},Lp={class:"navbar-dropdown"},Rp={class:"navbar-dropdown-subtitle"},Dp={key:1},Mp={class:"navbar-dropdown-subitem-wrapper"},Op=ue({__name:"NavbarDropdown",props:{item:{type:Object,required:!0}},setup(e){const r=e,{item:n}=qa(r),a=N(()=>n.value.ariaLabel||n.value.text),o=fe(!1),t=Xr();er(()=>t.path,()=>{o.value=!1});const s=i=>{i.detail===0?o.value=!o.value:o.value=!1},l=(i,c)=>c[c.length-1]===i;return(i,c)=>(U(),ee("div",{class:Ge(["navbar-dropdown-wrapper",{open:o.value}])},[he("button",{class:"navbar-dropdown-title",type:"button","aria-label":a.value,onClick:s},[he("span",Ap,_e(re(n).text),1),xp],8,Ip),he("button",{class:"navbar-dropdown-title-mobile",type:"button","aria-label":a.value,onClick:c[0]||(c[0]=d=>o.value=!o.value)},[he("span",_p,_e(re(n).text),1),he("span",{class:Ge(["arrow",o.value?"down":"right"])},null,2)],8,Tp),ne(Hi,null,{default:Me(()=>[ha(he("ul",Lp,[(U(!0),ee(Pe,null,Rr(re(n).children,d=>(U(),ee("li",{key:d.text,class:"navbar-dropdown-item"},[d.children?(U(),ee(Pe,{key:0},[he("h4",Rp,[d.link?(U(),Ae(vr,{key:0,item:d,onFocusout:u=>l(d,re(n).children)&&d.children.length===0&&(o.value=!1)},null,8,["item","onFocusout"])):(U(),ee("span",Dp,_e(d.text),1))]),he("ul",Mp,[(U(!0),ee(Pe,null,Rr(d.children,u=>(U(),ee("li",{key:u.link,class:"navbar-dropdown-subitem"},[ne(vr,{item:u,onFocusout:m=>l(u,d.children)&&l(d,re(n).children)&&(o.value=!1)},null,8,["item","onFocusout"])]))),128))])],64)):(U(),Ae(vr,{key:1,item:d,onFocusout:u=>l(d,re(n).children)&&(o.value=!1)},null,8,["item","onFocusout"]))]))),128))],512),[[ya,o.value]])]),_:1})],2))}}),zp=Ce(Op,[["__file","NavbarDropdown.vue"]]),ss=e=>decodeURI(e).replace(/#.*$/,"").replace(/(index)?\.(md|html)$/,""),Np=(e,r)=>{if(r.hash===e)return!0;const n=ss(r.path),a=ss(e);return n===a},Ji=(e,r)=>e.link&&Np(e.link,r)?!0:e.children?e.children.some(n=>Ji(n,r)):!1,Wi=e=>!Vn(e)||/github\.com/.test(e)?"GitHub":/bitbucket\.org/.test(e)?"Bitbucket":/gitlab\.com/.test(e)?"GitLab":/gitee\.com/.test(e)?"Gitee":null,Fp={GitHub:":repo/edit/:branch/:path",GitLab:":repo/-/edit/:branch/:path",Gitee:":repo/edit/:branch/:path",Bitbucket:":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"},Bp=({docsRepo:e,editLinkPattern:r})=>{if(r)return r;const n=Wi(e);return n!==null?Fp[n]:null},Up=({docsRepo:e,docsBranch:r,docsDir:n,filePathRelative:a,editLinkPattern:o})=>{if(!a)return null;const t=Bp({docsRepo:e,editLinkPattern:o});return t?t.replace(/:repo/,Vn(e)?e:`https://github.com/${e}`).replace(/:branch/,r).replace(/:path/,di(`${ci(n)}/${a}`)):null},Hp={key:0,class:"navbar-items"},Jp=ue({__name:"NavbarItems",setup(e){const r=()=>{const d=$r(),u=bn(),m=bi(),f=No(),w=Jm(),P=Ue();return N(()=>{const k=Object.keys(m.value.locales);if(k.length<2)return[];const v=d.currentRoute.value.path,S=d.currentRoute.value.fullPath;return[{text:`${P.value.selectLanguageText}`,ariaLabel:`${P.value.selectLanguageAriaLabel??P.value.selectLanguageText}`,children:k.map(A=>{var F,Y;const G=((F=m.value.locales)==null?void 0:F[A])??{},Z=((Y=w.value.locales)==null?void 0:Y[A])??{},M=`${G.lang}`,g=Z.selectLanguageName??M;let J;if(M===f.value.lang)J=S;else{const q=v.replace(u.value,A);d.getRoutes().some(L=>L.path===q)?J=S.replace(v,q):J=Z.home??A}return{text:g,link:J}})}]})},n=()=>{const d=Ue(),u=N(()=>d.value.repo),m=N(()=>u.value?Wi(u.value):null),f=N(()=>u.value&&!Vn(u.value)?`https://github.com/${u.value}`:u.value),w=N(()=>f.value?d.value.repoLabel?d.value.repoLabel:m.value===null?"Source":m.value:null);return N(()=>!f.value||!w.value?[]:[{text:w.value,link:f.value}])},a=d=>ve(d)?Ko(d):d.children?{...d,children:d.children.map(a)}:d,o=()=>{const d=Ue();return N(()=>(d.value.navbar||[]).map(a))},t=fe(!1),s=o(),l=r(),i=n(),c=N(()=>[...s.value,...l.value,...i.value]);return Ui(zn.MOBILE,d=>{window.innerWidth<d?t.value=!0:t.value=!1}),(d,u)=>c.value.length?(U(),ee("nav",Hp,[(U(!0),ee(Pe,null,Rr(c.value,m=>(U(),ee("div",{key:m.text,class:"navbar-item"},[m.children?(U(),Ae(zp,{key:0,item:m,class:Ge(t.value?"mobile":"")},null,8,["item","class"])):(U(),Ae(vr,{key:1,item:m},null,8,["item"]))]))),128))])):je("v-if",!0)}}),Gi=Ce(Jp,[["__file","NavbarItems.vue"]]),Wp=["title"],Gp={class:"icon",focusable:"false",viewBox:"0 0 32 32"},Vp=Bc('<path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path>',9),Kp=[Vp],Yp={class:"icon",focusable:"false",viewBox:"0 0 32 32"},$p=he("path",{d:"M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z",fill:"currentColor"},null,-1),Xp=[$p],Qp=ue({__name:"ToggleColorModeButton",setup(e){const r=Ue(),n=Vo(),a=()=>{n.value=!n.value};return(o,t)=>(U(),ee("button",{class:"toggle-color-mode-button",title:re(r).toggleColorMode,onClick:a},[ha((U(),ee("svg",Gp,Kp,512)),[[ya,!re(n)]]),ha((U(),ee("svg",Yp,Xp,512)),[[ya,re(n)]])],8,Wp))}}),Zp=Ce(Qp,[["__file","ToggleColorModeButton.vue"]]),eh=["title"],rh=he("div",{class:"icon","aria-hidden":"true"},[he("span"),he("span"),he("span")],-1),nh=[rh],ah=ue({__name:"ToggleSidebarButton",emits:["toggle"],setup(e){const r=Ue();return(n,a)=>(U(),ee("div",{class:"toggle-sidebar-button",title:re(r).toggleSidebar,"aria-expanded":"false",role:"button",tabindex:"0",onClick:a[0]||(a[0]=o=>n.$emit("toggle"))},nh,8,eh))}}),oh=Ce(ah,[["__file","ToggleSidebarButton.vue"]]),th=ue({__name:"Navbar",emits:["toggle-sidebar"],setup(e){const r=Ue(),n=fe(null),a=fe(null),o=fe(0),t=N(()=>o.value?{maxWidth:o.value+"px"}:{});Ui(zn.MOBILE,l=>{var c;const i=s(n.value,"paddingLeft")+s(n.value,"paddingRight");window.innerWidth<l?o.value=0:o.value=n.value.offsetWidth-i-(((c=a.value)==null?void 0:c.offsetWidth)||0)});function s(l,i){var u,m,f;const c=(f=(m=(u=l==null?void 0:l.ownerDocument)==null?void 0:u.defaultView)==null?void 0:m.getComputedStyle(l,null))==null?void 0:f[i],d=Number.parseInt(c,10);return Number.isNaN(d)?0:d}return(l,i)=>{const c=yr("NavbarSearch");return U(),ee("header",{ref_key:"navbar",ref:n,class:"navbar"},[ne(oh,{onToggle:i[0]||(i[0]=d=>l.$emit("toggle-sidebar"))}),he("span",{ref_key:"navbarBrand",ref:a},[ne(jp)],512),he("div",{class:"navbar-items-wrapper",style:Fn(t.value)},[we(l.$slots,"before"),ne(Gi,{class:"can-hide"}),we(l.$slots,"after"),re(r).colorModeSwitch?(U(),Ae(Zp,{key:0})):je("v-if",!0),ne(c)],4)],512)}}}),sh=Ce(th,[["__file","Navbar.vue"]]),ih={class:"page-meta"},lh={key:0,class:"meta-item edit-link"},ch={key:1,class:"meta-item last-updated"},dh={class:"meta-item-label"},uh={class:"meta-item-info"},mh={key:2,class:"meta-item contributors"},ph={class:"meta-item-label"},hh={class:"meta-item-info"},gh=["title"],fh=ue({__name:"PageMeta",setup(e){const r=()=>{const i=Ue(),c=_r(),d=fr();return N(()=>{if(!(d.value.editLink??i.value.editLink??!0))return null;const{repo:m,docsRepo:f=m,docsBranch:w="main",docsDir:P="",editLinkText:k}=i.value;if(!f)return null;const v=Up({docsRepo:f,docsBranch:w,docsDir:P,filePathRelative:c.value.filePathRelative,editLinkPattern:d.value.editLinkPattern??i.value.editLinkPattern});return v?{text:k??"Edit this page",link:v}:null})},n=()=>{const i=Ue(),c=_r(),d=fr();return N(()=>{var f,w;return!(d.value.lastUpdated??i.value.lastUpdated??!0)||!((f=c.value.git)!=null&&f.updatedTime)?null:new Date((w=c.value.git)==null?void 0:w.updatedTime).toLocaleString()})},a=()=>{const i=Ue(),c=_r(),d=fr();return N(()=>{var m;return d.value.contributors??i.value.contributors??!0?((m=c.value.git)==null?void 0:m.contributors)??null:null})},o=Ue(),t=r(),s=n(),l=a();return(i,c)=>{const d=yr("ClientOnly");return U(),ee("footer",ih,[re(t)?(U(),ee("div",lh,[ne(vr,{class:"meta-item-label",item:re(t)},null,8,["item"])])):je("v-if",!0),re(s)?(U(),ee("div",ch,[he("span",dh,_e(re(o).lastUpdatedText)+": ",1),ne(d,null,{default:Me(()=>[he("span",uh,_e(re(s)),1)]),_:1})])):je("v-if",!0),re(l)&&re(l).length?(U(),ee("div",mh,[he("span",ph,_e(re(o).contributorsText)+": ",1),he("span",hh,[(U(!0),ee(Pe,null,Rr(re(l),(u,m)=>(U(),ee(Pe,{key:m},[he("span",{class:"contributor",title:`email: ${u.email}`},_e(u.name),9,gh),m!==re(l).length-1?(U(),ee(Pe,{key:0},[Mr(", ")],64)):je("v-if",!0)],64))),128))])])):je("v-if",!0)])}}}),vh=Ce(fh,[["__file","PageMeta.vue"]]),bh={key:0,class:"page-nav"},yh={class:"inner"},Sh={key:0,class:"prev"},wh={key:1,class:"next"},Ph=ue({__name:"PageNav",setup(e){const r=i=>i===!1?null:ve(i)?Ko(i):Oo(i)?i:!1,n=(i,c,d)=>{const u=i.findIndex(m=>m.link===c);if(u!==-1){const m=i[u+d];return m!=null&&m.link?m:null}for(const m of i)if(m.children){const f=n(m.children,c,d);if(f)return f}return null},a=fr(),o=Yo(),t=Xr(),s=N(()=>{const i=r(a.value.prev);return i!==!1?i:n(o.value,t.path,-1)}),l=N(()=>{const i=r(a.value.next);return i!==!1?i:n(o.value,t.path,1)});return(i,c)=>s.value||l.value?(U(),ee("nav",bh,[he("p",yh,[s.value?(U(),ee("span",Sh,[ne(vr,{item:s.value},null,8,["item"])])):je("v-if",!0),l.value?(U(),ee("span",wh,[ne(vr,{item:l.value},null,8,["item"])])):je("v-if",!0)])])):je("v-if",!0)}}),Eh=Ce(Ph,[["__file","PageNav.vue"]]),kh={class:"page"},Ch={class:"theme-default-content"},jh=ue({__name:"Page",setup(e){return(r,n)=>{const a=yr("Content");return U(),ee("main",kh,[we(r.$slots,"top"),he("div",Ch,[we(r.$slots,"content-top"),ne(a),we(r.$slots,"content-bottom")]),ne(vh),ne(Eh),we(r.$slots,"bottom")])}}}),qh=Ce(jh,[["__file","Page.vue"]]),Ih=["onKeydown"],Ah={class:"sidebar-item-children"},xh=ue({__name:"SidebarItem",props:{item:{type:Object,required:!0},depth:{type:Number,required:!1,default:0}},setup(e){const r=e,{item:n,depth:a}=qa(r),o=Xr(),t=$r(),s=N(()=>Ji(n.value,o)),l=N(()=>({"sidebar-item":!0,"sidebar-heading":a.value===0,active:s.value,collapsible:n.value.collapsible})),i=N(()=>n.value.collapsible?s.value:!0),[c,d]=Tm(i.value),u=f=>{n.value.collapsible&&(f.preventDefault(),d())},m=t.afterEach(f=>{Hn(()=>{c.value=i.value})});return Wn(()=>{m()}),(f,w)=>{var k;const P=yr("SidebarItem",!0);return U(),ee("li",null,[re(n).link?(U(),Ae(vr,{key:0,class:Ge(l.value),item:re(n)},null,8,["class","item"])):(U(),ee("p",{key:1,tabindex:"0",class:Ge(l.value),onClick:u,onKeydown:Ed(u,["enter"])},[Mr(_e(re(n).text)+" ",1),re(n).collapsible?(U(),ee("span",{key:0,class:Ge(["arrow",re(c)?"down":"right"])},null,2)):je("v-if",!0)],42,Ih)),(k=re(n).children)!=null&&k.length?(U(),Ae(Hi,{key:2},{default:Me(()=>[ha(he("ul",Ah,[(U(!0),ee(Pe,null,Rr(re(n).children,v=>(U(),Ae(P,{key:`${re(a)}${v.text}${v.link}`,item:v,depth:re(a)+1},null,8,["item","depth"]))),128))],512),[[ya,re(c)]])]),_:1})):je("v-if",!0)])}}}),Th=Ce(xh,[["__file","SidebarItem.vue"]]),_h={key:0,class:"sidebar-items"},Lh=ue({__name:"SidebarItems",setup(e){const r=Xr(),n=Yo();return He(()=>{er(()=>r.hash,a=>{const o=document.querySelector(".sidebar");if(!o)return;const t=document.querySelector(`.sidebar a.sidebar-item[href="${r.path}${a}"]`);if(!t)return;const{top:s,height:l}=o.getBoundingClientRect(),{top:i,height:c}=t.getBoundingClientRect();i<s?t.scrollIntoView(!0):i+c>s+l&&t.scrollIntoView(!1)})}),(a,o)=>re(n).length?(U(),ee("ul",_h,[(U(!0),ee(Pe,null,Rr(re(n),t=>(U(),Ae(Th,{key:`${t.text}${t.link}`,item:t},null,8,["item"]))),128))])):je("v-if",!0)}}),Rh=Ce(Lh,[["__file","SidebarItems.vue"]]),Dh={class:"sidebar"},Mh=ue({__name:"Sidebar",setup(e){return(r,n)=>(U(),ee("aside",Dh,[ne(Gi),we(r.$slots,"top"),ne(Rh),we(r.$slots,"bottom")]))}}),Oh=Ce(Mh,[["__file","Sidebar.vue"]]),zh=ue({__name:"Layout",setup(e){const r=_r(),n=fr(),a=Ue(),o=N(()=>n.value.navbar!==!1&&a.value.navbar!==!1),t=Yo(),s=fe(!1),l=k=>{s.value=typeof k=="boolean"?k:!s.value},i={x:0,y:0},c=k=>{i.x=k.changedTouches[0].clientX,i.y=k.changedTouches[0].clientY},d=k=>{const v=k.changedTouches[0].clientX-i.x,S=k.changedTouches[0].clientY-i.y;Math.abs(v)>Math.abs(S)&&Math.abs(v)>40&&(v>0&&i.x<=80?l(!0):l(!1))},u=N(()=>[{"no-navbar":!o.value,"no-sidebar":!t.value.length,"sidebar-open":s.value},n.value.pageClass]);let m;He(()=>{m=$r().afterEach(()=>{l(!1)})}),Ta(()=>{m()});const f=Ni(),w=f.resolve,P=f.pending;return(k,v)=>(U(),ee("div",{class:Ge(["theme-container",u.value]),onTouchstart:c,onTouchend:d},[we(k.$slots,"navbar",{},()=>[o.value?(U(),Ae(sh,{key:0,onToggleSidebar:l},{before:Me(()=>[we(k.$slots,"navbar-before")]),after:Me(()=>[we(k.$slots,"navbar-after")]),_:3})):je("v-if",!0)]),he("div",{class:"sidebar-mask",onClick:v[0]||(v[0]=S=>l(!1))}),we(k.$slots,"sidebar",{},()=>[ne(Oh,null,{top:Me(()=>[we(k.$slots,"sidebar-top")]),bottom:Me(()=>[we(k.$slots,"sidebar-bottom")]),_:3})]),we(k.$slots,"page",{},()=>[re(n).home?(U(),Ae(kp,{key:0})):(U(),Ae(Gn,{key:1,name:"fade-slide-y",mode:"out-in",onBeforeEnter:re(w),onBeforeLeave:re(P)},{default:Me(()=>[(U(),Ae(qh,{key:re(r).path},{top:Me(()=>[we(k.$slots,"page-top")]),"content-top":Me(()=>[we(k.$slots,"page-content-top")]),"content-bottom":Me(()=>[we(k.$slots,"page-content-bottom")]),bottom:Me(()=>[we(k.$slots,"page-bottom")]),_:3}))]),_:3},8,["onBeforeEnter","onBeforeLeave"]))])],34))}}),Nh=Ce(zh,[["__file","Layout.vue"]]),Fh={class:"theme-container"},Bh={class:"page"},Uh={class:"theme-default-content"},Hh=he("h1",null,"404",-1),Jh=ue({__name:"NotFound",setup(e){const r=bn(),n=Ue(),a=n.value.notFound??["Not Found"],o=()=>a[Math.floor(Math.random()*a.length)],t=n.value.home??r.value,s=n.value.backToHome??"Back to home";return(l,i)=>{const c=yr("RouterLink");return U(),ee("div",Fh,[he("main",Bh,[he("div",Uh,[Hh,he("blockquote",null,_e(o()),1),ne(c,{to:re(t)},{default:Me(()=>[Mr(_e(re(s)),1)]),_:1},8,["to"])])])])}}}),Wh=Ce(Jh,[["__file","NotFound.vue"]]);const Gh=wr({enhance({app:e,router:r}){e.component("Badge",fm),e.component("CodeGroup",vm),e.component("CodeGroupItem",wm),e.component("AutoLinkExternalIcon",()=>{const a=e.component("ExternalLinkIcon");return a?ce(a):null}),e.component("NavbarSearch",()=>{const a=e.component("Docsearch")||e.component("SearchBox");return a?ce(a):null});const n=r.options.scrollBehavior;r.options.scrollBehavior=async(...a)=>(await Ni().wait(),n(...a))},setup(){Wm(),Km()},layouts:{Layout:Nh,NotFound:Wh}}),Vh={enhance:({app:e})=>{e.component("CCLicense-component",D(()=>y(()=>import("./CCLicense-component-80ae505b.js"),[]))),e.component("DocumentCover-component",D(()=>y(()=>import("./DocumentCover-component-c5a9b584.js"),[]))),e.component("DownloadPDF-component",D(()=>y(()=>import("./DownloadPDF-component-370f1aed.js"),[])))}};/*! medium-zoom 1.0.8 | MIT License | https://github.com/francoischalifour/medium-zoom */var Br=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},ta=function(r){return r.tagName==="IMG"},Kh=function(r){return NodeList.prototype.isPrototypeOf(r)},la=function(r){return r&&r.nodeType===1},is=function(r){var n=r.currentSrc||r.src;return n.substr(-4).toLowerCase()===".svg"},ls=function(r){try{return Array.isArray(r)?r.filter(ta):Kh(r)?[].slice.call(r).filter(ta):la(r)?[r].filter(ta):typeof r=="string"?[].slice.call(document.querySelectorAll(r)).filter(ta):[]}catch{throw new TypeError(`The provided selector is invalid.
Expects a CSS selector, a Node element, a NodeList or an array.
See: https://github.com/francoischalifour/medium-zoom`)}},Yh=function(r){var n=document.createElement("div");return n.classList.add("medium-zoom-overlay"),n.style.background=r,n},$h=function(r){var n=r.getBoundingClientRect(),a=n.top,o=n.left,t=n.width,s=n.height,l=r.cloneNode(),i=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,c=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return l.removeAttribute("id"),l.style.position="absolute",l.style.top=a+i+"px",l.style.left=o+c+"px",l.style.width=t+"px",l.style.height=s+"px",l.style.transform="",l},en=function(r,n){var a=Br({bubbles:!1,cancelable:!1,detail:void 0},n);if(typeof window.CustomEvent=="function")return new CustomEvent(r,a);var o=document.createEvent("CustomEvent");return o.initCustomEvent(r,a.bubbles,a.cancelable,a.detail),o},Xh=function e(r){var n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=window.Promise||function(q){function L(){}q(L,L)},o=function(q){var L=q.target;if(L===J){w();return}x.indexOf(L)!==-1&&P({target:L})},t=function(){if(!(G||!g.original)){var q=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(Z-q)>M.scrollOffset&&setTimeout(w,150)}},s=function(q){var L=q.key||q.keyCode;(L==="Escape"||L==="Esc"||L===27)&&w()},l=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},L=q;if(q.background&&(J.style.background=q.background),q.container&&q.container instanceof Object&&(L.container=Br({},M.container,q.container)),q.template){var R=la(q.template)?q.template:document.querySelector(q.template);L.template=R}return M=Br({},M,L),x.forEach(function(ie){ie.dispatchEvent(en("medium-zoom:update",{detail:{zoom:F}}))}),F},i=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e(Br({},M,q))},c=function(){for(var q=arguments.length,L=Array(q),R=0;R<q;R++)L[R]=arguments[R];var ie=L.reduce(function(W,oe){return[].concat(W,ls(oe))},[]);return ie.filter(function(W){return x.indexOf(W)===-1}).forEach(function(W){x.push(W),W.classList.add("medium-zoom-image")}),A.forEach(function(W){var oe=W.type,te=W.listener,ze=W.options;ie.forEach(function(De){De.addEventListener(oe,te,ze)})}),F},d=function(){for(var q=arguments.length,L=Array(q),R=0;R<q;R++)L[R]=arguments[R];g.zoomed&&w();var ie=L.length>0?L.reduce(function(W,oe){return[].concat(W,ls(oe))},[]):x;return ie.forEach(function(W){W.classList.remove("medium-zoom-image"),W.dispatchEvent(en("medium-zoom:detach",{detail:{zoom:F}}))}),x=x.filter(function(W){return ie.indexOf(W)===-1}),F},u=function(q,L){var R=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return x.forEach(function(ie){ie.addEventListener("medium-zoom:"+q,L,R)}),A.push({type:"medium-zoom:"+q,listener:L,options:R}),F},m=function(q,L){var R=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return x.forEach(function(ie){ie.removeEventListener("medium-zoom:"+q,L,R)}),A=A.filter(function(ie){return!(ie.type==="medium-zoom:"+q&&ie.listener.toString()===L.toString())}),F},f=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},L=q.target,R=function(){var W={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},oe=void 0,te=void 0;if(M.container)if(M.container instanceof Object)W=Br({},W,M.container),oe=W.width-W.left-W.right-M.margin*2,te=W.height-W.top-W.bottom-M.margin*2;else{var ze=la(M.container)?M.container:document.querySelector(M.container),De=ze.getBoundingClientRect(),Je=De.width,Ne=De.height,Pr=De.left,Er=De.top;W=Br({},W,{width:Je,height:Ne,left:Pr,top:Er})}oe=oe||W.width-M.margin*2,te=te||W.height-M.margin*2;var ir=g.zoomedHd||g.original,Le=is(ir)?oe:ir.naturalWidth||oe,C=is(ir)?te:ir.naturalHeight||te,H=ir.getBoundingClientRect(),O=H.top,K=H.left,de=H.width,p=H.height,h=Math.min(Math.max(de,Le),oe)/de,b=Math.min(Math.max(p,C),te)/p,E=Math.min(h,b),j=(-K+(oe-de)/2+M.margin+W.left)/E,I=(-O+(te-p)/2+M.margin+W.top)/E,B="scale("+E+") translate3d("+j+"px, "+I+"px, 0)";g.zoomed.style.transform=B,g.zoomedHd&&(g.zoomedHd.style.transform=B)};return new a(function(ie){if(L&&x.indexOf(L)===-1){ie(F);return}var W=function Je(){G=!1,g.zoomed.removeEventListener("transitionend",Je),g.original.dispatchEvent(en("medium-zoom:opened",{detail:{zoom:F}})),ie(F)};if(g.zoomed){ie(F);return}if(L)g.original=L;else if(x.length>0){var oe=x;g.original=oe[0]}else{ie(F);return}if(g.original.dispatchEvent(en("medium-zoom:open",{detail:{zoom:F}})),Z=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,G=!0,g.zoomed=$h(g.original),document.body.appendChild(J),M.template){var te=la(M.template)?M.template:document.querySelector(M.template);g.template=document.createElement("div"),g.template.appendChild(te.content.cloneNode(!0)),document.body.appendChild(g.template)}if(g.original.parentElement&&g.original.parentElement.tagName==="PICTURE"&&g.original.currentSrc&&(g.zoomed.src=g.original.currentSrc),document.body.appendChild(g.zoomed),window.requestAnimationFrame(function(){document.body.classList.add("medium-zoom--opened")}),g.original.classList.add("medium-zoom-image--hidden"),g.zoomed.classList.add("medium-zoom-image--opened"),g.zoomed.addEventListener("click",w),g.zoomed.addEventListener("transitionend",W),g.original.getAttribute("data-zoom-src")){g.zoomedHd=g.zoomed.cloneNode(),g.zoomedHd.removeAttribute("srcset"),g.zoomedHd.removeAttribute("sizes"),g.zoomedHd.removeAttribute("loading"),g.zoomedHd.src=g.zoomed.getAttribute("data-zoom-src"),g.zoomedHd.onerror=function(){clearInterval(ze),console.warn("Unable to reach the zoom image target "+g.zoomedHd.src),g.zoomedHd=null,R()};var ze=setInterval(function(){g.zoomedHd.complete&&(clearInterval(ze),g.zoomedHd.classList.add("medium-zoom-image--opened"),g.zoomedHd.addEventListener("click",w),document.body.appendChild(g.zoomedHd),R())},10)}else if(g.original.hasAttribute("srcset")){g.zoomedHd=g.zoomed.cloneNode(),g.zoomedHd.removeAttribute("sizes"),g.zoomedHd.removeAttribute("loading");var De=g.zoomedHd.addEventListener("load",function(){g.zoomedHd.removeEventListener("load",De),g.zoomedHd.classList.add("medium-zoom-image--opened"),g.zoomedHd.addEventListener("click",w),document.body.appendChild(g.zoomedHd),R()})}else R()})},w=function(){return new a(function(q){if(G||!g.original){q(F);return}var L=function R(){g.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(g.zoomed),g.zoomedHd&&document.body.removeChild(g.zoomedHd),document.body.removeChild(J),g.zoomed.classList.remove("medium-zoom-image--opened"),g.template&&document.body.removeChild(g.template),G=!1,g.zoomed.removeEventListener("transitionend",R),g.original.dispatchEvent(en("medium-zoom:closed",{detail:{zoom:F}})),g.original=null,g.zoomed=null,g.zoomedHd=null,g.template=null,q(F)};G=!0,document.body.classList.remove("medium-zoom--opened"),g.zoomed.style.transform="",g.zoomedHd&&(g.zoomedHd.style.transform=""),g.template&&(g.template.style.transition="opacity 150ms",g.template.style.opacity=0),g.original.dispatchEvent(en("medium-zoom:close",{detail:{zoom:F}})),g.zoomed.addEventListener("transitionend",L)})},P=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},L=q.target;return g.original?w():f({target:L})},k=function(){return M},v=function(){return x},S=function(){return g.original},x=[],A=[],G=!1,Z=0,M=n,g={original:null,zoomed:null,zoomedHd:null,template:null};Object.prototype.toString.call(r)==="[object Object]"?M=r:(r||typeof r=="string")&&c(r),M=Br({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},M);var J=Yh(M.background);document.addEventListener("click",o),document.addEventListener("keyup",s),document.addEventListener("scroll",t),window.addEventListener("resize",w);var F={open:f,close:w,toggle:P,update:l,clone:i,attach:c,detach:d,on:u,off:m,getOptions:k,getImages:v,getZoomedImage:S};return F};function Qh(e,r){r===void 0&&(r={});var n=r.insertAt;if(!(!e||typeof document>"u")){var a=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css",n==="top"&&a.firstChild?a.insertBefore(o,a.firstChild):a.appendChild(o),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(document.createTextNode(e))}}var Zh=".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";Qh(Zh);const eg=Xh,rg=Symbol("mediumZoom");const ng=":not(a) > img",ag={},og=500,tg=wr({enhance({app:e,router:r}){const n=eg(ag);n.refresh=(a=ng)=>{n.detach(),n.attach(a)},e.provide(rg,n),r.afterEach(()=>{setTimeout(()=>n.refresh(),og)})}}),sg=e=>e instanceof Element?document.activeElement===e&&(["TEXTAREA","SELECT","INPUT"].includes(e.tagName)||e.hasAttribute("contenteditable")):!1,ig=(e,r)=>r.some(n=>{if(ve(n))return n===e.key;const{key:a,ctrl:o=!1,shift:t=!1,alt:s=!1}=n;return a===e.key&&o===e.ctrlKey&&t===e.shiftKey&&s===e.altKey}),lg=/[^\x00-\x7F]/,cg=e=>e.split(/\s+/g).map(r=>r.trim()).filter(r=>!!r),cs=e=>e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),ds=(e,r)=>{const n=r.join(" "),a=cg(e);if(lg.test(e))return a.some(s=>n.toLowerCase().indexOf(s)>-1);const o=e.endsWith(" ");return new RegExp(a.map((s,l)=>a.length===l+1&&!o?`(?=.*\\b${cs(s)})`:`(?=.*\\b${cs(s)}\\b)`).join("")+".+","gi").test(n)},dg=({input:e,hotKeys:r})=>{if(r.value.length===0)return;const n=a=>{e.value&&ig(a,r.value)&&!sg(a.target)&&(a.preventDefault(),e.value.focus())};He(()=>{document.addEventListener("keydown",n)}),Wn(()=>{document.removeEventListener("keydown",n)})},ug=[{title:"",headers:[],path:"/",pathLocale:"/",extraFields:[`---\r
home: true\r
title: \r
heroImage: /images/quote.jpg\r
tagline: \r
actions:\r
- text: PSP (English)    \r
  link: /en/\r
  type: secondary\r
- text: PSP (Castellano) \r
  link: /es/\r
  type: secondary \r
features:\r
- title: CFGS DAM\r
  details: Mdulo de 2 curso\r
- title: Profesor\r
  details: Vicente Martnez Martnez\r
- title: Centro\r
  details: IES Doctor Balmis (Alicante)\r
footer:  2024/2025\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Except where otherwise noted, content on this site (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources">PSP class notes</a>) by <span property="cc:attributionName">Vicente Martnez</span> is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>    \r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Excepto donde se indique lo contrario, el contenido de este sitio (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources/es/">Apuntes de PSP</a>) creado por <span property="cc:attributionName">Vicente Martnez</span> est bajo una licencia  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>\r
`]},{title:"PSP",headers:[{level:2,title:"Acerca de",slug:"acerca-de",link:"#acerca-de",children:[]},{level:2,title:"Segundo apartado",slug:"segundo-apartado",link:"#segundo-apartado",children:[]},{level:2,title:"Segundo apartado",slug:"segundo-apartado-1",link:"#segundo-apartado-1",children:[]}],path:"/test_page.html",pathLocale:"/",extraFields:[`---\r
title: PSP\r
---\r
\r
<div class="pagebreak"></div>\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="PSP" />\r
\r
# PSP\r
\r
[[toc]]\r
\r
## Acerca de\r
\r
::: info\r
["Google"](http://www.google.es)\r
:::\r
\r
::: tip Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: warning Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: danger Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: question Chech your skills\r
Qu pasar ahora?\r
:::\r
<div class="pagebreak"></div>\r
\r
## Segundo apartado\r
\r
\`\`\`java\r
public static void main() {\r
    return;\r
}\r
\`\`\`\r
\r
::: info\r
["Google"](http://www.google.es)\r
:::\r
\r
::: tip Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: warning Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: danger Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: question Chech your skills\r
Qu pasar ahora?\r
:::\r
<div class="pagebreak"></div>\r
\r
## Segundo apartado\r
\r
\`\`\`java\r
public static void main() {\r
    return;\r
}\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
\r
<!--\r
## Diagrama de flujo\r
![diagrama de sequencia|, 20%](/media/puml_sequence_test.png)\r
\r
\`\`\`puml {align="center", style="zoom:1"}\r
@startuml\r
skinparam handwritten true\r
title Protocolo validacin user/passwd\r
header Prueba\r
footer Prueba\r
hide footbox\r
skinparam sequence {\r
ParticipantBorderColor DeepSkyBlue\r
ParticipantBackgroundColor DodgerBlue\r
} \r
note left of Cliente: El programa cliente lee por teclado\\nun usuario y una contrasea \r
Cliente->Servidor: Usuario\r
Cliente->Servidor: Password\r
note right of Servidor: El programa servidor comprueba\\n- Si el usuario es "vicente"\\n     contesta "USEROK" \\nsino \\n    contesta "USERERROR"\r
note right of Servidor: El programa servidor comprueba\\n- Si el password es "psp"\\n     contesta "PASSOK" \\nsino \\n    contesta "PASSERROR"\r
Servidor->Cliente: USEROK  USERERROR\r
Servidor->Cliente: PASSOK  PASSERROR\r
note left of Cliente: El programa mostrar un mensaje\\nen base a la informacin recibida\\nIndicando si el usuario y la contrasea\\nenviadas han diso correctas o no\r
@enduml\r
\`\`\`\r
-->\r
`]},{title:"PSP - Documentation Site",headers:[],path:"/en/",pathLocale:"/en/",extraFields:[`---\r
home: true\r
title: PSP - Documentation Site\r
heroImage: /LogoPSP_en.png\r
tagline: Class notes\r
actions:\r
- text: Unit 1 (  Intro  )    \r
  link: /en/unit1/\r
  type: secondary\r
- text: Unit 2 (  Processes  )    \r
  link: /en/unit2/\r
  type: secondary\r
- text: Unit 3 (  Threads  )    \r
  link: /en/unit3/\r
  type: secondary\r
- text: Unit 4 (  Sockets  )    \r
  link: /en/unit4/\r
  type: secondary\r
- text: Unit 5 (  Services  )    \r
  link: /en/unit5/\r
  type: secondary\r
- text: Unit 6 (  Security  )    \r
  link: /en/unit6/\r
  type: secondary\r
features:\r
- title: \r
  details: \r
- title: \r
  details: \r
- title: \r
  details: \r
footer:  2024/2025\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Except where otherwise noted, content on this site (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources">PSP class notes</a>) by <span property="cc:attributionName">Vicente Martnez</span> is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>    \r
`]},{title:"PSP - Pgina  de documentacin",headers:[],path:"/es/",pathLocale:"/es/",extraFields:[`---\r
home: true\r
title: PSP - Pgina  de documentacin\r
heroImage: /LogoPSP_es.png\r
tagline: Apuntes de clase\r
actions: \r
- text: Tema 1 (  Intro  )       \r
  link: /es/unit1/\r
  type: secondary\r
- text: Tema 2 (  Procesos  )       \r
  link: /es/unit2/\r
  type: secondary\r
- text: Tema 3 (  Hilos  )       \r
  link: /es/unit3/\r
  type: secondary\r
- text: Tema 4 (  Sockets  )    \r
  link: /es/unit4/\r
  type: secondary\r
- text: Tema 5 (  Servicios  )    \r
  link: /es/unit5/\r
  type: secondary\r
- text: Tema 6 (  Seguridad  )    \r
  link: /es/unit6/\r
  type: secondary\r
features:\r
- title: \r
  details: \r
- title: \r
  details: \r
- title: \r
  details: \r
footer:  2024 / 2025\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Excepto donde se indique lo contrario, el contenido de este sitio (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources/es/">Apuntes de PSP</a>) creado por <span property="cc:attributionName">Vicente Martnez</span> est bajo una licencia  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>`]},{title:"1.2 Concurrency",headers:[{level:2,title:"1.2.1. Concurrency vs Parallelism",slug:"_1-2-1-concurrency-vs-parallelism",link:"#_1-2-1-concurrency-vs-parallelism",children:[{level:3,title:"Monoprocess",slug:"monoprocess",link:"#monoprocess",children:[]},{level:3,title:"Multitasking",slug:"multitasking",link:"#multitasking",children:[]},{level:3,title:"Parallelism",slug:"parallelism",link:"#parallelism",children:[]}]},{level:2,title:"1.2.2. Distributed systems",slug:"_1-2-2-distributed-systems",link:"#_1-2-2-distributed-systems",children:[]},{level:2,title:"1.2.3. Advantages and disadvantages",slug:"_1-2-3-advantages-and-disadvantages",link:"#_1-2-3-advantages-and-disadvantages",children:[]},{level:2,title:"1.2.4. Bernstein's conditions",slug:"_1-2-4-bernstein-s-conditions",link:"#_1-2-4-bernstein-s-conditions",children:[]}],path:"/en/unit1/concurrency.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.2 Concurrency\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.2. Concurrency" />\r
\r
# 1.2. Concurrency\r
\r
[[toc]]\r
\r
According to the [Collins dictionary](https://www.collinsdictionary.com/es/diccionario/ingles/concurrency) some of the senses os the word concurrency are\r
> Cooperation or combination. Simultaneous occurrence; coincidence.\r
\r
If we change occurrence to  \`process\`, we get a definition closer to its sense in the computer science.\r
\r
This is not the first time the word  \`process\` appears, that is because they are one of the most important concepts in programming.\r
\r
## 1.2.1. Concurrency vs Parallelism\r
\r
Now that we already know what a process is, let's look at its relationship with the hardware where they are run.\r
\r
### Monoprocess\r
\r
Maybe we want to run many processes at the same time, but if we only have one processor unit, it's absolutely impossible to have more than one task running at the same time.\r
\r
One possibility is to run the tasks in sequence. The system starts running one process and it doesn't start with the next one until the current task has completely finished. That is what happens in systems that are able to do one task at a time, something really strange nowadays.\r
\r
![Sequential execution of tasks (monoprocessor system)](./../../media/unit1/gantt_sequential.svg)\r
\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Sequential execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1       :done, t1, 0, 4s\r
Process 2     : active, t2, after t1, 5s\r
Process 3     : crit, t3, after t2, 2s\r
Process 4    : t4, after t3, 5s\r
\`\`\`\r
-->\r
\r
### Multitasking\r
\r
In a multiprogramming system there are one or more programs loaded in main memory which are ready to execute. Only one program at a time is able to get the CPU for executing its instructions while all the others are waiting their turn.\r
\r
The main idea of multiprogramming is to maximize the use of CPU time. Indeed, suppose the currently running process is performing an I/O task (which, by definition, does not need the CPU to be accomplished). Then, the OS may interrupt that process and give the control to one of the other in-main-memory programs that are ready to execute (i.e. process context switching).  It is said that running processes are multiplexed on time.\r
\r
This way, the OS gives as the illusion that many processes are running simultaneously. That is commonly called \`multitasking\`.\r
\r
![Concurrent execution of tasks (monoprocessor system)](./../../media/unit1/gantt_concurrent.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Concurrent execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 3  :crit, t3, after t2, 2s\r
Process 4  : t4, after t3, 1s\r
Process 1  :done, t5, after t4, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 4  : t7, after t6, 3s\r
Process 2  :active, t8, after t7, 2s\r
Process 4  : t9, after t8, 1s\r
\`\`\`\r
-->\r
\r
On both previous images can be observed how the total CPU time to complete all processes is the same in both models. Nonetheless, on the second model the user has the sensation that all tasks are running at the same time.\r
\r
### Parallelism\r
\r
Multiprocessing sometimes refers to executing multiple processes (programs) at the same time. This might be misleading because we have already introduced the term multiprogramming to describe that before.\r
In fact, multiprocessing refers to the hardware (i.e., the CPU units) rather than the software (i.e., running processes). If the underlying hardware provides more than one processor then that is multiprocessing. Several variations on the basic scheme exist, e.g., multiple cores on one die or multiple dies in one package or multiple packages in one system.\r
Anyway, a system can be both multiprogrammed by having multiple programs running at the same time and multiprocessing by having more than one physical processor.\r
\r
Nowadays most devices, from desktop to laptops through mobile devices and IoT, all of them offer multiprocess capabilities, that is, they have mor than one processing unit to really do many tasks at the same time, no simulate it.\r
This kind of execution is called \`parallelism\`.\r
\r
![Parallel execution of tasks (dual processor system)](./../../media/unit1/gantt_parallel.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Parallel execution of tasks (dual processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 1  :done, t5, after t2, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 2  :active, t8, after t6, 2s\r
section Processor 2\r
Process 3  :crit, t3, 0, 2s\r
Process 4  : t4, after t3, 1s\r
Process 4  : t7, after t4, 3s\r
Process 4  : t9, after t7, 1s\r
\`\`\`\r
-->\r
\r
The bigger the processor units number is, the less time the tasks it takes to run and the user will have a better experience. This is one of the goals of operating systems, schedule properly the tasks to minimize running times, wait times and to maximize the resources use , mainly the processors.\r
\r
::: question cores vs threads\r
have you bought a microprocessor recently? Are you up-to-date in the state of the art of hardware? Then, you'll probably know that one of the main characteristics of a microprocessor are its  **cores number** (4, 8, 16).\r
\r
Moreover, the number of cores is completed with another configuration, **treads number**, that usually is twice the number of cores.\r
\r
What is the relationship between processor threads and concurrency? A computer system with 8 cores / 16 threads means that it can run up to 16 process in parallel?\r
:::\r
\r
## 1.2.2. Distributed systems\r
\r
> "A collection of independent computers that appears to its users as a single. coherent system"\r
>\r
> "Andrew S. Tanembaum"\r
\r
This definition has several important aspects:\r
\r
- The first one is that a distributed system consists of components (i.e., computers) that are autonomous.\r
- A second aspect is that users (people or programs) think they are dealing with a single system. This means that one way or the other the autonomous components need to collaborate. How to establish this collaboration lies at the heart of developing distributed systems\r
\r
The most known and famous example of distributed system is \`the Internet\`. The Internet is seen by the users as a single huge documents repository, that is, a single system able to provide almost any information or service. Notwithstanding the above, we know that is made up of millions of devices located all over the world and interconnected.\r
\r
It began with the need to share resources. Actually the state-of-the-art on these systems are \`Cloud Computing\` or cloud services. It's said that a distributed system is where software components are distributed on a network and they communicate and coordinate with each other by using message passing.\r
\r
Let's concentrate on important characteristics of distributed systems:\r
\r
- Concurrency. Allows running multiple process in parallel.\r
- Global watch independency. Implies synchronization using messaging.\r
- Scalability: distributed systems should also be relatively easy to expand or scale. This characteristic is a direct consequence of having independent computers, but at the same time, hiding how these computers actually take part in the system as a whole.\r
- Fault tolerance: A distributed system will normally be continuously available, although perhaps some parts may be temporarily out of order.\r
\r
## 1.2.3. Advantages and disadvantages\r
\r
Pros of parallel processing:\r
\r
- Simultaneous running of tasks\r
- Reduce total running time\r
- Helps to solve big and complex problems\r
- Use of non local resources on the network\r
- Reduce expenses by taking advantage of shared resources. It's not necessary to invest on a supercomputer because it's possible to have the same processing power with smaller computers distributed\r
\r
Cons of parallel processing:\r
\r
- Compilers and development environments are more complex to develop.\r
- Parallel programs are more difficult to write\r
- Higher power consumption\r
- Bigger data access complexity\r
- High communication and synchronization complexity on subtasks <Badge type="danger" text="warning" vertical="middle" />\r
\r
Pros of distributed programming\r
\r
- Resource & data sharing\r
- Scale under demand\r
- Bigger flexibility to distribute processing load\r
- High availability\r
- Support for distributed applications\r
- Open philosophy and heterogeneous development\r
\r
::: question Scalability\r
Scalability means the possibility of increase the processing, storage, and capabilities of a system\r
\r
Research about differences, pros and cons of  \`vertical scaling\` vs \`horizontal scaling\`.\r
:::\r
\r
Cons of distributed programming\r
\r
- Increase system complexity\r
- New specialized software is needed\r
- Communication problems (data lost, overflows, saturation, etc.)\r
- Security problems, DDoS attacks\r
\r
Distributed and parallel programming examples\r
\r
- Weather forecast analysis and research\r
- Human genome research\r
- Biosphere modelling\r
- Seismic predictions\r
- Molecule simulation\r
\r
::: info Example of parallel and distributed programming\r
[Allien intelligence research- SETI Project](https://setiathome.berkeley.edu/sah_about.php)\r
:::\r
\r
## 1.2.4. Bernstein's conditions\r
\r
Once we know what a concurrent program is and the different hardware architectures that support them, let's try to identify which program parts can be executed concurrently.\r
\r
If we look at the following code we can determine that the first sentence must be run before the second one in order to get always the same result (for the same input data set).\r
\r
\`\`\`java\r
x = x + 1;\r
y = x + 1;\r
\`\`\`\r
\r
Though in the following code the order isn't important at all and doesn't change the final result (output data set). In this situation all of them cam be run at the same time increasing processing speed.\r
\r
\`\`\`java\r
x = 1;\r
y = 2;\r
z = 3;\r
\`\`\`\r
\r
A.J. Bernsteins Conditions are the conditions applied on two statements S1 and S2 that are to be executed in the processor. It states that three conditions that are explained below must be satisfied for two successive statements S<sub>i</sub> y S<sub>j</sub> to be executed concurrently and still produce the same result\r
\r
Bernstein conditions are rely on the subsequent two sets of variables:\r
\r
- R(S<sub>k</sub>) = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...} read set consists of all variables that are read during execution of k statements set\r
- W(S<sub>k</sub>) = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, ...} write set consists of all variables that are written (updated) during execution of k statements set.\r
\r
To run concurrently both statement sets  S<sub>i</sub> y S<sub>j</sub> these three conditions must be matched simultaneously:\r
\r
- R(S<sub>i</sub>)  W(S<sub>j</sub>)\r
- W(S<sub>i</sub>)  R(S<sub>j</sub>)\r
- W(S<sub>i</sub>)  W(S<sub>j</sub>)\r
  \r
::: question Which of these instructions can be run concurrently?\r
\r
\`\`\`java\r
a = x + y;\r
b = z - 1;\r
c = a - b;\r
w = c + 1;\r
\`\`\`\r
\r
:::\r
\r
First of all we must get R & W sets for each sentence\r
\r
> R(S<sub>1</sub>) = {x, y}\r
> \r
> W(S<sub>1</sub>) = {a}\r
\r
> R(S<sub>2</sub>) = {z}  \r
> \r
> W(S<sub>2</sub>) = {b}\r
\r
> R(S<sub>3</sub>) = {a, b}\r
> \r
> W(S<sub>3</sub>) = {c}\r
\r
> R(S<sub>4</sub>) = {c}\r
> \r
> W(S<sub>4</sub>) = {w}\r
\r
And now let's apply the rules for each pair of sentences\r
\r
>R(S<sub>1</sub>)  W(S<sub>2</sub>) = \r
>\r
>W(S<sub>1</sub>)  R(S<sub>2</sub>) = \r
>\r
>W(S<sub>1</sub>)  W(S<sub>2</sub>) =          // They can be run simultaneously\r
\r
>R(S<sub>1</sub>)  W(S<sub>3</sub>) = \r
>\r
>W(S<sub>1</sub>)  R(S<sub>3</sub>) = {a}  \r
>\r
>W(S<sub>1</sub>)  W(S<sub>3</sub>) =          // NO parallelism without problems\r
\r
>R(S<sub>1</sub>)  W(S<sub>4</sub>) = \r
>\r
>W(S<sub>1</sub>)  R(S<sub>4</sub>) = \r
>\r
>W(S<sub>1</sub>)  W(S<sub>4</sub>) =          // They can be run simultaneously\r
\r
>R(S<sub>2</sub>)  W(S<sub>3</sub>) = \r
>\r
>W(S<sub>2</sub>)  R(S<sub>3</sub>) = {b]  \r
>\r
>W(S<sub>2</sub>)  W(S<sub>3</sub>) =          // NO parallelism without problems\r
\r
>R(S<sub>2</sub>)  W(S<sub>4</sub>) = \r
>\r
>W(S<sub>2</sub>)  R(S<sub>4</sub>) = \r
>\r
>W(S<sub>2</sub>)  W(S<sub>4</sub>) =          // They can be run simultaneously\r
\r
>R(S<sub>3</sub>)  W(S<sub>4</sub>) = \r
>\r
>W(S<sub>3</sub>)  R(S<sub>4</sub>) = {c}  \r
>\r
>W(S<sub>3</sub>)  W(S<sub>4</sub>) =          // NO parallelism without problems\r
`]},{title:"1 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit1/",pathLocale:"/en/",extraFields:[`---\r
title: 1 Introduction\r
---\r
\r
# Unit 1. Concurrent programming\r
\r
In this first unit we will learn about topic keys related to concurrent programming together with most of the vocabulary that we are going to use in this course.\r
\r
Digital technology has transformed nearly every aspect of modern life. Travel, work, shopping, entertainment, and communications are just some of the areas that have been revolutionized in recent decades. It's now rare to find an electronic device or piece of machinery that doesn't incorporate digital technology in some way.\r
\r
Digital technology means that devices can be more compact, faster, lighter, and more versatile. Huge amounts of information can be stored locally or remotely and moved around virtually instantaneously. Even the term "information" has expanded to include media such as photos, audio, and video, and no longer refers to just words and numbers.\r
\r
As programmers we should be capable of getting the maximum from software and hardware in our applications.\r
\r
There are a lot of tasks that need higher processing power to consume a huge amount of data. Two examples of this are \`Big Data\` and \`AI\` applications. These computing fields are rising in importance and require all the power the concurrent programming and the underlying hardware can offer.\r
\r
::: details What dou you think concurrency is?\r
We are gonna discuss it at class.\r
We will define the concept bit by bit throughout this course\r
:::\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To differentiate process and program\r
- To understand what concurrency is\r
- To know about relationship and differences between the two basic execution units: processes and threads.\r
- To know the basics about concurrent programming\r
- To know how concurrency performs on OS and hardware.\r
`]},{title:"1.3 Processes in the OS",headers:[{level:2,title:"1.3.1. The OS kernel",slug:"_1-3-1-the-os-kernel",link:"#_1-3-1-the-os-kernel",children:[]},{level:2,title:"1.3.2. Process conntrol in GNU/Linux",slug:"_1-3-2-process-conntrol-in-gnu-linux",link:"#_1-3-2-process-conntrol-in-gnu-linux",children:[{level:3,title:"Command to get the process PiD",slug:"command-to-get-the-process-pid",link:"#command-to-get-the-process-pid",children:[]},{level:3,title:"Commands to view active processes in GNU/Linux",slug:"commands-to-view-active-processes-in-gnu-linux",link:"#commands-to-view-active-processes-in-gnu-linux",children:[]},{level:3,title:"Process control",slug:"process-control",link:"#process-control",children:[]}]},{level:2,title:"1.3.3. Process states",slug:"_1-3-3-process-states",link:"#_1-3-3-process-states",children:[]},{level:2,title:"1.3.4 Process scheduler",slug:"_1-3-4-process-scheduler",link:"#_1-3-4-process-scheduler",children:[]},{level:2,title:"1.3.5. Process scheduling algorithms",slug:"_1-3-5-process-scheduling-algorithms",link:"#_1-3-5-process-scheduling-algorithms",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",link:"#fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",link:"#sjf-shortest-job-first",children:[]},{level:3,title:"Priority scheduling",slug:"priority-scheduling",link:"#priority-scheduling",children:[]},{level:3,title:"Round Robin",slug:"round-robin",link:"#round-robin",children:[]},{level:3,title:"Scheduler with I/O operations or locks",slug:"scheduler-with-i-o-operations-or-locks",link:"#scheduler-with-i-o-operations-or-locks",children:[]}]}],path:"/en/unit1/operatingsystem.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.3 Processes in the OS\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.3. Processes in the OS" />\r
\r
# 1.3. Processes in the Operating System\r
\r
[[toc]]\r
\r
## 1.3.1. The OS kernel\r
\r
The \`kernel or OS core\` is the responsible of the basic functions on the system and the resources management. It's accessed by systems calls. it is the smaller part of the OS and usually it's coded in low-level languages to improve its performance. The rest of the OS is called system apps.\r
\r
Essentially, a process is what a program becomes when it is loaded into memory from a secondary storage medium like a hard disk drive or an removable drive. Each process has its own address space, which typically contains both program instructions and data. Despite the fact that an individual processor or processor core can only execute one program instruction at a time, a large number of processes can be executed over a relatively short period of time by briefly assigning each process to the processor in turn.\r
\r
When a user starts an application program, the operating system's \`high-level scheduler (HLS)\` loads all or part of the program code from secondary storage into memory. It then creates a data structure in memory called a process control block (PCB) that will be used to hold information about the process, such as its current status and where in memory it is located.\r
\r
The operating system also maintains a separate process table in memory that lists all the user processes currently loaded. When a new process is created, it is given a unique process identification number (PID) and a new record is created for it in the process table which includes the address of the process control block in memory.\r
\r
As well as allocating memory space, loading the process, and creating the necessary data structures, the operating system must also allocate resources such as access to I/O devices and disk space if the process requires them. Information about the resources allocated to a process is also held within the process control block. The operating system's \`low-level scheduler (LLS)\` is **responsible for allocating CPU time to each process in turn**.\r
\r
When a process makes the transition from one state to another, the operating system updates the information in its PCB. When the process is terminated, the operating system removes it from the process table and frees the memory and any other resources allocated to the process so that they become available to other processes. The diagram below illustrates the relationship between the process table and the various process control blocks.\r
\r
These \`context changes\` are time and resource consuming. We will talk about this later, with a smaller running unit \`threads\`, that solve this problem partially.\r
\r
![Process Control Block](./../../media/unit1/process_control_blocks.gif)\r
\r
The process control block (PCB) maintains information that the operating system needs in order to manage a process. PCBs typically include information such as the process ID, the current state of the process (e.g. running, ready, blocked, etc.), the number of the next program instruction to be executed, and the starting address of the process in memory. The PCB also stores the contents of various processor registers (the execution context), which are saved when a process leaves the running state and which are restored to the processor when the process returns to the running state.\r
\r
## 1.3.2. Process conntrol in GNU/Linux\r
\r
Because Linux is a multi-user system, meaning different users can be running various programs on the system, each running instance of a program must be identified uniquely by the kernel.\r
\r
And a program is identified by its process ID (PID) as well as its parent processes ID (PPID), therefore processes can further be categorized into:\r
\r
- Parent processes  these are processes that create other processes during run-time.\r
- Child processes  these processes are created by other processes during run-time.\r
\r
Init process is the mother (parent) of all processes on the system, its the first program that is executed when the Linux system boots up; it manages all other processes on the system. It is started by the kernel itself, so in principle it does not have a parent process.\r
\r
::: info init process\r
The init process always has process ID of 1.\r
\r
It functions as an adoptive parent for all orphaned processes.\r
:::\r
\r
### Command to get the process PiD\r
\r
In Linux every process on a system has a PID (Process Identification Number) which can be used to kill the process. The command \`pidof cmdname\` shows all processes related to that command. Remember that every time we start a command or application a nes process is created.\r
\r
Shell variables \`$$\` and \`$PPID\` show the actual process PID and its PPID respectively.\r
\r
\`\`\`bash\r
# pidof systemd\r
1\r
# pidof top\r
2060\r
# pidof httpd\r
2103 2102 2101 2100 2099 1076\r
# Process pid\r
echo $$\r
2109\r
# Process parent pid\r
echo $PPID\r
2106\r
\`\`\`\r
\r
### Commands to view active processes in GNU/Linux\r
\r
There are several Linux tools for viewing/listing running processes on the system, the two traditional and well known are \`ps\` and \`top\` commands:\r
\r
The \`ps\` command displays information about a selection of the active processes on the system, along with some process information,  as shown below:\r
\r
This command offers many options to show more or less information about the processes, as well as our user's processes ot others' processes, including statistics about resource usage, etc.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD\r
root         1     0  0   223   576   5 11:00 ?        00:00:00 /init\r
root         7     1  0   223    80   3 11:00 ?        00:00:00 /init\r
root         8     7  0   223    80   1 11:00 ?        00:00:00 /init\r
vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash\r
vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF\r
vicente@Desktop-Vicente:~$ ps -auxf\r
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r
root         1  0.0  0.0    892   576 ?        Sl   11:00   0:00 /init\r
root         7  0.0  0.0    892    80 ?        Ss   11:00   0:00 /init\r
root         8  0.0  0.0    892    80 ?        S    11:00   0:00  \\_ /init\r
vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash\r
vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf\r
\`\`\`\r
\r
::: info Useful ps examples for Linux process monitoring\r
[https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/](https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/)\r
:::\r
\r
The \`top\`command  is a powerful tool that offers you a dynamic real-time view of a running system as shown in the screenshot below:\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00\r
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie\r
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r
MiB Mem :  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache\r
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem\r
\r
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r
    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init\r
    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init\r
    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init\r
    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash\r
   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top\r
\`\`\`\r
\r
::: info top examples in Linux\r
[https://www.tecmint.com/12-top-command-examples-in-linux/](https://www.tecmint.com/12-top-command-examples-in-linux/)\r
:::\r
\r
### Process control\r
\r
Process management is one of the important aspects of System Administration in Linux, and it includes killing of processes using the \`kill\` command.\r
\r
When killing processes, the kill command is used to send a named signal to a named process or groups of processes. The default signal is the TERM signal.\r
\r
A waiting process that can be interrupted by signals is called \`Interruptible\`, while a waiting process that is directly waiting on hardware conditions and cannot be interrupted under any conditions is called \`uninterruptible\`.\r
\r
\`\`\`bash\r
# Get Firefox PID after it freezes\r
$ pidof firefox\r
2687\r
# Send the SIGKILL (9) signal to end the process immediately\r
$ kill 9 2687\r
\`\`\`\r
\r
::: info How to control Linux process Using kill, pkill and kilall\r
[https://www.tecmint.com/how-to-kill-a-process-in-linux/](https://www.tecmint.com/how-to-kill-a-process-in-linux/)\r
:::\r
\r
The kernel stores a great deal of information about processes including process priority which is simply the scheduling priority attached to a process. Processes with a higher priority will be executed before those with a lower priority, while processes with the same priority are scheduled one after the next, repeatedly.\r
\r
A user with *root* privileges can modify processes priority. This value can be seen in the NI (nice) columns of \`top\`output. This value also influences the PRI (priority) column, meaning the priority the OS gives to a process.\r
\r
The priority is a nice value (niceness) which ranges from -20 (highest priority value) to 19 (lowest priority value) and the default is 0. Using the \`nice\` command we can guarantee that in high load CPU periods some processes will make a priority use of the CPU\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ nice\r
0\r
vicente@Desktop-Vicente:~$ nice -n 10 bash\r
vicente@Desktop-Vicente:~$ nice\r
10\r
vicente@Desktop-Vicente:~$\r
\`\`\`\r
\r
::: tip Process control in Windows\r
In Windows systems most of previous actions can be performed from the task manager, though commands **tasklist** and **taskkill** can be used in console mode..\r
\r
*tasklist /svc /fi imagename eq svchost.exe*\r
Will display you the result with Image name, PID and Service name to know which services are being run under the process svchost.exe, generic host services for services run from dynamic link libraries (DLL). There are so many processes for security reasons in order to avoid risks just in case one fails, not to hang the whole system.\r
:::\r
\r
## 1.3.3. Process states\r
\r
The simple process state diagram below shows three main states for a process. They are shown as ready (the process is ready to execute when a processor becomes available), running (the process is currently being executed by a processor) and waiting (the process is waiting for a specific event to occur before it can proceed). The lines connecting the states represent possible transitions from one state to another.\r
\r
At any instant, a process will exist in one of these three states. On a single-processor computer, only one process can be in the running state at any one time. The remaining processes will either be ready or blocked, and for each of these states there will be a queue of processes waiting for some event.\r
\r
![Process states](./../../media/unit1/process_state.png)\r
\r
- **Created**. The process is created from a program and loaded into the system\r
- **Ready**. The process is not running but it is ready to do so. The OS still hasn't assigned a processor to run. and the OS scheduler will be responsible of selecting the process to start running.\r
- **Running**. While a process is executing it has complete control of the processor, but at some point the operating system needs to regain control, such as when it must assign the processor to the next process. Execution of a particular process will be suspended if that process requests an I/O operation, if an interrupt occurs, or if the process times out.\r
- **Waiting**. The process is blocked waiting for an event to happen. For instance it can be waiting for an I/O operation to finish or a synchronization operation with another process. When the event occurs the process goes back to ready state until the OS scheduler decides to move it to running state.\r
- **Terminated**. The process ends its processing and frees its resources and all memory space (PCB). The process is the responsible to do a system call to tell the OS it has finished although the OS can interrupt it forcing its termination by using an exception (special interruption).\r
\r
States transitions:\r
\r
- **Running to waiting**: a process changes from running to waiting when it depends on an external event or operation.\r
- **De Waiting to ready**: a process changes from waiting to ready when the external event or operation it was waiting for occurs.\r
- **Ready to running**: a process changes from ready to running when the OS scheduler gives it CPU time.\r
- **Running to ready**: a process changes from running to ready when the CPU time given by the OS scheduler runs out.\r
\r
## 1.3.4 Process scheduler\r
\r
Process scheduling is a major element in process management, since the efficiency with which processes are assigned to the processor will affect the overall performance of the system. It is essentially a matter of managing queues, with the aim of minimizing delay while making the most effective use of the processor's time. The operating system carries out four types of process scheduling:\r
\r
- Process queue: contains all system processes\r
- Ready queue: contains all processes ready to be run.\r
- Devices queues: contains processes waiting for an IO operation to finish.\r
\r
![Scheduler process queues](./../../media/unit1/process_queues.gif)\r
\r
Scheduler is the one who manages processes movements into the queues.There's a short-term and a long-term scheduling:\r
\r
- The task of the \`short-term scheduler\` (sometimes referred to as the dispatcher) is to determine which process to execute next. This will occur each time the currently running process is halted. A process may cease execution because it requests an I/O operation, or because it times out, or because a hardware interrupt has occurred. The objectives of short-term scheduling are to ensure efficient utilization of the processor and to provide an acceptable response time to users.\r
  - Non-Preemptive Scheduling: a process only changes its state if it has finished or it gets locked.\r
  - Preemptive Scheduling: a process only changes its state if it has finished, it gets locked or a higher priority process is waiting.\r
  - Shared time: every amount of clock cicles (quantum), a process is moved to waiting and a new process changes from ready to running. All processes are considered to have the same priority\r
- The \`long-term scheduler\` determines which programs are admitted to the system for processing, and as such controls the degree of multiprogramming.\r
  - Before accepting a new program, the long-term scheduler must first decide whether the processor is able to cope effectively with another process. The more active processes there are, the smaller the percentage of the processor's time that can be allocated to each process.\r
\r
::: warning Context switch\r
The changeover from one process to the next is called a **context switch**. During a context switch, the processor obviously cannot perform any useful computation, and because of the frequency with which context switches occur, operating systems must minimize the context-switching time in order to reduce system overhead.\r
:::\r
\r
## 1.3.5. Process scheduling algorithms\r
\r
Scheduling algorithms are use to improve system performance and thus user experience.\r
\r
To set objective parameters and be able to compare different scenarios, a CPU scheduling algorithm tries to maximize and minimize the following:\r
\r
- **Waiting time**: Waiting time is an amount of time a process waits in the ready queue or in the waiting queue.\r
- **Turnaround Time**: Turnaround time is the amount of time to execute a specific process. It is the calculation of the total time spent waiting to get into the memory, waiting in the queue, locked for I/O operations and executing on the CPU. The period between the time of process submission to the completion time is the turnaround time.\r
- **CPU utilization**: CPU usage is the main task in which the operating system needs to make sure that CPU remains as busy as possible. It can range from 0 to 100 percent.\r
  \r
> In 1 processor systems\r
> ![1 CPU usage](./../../media/unit1/usage1cpu.gif)\r
<!--$\\frac{\\#\\ instants\\ of\\ time\\ the\\ processor\\ is\\ busy}{time\\ last\\ process\\ ends}$\\ \\ x \\ 100-->\r
>In N processor systems\r
![2 CPU usage](./../../media/unit1/usage2cpu.gif)\r
<!--$\\frac{\\sum_{n=1}^{N}\\#\\ instants\\ of\\ time\\ the\\ processor_n\\ is\\ busy}{instant\\ of\\ time\\ when\\ the\\ last\\ process\\ ends\\ *\\ N}$\\ \\ x\\  100-->\r
\r
- **Throughput**: The number of processes that finish their execution per unit time is known as \`throughput\`. So, when the CPU is busy executing the process, at that time, work is being done, and the work completed per unit time is called throughput.\r
![Throughput](./../../media/unit1/throughput.gif)\r
<!-- $\\frac{\\# \\ of\\ processes}{instant\\ of\\ time\\ when\\ the\\ last\\ process\\ ends}$-->\r
\r
| Process | Arrival | CPU time | Priority |\r
| :-----: | :-----: | :------: | :------: |\r
|   P1    |    0    |    10    |    5     |\r
|   P2    |    1    |    6     |    10    |\r
|   P3    |    2    |    3     |    7     |\r
\r
With this parameters let's compare the scheduling algorithms performance.\r
\r
### FCFS - First Come First Served\r
\r
First Come First Serve is the full form of FCFS. It is the easiest and most simple CPU scheduling algorithm. In this type of algorithm, the process which requests the CPU gets the CPU allocation first. This scheduling method can be managed with a FIFO queue.\r
\r
As the process enters the ready queue, its PCB (Process Control Block) is linked with the tail of the queue. So, when CPU becomes free, it should be assigned to the process at the beginning of the queue.\r
\r
Characteristics of FCFS method:\r
\r
- It offers non-preemptive and pre-emptive scheduling algorithm.\r
- Jobs are always executed on a first-come, first-serve basis\r
- It is easy to implement and use.\r
- However, this method is poor in performance, and the general wait time is quite high.\r
\r
![FCFS monoprocessor](./../../media/unit1/fcfs-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 2     : active,t2, after t1, 6s\r
Process 3     : crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      9       |       15        |             |\r
|   P3    |      14      |       17        |             |\r
|         |\r
|  Mean   |     7,6      |       14        |    100%     |    0,15    |\r
\r
![FCFS dual processor](./../../media/unit1/fcfs-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### SJF - Shortest Job First\r
\r
SJF is a full form of (Shortest job first) is a scheduling algorithm in which the process with the shortest execution time should be selected for execution next. This scheduling method can be preemptive or non-preemptive. It significantly reduces the average waiting time for other processes awaiting execution.\r
\r
Characteristics of SJF Scheduling\r
\r
- It is associated with each job as a unit of time to complete.\r
- In this method, when the CPU is available, the next process or job with the shortest completion time will be executed first.\r
- It is Implemented with non-preemptive policy.\r
- This algorithm method is useful for batch-type processing, where waiting for jobs to complete is not critical.\r
- It improves job output by offering shorter jobs, which should be executed first, which mostly have a shorter turnaround time. There can be situations where longer jobs would never been run, that's called \`starvation\`.\r
\r
![SJF monoprocessor](./../../media/unit1/sjf-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title SJF (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      12      |       18        |             |\r
|   P3    |      8       |       11        |             |\r
|         |\r
|  Mean   |     6,6      |       13        |    100%     |    0,15    |\r
\r
![SJF dual processor](./../../media/unit1/sjf-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### Priority scheduling\r
\r
Priority scheduling is a method of scheduling processes based on priority. In this method, the scheduler selects the tasks to work as per the priority.\r
\r
Priority scheduling also helps OS to involve priority assignments. The processes with higher priority should be carried out first, whereas jobs with equal priorities are carried out on a round-robin or FCFS basis. Priority can be decided based on memory requirements, time requirements, etc.\r
\r
As with SJF, with this algorithm low priority processes are in risk of starvation.\r
\r
![Prioridad monoprocessor](./../../media/unit1/prioridad-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      12      |       18        |             |\r
|   P3    |      8       |       11        |             |\r
|         |\r
|  Mean   |     6,6      |       13        |    100%     |    0,15    |\r
\r
![Prioridad dual processor](./../../media/unit1/prioridad-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### Round Robin\r
\r
Round robin is the oldest, simplest scheduling algorithm. The name of this algorithm comes from the round-robin principle, where each person gets an equal share of something in turn (\`quantum\`). It is mostly used for scheduling algorithms in multitasking. This algorithm method helps for starvation free execution of processes.\r
\r
Characteristics of Round-Robin Scheduling\r
\r
- Round robin is a hybrid model which is clock-driven\r
- Time slice should be minimum, which is assigned for a specific task to be processed. However, it may vary for different processes.\r
- It is a real time system which responds to the event within a specific time limit.\r
\r
We can find two situations with this method:\r
\r
- The process, or its remaining time, is less than the quantum. So, when the process finishes, a new process is run.\r
- The process, or its remaining time, is greater than the quantum. So, when the quantum times out the process is moved to ready and next scheduled process is moved to running.\r
\r
![RR monoprocessor](./../../media/unit1/roundrobin-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 2s\r
Process 2     : active,t2, after t1, 2s\r
Process 3     : crit, t3, after t2, 2s\r
Process 1      :done, t4, after t3, 2s\r
Process 2     : active,t5, after t4, 2s\r
Process 3     : crit, t6, after t5, 1s\r
Process 1      :done, t7, after t6, 2s\r
Process 2     : active,t8, after t7, 2s\r
Process 1      :done, t9, after t8, 2s\r
Process 1      :done, t10, after t9, 2s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      9       |       19        |             |\r
|   P2    |      8       |       14        |             |\r
|   P3    |      6       |        9        |             |\r
|         |\r
|  Mean   |     7,6      |       14        |    100%     |    0,15    |\r
\r
![RR dual processor](./../../media/unit1/roundrobin-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1_1, 0, 2s\r
Process 3     :crit, t3_1, after t1_1, 2s\r
Process 1     :done, t1_2, after t3_1, 2s\r
Process 3     :crit, t3_2, after t1_2, 1s\r
Process 1     :done, t1_3, after t3_2, 2s\r
Process 1     :done, t1_4, after t1_3, 2s\r
Process 1     :done, t1_5, after t1_4, 2s\r
section Processor 2\r
.     :active, ., 0, 0s\r
Process 2     :active, t2_1, 1, 2s\r
Process 2     :active, t2_2, after t2_1, 2s\r
Process 2     :active, t2_3, after t2_2, 2s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      3       |       13        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      2       |        5        |             |\r
|         |\r
|  Mean   |     1,6      |       7,6       |     73%     |    0,23    |\r
\r
::: question Combined scheduling\r
As a matter of fact, not only one scheduling algorithm is used but more than one are combined to improve performance and avoid problems like starvation. We have done so, in Round-Robin we have also used FCFS.\r
\r
Do you dare to plan the previous sample using Round-Robin with priority? Keep in mind that it will work mainly with the quantum and, the priority will be used to select the next process to change from ready to running.\r
:::\r
\r
### Scheduler with I/O operations or locks\r
\r
In previous examples all processes have expend all their time in CPU, the have not made any IO operation nor any interruption, but that behavior is far away from reality. Processes sometimes have to get locked to wait for a user input, read or store information on any storage or simply wait for another process to finish an operation and send to it a data before it can go on (synchronization).\r
\r
As we have already comment, when a process leaves the running state another one can start running and make use of the CPU. Once the process finishes its lock, it can go back to ready state to keep on executing its sentences.\r
\r
The next graph has a two activities specification in which before running their last sentence block, process 1 last IO operation must have finished.\r
\r
![Procesos con E/S](./../../media/unit1/operaciones_es.svg)\r
<!--\r
\`\`\`mermaid\r
graph LR\r
\r
subgraph Process 2\r
    p2_1["run for 2"]--p2_2["E/S for 3"]--p2_3["run for 4"]--p2_5["run for 3"]\r
end\r
subgraph Process 1\r
    p1_1["run for 3"]--p1_2["E/S for 1"]--p1_3["run for 5"]--p1_4["E/S for 2"]--p1_5["run for 4"]\r
    p1_4--p2_5\r
end\r
\`\`\`\r
-->\r
\r
Let's see how this affects the scheduling, guessing both processes arrive at the same time.\r
\r
![RR dual processor](./../../media/unit1/roundrobin-3.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Task 1\r
P1 runs 2 (exits because of q expiration)      :done, t1_1, 0, 2s\r
P1 runs 1 (exits and has to wait 1 for E/S)      :done, t1_2, after t2_1, 1s\r
E/S :crit, es1_1, after t1_2, 1s\r
P1 runs 2 (exits because of q expiration)      :done, t1_3, after es1_1, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_4, after t2_2, 2s\r
P1 runs 2 (exits and has to wait 1 for E/S)      :done, t1_5, after t2_3, 1s\r
E/S :crit, es1_2, after t1_5, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_6, after es1_2, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_7, after t2_4, 2s\r
\r
section Task 2 \r
P2 runs 2 (exits and has to wait 3 for E/S) :active, t2_1, after t1_1, 2s\r
E/S :crit, es2_1, after t2_1, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_2, after t1_3, 2s\r
P2 runs 2 (exits because of q expiration)      :active, t2_3, after t1_4, 2s\r
Locked waiting :crit, es2_2, after t2_3, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_4, after t1_6, 2s\r
P2 runs 2 (ends execution)      :active, t2_5, after t1_7, 1s\r
'''\r
-->\r
`]},{title:"1.1 Processes, programs, threads",headers:[{level:2,title:"1.1.1. Processes and programs",slug:"_1-1-1-processes-and-programs",link:"#_1-1-1-processes-and-programs",children:[]},{level:2,title:"1.1.2. Concurrent programming",slug:"_1-1-2-concurrent-programming",link:"#_1-1-2-concurrent-programming",children:[{level:3,title:"What for?",slug:"what-for",link:"#what-for",children:[]},{level:3,title:"Process communication and synchronization",slug:"process-communication-and-synchronization",link:"#process-communication-and-synchronization",children:[]}]},{level:2,title:"1.1.3. Services and threads",slug:"_1-1-3-services-and-threads",link:"#_1-1-3-services-and-threads",children:[{level:3,title:"Sequential program (Von Neumann architecture)",slug:"sequential-program-von-neumann-architecture",link:"#sequential-program-von-neumann-architecture",children:[]},{level:3,title:"Concurrent program",slug:"concurrent-program",link:"#concurrent-program",children:[]},{level:3,title:"Threads vs processes",slug:"threads-vs-processes",link:"#threads-vs-processes",children:[]}]}],path:"/en/unit1/process.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.1 Processes, programs, threads\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.1. Processes, programs, threads" />\r
\r
# 1.1. Processes, programs, threads\r
\r
[[toc]]\r
\r
## 1.1.1. Processes and programs\r
\r
A program and a process are related terms. A \`program\` is a group of instructions to carry out a specified task with some input data.\r
\r
::: tip Black box\r
Black-box testing is a method of software testing that examines the functionality of an application without peering into its internal structures or workings, just by setting some input data set and checking if the output data set meets the expected one.\r
:::\r
\r
While a \`process\` can be described as an instance of a program running on a computer. A program becomes a process when loaded into memory and thus is an active entity While a program is considered to be a passive one.\r
\r
A process has a high resource requirement, it needs resources like CPU, memory address, I/O during its lifetime. It has its own control block called Process Control Block where relevant information as program counter, registers, stack, *executable code*, state, ... and all it needs to be run by the OS is stored.\r
\r
![Process in memory](./../../media/unit1/proceso_memoria.png)\r
\r
Each process is an independent entity. There exist a many-to-one relationship between process and program, which means one program can be invoked multiple times getting several processes in memory running the same copy of the program.\r
\r
## 1.1.2. Concurrent programming\r
\r
In computer science, concurrency is the ability of different parts or units of a program to be executed out-of-order or at the same time simultaneously.\r
\r
This allows for \`parallel\` execution of the concurrent units, which can significantly improve overall speed of the execution in \`multi-processor and multi-core\` machines.\r
\r
The concept of concurrent computing is frequently confused with the related but distinct concept of parallel computing, although both can be described as *multiple processes executing during the same period of time*.\r
\r
- In parallel computing, execution occurs at the same physical instant: for example, on separate processors of a multi-processor machine, with the goal of speeding up computations.\r
- This parallel computing is impossible on a \`one-core single processor\`, as only one computation can occur at any instant (during any single clock cycle). By contrast, concurrent computing consists of process lifetimes overlapping, but execution need not happen at the same instant. The goal here is to model processes in the outside world that happen concurrently using \`multitask\`.\r
\r
![Concurrency vs parallelism](./../../media/unit1/concurrencia_vs_paralelismo.jpg)\r
\r
::: tip Concurrency\r
By and large, both previously described scenarios are gonna be referred to as **concurrency**.\r
:::\r
\r
### What for?\r
\r
The Real World is Massively Complex\r
\r
- In the natural world, many complex, interrelated events are happening at the same time, yet within a temporal sequence.\r
- Compared to serial computing, parallel computing is much better suited for modeling, simulating and understanding complex, real world phenomena.\r
\r
Imagine modeling these serially: climate change, rush hour traffic, weather forecast, galaxy formation, ...\r
\r
Main Reasons for Using Parallel Programming\r
\r
- Save time and money. In theory, throwing more resources at a task will shorten its time to completion, with potential cost savings.\r
  - Parallel computers can be built from cheap, commodity components.\r
- Solve larger and more complex problems.  Many problems are so large and/or complex that it is impractical or impossible to solve them using a serial program, especially given limited computer memory.\r
  - *Grand Challenge Problems* (en.wikipedia.org/wiki/Grand_Challenge) requiring petaflops and petabytes of computing resources.\r
  - Web search engines/databases processing millions of transactions every second\r
- Take advantage of non-local resources. Using compute resources on a wide area network, or even the Internet when local compute resources are scarce or insufficient.\r
  - *SETI@home* (setiathome.berkeley.edu) has over 1.7 million users in nearly every country in the world. (May, 2018).\r
- Make better use of underlying parallel hardware. Modern computers, even laptops, are parallel in architecture with multiple processors/cores.\r
  - Parallel software is specifically intended for parallel hardware with multiple cores, threads, etc.\r
  - In most cases, serial programs run on modern computers "waste" potential computing power.\r
- Increase security. Each task can be isolated in a different process, so debug and check the security, even finishing it when it's not working properly, can be done without hanging the whole system.\r
\r
Historically, parallel computing has been considered to be "the high end of computing", and has been used to model difficult problems in many areas of science and engineering.\r
Today, commercial applications provide an equal or greater driving force in the development of faster computers. These applications require the processing of large amounts of data in sophisticated ways. For example:\r
\r
New hardware environments can be classified in terms of:\r
\r
- Microprocessor with many cores sharing system memory.\r
- Multiprocessor systems with shared memory\r
- Distributed systems and cloud services.\r
\r
### Process communication and synchronization\r
\r
The concurrent running of many processes may suppose the collaboration of some of them in order to complete a common task, while they can also be competing for system resources.\r
\r
In both cases it is compulsory to add communication and synchronization techniques for the processes.\r
\r
:::info Concurrent programming\r
Concurrent programming and PSP is just about that, the knowledge of these **communication and synchronization techniques**.\r
:::\r
\r
When thinking about the way a process can communicate with each other, there are two main options:\r
\r
- Message passing: It's commonly used when processes are running on different devices. They exchange information following a protocol previously set and agreed by the parts.\r
- Shared resources / memory: It's only available when both processes are running on the same device and allows process synchronization based on a shared resource value or state.\r
\r
We can also classify the communication by the synchronization the processes use during the message passing process:\r
\r
- Synchronous communication happens when messages can only be exchanged in real time. It requires that the transmitter and receiver are present in the same time and/or space. Sender is blocked until receiver gets the message. Both processes are synchronized at the reception time.\r
  - Examples of synchronous communication are phone calls or video meetings.\r
- Asynchronous communication happens when information can be exchanged independent of time. It doesnt require the recipients immediate attention, allowing them to respond to the message at their convenience. Sender continues with it processing just after delivering the message to the receiver, not being blocked.\r
  - Examples of asynchronous communication are emails, online forums, and collaborative documents.\r
\r
## 1.1.3. Services and threads\r
\r
A program, as previously said, is a group of sentences (actions and checks) and a running workflow. The workflow line determines the execution order for the sentences, with dependency of the program structure and it's data.\r
\r
Based on the number of workflow lines a program can have, processes are classified in terms of::\r
\r
- Sequential: The have only one control workflow (monothread)\r
- Concurrent: They have multiple control workflows (multithread).\r
\r
### Sequential program (Von Neumann architecture)\r
\r
The classical Von Neumann model of computation4 is a familiar model of sequential behavior. According to this, when we start learning to code we learn the classical way, following Von Neummann's conceptual model.\r
\r
Sequential programs have a single workflow line. instructions on these applications are strictly sorted as a lineal time sequence.\r
\r
The program's behavior is a function of the kind of instructions it is made of and the order they are run (set by its input data)\r
\r
In sequential programs the time every sentence takes to complete has no consequences on the final result.\r
\r
![Sequential flowchart example](./../../media/unit1/sequential_flowchart.png)\r
\r
The way to test a sequential program (\`verify\` or \`debug\`) is so easy:\r
\r
- Every sentence gives the right output.\r
- The sentences are executed in the expected order.\r
\r
That's the basis of many basic test methods, as the "white-box" model.\r
\r
### Concurrent program\r
\r
In concurrent programs there are many workflow lines. The sentences are not run following the same order as in a sequential program the would do.\r
\r
In concurrent programs sequential order between sentences is still relevant. Nevertheless, in concurrent programs the order is only partial while in sequential programs the order is strict.\r
\r
![Concurrent flowchart example](./../../media/unit1/concurrent_flowchart.png)\r
\r
In concurrent programs the *sequencing* for concurrent processes is called **synchronization**.\r
\r
The partial order implies that concurrent programs does not have to be deterministic, that is, the application results with the same input data will not always be equal.\r
\r
::: danger Indeterminism\r
Having different outputs for the same inputs does not means that a concurrent program has any bug or malfunction.\r
:::\r
\r
Look at the following pseudo code example\r
\r
\`\`\`java {16-17,25-28}\r
public class TestClass {\r
    int x;\r
\r
    public void testMethod1() {\r
        for (int i=1; i <= 5; i++) {\r
            x++;\r
        }\r
    }\r
    public void testMethod2() {\r
        for (int j=1; j <= 5; j++) {\r
            x++;\r
        }\r
    }\r
    public void sequential() {\r
        x = 0;\r
        testMethod1();\r
        testMethod2();\r
        System.out.println(x);\r
    }\r
    public void parallel() {\r
        x = 0;\r
        // cobegin-coend means that both methods are run simultaneously\r
        // These sentences doesn't exist in Java. They are used for \r
        // sample purposes\r
        cobegin\r
            testMethod1();\r
            testMethod2();\r
        coend\r
        System.out.println(x);\r
    }\r
}\r
\`\`\`\r
\r
::: question\r
Which is the value for variable x after sequential method is run?\r
\r
Which is the value for variable x after parallel method is run?\r
:::\r
\r
::: info Historical review\r
The nature and models of interaction between processes of a concurrent program were studied and described by  **Dijkstra** (1968), Brinch **Hansen** (1973) and **Hoare** (1974).\r
\r
The academic study of concurrent algorithms started in the 1960s and they are the foundation for multiprocess operating systems in the 70's and 80's.\r
:::\r
\r
Concurrent programs inherent indeterminism makes its analysis and validation more complex. However, to test a concurrent program (\`verify\` or \`debug\`) the same techniques as for sequential ones are needed, adding these new ones:\r
\r
- Sentences can be validated individually only if the are not engaged to shared variables.\r
- If shared variables are used there can be many interference effects for concurrent sentences and testing can also become very difficult. <Badge type="danger" text="warning" vertical="middle" />\r
- Only when sequencing between tasks is made by using explicit **synchronization** sentences, time is not relevant on the result.\r
\r
::: warning Important\r
Three previous topics described above are the basis of concurrent programming.\r
\r
:eye: To know them, to understand them and to apply them in the right way is all about what we are gonna learn all this course.\r
:::\r
\r
### Threads vs processes\r
\r
A thread is the unit of execution within a process. A thread is just one of the workflow lines a concurrent process can have. A process is a heavyweight running unit.\r
\r
 A process can have anywhere from just one thread (the main thread) to many threads. If a process has more than one thread, every thread is a lightweight running unit.\r
\r
| Processes                        | Threads                                 |\r
| :------------------------------- | :-------------------------------------- |\r
| Have more than one thread        | A thread always exists within a process |\r
| They are independent from others | They share the process resources        |\r
| The OS manages them              | The process manages them                |\r
| they can communicate on the OS  | The process manages their communication |\r
\r
![Threads vs Processes](./../../media/unit1/threads_vs_process.jpg)\r
\r
In the above image you can see the relationship in the way a thread is created and its related process.\r
\r
- The process resides in its memory address space. Threads share that memory area. In the process's address space every thread has its reserved area, but all of them can share the process's global memory and his open resources (files, sockets, etc.)..\r
- We have already described a process PCD with the process information..\r
- In a similar way, have their TCB (Thread Control Block) where the threads store their specific information (program counter, stack pointer, thread status, registers and a PCB pointer).\r
\r
::: info Services\r
A service is a process commonly started during OS boot. As it does not need user interaction services are run as **daemons** run in *background mode*.\r
\r
They are called services because once started they are waiting for a process to ask them to do a task.  As they have to manage request from several processes they usually are multithread programs.\r
:::\r
`]},{title:"2.4 Annex I - System properties and console programming",headers:[{level:2,title:"I.1 System properties and command shells",slug:"i-1-system-properties-and-command-shells",link:"#i-1-system-properties-and-command-shells",children:[]},{level:2,title:"I.2 Console I/O format",slug:"i-2-console-i-o-format",link:"#i-2-console-i-o-format",children:[{level:3,title:"Console output",slug:"console-output",link:"#console-output",children:[]},{level:3,title:"Console input",slug:"console-input",link:"#console-input",children:[]},{level:3,title:"String format",slug:"string-format",link:"#string-format",children:[]},{level:3,title:"Number format",slug:"number-format",link:"#number-format",children:[]},{level:3,title:"Colours in console applications",slug:"colours-in-console-applications",link:"#colours-in-console-applications",children:[]}]}],path:"/en/unit2/console_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.4 Annex I - System properties and console programming\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.4 Annex I - System properties and console programming" />\r
\r
# 2.4 Annex I - System properties and console programming\r
\r
[[toc]]\r
\r
## I.1 System properties and command shells\r
\r
If we plan to code platform independent applications, we have to deal with many issues because of differences between OS. So sometimes we need to deal with specific OS information. A useful way to get that information is by getting System properties.\r
\r
[Specification System.getProperties](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#getProperties())\r
\r
Some examples are provided here using System properties. Similar solutions can be used for other issues.\r
\r
::: danger File separator\r
For file path or directory separator, the Unix system introduced the slash character / as directory separator, and the Microsoft Windows introduced backslash character \\ as the directory separator. In a nutshell, this is / on UNIX and \\ on Windows.\r
\r
Then, how can we code OS independent applications??\r
\r
In Java, we can use the following three methods to get the platform-independent file path separator.\r
\r
- System.getProperty("file.separator")\r
- FileSystems.getDefault().getSeparator() (Java NIO)\r
- File.separator Java IO\r
\r
From now on, we are gonna use System properties in our applications for several situations using \`System.getProperty(String propName)\`. These properties are configured by the OS and the JVM, though we can modify them by setting the JVM running setting\r
\r
> String separator = System.getProperty("file.separator");\r
\r
or\r
\r
> -Dfile.separator\r
\r
Nevertheless is always a good practice to use slash character **/** in paths as Java is able to convert them to the system it is running on.\r
:::\r
\r
If we want to run an OS command we have to do it as we usually do, by using the command shell, where once again we find the troubleshot with UNIX / Windows.\r
\r
Let's take a look at the way we can use the system properties, once again, to get a list of files in the user personal folder.\r
\r
\`\`\`java\r
// First we get the user folder path\r
String homeDirectory = System.getProperty("user.home");\r
// And then we set which OS are we running on\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info non-interactive shell mode\r
In the previous code example, both for Windows and UNIX modifier **c** is used for command shells. This modifier tells the system to open a command shell, to run the companion command and close the shell after it has finished.\r
:::\r
\r
Next you can look at a handler event manager for a mouse clic, into a graphic application, to open a web site in a browser. The code shows how to do it in  *X like operating system and one way to do it in Windows systems is commented.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Our first applications in java is not gonna be an easy one.\r
\r
Using methods from System class and Runtime class, write the code for an app that shows\r
\r
- all the system properties configured in your OS\r
- total memory, free memory, used memory and processors available\r
\r
Make a research into Runtime class methods. For System properties try to get a list or iterable data estructure to show each of the system properties and their values.\r
:::\r
\r
::: details Proposed solution to previous activity\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
## I.2 Console I/O format\r
\r
::: warning Character codification\r
One aspect to take into account when working with streams is the encoding of the information exchanged between processes, which depends on the operating system we are working on. Most systems (GNU/Linux, Mac OS, Android, iOS...) use UTF-8 encoding, based on the Unicode standard. \r
\r
For its part, MS Windows uses its own formats, incompatible with the rest, such as Windows-1252. So to correctly handle data in Java when using more advanced inter-process communication mechanisms, it will be necessary to take into account the type of encoding that the system itself uses.\r
\r
\`\`\`java\r
// Getting the default encoding\r
System.out.println(System.getProperty("file.encoding"));\r
// Setting the encoding\r
System.setProperty("file.encoding", "UTF-8");\r
\r
// Reading with a specific encoding\r
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));\r
// Writing with a specific encoding\r
PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out, "UTF-8"));\r
\r
// Stdin with a specific encoding\r
Scanner scanner = new Scanner(System.in, "UTF-8");\r
// Stdout with a specific encoding\r
System.out.println(new String("Hello, World!".getBytes("UTF-8")));\r
\`\`\`\r
\r
:::\r
\r
### Console output\r
\r
In Java, we can use the \`System.out\` object to print to the console. We can use the \`println\` method to print a line to the console.\r
\r
\`\`\`java:no-line-numbers\r
System.out.println("Hello, World!");\r
\`\`\`\r
\r
### Console input\r
\r
In Java, we can use the \`System.in\` object to read from the console. We can use the \`Scanner\` class to read from the console.\r
\r
\`\`\`java:no-line-numbers\r
Scanner scanner = new Scanner(System.in);\r
String name = scanner.nextLine();\r
\`\`\`\r
\r
### String format\r
\r
In Java, we can use the \`String\` class to format the output. We can use the \`format\` method to format the output. This method is similar to the \`printf\` method in C.\r
\r
\`\`\`java:no-line-numbers\r
String.format("The value of PI is %.2f", Math.PI);\r
\`\`\`\r
\r
### Number format\r
\r
In any programming language we have many different ways to format the information shown to the user. As in this first applications we are using the console as the system output, let's check the two main techniques we can use in Java\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Using NumberFormat class or any of its descendants we can get control on how the numbers are shown with high precision, using numeric patterns.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Hashes can be used instead of zeros to allow .30 to be shown as 0.3\r
// (additional digits are optional)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Similar to C's printf syntax, we can use the java.util.Formatter syntax to set how data is visualized.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// numbers after % print preceding spaces to fill \r
// and justify numbers.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
### Colours in console applications\r
\r
There is a way to print in different colours when using the console. Here you have got an example code with some colours and the way to use it.\r
\r
\`\`\`java:no-line-numbers\r
public class UsingColoursInConsole {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hello" \r
                          + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Bye bye" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
`]},{title:"2.5 Annex II - Curl",headers:[{level:2,title:"II.1 Get curl",slug:"ii-1-get-curl",link:"#ii-1-get-curl",children:[]},{level:2,title:"II.2 Calling a GET method",slug:"ii-2-calling-a-get-method",link:"#ii-2-calling-a-get-method",children:[]},{level:2,title:"II.3 Endpoints and routes",slug:"ii-3-endpoints-and-routes",link:"#ii-3-endpoints-and-routes",children:[]},{level:2,title:"II.4 HTTP methods and headers",slug:"ii-4-http-methods-and-headers",link:"#ii-4-http-methods-and-headers",children:[]},{level:2,title:"II.5 Authentication",slug:"ii-5-authentication",link:"#ii-5-authentication",children:[]},{level:2,title:"II.6 References",slug:"ii-6-references",link:"#ii-6-references",children:[]}],path:"/en/unit2/curl_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.5 Annex II - Curl\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.5 Annex II - Curl" />\r
\r
# 2.5 Annex II - Curl\r
\r
[[toc]]\r
\r
Whether its testing the output of a REST API on development or before deploying it to production, simply fetching a response from a website (for instance, to check its not down), or getting response times from a site / API Curl is practically omnipresent.\r
\r
Curl is a command-line tool that allows us to do HTTP requests from shell. This is its main use.\r
\r
::: info\r
The tool was about uploading and downloading data specified with a URL. It was a client-side program (the 'c'), a URL client, and would show the data (by default). So 'c' for Client and URL: cURL.\r
\r
Most of us pronounce "curl" with an initial k sound, just like the English word curl. It rhymes with words like girl.\r
\r
But it can also be spelled as c-URL which means see-URL, that is also a good definition about what the tool does.\r
:::\r
\r
Curl supports protocols that allow "data transfers" in either or both directions. It supports protocols which have a "URI format" and are described in an RFC, as curl works primarily with URLs (URIs really) as the input key that specifies the transfer.\r
\r
Curl actually supports these protocols:\r
\r
>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP.\r
\r
## II.1 Get curl\r
\r
curl is totally free, open and available. There are numerous ways to get it and install it for most operating systems and architecture. Some operating systems include curl by default.\r
\r
You can always download the source from [CURL official site](http://curl.se) or find binary packages to download from there.\r
\r
- Linux (Ubuntu / Debian). curl is installed by default. Anyway, you can add with the APT package manager\r
  > apt install curl\r
- Windows 10 comes with the curl tool bundled with the operating system since version 1804\r
    > download the latest official curl release for Windows from [curl windows binaries](http://curl.se/windows) and install that.\r
- MacOS comes with the curl tool bundled with the operating system since many years. If you want to upgrade to the latest version shipped by the curl project, we recommend installing homebrew (a macOS software package manager)\r
    > brew install curl\r
\r
## II.2 Calling a GET method\r
\r
In its most basic form, a curl command will look like this:\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl http://www.net.net\r
<head><title>Document Moved</title></head>\r
<body><h1>Object Moved</h1>This document may be found <a HREF="http://net.net">here</a></body>\r
\r
\`\`\`\r
\r
The default behavior for curl is to invoke an HTTP GET method on the given URL. This way, the programs output for that command will be the whole HTTP responses body (in this case, HTML which will be written as given on stdout.\r
\r
Many times well wish to direct the responses contents into a file. This is done with the \`-o (--output)\` argument, like this:\r
\r
> curl -o output.html www.net.net\r
> \r
> // Equivalent to \r
> \r
> curl www.net.net > output.html \r
\r
The URL must be in the last place, but optionally, you can specify the URL of the site you wish to call curl on with a \`-s (--silent) \`argument , allowing you to change the order of your arguments.\r
\r
curl -s http://www.net.net -o output.html\r
\r
In the previous example we are not getting the desired resource, because it has been moved or redirected to another URI. Using the \`-L (--location)\` mode, we can follow redirects and get the destination resource\r
\r
\`\`\`bash:no-line-numbers{1,3,5}\r
$> curl http://www.dataden.tech\r
Redirecting\r
$> curl -L http://www.dataden.tech\r
<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.dataden.tech/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTYzMzM4OTE3OSwiaWF0IjoxNjMzMzgxOTc5LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIycWxmMGdkZmg2YWlzaHMxdjgwdWx0aTQiLCJuYmYiOjE2MzMzODE5NzksInRzIjoxNjMzMzgxOTc5NzgzNzQ1fQ.y5LwDoSoZCpe2tzro_FbX7cSGIw4nx1XweNBqjpLXoo&sid=da601018-2557-11ec-a001-58f389072b17');<\/script></body></html>\r
$> curl -L http://www.net.net\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        <body>\r
                <!-- Begin: Google Analytics -->\r
                <script>\r
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r
                  ga('create', 'UA-32196-28', 'auto');\r
                  ga('send', 'pageview');\r
                <\/script>\r
                <!-- End: Google Analytics -->\r
                <center>\r
                        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\r
                        <font face="impact, Arial, Helvetica, sans-serif" size="14">\r
                                NET.NET\r
                        </font>\r
                        <br /><br /><br /><br />\r
                        <font face="Arial, Helvetica, sans-serif" size="1">\r
                                <a href="http://who.godaddy.com/whoischeck.aspx?domain=NET.NET" target="_blank">NET.NET</a> is the first and the best domain name on the Internet!\r
                                <br />\r
                                Coming Soon...\r
                        </font>\r
                </center>\r
        </body>\r
</html>\r
\`\`\`\r
\r
So far we have only get the html page. If we want to see also the headers of our GET request and response headers, we have to user the \`-v (--verbose)\` option  to get full information about the HTTP protocol.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl -v  http://www.net.net\r
*   Trying 34.250.90.28:80...\r
* TCP_NODELAY set\r
* Connected to net.net (34.250.90.28) port 80 (#0)\r
> GET / HTTP/1.1\r
> Host: net.net\r
> User-Agent: curl/7.68.0\r
> Accept: */*\r
>\r
* Mark bundle as not supporting multiuse\r
< HTTP/1.1 200 OK\r
< Cache-Control: private\r
< Content-Type: text/html\r
< Server: Microsoft-IIS/10.0\r
< Set-Cookie: ASPSESSIONIDASRSRRAR=IMFFLMBBBIFJNLNDHLOACDAI; path=/\r
< X-Powered-By: ASP.NET\r
< Date: Mon, 04 Oct 2021 21:40:49 GMT\r
< Content-Length: 1080\r
<\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        ...\r
\`\`\`\r
\r
In the previous output requests header are marked with \`>\` while response header are marked with \`<\`.\r
\r
::: info short and long command line options\r
Command line options pass on information to curl about how you want it to behave.\r
\r
Single-letter options are convenient since they are quick to write and use, but as there are a limited number of letters and not all options are available like that.\r
Long option names are therefore provided for those. Also, as a convenience and to allow scripts to become more readable, most short options have longer name aliases.\r
\r
Short options are preceded by the minus symbol and a single letter immediately following it. They can be used with just that option name. You can then also combine several single-letter options after the minus.\r
\r
> $> curl -v -L http://example.com\r
> $> curl -vL http://example.com\r
\r
Long options are always written with two dashes and then the name, and you can only write one option name per double-dash.\r
\r
> $> curl --verbose --location http://example.com\r
\r
:::\r
\r
Finally, we can access partially the verbose mode information using the \`-i (--include)\` or \`-I (--head)\` to get the complete answer from the server (headers & data) or just the headers, respectively.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$>  curl -I https://jsonplaceholder.typicode.com/todos/1\r
HTTP/2 200\r
date: Mon, 04 Oct 2021 21:57:55 GMT\r
content-type: application/json; charset=utf-8\r
content-length: 83\r
x-powered-by: Express\r
x-ratelimit-limit: 1000\r
x-ratelimit-remaining: 999\r
x-ratelimit-reset: 1631546224\r
vary: Origin, Accept-Encoding\r
access-control-allow-credentials: true\r
cache-control: max-age=43200\r
pragma: no-cache\r
expires: -1\r
x-content-type-options: nosniff\r
etag: W/"53-hfEnumeNh6YirfjyjaujcOPPT+s"\r
via: 1.1 vegur\r
cf-cache-status: HIT\r
age: 10926\r
accept-ranges: bytes\r
expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"\r
report-to: {"endpoints":[{"url":"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=LxJlkSosQdWmBFBOx1fB6zrbjSbU0iStl7jjtlVL27CtOEPxem%2Ffl9y%2BCajMUopcZINOEsaufiU8A2glOLEmNpO5a40%2FyWb%2B4dBuspS8VGWnCRW4jxBBmh%2F3FbupAEaxy66TUPariKJLqe3PL5iq"}],"group":"cf-nel","max_age":604800}\r
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}\r
server: cloudflare\r
cf-ray: 6991ab2c1a5037c7-MAD\r
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400\r
\`\`\`\r
\r
Finally, adding the \`-w "%{time_total}\\n"\` will simply output the total time it took to fetch the response from the given domain.\r
\r
## II.3 Endpoints and routes\r
\r
The term endpoint is focused on the URL that is used to make a request.\r
\r
For a typical web API, endpoints are URLs, and they are described in the API's documentation so programmers know how to use/consume them. For example, a particular web API may have this endpoint:\r
\r
> GET https://my-api.com/Library/Books\r
\r
This would return a list of all books in the library.\r
\r
A "route" is typically a part of URL endpoint that routes the pages to different components.\r
\r
> GET https://my-api.com/Library/Books/341 \r
\r
This would access book with id 341 using the Library/Books endpoint\r
\r
For instance, for [SWAPI (Star Wars API)](https://swapi.dev/) the endpoint is \`https://swapi.dev/api/\`. That's the entry point for all requests.\r
\r
Thus there are many routes depending on the information we want to access/add/modify/delete.\r
\r
\`\`\`java:no-line-numbers\r
$> curl https://swapi.dev/api/people/1\r
$> curl https://swapi.dev/api/planet/3\r
$> curl https://swapi.dev/api/vehicles\r
\`\`\`\r
\r
## II.4 HTTP methods and headers\r
\r
In every HTTP request, there's a method. Sometimes called a verb. The most commonly used ones are GET, POST, HEAD and PUT.\r
\r
POST is the HTTP method that was invented to send data to a receiving web application, and it is how most common HTML forms on the web works.\r
\r
When the data is sent by a browser it will send it URL encoded, as a serialized name=value pairs separated with ampersand symbols (&).\r
\r
You send such data with curl's \`-d (--data)\` option like this:\r
\r
> curl -d 'name=admin&shoesize=12' http://example.com/\r
\r
Curl selects which methods to use on its own depending on what action to ask for. -d will do POST, -I will do HEAD and so on. If you use the \`-X (--request)\` option you can change the method keyword curl selects.\r
\r
> curl -X POST -d 'imageSize=big&imageType=jpg' http://example.org/\r
\r
POSTing with curl's -d option will make it include a default header that looks like \`Content-Type: application/x-www-form-urlencoded\`. That's what your typical browser will use for a plain POST.\r
\r
If that header is not good enough for you, you should, of course, replace that and instead provide the correct one. Such as if you POST JSON to a server and want to more accurately tell the server about what the content is:\r
\r
> curl -X "POST" -d '{"imageSize":"big","imageType":"jpg","scale":"false"}' -H 'Content-Type: application/json' https://example.com\r
\r
## II.5 Authentication\r
\r
Each HTTP request can be made authenticated. If a server or a proxy wants the user to provide proof that they have the correct credentials to access a URL or perform an action, it can send back a HTTP response code that informs the client that it needs to provide a correct HTTP authentication header in the request to be allowed.\r
\r
To tell curl to do an authenticated HTTP request, you use the \`-u (--user)\` option to provide user name and password (separated with a colon). Like this:\r
\r
> curl --user daniel:secret http://example.com/\r
\r
This will make curl use the default "Basic" HTTP authentication method.\r
\r
Many applications and services make use of a secret key or an Authorization token provided by the service provider when you create the service.\r
\r
[Trello API Introduction](https://developer.atlassian.com/cloud/trello/guides/rest-api/api-introduction/)\r
\r
[Azure Translator API Reference](https://docs.microsoft.com/es-es/azure/cognitive-services/translator/reference/v3-0-translate)\r
\r
If we want to use the Azure service for translate text, first we need to obtain the secret key and send it with each call to identify the user and get the permission to use the service.\r
\r
\`\`\`java:no-line-numbers\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Ocp-Apim-Subscription-Key: <here goes your susbcription key>" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
Sometimes we can get a temporal authorization by getting an Authorization token, that later must be provided to access the service during a short period of time. Once the time expires, another token must be requested.\r
The \`Authorization: Bearer <token>\` header is used.\r
\r
\`\`\`java:no-line-numbers{1,3,5}\r
$> curl -X POST "https://api.cognitive.microsoft.com/sts/v1.0/issueToken" -H "Ocp-Apim-Subscription-Key: <here goes the secret key>" -d {}\r
eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzMwMTUxNywiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.0hyyBNr22E2sIO_ZBlTiBePXM_KE_5hQOCeHxz3US44" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
{"error":{"code":401000,"message":"The request is not authorized because credentials are missing or invalid."}}\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
## II.6 References\r
\r
[Everything curl](https://everything.curl.dev/) is a detailed and totally free book available that explains basically everything there is to know about curl.\r
\r
[freecodecamp.org](https://www.freecodecamp.org/news/how-to-start-using-curl-and-why-a-hands-on-introduction-ea1c913caaaa/)\r
\r
[curl official site](https://curl.se/)\r
`]},{title:"2 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit2/",pathLocale:"/en/",extraFields:[`---\r
title: 2 Introduction\r
---\r
\r
# Unit 2. Process programming\r
\r
Once we know about key concepts in concurrency, we can also differentiate programs and processes. In this second unit we will learn how we can launch a program from our own code, that is, how to create a process from a running process.\r
\r
In addition to launch programs and create new processes, there's a relationship between the parent process and its children that allow them to communicate exchanging information. This is the way our programs will be able to launch other applications, os command or even applications developed by us. Furthermore, parent-child processes allow synchronization and communication among them.\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know Java classes for process management\r
- To monitor and control process lifecycle\r
- To control parent-child communications\r
- To use synchronization methods for processes and sub-processes\r
- To learn how pipes communications works\r
- To learn curl syntax and use it for API REST testing purposes\r
- To create applications that run parallel tasks\r
`]},{title:"2.3 Handling Process Streams",headers:[{level:2,title:"2.3.1  Redirecting Standard Input and Output",slug:"_2-3-1-redirecting-standard-input-and-output",link:"#_2-3-1-redirecting-standard-input-and-output",children:[{level:3,title:"getInputStream()",slug:"getinputstream",link:"#getinputstream",children:[]},{level:3,title:"getErrorStream()",slug:"geterrorstream",link:"#geterrorstream",children:[]},{level:3,title:"getOutputStream()",slug:"getoutputstream",link:"#getoutputstream",children:[]},{level:3,title:"Inheriting the I/O of the parent process",slug:"inheriting-the-i-o-of-the-parent-process",link:"#inheriting-the-i-o-of-the-parent-process",children:[]}]},{level:2,title:"2.3.2 Redirecting Standard Input and Output",slug:"_2-3-2-redirecting-standard-input-and-output",link:"#_2-3-2-redirecting-standard-input-and-output",children:[]}],path:"/en/unit2/iostreams.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.3 Handling Process Streams\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.3 Handling Process Streams" />\r
\r
# 2.3 Handling Process Streams\r
\r
[[toc]]\r
\r
## 2.3.1  Redirecting Standard Input and Output\r
\r
By default, the created subprocess does not have its terminal or console. All its standard I/O (i.e., stdin, stdout, stderr) operations will be sent to the parent process. Thereby the parent process can use these streams to feed input to and get output from the subprocess.\r
\r
Consequently, this gives us a huge amount of flexibility as it gives us control over the input/output of our sub-process.\r
\r
In a parent-child process relationship I/O streams are also redirected from child process to parent, using 3 pipes, one per each standard stream. Those pipes  can be used like in a Linux system.\r
\r
<!--![alt_text](./../../media/unit2/pipe_with_two.jpg)-->\r
![alt_text](./../../media/unit2/ProcessIO.png)\r
\r
### getInputStream()\r
\r
We can fetch the output generated by a subprocess and consume within the parent process thus allowing share information between the processes\r
\r
\`\`\`java\r
Process p = pbuilder.start();\r
BufferedReader processOutput = \r
    new BufferedReader(new InputStreamReader(p.getInputStream()));\r
\r
String linea;    \r
while ((linea = processOutput.readLine()) != null) {\r
    System.out.println("> " + linea);        \r
}            \r
processOutput.close();    \r
\`\`\`\r
\r
![alt_text](./../../media/unit2/Java_Stream_Readers_BufferedReaders.jpg)\r
\r
::: warning Charset and encodings\r
From the time being computer science started we've been in trouble with encodings and charsets. And windows console is not an exception.\r
\r
Terminal in Windows was also known as "DOS prompt": so a way to run DOS programs in Windows, so they keep the code page of DOS. Microsoft dislikes non-backward compatible changes, so your DOS program should works also on Windows terminal without problem.\r
\r
Wikipedia indicates that **CP850** has theoretically been "largely replaced" by **Windows-1252** and, later, Unicode, but yet it's here, right in the OS's terminal.\r
\r
Then, if we want to print information from the console in our applications we must deal with the right charset and encoding, that is, CP-850.\r
\r
Fortunately, InputStreamReader has a constructor to manage streams with any encoding, so we must use it when working with console commands or applications.\r
\r
\`\`\`java:no-line-numbers\r
new InputStreamReader(p.getInputStream(), "CP850");\r
\`\`\`\r
\r
> We can force Netbeans to use a UTF-8 as default encoding. To do so we must modify its config file \`C:/Program Files/Netbeans-xx.x/netbeans/etc/netbeans.conf\`, changing directive \`netbeans_default_option\` and adding **-J-Dfile.encoding=UTF-8** to the end.\r
\r
:::\r
\r
### getErrorStream()\r
\r
Interestingly we can also fetch the errors generated from the subprocess and thereon perform some processing.\r
\r
if error output has been redirected by calling method  \`ProcessBuilder.redirectErrorStream(true)\` then, the error stream and the output stream will be shown using the same stream.\r
\r
If we want to have it differentiated from the output, then we can use asimilar schema than before\r
\r
\`\`\`java\r
Process p = pbuilder.start();\r
BufferedReader processError = \r
    new BufferedReader(new InputStreamReader(p.getErrorStream()));\r
int value = Integer.parseInt(processError.readLine());\r
processError.close();\r
\`\`\`\r
\r
::: info Decorator or Wrapper design pattern\r
In both input and error streams we are getting information from a BufferedReader. Although we are not aware of using a design pattern, we are using the **decorator design pattern"* or the so called **wrapper**.\r
\r
> Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the required behaviors.\r
\r
[Refactoring.Guru design patterns](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
Let's look at a complete example code using all the above operations\r
\r
\`\`\`java\r
import java.io.*;\r
public class Ejercicio2 {\r
    public static void main(String[] args) {\r
        String comando = "notepad";\r
        ProcessBuilder pbuilder = new ProcessBuilder (comando);\r
        Process p = null;\r
        try {\r
            p = pbuilder.start();\r
            // 1- Procedemos a leer lo que devuelve el proceso hijo\r
            InputStream is = p.getInputStream();\r
            // 2- Lo convertimos en un InputStreamReader\r
            // De esta forma podemos leer caracteres en vez de bytes\r
            // El InputStreamReader nos permite gestionar diferentes codificaciones\r
            InputStreamReader isr = new InputStreamReader(is);\r
            // 2- Para mejorar el rendimiento hacemos un wrapper sobre un BufferedReader\r
            // De esta forma podemos leer enteros, cadenas o incluso lneas.\r
            BufferedReader br = new BufferedReader(isr);\r
\r
            // A Continuacin leemos todo como una cadena, lnea a lnea\r
            String linea;\r
            while ((linea = br.readLine()) != null) \r
                System.out.println(linea);\r
        } catch (Exception e) {\r
            System.out.println("Error en: "+comando);\r
            e.printStackTrace();\r
        } finally {\r
            // Para finalizar, cerramos los recursos abiertos\r
            br.close();\r
            isr.close();\r
            is.close();\r
        }    \r
    }\r
}\r
\`\`\`\r
\r
### getOutputStream()\r
\r
We can even send input to a subprocess from a parent process\r
\r
There are three different ways of sending information to a child process. The first one is based on an OutputStream. Here no wrapper is used and the programmer has to manage all elements of the stream flow. From newline characters and type conversions to force sending information over the stream.\r
\r
\`\`\`java\r
// Low-level objects. We have to manage all elements of communication\r
OutputStream toProcess = p.getOutputStream();\r
toProcess.write((String.valueOf(number1)).getBytes("UTF-8"));\r
toProcess.write("\\n".getBytes());\r
toProcess.flush();\r
\`\`\`\r
\r
The next one is based on a Writer object as a wrapper for the OutputStream, where communication management is easier, but the programmer still has to manage elements as new lines.\r
\r
\`\`\`java\r
Writer w = new OutputStreamWriter(p.getOutputStream(), "UTF-8");\r
w.write("send to child\\n");\r
\`\`\`\r
\r
Finally, the top-level wrapper for using the OutputStream is the PrintWriter object, where we can use the wrapper with the same methods as the System.out to handle child communication flow.\r
\r
\`\`\`java\r
PrintWriter toProcess = new PrintWriter(\r
    new BufferedWriter(\r
        new OutputStreamWriter(\r
            p.getOutputStream(), "UTF-8")), true);\r
toProcess.println("sent to child");\r
\`\`\`\r
\r
### Inheriting the I/O of the parent process\r
\r
With the inheritIO() method We can redirect the sub-process I/O to the standard I/O of the current process (parent process)\r
\r
\`\`\`java\r
ProcessBuilder processBuilder = new ProcessBuilder("/bin/sh", "-c", "echo hello");\r
\r
processBuilder.inheritIO();\r
Process process = processBuilder.start();\r
\r
int exitCode = process.waitFor();\r
\`\`\`\r
\r
In the above example, by using the inheritIO() method we see the output of a simple command in the console in our IDE.\r
\r
::: warning Use it just for debugging purposes\r
This method is useful for debugging purposes, but it's not recommended for production code. It's better to use the getInputStream() and getErrorStream() methods to read the output and error streams of the subprocess, and the getOutputStream() method to write to the subprocess.\r
:::\r
\r
<!--\r
### Pipelines\r
\r
Java 9 introduced the concept of pipelines to the ProcessBuilder API:\r
\r
\`\`\`java:no-line-numbers\r
public static List<Process> startPipeline(List<ProcessBuilder> builders)\r
\`\`\`\r
\r
Using the startPipeline method we can pass a list of ProcessBuilder objects. This static method will then start a Process for each ProcessBuilder. Thus, creating a pipeline of processes which are linked by their standard output and standard input streams.\r
\r
For example, if we want to run something like this:\r
\r
> find . -name *.java -type f | wc -l\r
\r
What we'd do is create a process builder for each isolated command and compose them into a pipeline\r
\r
\`\`\`java\r
List builders = Arrays.asList(\r
    new ProcessBuilder("find", "src", "-name", "*.java", "-type", "f"), \r
    new ProcessBuilder("wc", "-l"));\r
\r
List processes = ProcessBuilder.startPipeline(builders);\r
Process last = processes.get(processes.size() - 1);\r
\r
// We can get lats process output to get the final results\r
\`\`\`\r
\r
In the example, we're searching for all the java files inside the src directory and piping the results into another process to count them.\r
-->\r
\r
## 2.3.2 Redirecting Standard Input and Output\r
\r
In the real world, we will probably want to capture the results of our running processes inside a log file for further analysis. Luckily the ProcessBuilder API has built-in support for exactly this.\r
\r
By default, our process reads input from a pipe. We can access this pipe via the output stream returned by Process.getOutputStream().\r
\r
However, as we'll see shortly, the standard output may be redirected to another source such as a file using the method \`redirectOutput(File)\`. In this case, getOutputStream() will return a ProcessBuilder.NullOutputStream.\r
\r
::: info Redirect before running the process\r
It's important to notice when we perform each action over a process.\r
\r
Before we've seen that I/O streams are consulted and managed once the process is running, so the methods that give us access to those streams are methods of the \`Process\` class.\r
\r
If we want to redirect I/O, as we are going to see next, we will do it while preparing the process to be executed. So when it's launched its I/O streams are modified. That's why this time the methods that allow us to redirect the I/O of the processes are methods of the \`ProcessBuilder\` class.\r
::::\r
\r
Let's prepare an example to print out the version of Java. But this time let's redirect the output to a log file instead of the standard output pipe:\r
\r
\`\`\`java\r
ProcessBuilder processBuilder = new ProcessBuilder("java", "-version");\r
\r
// Error output will be sent to the same place as the standard\r
processBuilder.redirectErrorStream(true);\r
\r
File log = folder.newFile("java-version.log");\r
processBuilder.redirectOutput(log);\r
\r
Process process = processBuilder.start();\r
\`\`\`\r
\r
In the above example, we create a new temporary file called log and tell our ProcessBuilder to redirect output to this file destination.\r
\r
Es lo mismo que si llamsemos a nuestra aplicacin usando el operador de redireccin de salida:\r
\r
> java ejemplo-java-version > java-version.log\r
\r
::: tip Cdigo del proceso hijo\r
Si el proceso hijo que lanzamos, en vez de ser un comando del sistema, es otra clase java, en ningn momento tenemos que modificar el cdigo de este proceso para que funcione como hijo.\r
\r
Por lo tanto, el proceso hijo seguir haciendo\r
\r
> System.out.println("Versin de Java: " + System.getProperty("java.version"));\r
\r
y ser el sistema operativo el que se encargue de redirigir las salidas o entradas al fichero, o donde se haya configurado con los mtodos de redireccin de la clase \`ProcessBuilder\`.\r
:::\r
\r
It's the same as if we called our application using the output redirection operator:\r
\r
> java example-java-version > java-version.log\r
\r
::: tip Child process code\r
If the child process we launch, instead of being a system command, is another Java class, we don't have to modify the code of this process to work as a child.\r
\r
Therefore, the child process will continue to do\r
\r
> System.out.println("Java version: " + System.getProperty("java.version"));\r
\r
and it will be the operating system that will take care of redirecting the outputs or inputs to the file, or where it has been configured with the redirection methods of the \`ProcessBuilder\` class.\r
:::\r
\r
Now let's take a look at a slight variation on this example. For instance when we wish to \`append to\` a log file rather than create a new one each time:\r
\r
\`\`\`java\r
File log = tempFolder.newFile("java-version-append.log");\r
processBuilder.redirectErrorStream(true);\r
processBuilder.redirectOutput(Redirect.appendTo(log));\r
\`\`\`\r
\r
It's also important to mention the call to \`redirectErrorStream(true)\`. In case of any errors, the error output will be merged into the normal process output file.\r
\r
We can also redirect error stream an input stream for the subprocess with methods\r
\r
- redirectError(File)\r
- redirectInput(File)\r
\r
To make the redirections we can use the \`ProcessBuilder.Redirect\` class as a parameter for the overloaded version of the previous methods, using one of the following values\r
\r
| Valor                   | Significado                                                         |\r
| ----------------------- | ------------------------------------------------------------------- |\r
| Redirect.DISCARD        | Information is discarded                                   |\r
| Redirect.to(File)       | Information is saved in the file. If it exists, it's emptied.       |\r
| Redirect.from(File)     | Information is read from the file                                   |\r
| Redirect.appendTo(File) | Information is saved in the file. If it exists, it's not emptied.   |\r
\r
This values are static fields of the Redirect class and can be used as parameters for the overloads of the redirectOutput, redirectError and redirectInput methods.\r
\r
\`\`\`java\r
File log = folder.newFile("sampleInputData.csv");\r
processBuilder.redirectInput(Redirect.from(log));\r
\`\`\`\r
`]},{title:"2.1 Interprocess communication",headers:[{level:2,title:"2.1.1. Communication through I/O",slug:"_2-1-1-communication-through-i-o",link:"#_2-1-1-communication-through-i-o",children:[{level:3,title:"Standard input redirection",slug:"standard-input-redirection",link:"#standard-input-redirection",children:[]},{level:3,title:"Standard output redirection",slug:"standard-output-redirection",link:"#standard-output-redirection",children:[]},{level:3,title:"Standard error output redirection",slug:"standard-error-output-redirection",link:"#standard-error-output-redirection",children:[]},{level:3,title:"Standard input redirection",slug:"standard-input-redirection-1",link:"#standard-input-redirection-1",children:[]}]},{level:2,title:"2.1.2. Redirection of the output of one process to the input of another process",slug:"_2-1-2-redirection-of-the-output-of-one-process-to-the-input-of-another-process",link:"#_2-1-2-redirection-of-the-output-of-one-process-to-the-input-of-another-process",children:[]},{level:2,title:"2.1.3. Communication through signals",slug:"_2-1-3-communication-through-signals",link:"#_2-1-3-communication-through-signals",children:[]},{level:2,title:"2.1.4. Communication through sockets",slug:"_2-1-4-communication-through-sockets",link:"#_2-1-4-communication-through-sockets",children:[]}],path:"/en/unit2/ipc.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.1 Interprocess communication\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1 Interprocess communication" />\r
\r
# 2.1 Interprocess communication\r
\r
[[toc]]\r
\r
Interprocess communication (IPC) is one of the main features of operating systems. In this section, we will focus on the communication between processes that are on the same device.\r
\r
## 2.1.1. Communication through I/O\r
\r
Communication between processes can be done in many ways, but one of the simplest and most common is communication through standard input and output.\r
\r
::: info I/O in Java\r
In Java, communication through standard input and output is done through standard input and output streams, \`System.in\` and \`System.out\` respectively.\r
:::\r
\r
Every process has three standard input and output streams that can be used for communication with other processes. These streams are:\r
\r
- **stdin** (standard input): where the process receives data. By default, it corresponds to the keyboard and the file identifier associated with it is 0.\r
- **stdout** (standard output): where the process sends data. By default, it corresponds to the console and the file identifier associated with it is 1.\r
- **stderr** (standard error output): where the process sends error messages. By default, it corresponds to the console and the file identifier associated with it is 2.\r
\r
A relatively simple IPC mechanism is the communication of processes through the redirection of standard inputs and outputs to/from other sources.\r
\r
::: warning I/O redirection\r
The redirection of standard input and output can be done on the command line of UNIX and Windows systems. In Java, it can be done using the \`ProcessBuilder\` class that we will see in the next section of the unit.\r
:::\r
\r
### Standard input redirection\r
\r
Standard input redirection can be done using the \`<\` operator in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass < input.txt\r
\`\`\`\r
\r
In the previous example, the \`MyClass\` program receives standard input from the \`input.txt\` file instead of from the keyboard.\r
\r
> When standard input is redirected, the program does not have to do anything special to read from a file instead of from the keyboard. The operating system takes care of redirecting the standard input of the program to the file that is indicated.\r
>\r
### Standard output redirection\r
\r
Standard output redirection can be done using the \`>\` and \`>>\` operators in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass > output.txt\r
$> java MyClass >> output2.txt\r
\`\`\`\r
\r
In the previous example, the standard output of the \`MyClass\` program is redirected to the \`output.txt\` file instead of to the console. If the \`output.txt\` file does not exist, it is created, and if the file already exists, its value is overwritten.\r
\r
If the operator is \`>>\`, the output is added to the end of the file instead of overwriting it.\r
\r
> When standard output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the standard output of the program to the file that is indicated.\r
\r
### Standard error output redirection\r
\r
Standard error output redirection can be done using the \`2>\` operator in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass 2> error.txt\r
$> java MyClass 2>> error2.txt\r
\`\`\`\r
\r
In the previous example, the standard error output of the \`MyClass\` program is redirected to the \`error.txt\` file instead of to the console.\r
\r
If the operator is \`2>>\`, the error output is added to the end of the file instead of overwriting it.\r
\r
> When the error output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the error output of the program to the file that is indicated.\r
\r
### Standard input redirection\r
\r
Standard input redirection can be done using the \`<\` operator in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass < input.txt\r
\`\`\`\r
\r
In the previous example, the \`MyClass\` program receives standard input from the \`input.txt\` file instead of from the keyboard.\r
\r
> When standard input is redirected, the program does not have to do anything special to read from a file instead of from the keyboard. The operating system takes care of redirecting the standard input of the program to the file that is indicated.\r
>\r
> ### Standard output redirection\r
>\r
> Standard output redirection can be done using the \`>\` and \`>>\` operators in UNIX and Windows systems.\r
>\r
> \`\`\`bash\r
> $> java MyClass > output.txt\r
> $> java MyClass >> output2.txt\r
> \`\`\`\r
\r
In the previous example, the standard output of the \`MyClass\` program is redirected to the \`output.txt\` file instead of to the console. If the \`output.txt\` file does not exist, it is created, and if the file already exists, its value is overwritten.\r
\r
If the operator is \`>>\`, the output is added to the end of the file instead of overwriting it.\r
\r
> When standard output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the standard output of the program to the file that is indicated.\r
>\r
> ### Standard error output redirection\r
>\r
> Standard error output redirection can be done using the \`2>\` operator in UNIX and Windows systems.\r
>\r
> \`\`\`bash\r
> $> java MyClass 2> error.txt\r
> $> java MyClass 2>> error2.txt\r
> \`\`\`\r
\r
In the previous example, the standard error output of the \`MyClass\` program is redirected to the \`error.txt\` file instead of to the console.\r
\r
If the operator is \`2>>\`, the error output is added to the end of the file instead of overwriting it.\r
\r
> When the error output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the error output of the program to the file that is indicated.\r
\r
## 2.1.2. Redirection of the output of one process to the input of another process\r
\r
The redirection of standard output to the standard input of another process can be done using the \`|\` operator in UNIX and Windows systems.\r
\r
Pipes allow you to connect the standard output of one process to the standard input of another, thus establishing a producer-consumer relationship.\r
\r
The use of pipes follows the following syntax:\r
\r
\`\`\`bash\r
$> java MyClass | java MyClass2\r
\`\`\`\r
\r
In the previous example, the standard output of the \`MyClass\` program is redirected to the standard input of the \`MyClass2\` program.\r
\r
> When the standard output of one process is redirected to the standard input of another, the operating system takes care of connecting the output and input streams of the processes.\r
\r
## 2.1.3. Communication through signals\r
\r
Signals are a form of communication between processes that is based on interrupting the execution of a process to perform a specific action.\r
\r
Signals are asynchronous events that are sent to a process to notify it of an event. Signals can be sent by the process itself, by another process, or by the operating system.\r
\r
Signals can be sent to a process using the \`kill\` command in UNIX systems.\r
\r
\`\`\`bash\r
$> kill -s SIGUSR1 1234\r
\`\`\`\r
\r
In the previous example, the \`SIGUSR1\` signal is sent to the process with PID \`1234\`.\r
\r
Signals in the Windows shell can be sent using the \`taskkill\` command.\r
\r
\`\`\`bash\r
$> taskkill /pid 1234 /f\r
\`\`\`\r
\r
In the previous example, the forced termination signal is sent to the process with PID \`1234\`.\r
\r
::: tip Signals\r
You can look at the [UNIX signal list](https://en.wikipedia.org/wiki/Signal_(IPC)) in Wikipedia.\r
\r
And you an read more on [Gestin de procesos en Windows](https://openwebinars.net/blog/gestion-de-procesos-y-servicios-desde-shell-script-en-windows/).\r
:::\r
\r
\r
\r
\r
## 2.1.4. Communication through sockets\r
\r
Sockets can be used for communication between processes on the same device or on different devices.\r
\r
Sockets will be studied in Unit 4, where we will see how they can be used for communication between processes on different devices.\r
`]},{title:"2.2 Process management in Java - ProcessBuilder and Process",headers:[{level:2,title:"2.2.1 Preparation and setting of a process",slug:"_2-2-1-preparation-and-setting-of-a-process",link:"#_2-2-1-preparation-and-setting-of-a-process",children:[{level:3,title:"Setting the command at runtime",slug:"setting-the-command-at-runtime",link:"#setting-the-command-at-runtime",children:[]},{level:3,title:"Additional settings for a process",slug:"additional-settings-for-a-process",link:"#additional-settings-for-a-process",children:[]}]},{level:2,title:"2.2.2 Process control from parent",slug:"_2-2-2-process-control-from-parent",link:"#_2-2-2-process-control-from-parent",children:[]},{level:2,title:"2.2.3 Spawn a java application from a class into the same project",slug:"_2-2-3-spawn-a-java-application-from-a-class-into-the-same-project",link:"#_2-2-3-spawn-a-java-application-from-a-class-into-the-same-project",children:[]},{level:2,title:"2.2.4 Current Java Process Information",slug:"_2-2-4-current-java-process-information",link:"#_2-2-4-current-java-process-information",children:[{level:3,title:"Getting information about the current process",slug:"getting-information-about-the-current-process",link:"#getting-information-about-the-current-process",children:[]},{level:3,title:"Getting information about a child process from parent",slug:"getting-information-about-a-child-process-from-parent",link:"#getting-information-about-a-child-process-from-parent",children:[]}]}],path:"/en/unit2/processbuilder.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.2 Process management in Java - ProcessBuilder and Process\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.2 Process management in Java - ProcessBuilder and Process" />\r
\r
# 2.2 Process management in Java ProcessBuilder and Process\r
\r
[[toc]]\r
\r
## 2.2.1 Preparation and setting of a process\r
\r
The class to set the running attributes for a new process, before it is being run, is the \`ProcessBuilder\` class.\r
\r
> [Specification java.lang.ProcessBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessBuilder.html)\r
\r
This is an auxiliary class for the Process and is instantiated to manage a collection of process attributes. We can invoke the \`start\` method to create a new process with the attributes defined by the instance of the ProcessBuilder class.\r
\r
Repeated calls to the start method would create a new process with the same attributes.\r
\r
The ProcessBuilder class defines two constructors, such as:\r
\r
\`\`\`java:no-line-numbers\r
ProcessBuilder(List<String> command)\r
ProcessBuilder(String... command)\r
\`\`\`\r
\r
The meaning implied by the parameters passed to both constructors is same. In the first constructor, the command to be executed, along with command line arguments, is passed in a list of strings. And, in the second constructor, the command and the command line arguments are specified through the varargs parameter. We can use either of the constructors, depending upon the way to pass the parameter.\r
\r
::: danger Arguments vs Parameters\r
If we want to launch a command with parameters, the command cannot be sent to ProcessBuilder in raw mode, it must be processed and converted into a List in order to make it work.\r
\r
\`\`\`java\r
// Different modes to pass the command to ProcessBuilder constructors\r
// 1st mode: using a string. It fails with parameters, \r
// Only works with commands having arguments\r
String command1 = "notepad.exe prueba1.txt"\r
ProcessBuilder pb = new ProcessBuilder(command1);\r
\r
// 2nd mode: using an array of strings. It also works with parameters\r
String[] command2 = {"cmd", "/c", "dir", "/o"};\r
ProcessBuilder pb = new ProcessBuilder(command2);\r
\r
// 3rd mode: using a string and splitting it to convert into a List\r
String command3 =  "c:/windows/system32/shutdown -s -t 0";  \r
// Regular expresion \\s means splitting the string by blank spaces\r
ProcessBuilder pb = new ProcessBuilder(command3.split("\\\\s"));\r
\`\`\`\r
\r
:::\r
\r
::: warning OS shutdown\r
You can use shutdown -s command to shutdown system. For windows OS, you need to provide full path of shutdown command e.g. C:\\Windows\\System32\\shutdown.\r
\r
Here you can use -s switch to shutdown system, -r switch to restart system, -h to put the system into hibernation, and -t switch to specify time delay.\r
\r
[Windows shutdown reference](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown)\r
:::\r
\r
::: question Activity psp.activities.U2A1_Shutdowner\r
Create a new Java application project (package psp.activities & main class U2A1_Shutdowner)\r
Using the command line, ask the user for the action he wants to do with the computer (shutdown ,restart or suspend) and how much time he needs before shutting down the system.\r
\r
Find information about the shutdown command in GNU/Linux and make your app work in both systems.\r
\r
Your app has to prepare the right command for the answers the user has given and for the OS it is running on.\r
\r
Get the ProcessBuilder.command() result and show it on the console in a readable format.\r
:::\r
\r
:::details U2A1_Shutdowner solution\r
\r
\`\`\`java\r
public class U2A1_Shutdowner {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Ask for the required information to prepare the command\r
        Scanner keyboard = new Scanner(System.in);\r
        \r
        System.out.print("Select your option (s-shutdown / r-reboot / h-hibernate): ");\r
        String shutdownOption = keyboard.nextLine();        \r
        \r
        System.out.print("How much seconds will the command wait to be run? (0 means immediately): ");\r
        String shutdownTime = keyboard.nextLine();        \r
        \r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "C:/Windows/System32/shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        } else {\r
            command = "shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder shutdowner = new ProcessBuilder(command.split("\\\\s"));\r
        //shutdowner.start();\r
        \r
        // Show the command to be run\r
        System.out.print("El comando a ejecutar es:  ");\r
        for (String commandPart: shutdowner.command()) {\r
            System.out.print(commandPart + " ");\r
        }\r
        System.out.println("");\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
### Setting the command at runtime\r
\r
If we want to set the command to be run at runtime, or at the time the ProcessBuilder instance is created we still don't know the command, it can be set later by using the command(String).\r
\r
The same way as the constructors, we have two versions of command method\r
\r
\`\`\`java:no-line-numbers\r
    command(List<String> command)\r
    command(String... command)\r
\`\`\`\r
\r
and there's also another command method, without parameters, to retrieve the command and parameters already set for the ProcessBuilder instance. Once we have the parameters list, we can modify it using List methods.\r
\r
\`\`\`java\r
// Sets and modifies the command after ProcessBuilder object is created\r
String command = "java -jar install.jar -install"; // tmp dir is missing\r
ProcessBuilder pbuilder = new ProcessBuilder(command.split("\\\\s"));\r
if (isWindows) {\r
    pbuilder.command().add(0, "cmd"); // Sets the 1st element\r
    pbuilder.command().add(1, "/c"); // Sets the 2nd element\r
    pbuilder.command().add("c:/temp"); // Sets the last element\r
    // Command to run cmd /c java -jar install.jar -install c:/temp\r
} else {\r
    pbuilder.command().add(0, "sh"); // Sets the 1st element\r
    pbuilder.command().add(1, "-c"); // Sets the 2nd element\r
    pbuilder.command().add("/tmp"); // Sets the last element\r
    // Command to run: sh -c java -jar install.jar -install /tmp\r
}\r
\r
// Starts the process\r
pbuilder.start();\r
\`\`\`\r
\r
### Additional settings for a process\r
\r
Some of the settings that can be changed for a process are:\r
\r
- Set the working directory where the process will be run\r
  We can override the default working directory of the current process by calling the directory method and passing a File object. **By default, the current working directory is set to the value returned by the user.dir system property**.\r
\r
    \`\`\`java\r
    // Change working directory for the running process\r
    pbuilder.directory(new File(System.getProperty("user.home")));\r
    \`\`\`\r
\r
- Set-up a custom key-value map and modify an existing one using builder.environment()\r
\r
    \`\`\`java\r
    // Retrieve and modify the process environment\r
    Map<String, String> environment = pbuilder.environment();\r
    // Get the PATH environment variable and add a new directory\r
    String systemPath = environment.get("path") + ";c:/users/public";\r
    environment.replace("path", systemPath);\r
    // Add a new environment variable and use it as a part of the command\r
    environment.put("GREETING", "Hola Mundo");\r
    processBuilder.command("/bin/bash", "-c", "echo $GREETING");\r
    \`\`\`\r
\r
    ::: info Environment variables vs System properties\r
    With Runtime we also accessed System properties, that are different from this environment ones.\r
    :::\r
\r
- Redirect input and output streams to custom replacements\r
- Inherit both of them to the streams of the current JVM process using builder.inheritIO()\r
  \r
  *This two settings will be covered later in this unit*.\r
\r
::: question Activity psp.activities.U2A2_WorkingDirectory\r
Create a new Java application project (package psp.activities & main class U2A2_WorkingDirectory    )\r
Prepare a process to run the dir/ls command to check that the directory listing is for the directory pointed by the user.dir property.\r
In the same application, change the value for the user.dir property.\r
Finally, set a working directory for the process.\r
\r
Print the user.dir environment value for the three scenarios after being changed.\r
:::\r
\r
::: details U2A2_WorkingDirectory solution\r
\r
\`\`\`java\r
public class U2A2_WorkingDirectory {\r
\r
    public static void main(String[] args) throws IOException, InterruptedException {\r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "cmd /c dir";\r
        } else {\r
            command = "sh -c ls";\r
        }\r
               \r
        //1st - Default working directory\r
        \r
        // Prepare the process \r
        ProcessBuilder commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir\r
        commander.start().waitFor();\r
        \r
        \r
        //2nd - Change user.dir but not the working directory\r
        \r
        // Change the user.dir system property\r
        System.setProperty("user.dir", System.getProperty("user.home"));\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir        \r
        commander.start().waitFor();\r
        \r
        \r
        // 3rd - Change the working directory\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        commander.directory(new File(System.getProperty("user.home")));             \r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
\r
        // Launch the process and show its result\r
        // Working directory is user.home and the process is run on it\r
        commander.start().waitFor();        \r
    }\r
}\r
\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.2 Process control from parent\r
\r
The \`Process\` is an abstract class defined in the java.lang package that encapsulates the runtime information of a program in execution. The \`start\` method invoked by the ProcessBuilder class returns a reference to this class instance. There is an another way to create an instance of this class, through the \`exec\` method of the Runtime instance.\r
\r
The methods defined by the Process class can be used to perform input/output operations from the process, check the exit status of the process, wait for it to complete, and terminate the process. These methods, however, are not built to work on special processes of the native platform like daemon processes, shell scripts, and so on.\r
\r
> [Specification java.lang.Process](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Process.html)\r
\r
::: warning Input/ output from the child process\r
Intriguingly, **the process created by the start() method does not own a console**. Instead, it redirects (stdin, stdout, stderr) to the parent process. If need be, we can access them via streams obtained using methods defined in the class, such as getInputStream(), getOutputStream() and getErrorSteam(). These are the ways we can feed input to and get results from the sub processes.\r
:::\r
\r
Some of the common methods defined in this class are:\r
\r
| method                                       | Description                                                                                                                                                |\r
| :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| int exitValue()                              | Exit code returned from the process executed                                                                                                              |\r
| Boolean isAlive()                            | Checks if the invoking process is still running.                                                                                                    |\r
| int waitFor()                                | Parent process waits for the child process to end. The integer value returned by the method is the exit code by the process.                                           |\r
| Boolean waitFor(long timeOut, TimeUnit unit) | Overloaded method of previous one. We can specify the wait time. This method returns true if the process has terminated and false if timeout has occurred. |\r
| void destroy()                               | These two methods are used to kill or terminate the process. One, the second, just does it forcibly.                                                       |\r
| Process destroyForcibly()                    |\r
\r
 Lets write a simple Java program to open an application as a separate process. After it is opened, the program would wait for, say, 10 seconds and then destroy the process, which will immediately close the application.\r
\r
\`\`\`java\r
public class ProcessDemo {\r
\r
   public static void main(String[] args) throws Exception {\r
\r
      ProcessBuilder pb = new ProcessBuilder("C:/Program Files (x86)/Notepad++/notepad++.exe");\r
      // Effectively launch the process\r
      Process p = pb.start();\r
      // Check is process is alive or not\r
      boolean alive = p.isAlive();\r
      // Wait for the process to end for 10 seconds.\r
      if (p.waitFor(10, TimeUnit.SECONDS)) {\r
          System.out.println("Process has finished");\r
      } else {\r
          System.out.println("Timeout. Process hasn't finished");\r
      }\r
      // Force process termination.\r
      p.destroy();\r
      // Check again if process remains alive\r
      alive = p.isAlive();\r
      // Get the process exit value\r
      int status = p.exitValue();        \r
   }\r
}\r
\`\`\`\r
\r
::: info Exit codes\r
An exit code, or sometimes known as a return code, is the code returned to a parent process by an executable. The standard exit code is 0 for success and any number from 1 to 255 for anything else.\r
:::\r
\r
::: question Activity psp.activities.U2A3_ExitValue\r
Create a new Java application project (package psp.activities & main class U2A3_ExitValue)\r
Prepare a process to run different commands (notepad, calc, shell commands) one after each other, and make your application get their exit code. Print it.\r
\r
Commands can be hardcoded. As an **optional** improvement for this activity you can ask the user for the command and make your app interactive. There must be an option to exit the app (empty command for instance).\r
\r
Try with non-existing applications or using wrong arguments/parameters for commands.\r
\r
Can you force a process not to be successful?\r
\r
How can you know your own process exit code?\r
:::\r
\r
::: details U2A3_ExitValue solution\r
\r
\`\`\`java\r
public class U2A3_ExitValue {\r
\r
    public static void main(String[] args) {\r
        do {\r
            // Cdigo para pedir un programa/comando a ejecutar\r
            Scanner teclado = new Scanner(System.in);\r
            System.out.println("Introduce el programa / comando que quieres ejecutar (intro para acabar): ");\r
            String comando = teclado.nextLine();\r
            \r
            if (comando.equals("")) System.exit(0);\r
\r
            try {\r
                // Preparamos el entrono de ejecucin del proceso\r
                // Como no sabemos el contenido del comando, forzamos su conversin\r
                // a una lista para que no haya problemas con su ejecucin\r
                ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
\r
                // Lanzamos el proceso hijo\r
                Process p = pb.start();          \r
\r
                // Esperamos a que acabe para recoger el valor de salida\r
                int exitValue = p.waitFor();\r
\r
                if (exitValue == 0) {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
                } else {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Cdigo (" + exitValue + ")");\r
                }\r
\r
            } catch (InterruptedException | IOException ex) {\r
                System.err.println(ex.getLocalizedMessage());\r
                ex.printStackTrace();\r
            }                       \r
        } while (true);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
::: danger Exceptions management\r
Call to method **waitFor** implies that the parent process gets locked until child process ends, or until a signal from the system (Exception) is received.\r
\r
It's better to handle exceptions than to throw them to upper levels.\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.3 Spawn a java application from a class into the same project\r
\r
For some activities you'll be required to create the parent and the child processes as Java applications. Then, from one the classes you will need to launch the other one.\r
\r
This implies that both classes are gonna have a main method. So, in the project properties we'll need to set which is the main class that will be run first, usually the \`Launcher\` class (parent process).\r
\r
![Main class](../../media/unit2/seleccionmain.png)\r
\r
Before one class can run the other, at least the second one (child process) must be compiled, that is, the .class file has to be generated into the build/classes directory.\r
\r
![Working directory](../../media/unit2/comandotree.png)\r
\r
Them and only then we can set the process environment to spawn a new process from an existing class. Here is the sample code\r
\r
\`\`\`java\r
// Prepare the environment and the command\r
ProcessBuilder pb = new ProcessBuilder("java", "psp.u2.actividad10.Sumador");\r
pb.directory(new File("build/classes"));\r
Process p = pb.start();\r
\`\`\`\r
\r
::: question Activity psp.activities.U2A4_Launcher\r
Create a new Java application project (package psp.activities & main class U2A4_Launcher).\r
\r
Into the project create another class, U2A4_Commander with a main method that receives a program name as a unique parameter in the main. Make this application to create and run a process for the program and wait until that process has finished.\r
\r
This class will return always the same value the launched program did.\r
\r
> System.exit() method\r
>\r
> - Zero. The zero status code should be used when the program execution went fine, i.e., the program is terminated successfully.\r
> - Non-Zero. A nonzero status code indicates abnormal termination. Java allows us to use different values for different kinds of errors.\r
\r
Now, make the U2A4_Launcher class ask the user for an application name and launch the Commander class passing it the name of the application entered by the user.\r
\r
Get the exitValue from Commander and show it's value, telling if the process worked fine or if it failed.\r
:::\r
\r
::: details U2A4_Launcher solution\r
\r
\`\`\`java\r
public class U2A4_Launcher {\r
\r
    public static void main(String[] args) {\r
\r
        // Cdigo para pedir un programa/comando a ejecutar\r
        Scanner teclado = new Scanner(System.in);\r
        System.out.println("Introduce el programa / comando que quieres ejecutar: ");\r
        String comando = teclado.nextLine();\r
\r
        try {\r
            // Preparamos el entrono de ejecucin del proceso\r
            // Como no sabemos el contenido del comando, forzamos su conversin\r
            // a una lista para que no haya problemas con su ejecucin\r
            comando = "java psp.activities.U2A4_Commander " + comando;\r
            ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
            pb.directory(new File("build/classes"));\r
\r
            // Lanzamos el proceso hijo\r
            Process p = pb.start();          \r
\r
            // Esperamos a que acabe para recoger el valor de salida\r
            int exitValue = p.waitFor();\r
\r
            if (exitValue == 0) {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
            } else {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Cdigo (" + exitValue + ")");                \r
            }\r
        } catch (InterruptedException | IOException ex) {\r
            System.err.println(ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }                       \r
    }\r
}\r
\r
public class U2A4_Commander {\r
\r
    public static void main(String[] args) throws Exception {       \r
        // Lectura de informacin desde los parmetros de entrada \r
        // Se supone que recibimos: args[0] args[1] args[2] ..... args[args.length-1 --> comando a ejecutar\r
        String comando = "";\r
        for (int i = 0; i < args.length; i++) {\r
            comando += args[i] + " ";\r
        }\r
        comando.trim();\r
                \r
        ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));            \r
\r
        // Lanzamos el proceso hijo\r
        Process p = pb.start();          \r
\r
        // Esperamos a que acabe para recoger el valor de salida\r
        int exitValue = p.waitFor();\r
\r
        System.exit(exitValue);\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
::: warning Child classes programming\r
Every class must be coded to be run independently or just as a child process. Think that in Netbeans all classes are run as child classes from the IDE.\r
\r
That's why the code, child or parent, needs to be done without thinking how they are gonna be called. The code must be  **independent** just like processes are one from each other.\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.4 Current Java Process Information\r
\r
We can now obtain a lot of information about the process via the API \`java.lang.ProcessHandle.Info\` API:\r
\r
- the command used to start the process\r
- the arguments of the command\r
- time instant when the process was started\r
- total time spent by it and the user who created it\r
\r
### Getting information about the current process\r
\r
Here's how we can do that for the current process:\r
\r
\`\`\`java{2-3}\r
// Get information about the current process\r
ProcessHandle processHandle = ProcessHandle.current();\r
ProcessHandle.Info processInfo = processHandle.info();\r
\r
System.out.println("PID: " + processHandle.pid());\r
System.out.println("Arguments: " + processInfo.arguments());\r
System.out.println("Command: " + processInfo.command());\r
System.out.println("Instant: " + processInfo.startInstant());\r
System.out.println("Total CPU duration: " + processInfo.totalCpuDuration());\r
System.out.println("User: " + processInfo.user());\r
\`\`\`\r
\r
### Getting information about a child process from parent\r
\r
It is also possible to get the process information of a newly spawned process. In this case, after we spawn the process and get an instance of the \`java.lang.Process\`, we invoke the \`toHandle()\` method on it to get an instance of java.lang.ProcessHandle.\r
\r
\`\`\`java{3-4}\r
// Get information about a child process from parent\r
Process process = processBuilder.inheritIO().start();\r
ProcessHandle childProcessHandle = process.toHandle();\r
ProcessHandle.Info childProcessInfo = childProcessHandle.info();\r
\`\`\`\r
\r
The rest of the details remain the same as in the section above\r
`]},{title:"2.1 Running processes in Java with Runtime",headers:[{level:2,title:"2.1.1. Quick process launch",slug:"_2-1-1-quick-process-launch",link:"#_2-1-1-quick-process-launch",children:[]},{level:2,title:"2.1.2 System properties and command shells",slug:"_2-1-2-system-properties-and-command-shells",link:"#_2-1-2-system-properties-and-command-shells",children:[]}],path:"/en/unit2/runtime.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.1 Running processes in Java with Runtime\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Running processes in Java with Runtime" />\r
\r
# 2.1. Running processes in Java with Runtime\r
\r
[[toc]]\r
\r
## 2.1.1. Quick process launch\r
\r
 There are several methods defined in the Runtime class. These methods can be invoked to get the information about the runtime environment such as number of processors available to the JVM, about of memory available, loading native library, explicitly call garbage collector, and so forth.\r
\r
> [Specification java.lang.Runtime](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html)\r
\r
Every Java program has an instance of the Runtime class, which encapsulates the runtime environment of the program. This class cannot be instantiated, but we can get a reference **singleton instance** to the Runtime of the currently running program with the help of the static method **java.lang.Runtime.getRuntime()**.\r
\r
::: question Design patterns: Singleton\r
What are design patterns? What is and what is used for the singleton pattern?\r
\r
Look how to implement a class with the singleton pattern.\r
\r
[Refactoring.Guru design patterns](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
The Runtime class method we are interested in, to create a new processes is\r
\r
> public Process exec(String command) throws IOException\r
\r
This is a simple, not yet customizable, way to spawn a new sub-process.\r
\r
\`\`\`java\r
public static void main(String[] args) throws IOException {\r
    // Launch notepad app\r
    Runtime.getRuntime().exec("notepad.exe");\r
\r
    // This way always works\r
    // String separator = System.getProperty("file.separator");\r
    // Runtime.getRuntime()\r
    //    .exec("c:"+separator+"windows"+separator+"notepad.exe");\r
\r
    // This way used to work (UNIX style paths)\r
    // Runtime.getRuntime().exec("c:/windows/notepad.exe");\r
}\r
\`\`\`\r
\r
As you can see the argument to  \`exec\` method is just the program we want to run. In this example, as *notepad* is in the system PATH it's not necessary to tell the path to the program. Otherwise, the path must be specified with the program name.\r
\r
<div class="pagebreak"></div>\r
\r
## 2.1.2 System properties and command shells\r
\r
If we plan to code platform independent applications, we have to deal with many issues because of differences between OS. So sometimes we need to deal with specific OS information. A useful way to get that information is by getting System properties.\r
\r
[Specification System.getProperties](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#getProperties())\r
\r
Some examples are provided here using System properties. Similar solutions can be used for other issues.\r
\r
::: danger File separator\r
For file path or directory separator, the Unix system introduced the slash character / as directory separator, and the Microsoft Windows introduced backslash character \\ as the directory separator. In a nutshell, this is / on UNIX and \\ on Windows.\r
\r
Then, how can we code OS independent applications??\r
\r
In Java, we can use the following three methods to get the platform-independent file path separator.\r
\r
- System.getProperty("file.separator")\r
- FileSystems.getDefault().getSeparator() (Java NIO)\r
- File.separator Java IO\r
\r
From now on, we are gonna use System properties in our applications for several situations using \`System.getProperty(String propName)\`. These properties are configured by the OS and the JVM, though we can modify them by setting the JVM running setting\r
\r
> String separator = System.getProperty("file.separator");\r
\r
or\r
\r
> -Dfile.separator\r
\r
Nevertheless is always a good practice to use slash character **/** in paths as Java is able to convert them to the system it is running on.\r
:::\r
\r
If we want to run an OS command we have to do it as we usually do, by using the command shell, where once again we find the troubleshot with UNIX / Windows.\r
\r
Let's take a look at the way we can use the system properties, once again, to get a list of files in the user personal folder.\r
\r
\`\`\`java\r
// First we get the user folder path\r
String homeDirectory = System.getProperty("user.home");\r
// And then we set which OS are we running on\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info non-interactive shell mode\r
In the previous code example, both for Windows and UNIX modifier **c** is used for command shells. This modifier tells the system to open a command shell, to run the companion command and close the shell after it has finished.\r
:::\r
\r
Next you can look at a handler event manager for a mouse clic, into a graphic application, to open a web site in a browser. The code shows how to do it in  *X like operating system and one way to do it in Windows systems is commented.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Our first applications in java is not gonna be an easy one.\r
\r
Using methods from System class and Runtime class, write the code for an app that shows\r
\r
- all the system properties configured in your OS\r
- total memory, free memory, used memory and processors available\r
\r
Make a research into Runtime class methods. For System properties try to get a list or iterable data estructure to show each of the system properties and their values.\r
:::\r
\r
::: details Proposed solution to previous activiy\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
::: info Number format\r
In any programming language we have many different ways to format the information shown to the user. As in this first applications we are using the console as the system output, let's check the two main techniques we can use in Java\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Using NumberFormat class or any of its descendants we can get control on how the numbers are shown with high precision, using numeric patterns.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Hashes can be used instead of zeros to allow .30 to be shown as 0.3\r
// (additional digits are optional)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Similar to C's printf syntax, we can use the java.util.Formatter syntax to set how data is visualized.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// numbers after % print preceding spaces to fill \r
// and justify numbers.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
:::\r
\r
::: info Colours in console applications\r
\r
There is a way to print in different colours when using the console. Here you have got an example code with some colours and the way to use it.\r
\r
\`\`\`java:no-line-numbers\r
public class UsingColoursInConsole {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hello" \r
                          + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Bye bye" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
`]},{title:"3.4 Alternative synchronization techniques",headers:[{level:2,title:"3.4.1. Semaphores",slug:"_3-4-1-semaphores",link:"#_3-4-1-semaphores",children:[]},{level:2,title:"3.4.2. High level synchronization techniques",slug:"_3-4-2-high-level-synchronization-techniques",link:"#_3-4-2-high-level-synchronization-techniques",children:[{level:3,title:"Concurrent Queues",slug:"concurrent-queues",link:"#concurrent-queues",children:[]},{level:3,title:"Concurrent Collections",slug:"concurrent-collections",link:"#concurrent-collections",children:[]},{level:3,title:"Atomic variables",slug:"atomic-variables",link:"#atomic-variables",children:[]}]},{level:2,title:"3.4.3 Executors, Callables & Future",slug:"_3-4-3-executors-callables-future",link:"#_3-4-3-executors-callables-future",children:[]}],path:"/en/unit3/alternatives.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.4 Alternative synchronization techniques\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.4 Alternative synchronization techniques" />\r
\r
# 3.4 Alternative synchronization techniques\r
\r
[[toc]]\r
\r
## 3.4.1. Semaphores\r
\r
There are many other ways to synchronize threads, one of the low-level ones ar \`semaphores\`. A semaphore controls access to a shared resource through the use of a counter. If the counter is greater than zero, then access is allowed. If it is zero, then access is denied. What the counter is counting are permits that allow access to the shared resource. Thus, to access the resource, a thread must be granted a permit from the semaphore.\r
\r
> [java.util.concurrent.Semaphore](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html) specification.\r
\r
Semaphores control access to \`critical sections\` where shared resources or variables are handled in a special way. Depending on thi initial value of the semaphore, a number of concurrent threads can access simultaneously to a shared resource.\r
\r
Semaphores can be manages with two methods and their initial value \`permits\`:\r
\r
- release(): When thread no longer needs access to a shared resource, it releases the permit, incrementing the semaphore count. By default the semaphore counter \`permits\` is incremented by 1, though it can get a value and increment the count in that value.\r
- acquire(): If a thread needs to access a shared resource or critical section, then it must get control over the semaphore. If semaphore count > 0, the thread acquires a permit, decrementing the semaphores count. Else, the thread is blocked until a permit can be acquired. Other value than 1 can be used to get the semaphore, having \`permits\` to be bigger than that value in order to get semaphore's control\r
- permits: The value of a counting semaphore at any point indicates the maximum number of processes that can enter the critical section at the exact same time. Each thread asks for a permit. if value is bigger than 0 that means free resources are available, so the thread will enter the semaphore and reduce the permit count\r
When the semaphore's permit count reaches to 0 that means no more shared resources are available and threads will be locked waiting for another thread to perform a release action on the semaphore.\r
\r
:::info Mutex\r
Binary semaphore: A binary semaphore only takes only 0 and 1 as values and is used to implement mutual exclusion as well as synchronize concurrent processes.\r
\r
The work similar to synchronized, providing **mut**ual **ex**clusion.\r
:::\r
\r
Let's take a look at this example\r
\r
\`\`\`java {class="line-numbers",5-7,13,15,20,27,37,39,44,51}\r
public class Almacen {\r
\r
  private final int MAX_LIMITE = 20;\r
  private int producto = 0;\r
  private Semaphore productor = new Semaphore(MAX_LIMITE);\r
  private Semaphore consumidor = new Semaphore(0);\r
  private Semaphore mutex = new Semaphore(1);\r
\r
  public void producir(String nombreProductor) {\r
    System.out.println(nombreProductor + " intentando almacenar un producto");\r
    try {\r
        // up to 20 producers can enter at the same time\r
        productor.acquire();\r
        // But only 1 (consumer/producer) at a time can update\r
        mutex.acquire();\r
\r
        producto++;\r
        System.out.println(nombreProductor + " almacena un producto. "\r
            + "Almacn con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
      \r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // Producers allow (notify) consumers to access\r
      consumidor.release();\r
    }\r
\r
  }\r
\r
  public void consumir(String nombreConsumidor) {\r
    System.out.println(nombreConsumidor + " intentando retirar un producto");\r
    try {\r
        // A producer must be run first, before any consumer\r
        consumidor.acquire();\r
        // But only 1 (consumer/producer) at a time can update\r
        mutex.acquire();\r
\r
        producto--;\r
        System.out.println(nombreConsumidor + " retira un producto. "\r
            + "Almacn con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // Consumers allow (notify) producers to add more products\r
      productor.release();\r
\r
    }\r
  }\r
\r
}\r
\`\`\`\r
\r
## 3.4.2. High level synchronization techniques\r
\r
The \`java.util.concurrent\` package provides tools for creating concurrent applications. There are some  \`thread-safe\` classes que to use Collections and basic data types without worrying about concurrent access.\r
\r
Using these classes in our code we can reduce out apps complexity.\r
\r
### Concurrent Queues\r
\r
The **BlockingQueue** interface defines a \`FIFO\` queue that locks threads trying to get elementos from an empty queue until there will be elements in the queue. it can set a maximum number of elements in the queue so that thread are blocked if they try to add elements over that number, having to wait until elements are extracted form the queue.\r
\r
Classes LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue and DelayQueue implement interface BlockingQueue.\r
\r
### Concurrent Collections\r
\r
Besides Queues, this package supplies Collection implementations designed for use in multithreaded contexts: ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and CopyOnWriteArraySet. When many threads are expected to access a given collection, a ConcurrentHashMap is normally preferable to a synchronized HashMap, and a ConcurrentSkipListMap is normally preferable to a synchronized TreeMap. A CopyOnWriteArrayList is preferable to a synchronized ArrayList when the expected number of reads and traversals greatly outnumber the number of updates to a list.\r
\r
**ConcurrentMap** is a subinterface of \`java.util.Map\` con with atomic operations to add / replace existing key,value pairs or to add non existing key,value pairs. ConcurrentHashMap is the thread-safe version for HashMap.\r
\r
### Atomic variables\r
\r
Package \`java.util.concurrent.atomic\` contains a small toolkit of classes that support lock-free thread-safe programming on single variables. Instances of Atomic classes maintain values that are accessed and updated using methods otherwise available for fields using associated atomic VarHandle operations.\r
\r
Instances of classes AtomicBoolean, AtomicInteger, AtomicLong, and AtomicReference each provide access and updates to a single variable of the corresponding type. Each class also provides appropriate utility methods for that type. For example, classes AtomicLong and AtomicInteger provide atomic increment methods.\r
\r
## 3.4.3 Executors, Callables & Future\r
\r
Executors is an interface to manage thread pools. Thread pools manage a pool of worker threads. The thread pools contain a work queue which holds tasks waiting to get executed.\r
\r
A thread pool can be described as a collection of Runnable/Callable objects (work queue) and a connection of running threads.\r
\r
These threads are constantly running and are checking the work query for new work. If there is new work to be done they execute this Runnable/Callable.\r
\r
Here you can check an illustrative example on how to use Executors\r
\r
[Executors: Ejemplo supermercado](https://jarroba.com/multitarea-e-hilos-en-java-con-ejemplos-ii-runnable-executors/)\r
\r
We have used a Runnable object to define the tasks that are executed inside a thread. While defining tasks using Runnable is very convenient, it is limited by the fact that the tasks can not return a result.\r
\r
What if you want to return a result from your tasks?\r
\r
Well, Java provides a \`Callable\` interface to define tasks that return a result. A Callable is similar to Runnable except that it can return a result and throw a checked exception.\r
\r
Callable interface has a single method call() which is meant to contain the code that is executed by a thread.\r
\r
\`Future\` interface has methods to obtain the result generated by a Callable object and manage its state. It represents the result of an asynchronous computation.\r
\r
The result can only be retrieved using method get() when the computation has completed, blocking if necessary until it is ready.\r
`]},{title:"3.6 Annex II - ArrayList cheat sheet by students",headers:[{level:2,title:"A. Definicin y creacin",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de ArrayList",slug:"a-1-constructores-de-arraylist",link:"#a-1-constructores-de-arraylist",children:[]}]},{level:2,title:"B. Mtodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creacin de un ArrayList",slug:"b-1-creacion-de-un-arraylist",link:"#b-1-creacion-de-un-arraylist",children:[]},{level:3,title:"B.2. Aadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si un elemento ya existe",slug:"b-3-comprobar-si-un-elemento-ya-existe",link:"#b-3-comprobar-si-un-elemento-ya-existe",children:[]},{level:3,title:"B.4. Acceder a un elemento del ArrayList",slug:"b-4-acceder-a-un-elemento-del-arraylist",link:"#b-4-acceder-a-un-elemento-del-arraylist",children:[]},{level:3,title:"B.5. Otras funciones de utilidad",slug:"b-5-otras-funciones-de-utilidad",link:"#b-5-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Aadir datos a un ArrayList",slug:"c-anadir-datos-a-un-arraylist",link:"#c-anadir-datos-a-un-arraylist",children:[{level:3,title:"C.1. Aadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Aadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Aadir / eliminar elementos desde cdigo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la coleccin",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el mtodo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Bsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Bsqueda usando los mtodos de la clase",slug:"e-1-busqueda-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Bsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Bsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Bsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtencin de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenacin de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar usando mtodos de Collection",slug:"g-1-ordenar-usando-metodos-de-collection",link:"#g-1-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.2. Ordenar con expresiones lambda",slug:"g-2-ordenar-con-expresiones-lambda",link:"#g-2-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.3. Ordenar con API Stream",slug:"g-3-ordenar-con-api-stream",link:"#g-3-ordenar-con-api-stream",children:[]}]}],path:"/en/unit3/arraylist_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.6 Annex II - ArrayList cheat sheet by students\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Annex II - ArrayList cheat sheet by students" />\r
\r
# 3.6 Annex II - ArrayList cheat sheet by students\r
\r
::: info Autora\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del mdulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informacin a la que podris acceder durante los exmenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definicin y creacin\r
\r
Una coleccin representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacn donde poder guardarlos. En Java, se emplea la interfaz genrica \`Collection\` para este propsito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de mtodos comunes, como pueden ser: aadir, eliminar, obtener el tamao de la coleccin.\r
\r
Partiendo de la interfaz genrica Collection extienden otra serie de interfaces genricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
La clase ArrayList en Java permite almacenar datos en memoria de forma similar a los Arrays con la ventaja de que el numero de elementos que almacena lo hace de forma dinmica, es decir, que no es necesario declarar su tamao como pasa con los Arrays. Los elementos pueden aadirse o eliminarse segn necesidad.\r
\r
### A.1. Constructores de ArrayList\r
\r
ArrayList proporciona 3 constructores que definen la capacidad inicial de la coleccin o si la inicializamos a partir de los valores de otra coleccin.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de ArrayList vaca.\r
ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\r
// ArrayList(int initialCapacity). Crea una instancia de ArrayList con una capacidad inicial especificada. \r
ArrayList<Persona> listaPersonas = new ArrayList<>(10);\r
\r
// ArrayList(Collection c). Crea una instancia de ArrayList a partir de otra coleccin de datos. Los datos se aaden en el orden en el que el Iterator de la otra coleccin los recorra.\r
ArrayList<Persona> listaPersonas = new ArrayList<>(c);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Mtodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendramos con la ejecucin de estos mtodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garca", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martnez", 65, 1.84d, 82, "Hombre");\r
  Persona p3 = new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre");\r
  Persona p4 = new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer");\r
\`\`\`\r
\r
### B.1. Creacin de un ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un ArrayList de Personas\r
  ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\`\`\`\r
\r
### B.2. Aadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Aadir un objeto Persona al final del ArrayList\r
  listaPersonas.add(p1);\r
\r
  // Aade el elemento al ArrayList en la posicin 'n+1'. \r
  // Cuidado, no podemos insertar en posiciones que no existen.\r
  listaPersonas.add(1, p1);\r
  \r
  // Borra el elemento de la posicin 'n+1' del ArrayList   \r
  // Cuidado, no podemos eliminar de posiciones que no existen.\r
  listaPersonas.remove(2);\r
\r
  // Borra el primer objeto pasado encontrado en el ArrayList que se le pasa como parmetro.  \r
  listaPersonas.remove(p1);  \r
\`\`\`\r
\r
::: info Duplicados\r
Si ya existe un elemento en el ArrayList, esta coleccin no controla la existencia de duplicados, por lo que tendremos el mismo objeto en dos posiciones diferentes.\r
Podemos evitarlo comprobando previamente si ya existe ese objeto, como veremos a continuacin.\r
:::\r
\r
### B.3. Comprobar si un elemento ya existe\r
\r
\`\`\`java:no-line-numbers\r
  // Comprueba si existe del objeto que se le pasa como parmetro\r
  listaPersonas.contains(p4);\r
\r
  // Devuelve la posicin del primer objeto pasado encontrado en el ArrayList  \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.indexOf(p1);\r
\r
  // Devuelve la posicin del ltimo objeto pasado en el ArrayList   \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### B.4. Acceder a un elemento del ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el elemento que esta en la posicin 'n+1' del ArrayList\r
  listaPersonas.get(2);\r
\`\`\`\r
\r
### B.5. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el numero de elementos del ArrayList\r
  listaPersonas.size();\r
\r
  //Borra todos los elementos de ArrayList   \r
  listaPersonas.clear();\r
\r
  // Devuelve true si el ArrayList esta vaco. Sino Devuelve false   \r
  listaPersonas.isEmpty();\r
\r
  // Pasa el ArrayList a un Array \r
  Object[] array = listaPersonas.toArray();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Aadir datos a un ArrayList\r
\r
::: info Orden de los elementos en un ArrayList\r
Cuando aadimos elementos a un ArrayList, el orden de insercin se conserva.\r
\r
Una Lista, por definicin, siempre mantiene el orden de los elementos. Esto no es solo para ArrayList, sino para todo tipo de listas como LinkedList, Vector, y el resto de clases que implementan el interfaz \`java.util.List\` .\r
\r
:::\r
\r
### C.1. Aadir elementos desde el constructor\r
\r
A la hora de crear el ArrayList, podemos aadirle datos, usando la sintaxis del doble corchete o bien con la construccin List.of o Arrays.asList\r
\r
\`\`\`java:no-line-numbers\r
  // Crea una nueva lista y a la vez la inicializa con valores  \r
  ArrayList<Persona> lista1 = new ArrayList<>() {{\r
      add(p1);\r
      add(p2);\r
  }};\r
\r
  // En este caso indicamos los valores como si de parmetros se tratase\r
  // De esta forma podemos aadir hasta un mximo de 10 elementos\r
  ArrayList<Persona> lista2 = new ArrayList<>(\r
        List.of(p1, p2, p3)\r
  );\r
\r
  // De forma similar al caso anterior, con una construccin a partir de un Array\r
  ArrayList<Persona> lista3 = new ArrayList<>(\r
        Arrays.asList(p1, p2, p3)\r
  );       \r
\`\`\`\r
\r
### C.2. Aadir elementos desde otras colecciones\r
\r
Podemos inicializar un ArrayList, como hemos visto en los ejemplos anteriores, desde varios tipos de colecciones (listas) que poseen caractersticas similares.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del cdigo anterior, creamos un nuevo ArrayList a partir de lista2\r
  ArrayList<Persona> lista4 = new ArrayList<>(lista3);  \r
  \r
  // Aade todos los elementos de la lista que indiquemos como argumento al final del ArrayList\r
  lista4.addAll(lista3);\r
\r
  // Hace lo mismo, pero lo inserta en la posicin indicada (debe existir al menos la posicin anterior)  \r
  lista4.addAll(lista3,2);\r
\`\`\`\r
\r
### C.3. Aadir / eliminar elementos desde cdigo\r
\r
\`\`\`java:no-line-numbers\r
  // Aadir un elemento al final de la lista\r
  lista4.add(p4);\r
  // Aade un elemento en la posicin indicada. El elemento que ocupaba esa posicin y todos los que haba detrs, se mueven una posicin a la derecha.\r
  // En el ejemplo, inserta p1 al principio de la lista.\r
  lista4.add(0,p1);   // Inserta p1 al principio de la lista.\r
  \r
  // Eliminar un elemento. Si existe lo elimina y devuelve true, si no devuelve false\r
  boolean existe = lista4.remove(p1);  \r
  // Eliminar un elemento por ndice. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = lista4.remove(2);  \r
  // Elimina del ArrayList todos aquellos elementos que coinciden con los indicados en la lista que pasamos como argumento \r
  lista4.removeAll(lista3);\r
  // Elimina del ArrayList todos aquellos elementos que cumplen con el predicado (la condicin) descrita como argumento en el mtodo e indicada como expresin lambda\r
  lista4.removeIf(p->p.getEdad()<18);   // Elimina los menores de 18\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la coleccin\r
\r
Vamos a preparar un ArrayList para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList creation\r
  ArrayList<Persona> grupoPersonas = new ArrayList<>() {{\r
    add(new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
    add(new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
    add(new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
    add(new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
    add(new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
    add(new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\r
\`\`\`\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por ndice\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(i));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el ArrayList es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : coleccin)\r
\r
\`\`\`java:no-line-numbers\r
    // Obtenemos un objeto de tipo Persona en cada iteracin del bucle\r
    for (Persona p: grupoPersonas) {\r
        System.out.println(p);\r
    }\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una coleccin y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un mtodo iterator() que devuelve una instancia de Iterator para recorrer la coleccin.\r
\r
Iterator tiene 4 mtodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento ms en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el ltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la accin indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la lista\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el mtodo forEach con expresiones lambda\r
\r
En este caso aprovechamos el mtodo foreach de las colecciones para poder realizar una accin concreta sobre cada uno de los elementos de la misma.\r
\r
De forma similar al bucle foreach, indicamos un elemento de la lista y la accin a realizar sobre el mismo\r
\r
\`\`\`java:no-line-numbers\r
  // Para cada persona (p) -> Accin a realizar\r
  grupoPersonas.forEach(p -> System.out.println(p));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin\r
\r
Mientras se est recorriendo una coleccin, no con todos los tipos de bucles se puede modificar (aadir/eliminar elementos) de la coleccin. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendramos problemas. Al acceder por ndice, podemos aadir o eliminar elementos mientras se recorre la coleccin.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.get(i).getNombre().equals("Jordi")) {\r
      grupoPersonas.remove(i);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Persona p : grupoPersonas) {\r
    if (p.getPeso()>100) {\r
      grupoPersonas.remove(p);\r
    }\r
    System.out.println("Eliminada: " + p);\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Siempre que usemos el mtodo remove de Iterator para eliminar elementos de la coleccin mientras la recorremos, podremos hacerlo sin que se genere ninguna excepcin.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Persona> iterator = grupoPersonas.iterator();\r
  while (iterator.hasNext()) {\r
    Persona p = iterator.next();\r
    if (p.getAltura() < 100) {\r
      // Si borramos usando iterator.remove funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el mtodo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.forEach((p) -> {if (p.getNombre().equals("Jordi")) grupoPersonas.remove(p);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la coleccin, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Bsqueda de elementos\r
\r
Para buscar elementos en un ArrayList hay distintas formas de hacerlo. Desde los propios mtodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Bsqueda usando los mtodos de la clase\r
\r
La clase ArrayList nos ofrece diferentes alternativas para buscar y/o saber si un elemento est presente en la coleccin. As, podemos usar los mtodos\r
\r
\`\`\`java:no-line-numbers\r
  // Comprobar si est el objeto en la coleccin\r
  boolean existe = grupoPersonas.contains(p1);\r
  // O simplemente obtener su posicin, si lo encuentra\r
  grupoPersonas.indexOf(p1);\r
  grupoPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### E.2. Bsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la coleccin hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> it = grupoPersonas.iterator();\r
  while (it.hasNext()) {\r
    Persona p = it.next();\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado: " + p);\r
      break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Bsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado:: " + p);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Bsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestin de las colecciones.\r
Podemos emplear varios mtodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcoleccin\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
\r
  // Obtener un subarray con los elementos que cumplan el criterio\r
  grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList());\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);   \r
  }\r
\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuntos cumplen el criterio de bsqueda\r
  grupoPersonas.stream().filter(p -> p.getAltura() > 170).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Persona> first = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .findFirst();\r
\r
  // Obtener cualquiera que cumpla el criterio, o null si no hay ninguno\r
  Persona any = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)                \r
          .findAny()\r
          .orElse(null);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtencin de subcolecciones\r
\r
Lo podemos considerar un tipo especial de bsqueda en el que el objetivo es conseguir una coleccin con los elementos que cumplan un determinado criterio.\r
\r
As, la forma de buscar es idntica a la del apartado anterior, pero en este caso lo que obtendremos de esa bsqueda ser una nueva lista con un subconjunto de elementos de la original\r
\r
### F.1. Subcolecciones usando bucles\r
\r
Para obtener los elementos podemos aplicar lo aprendido en el anterior punto. Buscaremos elemento a elemento y, cuando se cumpla una condicin especificada, aadiremos los elementos encontrados a una nueva coleccin.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas = new ArrayList<>();\r
  for (Persona p : grupoPersonas) {\r
    if (p.getNombre().startsWith("M")) {\r
      personas.add(p);\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
La idea es similar al punto anterior\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas2 = new ArrayList<>();\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().startsWith("M")) {\r
      personas2.add(p);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener directamente una subcoleccin mediante el filtrado, haciendo subconjuntos y guardando el resultado.\r
\r
Con API Stream podemos guardar el resultado usando diferentes formas de .collect, que darn como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList de Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas3 = (ArrayList<Persona>) grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toList());\r
\r
  // Conjunto de Personas cuyo nombre empieza por "M"\r
  Set<Persona> personas4 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toSet());\r
  \r
  // Mapa de Personas cuyo nombre empieza por "M"\r
  // En la construccin del mapa, hay que elegir un campo que sirva de clave\r
  Map<String, Persona> personas5 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toMap(Persona::getApellidos, Function.identity()));\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenacin de elementos\r
\r
### G.1. Ordenar usando mtodos de Collection\r
\r
Si lo que queremos es tener el conjunto ordenados, la forma ms fcil es ordenarla usando el mtodo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Ordena segn el mtodo compareTo sobrescrito al implementar el interfaz Comparable\r
  // Si no se ha implementado, ordena segn el orden natural\r
  Collections.sort(grupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(grupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su mtodo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos ms adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.2. Ordenar con expresiones lambda\r
\r
De esta forma no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparacin que queremos hacer como parmetro del mtodo sort.\r
\r
As podemos tener distintas formas de ordenar, segn nos convenga.\r
\r
\`\`\`java:no-line-numbers\r
  // Indicamos la comparacin que queremos hacer. Podemos usar compareTo \r
  Collections.sort(grupoPersonas, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(grupoPersonas);      \r
\r
  // o bien podemos definir nuestro propio comparador\r
  Collections.sort(grupoPersonas, (p1, p2) -> {\r
    String nombreCompleto1 = p1.getApellidos() + ", " + p1.getNombre();\r
    String nombreCompleto2 = p2.getApellidos() + ", " + p2.getNombre();\r
    return nombreCompleto1.compareTo(nombreCompleto2);\r
});\r
\`\`\`\r
\r
### G.3. Ordenar con API Stream\r
\r
Con API Stream usamos tambin el mtodo sorted para indicar qu comparacin se debe realizar. Tenemos varias opciones en funcin del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el ms flexible es aquel en el que indicamos, mediante una expresin lambda, qu comparacin realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en una nueva lista con los elementos ordenados\r
  ArrayList<Persona> grupoPersonasOrdenado = (ArrayList<Persona>) grupoPersonas.stream()\r
          // En este caso ordenamos por apellido, ascendente.\r
          .sorted((p1, p2) -> p1.getApellidos().compareTo(p2.getApellidos()))\r
          // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
          //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
          .collect(Collectors.toList());\r
\`\`\`\r
\r
::: info Encadenar mtodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcoleccin con los resultados.\r
\r
Es lo ms parecido que vamos a encontrar a una consulta SQL para los datos de una coleccin cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantneas, sin lugar a bugs, con muy poco cdigo.\r
:::\r
`]},{title:"3.5 Annex I - Debugging multithread apps in Netbeans",headers:[],path:"/en/unit3/debugger_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.5 Annex I - Debugging multithread apps in Netbeans\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.5 Annex I - Debugging multithread apps in Netbeans" />\r
\r
# 3.5 Annex I - Debugging multithread apps in Netbeans\r
\r
Modern IDE provide the user with facilities to debug multithread apps.\r
\r
Just like in monothread apps, we can use breakpoints to stop a thread execution to inspect object state, properties values, etc.\r
\r
If we want to use the Debugging window in NetBeans IDE to debug multi-threaded applications we have to activate it by setting it from menu *Window > Debugging > Debugging (Alt+Shift +9)*\r
\r
![Activate thread debug](../../media/unit3/NetbeansDebug1.jpg)\r
\r
The Debugging window simplifies the debugging process by integrating into one window the information about debugging sessions, application threads and thread call stacks. The Debugging window enables you to easily see the status of application threads and suspend and resume any of the threads in the session.\r
\r
![Debugging dialogue](../../media/unit3/NetbeansDebug2.jpg)\r
\r
- The *current thread* is indicated by a green bar in the margin (it is also highlighted in green).  The current thread is the one we can work on by using StepInto, StepOver, Pause, Continue actions from the debugger. We can also access the variables inspection on that thread.\r
- Threads that invoked the notification, by hitting a breakpoint, are indicated by a yellow bar and the thread icon (orange color) indicates that the thread is suspended by a breakpoint.\r
- In the right side we have a quick access to Resume/Pause each active thread.\r
  \r
![Thread change](../../media/unit3/NetbeansDebug3.jpg)\r
\r
Clicking with the right mouse button over any thread we can make it the *current thread*. This way we get control over it and we can inspect this thread while other are paused or keep on running.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug4.jpg)\r
\r
Furthermore, the cogwheel next to each thread identifier is giving us many information about a thread state.\r
\r
- When the cogwheel is orange that means the thread is suspended and it requires our attention.\r
- When the cogwheel is green that means the thread is running. If we move the mouse over the thread we can get a tip showing the thread state information. As you can observe in the image thread-2 is running but it is in a waiting state. Actually this thread is locked in a join (waiting for another thread to finish)\r
\r
![Thread monitors](../../media/unit3/NetbeansDebug5.jpg)\r
\r
Finally, thread debugging helps us with synchronization using monitors. We can know when a thread owns a monitor (lock) and we can also know which monitors (locks) a thread is waiting for.\r
\r
As an additional tool Netbeans provides an utility (Debug > Check for deadlocks) that checks if any deadlock has happened, telling the monitors owned by each thread and the monitors each thread is waiting for.\r
`]},{title:"3.7 Annex III - HashMap cheat sheet by students",headers:[{level:2,title:"A. Definicin y creacin",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de HashMap",slug:"a-1-constructores-de-hashmap",link:"#a-1-constructores-de-hashmap",children:[]}]},{level:2,title:"B. Mtodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creacin de un HashMap",slug:"b-1-creacion-de-un-hashmap",link:"#b-1-creacion-de-un-hashmap",children:[]},{level:3,title:"B.2. Aadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si una clave o un valor existen",slug:"b-3-comprobar-si-una-clave-o-un-valor-existen",link:"#b-3-comprobar-si-una-clave-o-un-valor-existen",children:[]},{level:3,title:"B.4. Acceder a las partes del mapa",slug:"b-4-acceder-a-las-partes-del-mapa",link:"#b-4-acceder-a-las-partes-del-mapa",children:[]},{level:3,title:"B.5. Acceder a un elemento del mapa",slug:"b-5-acceder-a-un-elemento-del-mapa",link:"#b-5-acceder-a-un-elemento-del-mapa",children:[]},{level:3,title:"B.6. Otras funciones de utilidad",slug:"b-6-otras-funciones-de-utilidad",link:"#b-6-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Aadir datos a un HashMap",slug:"c-anadir-datos-a-un-hashmap",link:"#c-anadir-datos-a-un-hashmap",children:[{level:3,title:"C.1. Aadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Aadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Aadir / eliminar elementos desde cdigo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la coleccin",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el mtodo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Bsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Bsqueda por clave o usando los mtodos de la clase",slug:"e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Bsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Bsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Bsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtencin de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenacin de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar por clave",slug:"g-1-ordenar-por-clave",link:"#g-1-ordenar-por-clave",children:[]},{level:3,title:"G.2. Ordenar usando mtodos de Collection",slug:"g-2-ordenar-usando-metodos-de-collection",link:"#g-2-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/en/unit3/hashmap_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.7 Annex III - HashMap cheat sheet by students\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.7 Annex III - HashMap cheat sheet by students" />\r
\r
# 3.7 Annex III - HashMap cheat sheet by students\r
\r
::: info Autora\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del mdulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informacin a la que podris acceder durante los exmenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definicin y creacin\r
\r
Una coleccin representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacn donde poder guardarlos. En Java, se emplea la interfaz genrica \`Collection\` para este propsito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de mtodos comunes, como pueden ser: aadir, eliminar, obtener el tamao de la coleccin.\r
\r
Partiendo de la interfaz genrica Collection extienden otra serie de interfaces genricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
Un HashMap bsicamente designa claves nicas para los valores correspondientes que se pueden recuperar en cualquier punto dado, es decir, nos permite almacenar elementos asociando a cada clave un valor.\r
\r
Para cada clave tenemos un valor asociado. Podemos despus buscar fcilmente un valor para una determinada clave. Las claves en el diccionario no pueden repetirse.\r
\r
### A.1. Constructores de HashMap\r
\r
HashMap proporciona 4 constructores que definen la capacidad inicial de la coleccin y en qu momento debe redimensionarse. Son parmetros para mejorar el rendimiento en el uso del HashMap.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de HashMap con una capacidad inicial de 16 y un factor de carga de 0,75.\r
HashMap<Integer, String> hm1 = new HashMap<>(); \r
\r
// HashMap(int initialCapacity). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga de 0,75. \r
HashMap<Integer, String> hm1 = new HashMap<>(10); \r
\r
// HashMap(int initialCapacity, float loadFactor). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga especificados. \r
HashMap<Integer, String> hm1 = new HashMap<>(5, 0.75f); \r
\r
//HashMap(Mapa de mapas) . Crea una instancia de HashMap con las mismas asignaciones que el mapa especificado. \r
HashMap<Integer, String> hm1 = new HashMap<>();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Mtodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendramos con la ejecucin de estos mtodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garca", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martnez", 65, 1.84d, 82, "Hombre");\r
\`\`\`\r
\r
### B.1. Creacin de un HashMap\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un HashMap con claves de tipo String y valores de tipo Persona\r
  HashMap<String,Persona> DNIs = new HashMap<>();\r
\`\`\`\r
\r
### B.2. Aadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Element.put(k,v) - Aade un par clave-valor al mapa.\r
  DNIs.put("390543M",p);\r
  // Element.remove(Object key) - Removes the key and his value.\r
  DNIs.remove("298423Z");// Will remove (390543M, p1) from the map.\r
\`\`\`\r
\r
::: warning Clave ya existente\r
Si ya existe un elemento con la misma clave en el mapa, el mtodo put reemplaza el valor existente por el nuevo.\r
Podemos evitarlo comprobando previamente si ya existe esa clave o con el mtodo **DNIs.putIfAbsent(k,v)**.\r
:::\r
\r
### B.3. Comprobar si una clave o un valor existen\r
\r
\`\`\`java:no-line-numbers\r
  // Element.containsKey(Key)  Comprueba si existe la clave dada\r
  DNIs.containsKey("390543M");\r
  // Element.containsValue(Value)  Comprueba si existe el valor dado asociado a alguna clave\r
  DNIs.containsValue(p2);\r
\`\`\`\r
\r
### B.4. Acceder a las partes del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.keySet() - Obtiene el conjunto de claves del mapa\r
  Set<String> claves = DNIs.keySet();\r
  // Element.values() - Obtiene el conjunto de valores almacenados en el mapa\r
  Collection<Persona> valores = DNIs.values();\r
  // Element.entrySet() - Obtiene el conjunto de pares clave-valor del mapa\r
  Set<Entry<String,Persona>> tuplas = DNIs.entrySet();\r
\`\`\`\r
\r
### B.5. Acceder a un elemento del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.get(Key) - Obtiene el valor asociado a la clave\r
  Persona p = DNIs.get("390543")\r
\`\`\`\r
\r
### B.6. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Element.size() - Devuelve el nmero de elementos en el mapa\r
  int size = DNIs.size();\r
  //Element.clear() - Elimina todas las asignaciones y vaca el mapa\r
  DNIs.clear();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Aadir datos a un HashMap\r
\r
::: info Orden de los elementos en el HashMap\r
Cuando aadimos elementos a una HashMap, el orden de insercin no se conserva. Internamente, para cada elemento, se genera un hash separado y los elementos se indexan en funcin de este hash para hacerlo ms eficiente. Antes de aadir un elemento, como se ha avisado antes, es recomendable comprobar si ya existe para no sustituirlo\r
:::\r
\r
### C.1. Aadir elementos desde el constructor\r
\r
A la hora de crear el Hashmap, podemos aadirle datos, usando la sintaxis del doble corchete o bien con la construccin Map.of\r
\r
\`\`\`java:no-line-numbers\r
  // Crea un nuevo mapa y a la vez lo inicializa con valores  \r
  HashMap<String, Persona> map1 = new HashMap<>() {{\r
    put("390543M", p1);\r
    put("298423Z", p2);\r
  }};\r
  // En este caso indicamos los pares clave valor como si de un array se tratase\r
  // De esta forma podemos aadir hasta un mximo de 10 elementos\r
  HashMap<String, Persona> map2 = new HashMap<>(\r
    Map.of("390543M", p1, "298423Z", p2)\r
  );\r
\`\`\`\r
\r
### C.2. Aadir elementos desde otras colecciones\r
\r
Al ser una coleccin compuesta por una clave y un valor, la inicializacin se limita a los tipos de colecciones que tienen una estructura similar.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del cdigo anterior, creamos un nuevo mapa a partir de map2\r
  HashMap<String, Persona> map3 = new HashMap<>(map2);\r
  // O bien copiando todos los pares clave-valor\r
  map3.putAll(map2);  \r
\`\`\`\r
\r
### C.3. Aadir / eliminar elementos desde cdigo\r
\r
\`\`\`java:no-line-numbers\r
  // Aadir y si existe la clave reemplazarlo\r
  DNIs.put("390543M", p1);\r
  // Aadir slo si la clave no existe\r
  DNIs.putIfAbsent("390543M", p1);\r
  // Eliminar un elemento. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = map3.remove("390543M");  \r
  // Eliminar un par clave-valor. Si existe la tupla, la elimina y devuelve true, si no devuelve false\r
  boolean existe = map3.remove("390543M", p1);  \r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la coleccin\r
\r
Vamos a preparar un HashMap para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap creation\r
  HashMap<String, Persona> grupoPersonas = new HashMap<>() {{\r
          put("12345678A", new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
          put("23456789B", new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
          put("34567890C", new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
          put("45678901D", new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
          put("56789012E", new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
          put("67890123F", new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\`\`\`\r
\r
::: info Tipos de valores\r
Vamos a mostrar ejemplos de cmo recorrer cada uno de los elementos que componen el HashMap, claves, valores y pares clave-valor.\r
\r
.entrySet() - devuelve el conjunto de pares clave-valor\r
\r
.keySet() - devuelve el conjunto de claves\r
\r
.values() - devuelve la coleccin de valores\r
:::\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por ndice, por lo que vamos a necesitar una forma de obtener el ndice (i) de cada elemento para recorrer el HashMap.\r
\r
En este caso, vamos a usar el ndice de la clave, a travs del mtodo toArray.\r
\r
::: warning Orden de los elementos en el HashMap\r
Es importante recordar y tener en cuenta que los elementos en un HashMap se ordenan automticamente en base a una funcin Hash (resumen) que permite realizar una bsqueda muy rpida sobre la clave. Por lo tanto, no podemos esperar que el recorrido por ndice coincida con el orden en el que los elementos se aaden al mapa.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(map.keySet().toArray()[i]));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el HashMap es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : coleccin)\r
\r
\`\`\`java:no-line-numbers\r
  // Recorremos la estructura obteniendo la tupla (k,v) en cada iteracin\r
  for (Map.Entry<String, Persona> entry : grupoPersonas.entrySet()) {\r
        System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\r
  }\r
\`\`\`\r
\r
o bien para ir mostrando las claves\r
\r
\`\`\`java:no-line-numbers\r
  for (String key : grupoPersonas.keySet()) {\r
    System.out.println("DNI = " + key);\r
  }\r
\`\`\`\r
\r
o los valores\r
\r
\`\`\`java:no-line-numbers\r
  for (Person value : grupoPersonas.values()) {\r
    System.out.println("Value = " + value);\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una coleccin y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un mtodo iterator() que devuelve una instancia de Iterator para recorrer la coleccin.\r
\r
Iterator tiene 4 mtodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento ms en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el ltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la accin indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la coleccin\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.values().iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el mtodo forEach con expresiones lambda\r
\r
En este caso aprovechamos el mtodo foreach de las colecciones para poder realizar una accin concreta sobre cada uno de los elementos de la misma\r
\r
\`\`\`java:no-line-numbers\r
  // Pares (clave,valor)\r
  grupoPersonas.forEach((k,v) -> System.out.println("Clave: " + k + ", Values: " + v));\r
  // Claves\r
  grupoPersonas.keySet().forEach(k -> System.out.println("Clave: " + k));\r
  // Valores\r
  grupoPersonas.values().forEach(v -> System.out.println("Values: " + v));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin\r
\r
Mientras se est recorriendo una coleccin, no con todos los tipos de bucles se puede modificar (aadir/eliminar elementos) de la coleccin. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendramos problemas. Al acceder por ndice, podemos aadir o eliminar elementos mientras se recorre la coleccin.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.keySet().toArray()[i].equals("23456789B")) {\r
      grupoPersonas.remove(grupoPersonas.entrySet().toArray()[i]);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Map.Entry<String, Persona> p : grupoPersonas.entrySet()) {\r
    if (p.getKey().equals("34567890C")) {\r
      personas.remove(p.getKey());\r
    }\r
    System.out.println("Clave: " + p.getKey() + " Valor: " + p.getValue().toString());\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Si usamos el mtodo remove para eliminar elementos de la coleccin mientras la recorremos, podremos hacerlo sin que se genere ninguna excepcin.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Entry<String, Persona>> iterator = grupoPersonas.entrySet().iterator();\r
  while (iterator .hasNext()) {\r
    Map.Entry<String, Persona> p = (Map.Entry<String, Persona>) iterator.next();\r
    if (p.getKey().equals("12345678A")) {\r
      // Si borramos usando iterator.remove o el mtodo remove(key) de HashMap, funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el mtodo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.keySet().forEach((k) -> {if (k.equals("34567890C")) grupoPersonas.remove(k);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la coleccin, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.values().forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Bsqueda de elementos\r
\r
Para buscar elementos en un HashMap hay distintas formas de hacerlo. Desde los propios mtodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Bsqueda por clave o usando los mtodos de la clase\r
\r
La clase HashMap nos ofrece diferentes alternativas para buscar y/o saber si un elemento est presente en la coleccin. As, podemos usar los mtodos\r
\r
\`\`\`java:no-line-numbers\r
  // A partir de una clave, obtener el valor\r
  grupoPersonas.get("34567890C");\r
  // O simplemente comprobar si existe esa clave o ese valor antes de buscarlo\r
  grupoPersonas.containsKey("34567890C");\r
  grupoPersonas.containsValue(person);\r
\`\`\`\r
\r
### E.2. Bsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la coleccin hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
  Iterator<Map.Entry<String, Persona>> it = grupoPersonas.entrySet().iterator();\r
  while (it.hasNext()) {\r
    Map.Entry<String, Persona> entry = it.next();\r
    if (((Persona)entry.getValue()).getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + entry.getKey() + ", Value: " +\r
      entry.getValue());\r
    break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Bsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
  grupoPersonas.forEach((k, v) -> {\r
    if (v.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + k + ", Value: " + v);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Bsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestin de las colecciones.\r
Podemos emplear varios mtodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcoleccin\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
\r
  // Obtener un submapa con los elementos que cumplan el criterio\r
  grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("abc"))\r
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Entry<String, Persona> p : grupoPersonas.entrySet().stream()\r
      .filter(k -> k.getKey().equals("abc"))\r
      .collect(Collectors.toList())) {\r
          System.out.println(p.getValue());   // Sacamos el valor de la tupla <clave,valor>\r
  }\r
\r
  for (Persona p : grupoPersonas.entrySet().stream()\r
      .filter((k) -> k.getKey().equals("98761234D"))\r
      .map(Map.Entry::getValue)         // Cogemos slo los valores del entryMap\r
      .collect(Collectors.toList())) {\r
          System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuntos cumplen el criterio de bsqueda\r
  grupoPersonas.entrySet().stream().filter(k -> k.getKey().equals("abc")).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Entry<String,Persona>> s = grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("6780123F"))\r
    .findFirst();\r
  \`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtencin de subcolecciones\r
\r
Lo podemos considerar un tipo especial de bsqueda en el que el objetivo es conseguir una coleccin con los elementos que cumplan un determinado criterio.\r
\r
As, la forma de buscar es idntica a la del apartado anterior, pero en este caso lo que obtendremos de esa bsqueda ser un nuevo tipo de coleccin, no necesariamente otro HashMap.\r
\r
### F.1. Subcolecciones usando bucles\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String,Persona> personas2 = new HashMap<String,Persona>();\r
  for (Entry<String, Persona> e : grupoPersonas.entrySet()) {\r
    if(e.getKey().endsWith("F")) {\r
      personas2.put(e.getKey(), e.getValue());\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
En este ejemplo obtenemos un nuevo HashMap, pero tambin podramos guardar la informacin en un ArrayList o en cualquier otro tipo de estructura.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas2 = new HashMap<String, Persona>();\r
  grupoPersonas.forEach((k, v) -> {\r
    if (k.endsWith("F")) {\r
      grupoPersonas2.put(k, v);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener diferentes tipos de subcolecciones. Con API Stream podemos filtrar, hacer subconjuntos y guardar el resultado usando diferentes formas de .collect, que darn como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap de Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas3 = (HashMap<String, Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // Lista de Personas cuyo DNI acaba en "F"\r
  List<Persona> listaPersonas3 = (List<Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toList());\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenacin de elementos\r
\r
::: danger HashMap no garantiza el orden de los elementos\r
Como ya hemos comentado anteriormente, un HashMap es una estructura de datos en la que el orden de los elementos no est garantizado. Es por eso que si queremos mantener una copia ordenada de los elementos, deberemos recurrir a otros tipos de colecciones que s garantizan el orden.\r
:::\r
\r
### G.1. Ordenar por clave\r
\r
Hay un tipo especial de map, TreeMap, en el que los elementos se ordenan siguiendo el orden natural de las claves. Por lo tanto es la opcin ideal si queremos tener los elementos ordenados por clave.\r
\r
\`\`\`java:no-line-numbers\r
  // As podemos recorrer el TreeMap y mostrar los elementos ordenados por clave\r
  TreeMap<String, Persona> grupoPersonasOrdenado = new TreeMap<>(grupoPersonas);\r
 \r
  Iterator it=grupoPersonasOrdenado.keySet().iterator();\r
  while(it.hasNext())\r
  {\r
    int key=(int)itr.next();\r
    System.out.println("Key: "+key+" Element: "+hashMap.get(key));\r
  }\r
\`\`\`\r
\r
### G.2. Ordenar usando mtodos de Collection\r
\r
Si lo que queremos es tener el conjunto de claves o valores ordenados por separado, la forma ms fcil es obtener una lista y ordenarla usando el mtodo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Para las claves\r
  List<String> clavesGrupoPersonas = new ArrayList<>(grupoPersonas.keySet());\r
  Collections.sort(clavesGrupoPersonas);\r
\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas = new ArrayList<>(grupoPersonas.values());\r
  // Ordena segn el mtodo compareTo sobrescrito al implementar el interfaz Comparable\r
  Collections.sort(valoresGrupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(valoresGrupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su mtodo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos ms adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
Si usamos una lista, no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparacin que queremos hacer como parmetro del mtodo sort\r
\r
\`\`\`java:no-line-numbers\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas2 = new ArrayList<>(grupoPersonas.values());\r
  // Indicamos la comparacin que queremos hacer. Podemos usar compareTo o definir\r
  // nuestro propio comparador\r
  Collections.sort(valoresGrupoPersonas2, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(valoresGrupoPersonas2);      \r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos tambin el mtodo sorted para indicar qu comparacin se debe realizar. Tenemos varias opciones en funcin del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el ms flexible es aquel en el que indicamos, mediante una expresin lambda qu comparacin realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en un LinkedHashMap que s garantiza el orden\r
  Map<String, Persona> sortedMap = grupoPersonas.entrySet().stream()\r
      // En este caso ordenamos por apellido, ascendente.\r
      .sorted((e1, e2) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
      //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\r
\`\`\`\r
\r
::: info Encadenar mtodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcoleccin con los resultados.\r
\r
Es lo ms parecido que vamos a encontrar a una consulta SQL para los datos de una coleccin cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantneas, sin lugar a bugs, con muy poco cdigo.\r
:::\r
`]},{title:"3 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit3/",pathLocale:"/en/",extraFields:[`---\r
title: 3 Introduction\r
---\r
\r
# Unit 3. Multithread programming\r
\r
After leaning the basics of concurrent programming and learn how processes can be used to do multitasking, in this unit we are going to look into a single process.\r
\r
We are gonna make use of threads and the eay they are programmed to do concurrent task into a process.\r
\r
key differences between processes and threads are:\r
\r
- Threads share process memory space\r
- Threads share file descriptors\r
- Threads share program code.\r
\r
As they run into the context of a process, the TCB (Tread Control Block) is smaller than the PCB (Process Control Block) because they share part of PCB. That's why sometimes threads are so called \`lightweight processes\`.\r
\r
All previous features simplify threads communication, thus coordination and synchronization becomes harder to program and manage.\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know thread characteristics in Java\r
- To Learn how to create and manage threads\r
- To debug multithread applications\r
- To use synchronization methods for processes and sub-processes\r
- To share information between threads on a process\r
- To learn about shared memory problems\r
- To use different programming approaches to synchronize threads execution\r
`]},{title:"3.3 Producer-Consumer model",headers:[{level:2,title:"3.3.1. Communication & synchronization template",slug:"_3-3-1-communication-synchronization-template",link:"#_3-3-1-communication-synchronization-template",children:[]},{level:2,title:"3.3.2 Main class",slug:"_3-3-2-main-class",link:"#_3-3-2-main-class",children:[]},{level:2,title:"3.3.3 Producer & Consumer classes",slug:"_3-3-3-producer-consumer-classes",link:"#_3-3-3-producer-consumer-classes",children:[]},{level:2,title:"3.3.4 Shared class. Threads synchronization",slug:"_3-3-4-shared-class-threads-synchronization",link:"#_3-3-4-shared-class-threads-synchronization",children:[]}],path:"/en/unit3/producer-consumer.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.3 Producer-Consumer model\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.3 Producer-Consumer model" />\r
\r
# 3.3 Producer-Consumer model\r
\r
[[toc]]\r
\r
## 3.3.1. Communication & synchronization template\r
\r
Threads synchronization means having tools to avoid \`starvation\` (threads lock), \`deadlocks\` (when a condition can never be satisfied) and to ensure shared resources are well managed by concurrent threads access.\r
\r
The Producer-Consumer problem is a classic example of a multi-threaded synchronization problem. Let's go into the usage of the shared resources by using this famous algorithm. [Wikipedia](https://es.wikipedia.org/wiki/Problema_productor-consumidor).\r
\r
Without thread control mechanism we already know that problems will rise up randomly:\r
\r
- Consumer can get elements more than once, exceeding the stock (banc account balance under 0, reader reading a book before it is finished).\r
- Producers can be quicker than Consumer and produce more information than the system can get, making data loose.- Consumer can be quicker than the Producer and can get more than once the same value, having inconsistent systems.\r
\r
That's all we know as \`race conditions\`.\r
\r
The following code template repeats over and over again for almos all activities we are going to work on. That's what we call the Producer-Consumer model.\r
\r
![Producer-Consumer](./../../media/unit3/ProducerConsumer.png)\r
\r
This model is based on three classes, but depending on the problem we can have only producers or just consumers.\r
\r
::: info Model as a design pattern\r
It's very important to fit our code into the model schema\r
\r
This is like a puzzle where we have to adjust the problem solution. Sometimes we won't have a producer, other there will be no consumer. Maybe we will use the wait condition only in one of them.\r
\r
We shouldn't add or modify the way the schema is presented, all parts must fit into the given model.\r
:::\r
\r
## 3.3.2 Main class\r
\r
> Main class will always have the same estructure. Following code can be used as a a template.\r
\r
Here we instantiate the shared object to be used by producers&consumers. This is the object that will hold communication, synchronization and information exchange between threads.\r
\r
In this example it is an object, but we can use a Collection or any other data structure useful for thread to share information and synchronize.\r
\r
\`\`\` java {4,5,6}\r
public class ClasePrincipal { \r
\r
    public static void main(String[] args) {    \r
        ClaseCompartida objetoCompartido = new ClaseCompartida();\r
        Productor productor  = new Productor(objetoCompartido);\r
        Consumidor consumidor  = new Consumidor(objetoCompartido);\r
        productor.start();\r
        consumidor.start();\r
\r
        // No es obligatorio, pero en ocasiones puede interesar que la ClasePrincipal\r
        // espere a que acaben los hilos\r
        productor.join();\r
        consumidor.join();\r
\r
        // Acciones a realizar una vez hayan acabado el productor y el consumidor\r
    }\r
    \r
}\r
\`\`\`\r
\r
::: warning Number of producer & consumer threads\r
In the previous code we have created and launched one of each, but it has not to be like that.\r
\r
Each problem to solve will need a different number of *Producers* and *Consumers*, that will be instantiated and launched in the main method or in any other complementary method in the class in charge of thread management.\r
\r
In the same way, it's on the problem if the main thread has to wait for the others to finish or not.\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.3 Producer & Consumer classes\r
\r
> Both **Producer** and **Consumer** classes will call methods in the shared object.\r
\r
In both classes, the application logic will be developed inside **run** method. This will be done basically accessing the shared object, calling its synchronized methods, modifying its properties and updating the object state to control its functionality.\r
\r
\`\`\` java {2,5,15}\r
public class Consumidor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Consumidor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecucin del mtodo run estar normalmente gestionada por un bucle\r
        // que controlar el ciclo de vida del hilo y se adaptar al problema.\r
        // En el caso de simulaciones se harn esperas proporcionales.\r
        try {\r
            // Cdigo que hace el hilo consumidor\r
            objetoCompartido.accionDeConsumir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
}    \r
\`\`\`\r
\r
\`\`\` java {2,5,15}\r
public class Productor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Productor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecucin del mtodo run estar normalmente gestionada por un bucle\r
        // que controlar el ciclo de vida del hilo y se adaptar al problema.\r
        // En el caso de simulaciones se harn esperas proporcionales.\r
        try {\r
            // Cdigo que hace el hilo productor\r
            objetoCompartido.accionDeProducir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
} \r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.4 Shared class. Threads synchronization\r
\r
 This model is completed with the shared object class. Here we provide methods to be used by both Producers and Consumers. Furthermore, this class must be thread-safe to avoid \`race conditions\`.\r
\r
\`\`\` java {2,9,11,14,21,25,28,30,33,40,44}\r
public class ClaseCompartida {\r
    int valorAccedidoSimultaneamente;\r
    \r
    ClaseCompartida() {\r
        // Se inicializa el valor\r
        this.valorAccedidoSimultaneamente = 0;\r
    }\r
\r
    public synchronized void accionDeConsumir() {\r
        // Si no se cumple la condicin para poder consumir, el consumidor debe esperar\r
        while (valorAccedidoSimultaneamente == 0) {\r
            try {\r
                System.out.println("Consumidor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar la gestin de la Interrupcin\r
            }\r
        }\r
                \r
        // Cuando se ha cumplido la condicin para consumir, el consumidor consume\r
        valorAccedidoSimultaneamente--;\r
        System.out.printf("Se ha consumido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
    \r
    public synchronized void accionDeProducir () {\r
        // Si no se cumple la condicin para poder producir, el productor debe esperar\r
        while (valorAccedidoSimultaneamente > 10) {\r
            try {\r
                System.out.println("Productor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar la gestin de la Interrupcin                \r
            }\r
        }\r
        \r
        // Cuando se ha cumplido la condicin para producir, el productor produce\r
        valorAccedidoSimultaneamente++;\r
        System.out.printf("Se ha producido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
}\r
\`\`\`\r
\r
What's interesting from above code is the pair  \`wait / notifyAll\` together with the \`synchronized\` modifier.\r
\r
- A call to a **synchronized** method makes it be run if and only if there is no other thread running another **synchronized** method \`for the same object instance\`. If that happens the thread trying to access the synchronized block will be locked until another thread leaves the synchronized block. Then one random thread is chosen from the threads waiting for the monitor and then it owns the monitor and runs the synchronized block.\r
- Simply put, calling **wait()** forces the current thread to wait until some other thread invokes **notify()** or **notifyAll()** on the same object. For this, the current thread must own the object's monitor, because the monitor will be released after the wait call. \r
- We use the **notify/notifyAll** methods for waking up threads that have previously made a wait() call for this monitos. All awaken threads are automatically sent onto the monitor queue together with all threads already waiting to own the monitor. All threads, once the monitor is owned by them, will start running the synchronized code o will continue running the next sentence after the wait call.\r
\r
> With **wait**, **notifyAll** methods and **synchronized** code blocks we can avoid concurrent threads to modify a shared variable. *(lines 21 and 40 from previous code)*.\r
\r
::: info Producer-Consumer model summary\r
Original Producer-Consumer works with a buffer where the Producer puts information and the Consumer gets it from the buffer. The buffer can never be overflown and it cannot be read if it is empty.\r
\r
Our example has been simplified by using a int variable that has to be always in the range [0.10]\r
\r
This variables can be of any type and the class code will be different depending on it. It must be valid for the problem and the data type control.\r
\r
Finally, conditions or states added for waiting and updates will be what us, as programmers, must code in order to make it work as specified by problems requirements.\r
:::\r
`]},{title:"3.1 Java classes for threads",headers:[{level:2,title:"3.1.1. Runnable Interface",slug:"_3-1-1-runnable-interface",link:"#_3-1-1-runnable-interface",children:[{level:3,title:"Java Class Implements Runnable",slug:"java-class-implements-runnable",link:"#java-class-implements-runnable",children:[]},{level:3,title:"Anonymous Implementation of Runnable",slug:"anonymous-implementation-of-runnable",link:"#anonymous-implementation-of-runnable",children:[]},{level:3,title:"Java Lambda Implementation of Runnable",slug:"java-lambda-implementation-of-runnable",link:"#java-lambda-implementation-of-runnable",children:[]},{level:3,title:"Calling the run method on a Runnable class",slug:"calling-the-run-method-on-a-runnable-class",link:"#calling-the-run-method-on-a-runnable-class",children:[]}]},{level:2,title:"3.1.2 Thread subclass",slug:"_3-1-2-thread-subclass",link:"#_3-1-2-thread-subclass",children:[]},{level:2,title:"3.1.3 Starting a Thread from a Runnable",slug:"_3-1-3-starting-a-thread-from-a-runnable",link:"#_3-1-3-starting-a-thread-from-a-runnable",children:[{level:3,title:"Subclass or Runnable?",slug:"subclass-or-runnable",link:"#subclass-or-runnable",children:[]}]},{level:2,title:"3.1.4 Thread class methods",slug:"_3-1-4-thread-class-methods",link:"#_3-1-4-thread-class-methods",children:[{level:3,title:"Pause a thread",slug:"pause-a-thread",link:"#pause-a-thread",children:[]},{level:3,title:"Threads priority management",slug:"threads-priority-management",link:"#threads-priority-management",children:[]}]}],path:"/en/unit3/runnable.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.1 Java classes for threads\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.1. Java classes for threads" />\r
\r
# 3.1. Java classes for threads\r
\r
[[toc]]\r
\r
## 3.1.1. Runnable Interface\r
\r
A Java Thread can execute your Java code inside your Java application.\r
\r
When a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application. From inside your application you can create and start more threads which can execute parts of your application code in parallel with the main thread.\r
\r
Java threads are objects like any other Java objects. Threads are instances of class java.lang.Thread, or instances of subclasses of this class. In addition to being objects, java threads can also execute code.\r
\r
The first way to specify what code a thread should run is by creating a class that implements the \`java.lang.Runnable\` interface.\r
\r
The Runnable interface is a standard Java Interface that comes with the Java platform. The Runnable interface only has a single method run().\r
\r
> [java.lang.Runnable specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html)\r
\r
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method. There are three ways to implement the Runnable interface:\r
\r
- Create a Java class that implements the Runnable interface.\r
- Create an anonymous class that implements the Runnable interface.\r
- Create a Java Lambda that implements the Runnable interface.\r
\r
All three options are explained in the following sections.\r
\r
### Java Class Implements Runnable\r
\r
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface. Here is an example of a custom Java class that implements the Runnable interface:\r
\r
\`\`\`java\r
public class MyRunnable implements Runnable {\r
\r
  public void run(){\r
      System.out.println("MyRunnable running");\r
  }\r
}\r
\`\`\`\r
\r
All this Runnable implementation does is to print out the text MyRunnable running. After printing that text, the run() method exits, and the thread running the run() method will stop.\r
\r
### Anonymous Implementation of Runnable\r
\r
You can also create an anonymous implementation of Runnable. Here is an example of an anonymous Java class that implements the Runnable interface:\r
\r
\`\`\`java\r
Runnable myRunnable =\r
    new Runnable(){\r
        public void run(){\r
            System.out.println("Runnable running");\r
        }\r
    }\r
\`\`\`\r
\r
Apart from being an anonymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.\r
\r
### Java Lambda Implementation of Runnable\r
\r
The third way to implement the Runnable interface is by creating a Java Lambda implementation of the Runnable interface. This is possible because the Runnable interface only has a single unimplemented method, and is therefore practically (although possibly unintentionally) a functional Java interface.\r
\r
Here is an example of a Java lambda expression that implements the Runnable interface:\r
\r
\`\`\`java\r
Runnable runnable =\r
        () -> { System.out.println("Lambda Runnable running"); };\r
\`\`\`\r
\r
### Calling the run method on a Runnable class\r
\r
Look at this sample code of Runnable implementation\r
\r
\`\`\`java{1,13,23}\r
public class LiftOff implements Runnable {\r
    private int countDown = 10;\r
    private static int taskCount = 0;\r
    private final int id = taskCount;\r
    \r
    public LiftOff() {}\r
    \r
    public LiftOff(int countDown) {\r
        this.countDown = countDown;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        while (countDown > 0) {\r
            System.out.println("#" + id + " (" + countDown + ")" );\r
            countDown--;\r
        }\r
        System.out.println("LiftOff (" + id + ")");\r
    }\r
    \r
    public static void main(String[] args) {\r
        LiftOff launch = new LiftOff();\r
        launch.run();\r
        System.out.println("Waiting for LiftOff!");\r
    }    \r
}\r
\`\`\`\r
\r
Copy the code above and run it in your IDE. What do you see in the output?\r
\r
::: question What's wrong with previous execution\r
Is the "Waiting for LiftOff!" placed in the right place?\r
\r
Try to create more instances of LiftOff and run them all?\r
\r
Is the application doing something different to a single threaded application?\r
What can you notice from the program output?\r
:::\r
\r
## 3.1.2 Thread subclass\r
\r
The second way to specify what code a thread is to run, is to create a subclass of \`java.lang.Thread\` and override the run() method. The run() method is what is executed by the thread after you call \`start()\`.\r
\r
> [java.lang.Thread specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html)\r
\r
Here is an example of creating a Java Thread subclass:\r
\r
\`\`\`java\r
public class MyThread extends Thread {\r
  public void run(){\r
      System.out.println("MyThread running");\r
  }\r
}\r
\`\`\`\r
\r
To create and start the above thread you can do like this:\r
\r
\`\`\`java\r
MyThread myThread = new MyThread();\r
myTread.start();\r
\`\`\`\r
\r
The start() call will return as soon as the thread is started. **It will not wait until the run() method is done**. The run() method will execute as if executed by a different CPU. When the run() method executes it will print out the text "MyThread running".\r
\r
You can also create an anonymous subclass of Thread like this:\r
\r
\`\`\`java\r
Thread thread = new Thread(){\r
  public void run(){\r
    System.out.println("Thread Running");\r
  }\r
}\r
\r
thread.start();\r
\`\`\`\r
\r
This example will print out the text "Thread running" once the run() method is executed by the new thread.\r
\r
::: question LiftOff example\r
Copy the original LiftOff example and now make it extends Thread class.\r
\r
Is the "Waiting for LiftOff!" placed in the right place? Is it working as it's supposed to?\r
\r
Try to create more instances of LiftOff and run them all\r
is the application doing something different to a single threaded application?\r
What can you notice from the program output?\r
:::\r
\r
## 3.1.3 Starting a Thread from a Runnable\r
\r
To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor. Here is how that is done:\r
\r
\`\`\`java\r
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...\r
\r
Thread thread = new Thread(runnable);\r
thread.start();\r
\`\`\`\r
\r
When the thread is started it will call the run() method of the MyRunnable instance (see previous examples) instead of executing it's own run() method. The above example would print out the text "MyRunnable running".\r
\r
::: info\r
Hence, there are two ways to specify what code the thread should execute.\r
\r
- The first is to create a subclass of Thread and override the run() method.\r
- The second method is to pass an object that implements Runnable to the Thread constructor.\r
:::\r
\r
<CodeGroup>\r
<CodeGroupItem title="Extends Thread" active>\r
\r
\`\`\`java{1,7}\r
public class EjemploThread extends Thread {\r
  public void run() {\r
    // Cdigo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    EjemploThread hilo = new EjemploThread();\r
    hilo.start();\r
  }\r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Runnable">\r
\r
\`\`\`java{1,7}\r
public class EjemploRunnable implements Runnable {\r
  public void run() {\r
    // Cdigo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    Thread hilo = new Thread(new EjemploRunnable());\r
    hilo.start();\r
  }    \r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
</CodeGroup>\r
\r
### Subclass or Runnable?\r
\r
There are no rules about which of the two methods is the best. Both methods works. **The preferred method is implementing Runnable**, and handing an instance of the implementation to a Thread instance.\r
\r
A few reasons against extending Thread\r
\r
- When extending the Thread class, we're not overriding any of its methods. Instead, we override the method of Runnable (which Thread happens to implement). This is a clear violation of IS-A Thread principle.\r
- Creating an implementation of Runnable and passing it to the Thread class utilizes composition and not inheritance  which is more flexible\r
- After extending the Thread class, we can't extend any other class\r
From Java 8 onwards, Runnables can be represented as lambda expressions\r
\r
::: danger Common Pitfall: Calling run() Instead of start()\r
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:\r
\r
> Thread newThread = new Thread(MyRunnable());\r
> newThread.run();  //should be start();\r
\r
or\r
\r
> MyRunnable runnable = new MyRunnable();\r
> runnable.run();  \r
\r
At first you may not notice anything because the Runnable's run() method is executed like you expected. However, it is **NOT executed by the new thread** you just created. Instead the run() method is executed by the thread that created the thread. In other words, the thread that executed the above two lines of code. To have the run() method of the MyRunnable instance called by the new created thread, newThread, **you MUST call the newThread.start() method**.\r
:::\r
\r
## 3.1.4 Thread class methods\r
\r
If we take a look at the Thread class definition, we will find many methods. We must be careful because some of those methods like stop(), suspend(), resume() and destroy() are \`deprecated\`.\r
\r
Next we can see the most commonly used methods of Thread class:\r
\r
| Method                      | Description                                                                                                                                           |\r
| :-------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| start()                     | Makes a thread execute the code in the run method()                                                                                                   |\r
| boolean isAlive()           | Checks if the thread is alive or not                                                                                                                  |\r
| sleep(long ms)              | Changes the thread state to blocked for the ms specified                                                                                              |\r
| run()                       | Is the thread code to be run. It is called by the start method. It represents the lifecycle of a thread.                                              |\r
| String toString()           | Returns a readable representation a thread [threadName, priority, threadGroupName]                                                                    |\r
| long getId()                | Returns the thread id                                                                                                                                 |\r
| void yield()                | Makes the thread stop running at the moment going back to the queue and allowing other threads to be executed.                                        |\r
| void join()                 | Called from another thread, waits for this thread to die                                                                                              |\r
| String getName()            | Gets the thread name                                                                                                                                  |\r
| String setName(String name) | Sets a name for the thread                                                                                                                            |\r
| int getPriority()           | Gets the thread priority                                                                                                                              |\r
| setPriority(int p)          | Sets the thread priority                                                                                                                              |\r
| void interrupt()            | Interrupts the thread executions causing a InterruptedException                                                                                       |\r
| boolean interrupted()       | Checks if a thread has been interrupted                                                                                                               |\r
| Thread.currentThread()      | STATIC method returns a reference to the thread that is running this code                                                                             |\r
| boolean isDaemon()          | Checks if thread is a daemon. A low-level process running independently from its process. A process can finish while a daemon thread is still running |\r
| setDaemon(boolean on)       | Makes a thread turn into a daemon. By default all threads are user-threads when they are created.                                                     |\r
| int activeCount()           | Returns the number of active threads in the thread group where the thread belongs to.                                                                 |\r
| Thread.State getState()     | Returns the thread state, one of NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.                                                        |\r
\r
Thread also has up to 9 constructors, most of them getting a Runnable object as parameter along with the thread name and the tread group.\r
\r
| Thread constructors                                                                                   |\r
| :---------------------------------------------------------------------------------------------------- |\r
| Thread()                                                                                              |\r
| Thread(Runnable target)                                                                              |\r
| Thread(String name)                                                                                  |\r
| Thread(Runnable target, String name)                                                                 |\r
| Thread(ThreadGroup group, Runnable target)                                                           |\r
| Thread(ThreadGroup group, String name)                                                               |\r
| Thread(ThreadGroup group, Runnable target, String name)                                              |\r
| Thread(ThreadGroup group, Runnable target, String name, long stackSize)                              |\r
| Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) |\r
\r
Here we can see an example of some of these methods in use\r
\r
\`\`\`java\r
public class ThreadMethodsExample extends Thread {\r
    \r
    ThreadMethodsExample (ThreadGroup group, String name) {\r
        // Call to parent class constructor with group and thread name\r
        super(group, name);\r
    }\r
    \r
    @Override\r
    public void run() {\r
        String threadName = Thread.currentThread().getName();\r
        System.out.println("["+threadName+"] " + "Inside the thread");\r
        System.out.println("["+threadName+"] " + "Priority: " \r
          + Thread.currentThread().getPriority());\r
        Thread.yield();\r
        System.out.println("["+threadName+"] " + "Id: " \r
          + Thread.currentThread().getId());\r
        System.out.println("["+threadName+"] " + "ThreadGroup: " \r
          + Thread.currentThread().getThreadGroup().getName());\r
        System.out.println("["+threadName+"] " + "ThreadGroup count: " \r
          + Thread.currentThread().getThreadGroup().activeCount());\r
    } \r
    \r
    public static void main(String[] args) {\r
        // main thread \r
        Thread.currentThread().setName("Main");\r
        System.out.println(Thread.currentThread().getName());\r
        System.out.println(Thread.currentThread().toString());\r
        \r
        ThreadGroup even = new ThreadGroup("Even threads");\r
        ThreadGroup odd = new ThreadGroup("Odd threads");\r
        \r
        Thread localThread = null;\r
        for (int i=0; i<10; i++) {\r
            localThread = new ThreadMethodsExample((i%2==0)?even:odd, "Thread"+i);\r
            localThread.setPriority(i+1);\r
            localThread.start();\r
        }\r
              \r
        try {\r
            localThread.join(); // --> Will wait until last thread ends \r
                                // like a waitFor() for processes\r
        } catch (InterruptedException ex) {\r
            ex.printStackTrace();\r
            System.err.println("The main thread was interrupted while waiting for " \r
              + localThread.toString() + "to finish");\r
        }\r
        System.out.println("Main thread ending");\r
    }    \r
}\r
\`\`\`\r
\r
As you can see in the code above, the static method Thread.currentThread() should be called in order to get the instance of the current thread running each statement, as there are many threads running the same code at the same time.\r
\r
In the previous example we have used just one class for the new threads and for the main thread. And that's not the usual way to run threads. It's a better practice to split the code in separate classes.\r
\r
Also note that the Thread (or Runnable) class can have it's own constructor to set its local properties or call the superclass constructors.\r
\r
:::question Split the code in two classes\r
Copy the code from the ThreadMethodsExample and split in in two classes. One containing the thread class and the other just having the main method and the calls to create and launch the processes.\r
\r
Next, change the ThreadMethodsExample to implement the Runnable interface and make the appropriate changes in the other class to make it work again.\r
:::\r
\r
Pay attention to  even if the threads are started in sequence (1, 2, 3 etc.) they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out. This is because the threads are in principle executing in parallel and not sequentially. The JVM and/or operating system determines the order in which the threads are executed. This order does not have to be the same order in which they were started nor each time the are run.\r
\r
### Pause a thread\r
\r
A thread can pause itself by calling the static method **Thread.sleep()**. The sleep() takes a number of milliseconds as parameter. The sleep() method will attempt to sleep that number of milliseconds before resuming execution. The Thread sleep() is not 100% precise, but it is pretty good still. Here is an example of pausing a Java thread for 3 seconds (3.000 milliseconds) by calling the Thread sleep() method:\r
\r
\`\`\`java:no-line-numbers\r
try {\r
    Thread.sleep(3000L);\r
} catch (InterruptedException e) {\r
    e.printStackTrace();\r
}\r
\`\`\`\r
\r
::: info Real systems simulation\r
This method is going to be used in activities to simulate time lapses and speed up the real systems simulation. For instance, we can set that each *real* hour is just a second in the simulation, so one day will be reduced to 24 seconds.\r
\r
Also it's interesting when we need to set random time lapses for each thread, in order to get a realistic simulation of events in the real system.\r
:::\r
\r
Random numbers within a specific range of type integer, float, double, long, and boolean can be generated in Java.\r
\r
There are three methods to generate random numbers in Java.\r
\r
#### Method 1: Using random class\r
\r
We can use the \`java.util.Random\` class to generate random numbers, following the steps below:\r
\r
- Import the class java.util.Random\r
- Make the instance of the class Random, i.e., Random rand = new Random()\r
- Invoke one of the following methods of rand object:\r
  - nextInt(upperbound) generates random numbers in the range 0 to upperbound-1.\r
  - nextFloat() generates a float between 0.0 and 1.0.\r
  - nextDouble() generates a double between 0.0 and 1.0.\r
  \r
if we use the netxInt invocation with the bound parameter, we'll get numbers within a range\r
\r
> int randomIntWithinARange = random.nextInt(max)\r
\r
This will give us a number between *0 (inclusive)* and *max* (exclusive). The bound parameter must be greater than 0. Otherwise, we'll get a java.lang.IllegalArgumentException.\r
\r
#### Method 2: Using Math.random\r
\r
For generating random numbers within a range using Math.random(), follow the steps below:\r
\r
- Declare the minimum value of the range\r
- Declare the maximum value of the range\r
- Use the formula Math.random()*(max-min)+min to generate values with the min and the max value inclusive.\r
\r
The value returned by Math.random() is in the range 0 to 1 inclusive.\r
\r
To generate a random value between 0 and an upper limit (50)\r
\r
> Math.random()*50\r
\r
To generate a random value between 1 and an upper limit (50)\r
\r
> Math.random()*49+1\r
\r
To generate a random bounded value, let's say between 200 and 500\r
\r
> Math.random()*300+200\r
\r
#### Method 3: Use ThreadLocalRandom\r
\r
The \`java.util.Random\` class doesn't perform well in a multi-threaded environment.\r
\r
In a simplified way, the reason for the poor performance of Random in a multi-threaded environment is due to contention  given that multiple threads share the same Random instance.\r
\r
To address that limitation, Java introduced the \`java.util.concurrent.ThreadLocalRandom\` for generating random numbers in a multi-threaded environment.\r
\r
We just need to call \`ThreadLocalRandom.current()\` method, and it will return the instance of ThreadLocalRandom for the current thread. We can then generate random values by invoking available instance methods of the class.\r
\r
To generate a random int value without any bounds:\r
\r
> int unboundedRandomValue = ThreadLocalRandom.current().nextInt());\r
\r
To generate a random bounded int value, meaning a value between a given lower and upper limit.\r
\r
> int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);\r
\r
Please note, 0 is the inclusive lower limit and 100 is the exclusive upper limit.\r
\r
We can generate random values for long and double by invoking \`nextLong()\` and \`nextDouble()\` methods in a similar way as shown in the examples above.\r
  \r
### Threads priority management\r
\r
In Java, a thread's priority is an integer in the range 1 to 10. *The larger the integer, the higher the priority*. The thread scheduler uses this integer from each thread to determine which one should be allowed to execute. The Thread class defines three types of priorities:\r
\r
- Minimum priority\r
- Normal priority\r
- Maximum priority\r
  \r
The Thread class defines these priority types as constants \`MIN_PRIORITY\`, \`NORM_PRIORITY\`, and \`MAX_PRIORITY\`, with values 1, 5, and 10, respectively. **NORM_PRIORITY is the default priority for a new Thread**.\r
\r
Java's Thread class provides methods for checking the threads priority and for modifying it.\r
\r
The \`getPriority()\` instance method returns the integer that represents its priority.\r
\r
The \`setPriority()\` instance method takes an integer between 1 and 10 for changing the thread's priority. If we pass a value outside the 1-10 range, the method will throw an error.\r
\r
When we create a Thread, it inherits its default priority. When multiple threads are ready to execute, the JVM selects and executes the Runnable thread that has the highest priority. If this thread stops or becomes not runnable, the lower-priority threads will execute. In case two threads have the same priority, the JVM will execute them in FIFO order.\r
\r
There are two scenarios that can cause a different thread to run:\r
\r
- A thread with higher priority than the current thread becomes runnable\r
- The current thread exits the runnable state or yields (temporarily pause and allow other threads)\r
\r
In general, at any time, the highest priority thread is running. But sometimes, the thread scheduler might choose low-priority threads for execution to avoid starvation.\r
\r
\`\`\`java\r
class U3S3_HiloPrioridad1 extends Thread {\r
  private long c = 0;\r
  private boolean stopHilo = false;\r
  public long getContador () {\r
    return c;\r
  }\r
  public void pararHilo() {\r
    stopHilo = true;\r
  }\r
  @Override\r
  public void run() {\r
    while (!stopHilo) c++;\r
  }\r
}\r
\r
public class U3S3_EjemploHiloPrioridad1 {\r
  public static void main(String args[]) {\r
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();\r
\r
    h1.setPriority(Thread.NORM_PRIORITY);\r
    h2.setPriority(Thread.MAX_PRIORITY);\r
    h3.setPriority(Thread.MIN_PRIORITY);\r
\r
    h1.start();\r
    h2.start();\r
    h3.start();\r
\r
    try {\r
      Thread.sleep(10000);\r
        } catch (InterruptedException e) {}\r
\r
    h1.pararHilo();\r
    h2.pararHilo();\r
    h3.pararHilo();\r
\r
    System.out.println("h2 (Prio. Mx: "+h2.getContador());\r
    System.out.println("h1 (Prio. Normal: "+h1.getContador());\r
    System.out.println("h3 (Prio. Mnima: "+h3.getContador());\r
  }\r
}\r
\`\`\`\r
`]},{title:"3.2 Threads synchronization and communication",headers:[{level:2,title:"3.2.1. Shared memory",slug:"_3-2-1-shared-memory",link:"#_3-2-1-shared-memory",children:[]},{level:2,title:"3.2.2. Synchronization",slug:"_3-2-2-synchronization",link:"#_3-2-2-synchronization",children:[{level:3,title:"Monitors and locks",slug:"monitors-and-locks",link:"#monitors-and-locks",children:[]},{level:3,title:"Critical sections",slug:"critical-sections",link:"#critical-sections",children:[]},{level:3,title:"Synchronized and Data Visibility",slug:"synchronized-and-data-visibility",link:"#synchronized-and-data-visibility",children:[]}]},{level:2,title:"3.2.3 Inter-Thread synchronization",slug:"_3-2-3-inter-thread-synchronization",link:"#_3-2-3-inter-thread-synchronization",children:[]}],path:"/en/unit3/synchronization.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.2 Threads synchronization and communication\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.2 Threads synchronization and communication" />\r
\r
# 3.2 Threads synchronization and communication\r
\r
[[toc]]\r
\r
::: info Multithread Vocabulary\r
\r
- **Race condition**: A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.\r
- **Deadlock**: Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. Deadlock occurs when multiple threads need the same locks but obtain them in different order.\r
- **Critical section**: A critical section is a section of code that is executed by multiple threads and where the sequence of execution for the threads makes a difference in the result of the concurrent execution of the critical section. It needs to be executed without outside interference - i.e. without another thread potentially affecting/being affected by "intermediate" states within the section.\r
- **Thread-safe**: A class (or chunk of code) is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and **with no additional synchronization or other coordination on the part of the calling code**.\r
\r
:::\r
\r
## 3.2.1. Shared memory\r
\r
Usually threads need to communicate with each other. The most common way of communication is sharing a common object.\r
\r
Let's code an example where two threads share the same Contador instance.\r
\r
![alt_text](../../media/unit3/SumadorRestador_uml.jpg)\r
\r
<!--\r
\`\`\`puml\r
class Contador {\r
  - int c = 0\r
  + Contador(int c)\r
  +void incrementa()\r
  +void decrementa()\r
  + int valor()\r
}\r
class Sumador extends Thread {\r
  - Contador c\r
  + Sumador(String name, Contador c)\r
  + void run()\r
\r
}\r
class Restador implements Runnable{\r
  - Contador c\r
  + Restador(String name, Contador c)\r
  + void run()\r
\r
}\r
Restador o-- Contador\r
Sumador o-- Contador\r
\`\`\`\r
-->\r
\r
To test the shared object, there must be just another class - containing the main method - to create the shared object (with init value of 100) and to launch the Sumador and Restador threads. In Sumador class we call the Contador.incrementa method in order to add 1 the Contador c property, and similarly Restador calls the decrementa method to substract 1 on Contador c property. Each thread will repeat the same action 300 times, waiting a random time between 50ms and 150ms.\r
It is very relevant to use the same Contador object as parameter for Sumador and Restador, to make sure they are sharing the same Contador instance.\r
\r
::: question Expected behaviour\r
Write the four classes attending to the Class diagram. Make sure to have Sumador extending Thread and Restador implementing Runnable to test differences in how a thread is obtained from each approach.\r
\r
What should happen after running the code?\r
\r
Check what it really happens. Try to run the program many times.\r
:::\r
\r
:::details Code for the example\r
\r
\`\`\`java{4,7,9}\r
public class U3S3_SharedMemory {\r
  public static void main(String[] args) throws InterruptedException {\r
    // Inicializar el objeto Contador\r
    Contador c = new Contador(100);\r
    \r
    // Crear y lanzar 2 hilos (Sumador + Restador)\r
    Sumador s1 = new Sumador("Sumador1", c);\r
    Restador r1 = new Restador("Restador1", c);\r
    Thread h1 = new Thread(r1);\r
    \r
    s1.start();\r
    h1.start();\r
    \r
    // El hilo principal espera a que los hilos s1 y r1 terminen\r
    s1.join();\r
    h1.join();\r
    \r
    System.out.println("El valor final de c es " + c.valor());\r
    \r
  }\r
\`\`\`\r
\r
\`\`\`java\r
public class Contador {\r
  private int c = 0;\r
  \r
  public Contador(int c) {\r
    this.c = c;\r
  }\r
  \r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
  \r
  public int valor() {\r
    return c;\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,5,14}\r
public class Sumador extends Thread {\r
  private Contador c;\r
  public Sumador(String name, Contador c) {\r
    // To set the thread name we can access the Thread class constructor\r
    super(name);\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.incrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());\r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }\r
    }\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,3,13,17}\r
public class Restador implements Runnable {\r
  private Contador c;\r
  private String name;\r
  public Restador(String name, Contador c) {\r
    // Restador doesn't extend Thread, so it cannot call the Thread constructor\r
    // super(name);\r
    this.name = name;\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    Thread.currentThread().setName(this.name);\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.decrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());              \r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }      \r
    }    \r
  }\r
}\r
\`\`\`\r
\r
If we run the code, sometimes it will end by showing a final value of 100 for c, what it should be expected. But if you run the code many times you'll find that sometimes the value can be 99, 101 or any other value.\r
\r
To avoid this synchronization problems (random problems really hard to detect), we need the threads to be synchronized.\r
:::\r
\r
if we check the above problem, we'll find that we are trying to run this code in parallel, from different threads, on the same object instance (shared instance):\r
\r
\`\`\`java\r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
\`\`\`\r
\r
If we apply Bernstein conditions, we well get that none of the three conditions are met, so this code cannot be run concurrently, at least not without having concurrency problems.\r
\r
So, we have to set a special configuration in our code in order to avoid this code to be run simultaneously.\r
\r
## 3.2.2. Synchronization\r
\r
As we have previously seen, threads communicate primarily by sharing access to objects and their properties. This form of communication is extremely efficient but makes two kinds of errors possible:\r
\r
- thread interference\r
- memory consistency errors.\r
\r
The tool needed to prevent these errors is synchronization.\r
\r
When one thread is able to observe the effects of other threads and may be able to detect that variable accesses become visible to other threads in a different order than executed or specified in the program, we talk about reorderings, usually happening with incorrectly synchronized multithread programs. Most of the time, one thread doesnt care what the other is doing. But when it does, thats what synchronization is for.\r
\r
### Monitors and locks\r
\r
To synchronize threads, Java uses \`monitors\`, which are a high-level mechanism for allowing only one thread at a time to execute a region of code protected by the monitor. The behavior of monitors is explained in terms of locks; **there is a lock associated with each object**.\r
\r
Synchronization has several aspects. The most well-understood is \`mutual exclusion\`  **only one thread can hold a monitor at once**, so synchronizing on a monitor means that once one thread enters a synchronized block protected by a monitor, no other thread can enter a block protected by that monitor until the first thread exits the synchronized block.\r
\r
But there is more to synchronization than mutual exclusion. Synchronization ensures that memory writes by a thread before or during a synchronized block are made visible in a predictable manner to other threads that synchronize on the same monitor.\r
\r
::: info Volatile-like behaviour\r
After we exit a synchronized block, we release the monitor, which has the effect of flushing the cache to main memory, so that writes made by this thread can be visible to other threads. Before we can enter a synchronized block, we acquire the monitor, which has the effect of invalidating the local processor cache so that variables will be reloaded from the main memory.\r
:::\r
\r
### Critical sections\r
\r
Synchronized blocks in Java are marked with the \`synchronized\` keyword. A synchronized block in Java is synchronized with some objects. All synchronized blocks synchronized on the same object can only have one thread executing inside them at the same time. All other threads attempting to enter the synchronized block are blocked until the thread inside the synchronized block exits the block.\r
\r
The synchronized keyword can be used to mark four different types of blocks:\r
\r
- Instance methods\r
- Static methods\r
- Code blocks inside instance methods\r
- Code blocks inside static methods\r
\r
Here is a synchronized instance method:\r
\r
\`\`\`java{3}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
}\r
\`\`\`\r
\r
Notice the use of the synchronized keyword in the add() method declaration. This tells Java that the method is synchronized.\r
\r
A synchronized instance method in Java is synchronized on the instance (object) owning the method. Thus, each instance has its synchronized methods synchronized on a different object: the owning instance.\r
\r
Only one thread per instance can execute inside a synchronized instance method. If more than one instance exists, then one thread at a time can execute inside a synchronized instance method per instance. One thread per instance.\r
\r
This is true across all synchronized instance methods for the same object (instance). Thus, in the following example, only one thread can execute inside either of the two synchronized methods. One thread in total per instance:\r
\r
\`\`\`java{3,6}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
 public synchronized void sub(int value){\r
   this.count -= value;\r
 }\r
}\r
\`\`\`\r
\r
::: info Synchronized with static methods\r
Synchronized static methods are synchronized on the **class object** of the class the synchronized static method belongs to. Since **only one class object exists in the Java VM per class**, only one thread can execute inside a static synchronized method in the same class.\r
:::\r
\r
You do not have to synchronize a whole method. Sometimes it is preferable to synchronize only part of a method. Java synchronized blocks inside methods make this possible.\r
Here is a synchronized block of Java code inside an unsynchronized Java method:\r
\r
\`\`\`java{2}\r
public void add(int value){\r
  synchronized(this){\r
    this.count += value;  \r
  }\r
 }\r
\`\`\`\r
\r
This example uses the Java synchronized block construct to mark a block of code as synchronized. This code will now execute as if it was a synchronized method.\r
\r
Notice how the Java synchronized block construct takes an object in parentheses. In the example this is used, which is the instance the add method is called on. The object taken in the parentheses by the synchronized construct is called a monitor object. The code is said to be synchronized on the monitor object. **A synchronized instance method uses the object it belongs to as a monitor object**.\r
\r
Only one thread can execute inside a Java code block synchronized on the same monitor object.\r
\r
The following two examples are both synchronized on the instance they are called on. **They are therefore equivalent with respect to synchronization**:\r
\r
\`\`\`java{2,8}\r
public class MyClass { \r
  public synchronized void log1(String msg1, String msg2){\r
    log.writeln(msg1);\r
    log.writeln(msg2);\r
  }\r
 \r
  public void log2(String msg1, String msg2){\r
    synchronized(this){\r
     log.writeln(msg1);\r
     log.writeln(msg2);\r
    }\r
  }\r
 }\r
\`\`\`\r
\r
Thus only a single thread can execute inside either of the two synchronized blocks in this example.\r
\r
::: warning What Objects to Synchronize On\r
The synchronized block must be synchronized on some object. You can actually choose any object to synchronize on, but **it is recommended that you do not synchronize on String objects, or any primitive type wrapper objects** (Integer, Double, Boolean, ...).\r
\r
To be on the safe side, synchronize on this - or on a new Object() . Those are not cached or reused internally by the Java compiler, Java VM, or Java libraries.\r
:::\r
\r
### Synchronized and Data Visibility\r
\r
Without the use of the synchronized keyword (or the Java \`volatile\` keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g. via an object all threads have access to), that the other threads can see the changed value. There are no guarantees about when a variable kept in a CPU register by one thread is "committed" to main memory, and there is no guarantee about when other threads "refresh" a variable kept in a CPU register from main memory.\r
\r
The synchronized keyword changes that.\r
\r
- When a thread enters a synchronized block it will refresh the values of all variables visible to the thread.\r
- When a thread exits a synchronized block all changes to variables visible to the thread will be committed to the main memory.\r
\r
This is similar to how the volatile keyword works.\r
\r
## 3.2.3 Inter-Thread synchronization\r
\r
We can avoid several threads run the same code at the same time by using the \`synchronized\` keyword in order to get \`mutual exclusion\` in the form of \`critical sections\`.\r
Sometimes it can be enough, but others we need the threads to keep certain order in their execution, probably related to other threads previous actions or results.\r
\r
To do so, we need to use three new methods from the object class, directly related to synchronized.\r
\r
- **wait()**: When you call wait method on the object then it tell threads to \`give up the lock\` and go to sleep state unless and until some other thread enters in same monitor and calls notify or notifyAll methods on it.\r
- **notify()**: When you call notify method on the object, it \`wakes one of thread waiting for that object\`. So if multiple threads are waiting for an object, it will wake of one of them. Now you must be wondering which one it will wake up. It actually depends on OS implementation.\r
- **notifyAll()**: notifyAll will \`wake up all threads waiting on that object\` unlike notify which wakes up only one of them. Which one will wake up first depends on thread priority and OS implementation.\r
\r
wait , notify and notifyAll method are used to allow threads to communicate to each other via accessing common object. This common object can be considered a medium for \`inter thread communication\`via these methods. **These methods need to be called from synchronized context**,otherwise it will throw java.lang.IllegalMonitorStateException.\r
\r
When **wait()** method is called, the thread is running inside the synchronized block so it will own the monitor (lock) for the object. That monitor is released by the thread and the thread is locked into another **queue (from the lock object) of threads waiting to be notified**, different than the queue of threads waiting for the object monitor (lock).\r
\r
When a thread is unlocked because another thread has called **notify()/notifyAll()** on the same object, the thread goes back to the point where the wait was made, so the thread is still into a synchronized block. To keep on running, the thread goes back to the **queue of threads waiting for the object monitor (lock)** and it has to wait until it gets the lock to run the sentences after the wait().\r
\r
![Monitor queues](../../media/unit3/Monitor_queues.png)\r
\r
Let's learn how these methods work by looking at the following example\r
\r
\`\`\`java\r
// It is the common java class on which thread will act and call wait and notify method.\r
public class Book {\r
 String title;\r
 boolean isCompleted;\r
 \r
 public Book(String title) {\r
 super();\r
 this.title = title;\r
 }\r
 \r
 public String getTitle() {\r
 return title;\r
 }\r
 public void setTitle(String title) {\r
 this.title = title;\r
 }\r
 public boolean isCompleted() {\r
 return isCompleted;\r
 }\r
 public void setCompleted(boolean isCompleted) {\r
 this.isCompleted = isCompleted;\r
 } \r
}\r
\`\`\`\r
\r
\`\`\`java{14,17}\r
// It will first take a lock on book object \r
// Then, the thread will wait until other thread call notify method, then after it will complete its processing. \r
// So in this example, it will wait for BookWriter to complete the book.\r
public class BookReader implements Runnable{\r
 Book book;\r
 \r
 public BookReader(Book book) {\r
 super();\r
 this.book = book;\r
 }\r
 \r
 @Override\r
 public void run() {\r
 synchronized (book) {\r
  System.out.println(Thread.currentThread().getName()+" is waiting for the book to be completed: "+book.getTitle());\r
  try {\r
  book.wait();\r
  } catch (InterruptedException e) {  \r
  e.printStackTrace();\r
  }\r
  System.out.println(Thread.currentThread().getName()+": Book has been completed now!! you can read it");\r
 }\r
 } \r
}\r
\`\`\`\r
\r
\`\`\`java{15,22,25}\r
// This class will notify thread(in case of notify) which is waiting on book object. \r
// It will not give away lock as soon as notify is called, it first complete its synchronized block. \r
// So in this example, BookWriter will complete the book and notify it to BookReaders. \r
public class BookWriter implements Runnable{\r
\r
 Book book;\r
 \r
 public BookWriter(Book book) {\r
 super();\r
 this.book = book;\r
 }\r
 \r
 @Override\r
 public void run() {\r
 synchronized (book) {\r
  System.out.println("Author is Starting book : " +book.getTitle() );\r
  try {\r
  Thread.sleep(1000);\r
  } catch (InterruptedException e) {\r
  e.printStackTrace();\r
  }\r
  book.setCompleted(true);\r
  System.out.println("Book has been completed now");\r
 \r
  book.notify();\r
  System.out.println("notify one reader");\r
 } \r
 }\r
}\r
\`\`\`\r
\r
\`\`\`java{8,9,26}\r
// This is our main class which will create object of above classes and run it.\r
public class U3S5_Books {\r
 \r
 public static void main(String args[])\r
 {\r
 // Book object on which wait and notify method will be called\r
 Book book=new Book("The Alchemist");\r
 BookReader johnReader=new BookReader(book);\r
 BookReader arpitReader=new BookReader(book);\r
 \r
 // BookReader threads which will wait for completion of book\r
 Thread johnThread=new Thread(johnReader,"John");\r
 Thread arpitThread=new Thread(arpitReader,"Arpit");\r
 \r
 arpitThread.start();\r
 johnThread.start();\r
 \r
 // To ensure both readers started waiting for the book\r
 try {\r
  Thread.sleep(3000);\r
 } catch (InterruptedException e) {\r
 \r
  e.printStackTrace();\r
 }\r
\r
 // BookWriter thread which will notify once book get completed\r
 BookWriter bookWriter=new BookWriter(book);\r
 Thread bookWriterThread=new Thread(bookWriter);\r
 bookWriterThread.start();\r
 }\r
}\r
\`\`\`\r
\r
There must be a notify call for every wait to ensure we have no deadlocks in our app.\r
\r
::: question Does order matter?\r
If we run the previous code, we have to ask ourselves:\r
\r
- a) How many wait() are done? And how many notify()?\r
\r
Just by looking at the code, we can see that there are 2 wait() and 1 notify(). Something doesn't fit.\r
\r
One of the readers is not notified, so a thread is waiting in a wait(). As that thread doesn't finish, the process doesn't either. We have to remember that a process doesn't finish until the last of its threads does. In Netbeans, this means the program doesn't end and we have to stop it.\r
\r
**Solution**: In this case we have two alternatives. The first one is to use notifyAll() instead of notify(). This way, both BookReaders are activated and they wait to take the monitor lock. One will do it first and the other one later, but both will end up reading the book.\r
The other option is, following with notify(), that each reader, when finishing reading the book, notifies other possible readers waiting so that one wakes up and reads the book.\r
\r
- b) What will happen to the above code if we change the order for the Readers and Writer in the main method? That is, first we make sure the Book is finished and then we call the Readers. What if we start all threads at the same time and we don't know in which order they will run? What if we start the Readers first and then the Writer?\r
\r
If the BookWriter is launched first, it finishes the book and notifies... nobody, because the BookReaders are not waiting yet. Then the BookReaders arrive and both get stuck, as no other thread will notify them.\r
\r
**Solution**: Threads are now blocking indiscriminately, but they should only block if the book they want to read is not finished. Therefore, we have to control the blocking of the BookReader with a condition. As we have commented, the conditions must be in the shared object, in this case book, shared by BookWriter and the two BookReader. The condition that allows us to discriminate if a BookReader can continue or not is the isCompleted property that we consult through the book.isCompleted() method.\r
\r
\`\`\`java\r
try {\r
  if (!book.isCompleted())\r
    book.wait();\r
} catch (InterruptedException e) { \r
\`\`\`\r
\r
With these two changes, the application should work with any number of BookReaders and BookWriters, regardless of the order or the amount.\r
:::\r
\r
::: info notify() o notifyAll()?\r
All will depend on the system we are programming, but as a general rule, if we want only one thread to continue after modifying the system state, we will call notify().\r
\r
Otherwise, notifyAll() should be used. If everything is well programmed, the thread will check if it can continue and, if not, it will wait() again and continue waiting, so it is not a problem that more than one thread is activated.\r
\r
The use of notify() poses a greater risk of indefinite blocking of threads waiting for notifications that will never arrive, this blocking being different from a deadlock. We must be very careful with the programming of synchronization mechanisms.\r
\r
It should also be noted that there should be at least one notify() call for each wait() that has been made, although that does not ensure that some thread will not be blocked.\r
:::\r
\r
::: question Modifify previous Sumador-Restador\r
Make the necessary changes in the classes of the U3S3_SharedMemory project (save it as U3S3_SharedMemory_v2) so that:\r
\r
- The first thread that performs an operation on the counter is a Sumador\r
- After a Sumador, a Restador is always executed and after a Restador, a Sumador is always executed, making a sequence Sumador-Restador-Sumador-Restador-...\r
:::\r
\r
::: details U3S3_SharedMemory_v2\r
\r
\`\`\`java\r
public class Contador {\r
\r
    private int c = 0;\r
    boolean ahoraSumador = true;\r
\r
    public Contador(int c) {\r
        this.c = c;\r
        ahoraSumador = true;\r
    }\r
\r
    public synchronized void incrementa() {\r
        while (!ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) {\r
            }\r
        }\r
\r
        // El hilo hace su tarea\r
        c++;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = false;\r
        notifyAll();\r
\r
    }\r
\r
    public synchronized void decrementa() {\r
        while (ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) { }\r
        }\r
\r
        // El hilo hace su tarea\r
        c--;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = true;\r
        notifyAll();\r
    }\r
\r
    public int valor() {\r
        return c;\r
    }\r
}\r
\`\`\`\r
\r
In Contador class a new state variable has been added to control the threads order, which one has to wait and which one can run its code.\r
\r
Furthermore, output from the threads run method has been moved into the synchronized methods in this class.\r
\r
\`\`\`java\r
public class Restador  implements Runnable {\r
    private Contador c;\r
    private String name;\r
    public Restador(String name, Contador c) {\r
        // super(name);\r
        this.name = name;\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        Thread.currentThread().setName(this.name);\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.decrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }        \r
    }\r
}\r
\`\`\`\r
\r
Restador and Sumador have few changes.\r
\r
\`\`\`java\r
public class Sumador  extends Thread {\r
    private Contador c;\r
    public Sumador(String name, Contador c) {\r
        super(name);\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.incrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }\r
    }\r
}\r
\`\`\`\r
\r
Main class remains equal.\r
\r
::: danger Synchronized output\r
As you can see from the previous code, the output originally in the threads' run methods now is into Contador class methods, more specifically into the \`synchronized\` methods.\r
\r
Careful with console output. All threads are in a \`race condition\` to use the System.out stream. The concequence is that what we see on the console doesn't match the order in which the output has been sent to the stream. That's why is so important to move the console output into the synchronized methods, when possible.\r
\r
If we don't control the console output we can have well coded and solved problems but in the console we will see wrong results.\r
:::\r
\r
`]},{title:"4 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit4/",pathLocale:"/en/",extraFields:[`---\r
title: 4 Introduction\r
---\r
\r
# Unit 4. Network programming\r
\r
---\r
\r
We have already studied how independent applications can collaborate to do a task (\`multiprocess\`) or just how to divide a program in many execution threads to be run simultaneously and even concurrently (\`multithread\`). But all this happens inside one computer, it can be **monoprocessor** or **multiprocessor**, under the same OS and sharing memory and I/O.\r
\r
In this unit we are going one step forward, we are going to code applications working on distributed environments. Once again we will have multiple processes running, but instead having a parent-child (launcher-launched) relationship, now the processes will be run on independent systems, and what's more interesting, the will communicate through the network by using \`communication protocols\`.\r
\r
Basically we can classify distributed systems in two groups::\r
\r
- **Client / Server**: where one process, called the \`server\`, offers services to one or more processes, called \`clients\`.\r
- **Peer to peer (P2P)**: where all the processes collaborate in a similar way without any particular specialization or difference among them.\r
\r
::: warning Processes and Threads\r
To make a distributed application, with processes and network communication, we are not starting form the scratch.\r
\r
Network programming is strongly linked with multiprocess programming. We will see how communication between process is exactly the same as through the network.\r
\r
On the other side, the specialization and service offered by a server, simultaneously to many clients, is based on the multithread approach..\r
\r
All the above, all concepts and knowledge acquired from unit 1 to unit 3, will be the scaffold to start creating distributed applications.\r
:::\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know about TCP/IP protocol, addresses used in each protocol layer and associated protocols.\r
- To know Java classes tp work with Internet addresses and server names.\r
- To learn about basic TPC and UPD protocols features.\r
- To code applications that use TCP protocol for communication purposes.\r
- To code applications that use UDP protocol for communication purposes.\r
- To design and code protocols for distributed applications.\r
- to coordinate multiple client access to servers by using multithread programming.\r
`]},{title:"4.2 TCP Sockets",headers:[{level:2,title:"4.2.1. Comunicacin cliente/servidor con sockets TCP",slug:"_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",link:"#_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",children:[{level:3,title:"Programacin de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.2.2. Cliente TCP",slug:"_4-2-2-cliente-tcp",link:"#_4-2-2-cliente-tcp",children:[{level:3,title:"Streams para E/S en los sockets",slug:"streams-para-e-s-en-los-sockets",link:"#streams-para-e-s-en-los-sockets",children:[]}]},{level:2,title:"4.2.3 Servidor TCP",slug:"_4-2-3-servidor-tcp",link:"#_4-2-3-servidor-tcp",children:[]},{level:2,title:"4.2.4 Servidor multihilo",slug:"_4-2-4-servidor-multihilo",link:"#_4-2-4-servidor-multihilo",children:[]}],path:"/en/unit4/sockets-tcp.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.2 TCP Sockets\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 TCP Sockets" />\r
\r
# 4.2 TCP Sockets\r
\r
[[toc]]\r
\r
## 4.2.1. Comunicacin cliente/servidor con sockets TCP\r
\r
Oracle ha resumido el uso de los sockets en un breve tutorial. Todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)\r
\r
La interfaz Java que da soporte a sockets TCP est constituida por las clases **ServerSocket** y **Socket**.\r
\r
- ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexin de los clientes. Su mtodo \`accept\` toma una peticin de conexin de la cola, o si la cola est vaca, se bloquea hasta que llega una peticin.\r
  \r
  El resultado de ejecutar accept es una instancia de Socket, a travs del cual el servidor tiene acceso a los datos enviados por el cliente.\r
\r
- Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, as se crea el socket local y adems se conecta con el servicio.\r
  \r
  Esta clase proporciona los mtodos \`getInputStream\` y \`getOutputStream\` para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir \`BufferedReader\` y \`PrintWriter\`, respectivamente, para poder procesar los datos de forma ms sencilla.\r
\r
### Programacin de aplicaciones Cliente y/o Servidor\r
\r
Al crear aplicaciones cliente y servidor puede que nos encontremos con varios escenarios, a saber:\r
\r
- Si tenemos que programar solo el servidor **deberemos definir un protocolo** de comunicacin para usar ese servidor.\r
- Si tenemos que programar solo el cliente **necesitaremos conocer el protocolo** de comunicacin para conectar con ese servidor.\r
- Si tenemos que programar el cliente y el servidor, tendremos que empezar por **definir el protocolo** de comunicacin entre ambos.\r
\r
::: info Herramientas para definir los protocolos\r
Dentro de todos los diagramas que ofrece UML, el diagrama de secuencia es el que mejor se adapta para definir los protocolos de comunicacin entre clases y las interacciones que se producen.\r
\r
Para crear estos diagramas existen multitud de herramientas, tanto de escritorio como online. De todas ellas cabe destacar:\r
\r
- [Mermaid Live editor](https://mermaid.live/) que usa una [sintaxis en modo texto](https://mermaid-js.github.io/mermaid/#/sequenceDiagram) para definir los diagramas.\r
- [WebSequenceDiagrams](https://www.websequencediagrams.com/): Ms visual y tambin con una definicin textual de los diagramas.\r
- [Visual Paradigm Online](https://online.visual-paradigm.com/drive/#diagramlist:proj=0&dashboard): Herramienta totalmente visual y con unos resultados ms espectaculares.\r
\r
Estas herramientas son las que tenis que usar en las actividades en las que se os pida definir un protocolo de comunicacin cliente / servidor.\r
:::\r
\r
## 4.2.2. Cliente TCP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser:\r
\r
1. Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.\r
2. Obtener las referencias al stream de entrada y al de salida al socket.\r
3. Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar el socket.\r
\r
\`\`\`java{12,14,17,36,38,51,52,54}\r
public class BasicClient {\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est en la misma mquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket("localhost", 4444);\r
            // Obtenemos el canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexin");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenva al servidor hasta que este\r
        // se despide con "Adios"\r
        try {\r
            while (true) {\r
                // Leo la entrada del usuario\r
                linea = stdIn.nextLine();\r
                // La envia al servidor por el OutputStream\r
                salida.println(linea);\r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Enva a la salida estndar la respuesta del servidor\r
                System.out.println("Respuesta servidor: " + linea);\r
                // Si es "Adios" es que finaliza la comunicacin\r
                if (linea.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
\r
        // Libera recursos\r
        salida.close();\r
        entrada.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\r
\`\`\`\r
\r
::: info Herramientas para simular clientes genricos\r
Si slo tenemos que desarrollar un servidor y no tenemos o no queremos hacer un cliente para las pruebas, tenemos varias herramientas que nos ayudan a hacer de clientes genricos, tiles para una gran variedad de servidores, incluso para servidores estndar como FTP, HTTP, etc.\r
\r
La primera herramienta es una aplicacin y un protocolo de nivel de aplicacin de TCP/IP, es la herramienta \`Telnet\`.\r
\r
Esta herramienta suele venir instalada en los sistemas GNU/Linux y OS X. Sin embargo en los sistemas Windows viene deshabilitada por defecto.\r
\r
Os dejo un enlace al artculo de Xataka [Telnet: qu es y cmo activarlo en Windows 10](https://www.xataka.com/basics/telnet-que-como-activarlo-windows-10).\r
\r
Es importante que lo activis tanto en clase como en el aula.\r
\r
La segunda herramienta es NetCat. Es una herramienta muy verstil y potente, ya que no slo puede hacernos de cliente, sino que tambin puede servir como servidor.\r
\r
Como muchas otras herramientas, esta tambin viene instalada de serie en GNU/Linux y OS X, pero no en Windows. Su uso en los sistemas de Microsoft es algo ms controvertido ya que el sistema la detecta como un malware y tenemos que habilitar su uso en el *Guardian* del SO.\r
\r
Os dejo tambin un enlace a este artculo de IONOS [Qu es Netcat y cmo funciona?](https://www.ionos.es/digitalguide/servidores/herramientas/netcat/)\r
:::\r
\r
### Streams para E/S en los sockets\r
\r
Si vemos ejemplos en Internet o en tutoriales, podemos observar que hay dos formas mayoritarias de enviar y recibir la informacin a travs de los streams que proporciona un socket.\r
\r
![Basic Stream IO](../../media/unit4/basicIOStreams.png)\r
\r
En cualquier caso, a travs de los streams enviamos bytes, que es la forma ms bsica de generar informacin, bien sea a travs de la red o entre procesos.\r
\r
Como es complicado gestionar a nivel de bytes toda la informacin que queremos enviar o recibir, usamos \`Decorators\` o \`Wrappers\` para enviar tipos de datos de un nivel de abstraccin mayor.\r
\r
En los temas anteriores, cuando hemos tenido que intercambiar informacin entre procesos, hemos estado usando BufferedReader y PrintWriter. Estas clases trabajan a nivel de Strings, y son muy tiles cuando lo que queremos intercambiar a travs de los streams son cadenas de texto.\r
\r
> En los protocolos de comunicaciones, ms del 90% de la informacin que se intercambia, a nivel de protocolo, es en formato texto.\r
\r
Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos. \r
\r
\`DataInputStream\` y \`DataOutputStream\` proporcionan mtodos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo nmeros y valores booleanos. \r
\r
![Basic Stream IO](../../media/unit4/streamWrappers.png)\r
\r
DataOutputStream codifica esos valores de forma independiente de la mquina y los enva al stream de ms bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.\r
\r
As, podemos trabajar con DataInputStream y DataOutputStream a partir de los streams que nos proporcionan los sockets\r
\r
\`\`\`java\r
// Cdigo en el cliente\r
DataInputStream dis = new DataInputStream(socket.getInputStream());\r
dis.readDouble();\r
\r
// Cdigo en el servidor\r
DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\r
dis.writeDouble(number);\r
\`\`\`\r
\r
Los mtodos \`readUTF()\` and \`writeUTF()\` de DataInputStream y DataOutputStream leen y escriben un String de caracteres Unicode usando la codificacin UTF-8.\r
\r
::: warning Elige un mtodo y usa siempre el mismo\r
Es muy importante no mezclar diferentes wrappers en el mismo sistema. Aunque todos acaban utilizando el InputStream y el OutputStream, las codificaciones y la forma de enviar la informacin no es la misma.\r
\r
Por lo que, si usas DataInputStream en el cliente para leer, debes usar DataOutputStream en el servidor para enviar. Adems de usar los mtodos complementarios para la lectura y escritura, por ejemplo readInt / writeInt.\r
:::\r
\r
Informacin extrada de [Learning Java, 4th Edition - O'Reilly](https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch12s01.html)\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.3 Servidor TCP\r
\r
La forma de implementar un servidor ser:\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_states.png)\r
\r
1. Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.\r
2. Esperar solicitudes de clientes\r
3. Cuando se produce una solicitud:\r
    - Aceptar la conexin obteniendo un objeto de la clase Socket\r
    - Obtener las referencias al stream de entrada y al de salida al socket anterior.\r
    - Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket.Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar los sockets.\r
\r
\`\`\`java{9,23,26,29,36,40,50,51,52,53}\r
public class BasicServer {\r
\r
    public static final int PORT = 4444;\r
\r
    public static void main(String[] args) throws IOException {\r
        // Establece el puerto en el que escucha peticiones\r
        ServerSocket socketServidor = null;\r
        try {\r
            socketServidor = new ServerSocket(PORT);\r
        } catch (IOException e) {\r
            System.out.println("No puede escuchar en el puerto: " + PORT);\r
            System.exit(-1);\r
        }\r
\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        System.out.println("Escuchando: " + socketServidor);\r
        try {\r
            // Se bloquea hasta que recibe alguna peticin de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexin aceptada: " + socketCliente);\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Hace eco de lo que le proporciona el cliente, hasta que recibe "Adios"\r
            while (true) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
                // Enva a la salida estndar el mensaje del cliente\r
                System.out.println("Cliente: " + str);\r
                // Le enva la respuesta al cliente por el OutputStream                \r
                salida.println(str);\r
                // Si es "Adios" es que finaliza la comunicacin\r
                if (str.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
        salida.close();\r
        entrada.close();\r
        socketCliente.close();\r
        socketServidor.close();\r
    }\r
\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_sequence.png)\r
\r
El servidor monohilo se encarga de realizar las operaciones de E/S con el cliente. Hasta que no acaba no puede hacer otro \`accept\` y atender a otro cliente.\r
\r
::: warning Local Name Resolver (hosts file)\r
You should know that DNS translates domain names like into IP addresses. But did you know that theres a file on your system that can override that?\r
\r
Its called your \`hosts\` file and lets you map specific domain names to an IP address of your choosing. Your HOSTS file only affects your computer, so you can use it to create custom URLs for IP addresses on your network, or you can use it to redirect certain websites.\r
\r
As you can imagine, editing the HOSTS file can easily break your internet if its modified incorrectly or maliciously. So, its not particularly easy for a normal user to edit. This is a good thing.\r
\r
- Windows\r
\r
The HOSTS file is normally stored in a plain text file in the Windows System folder.\r
\r
Hit the start menu or press the Windows key and start typing Notepad.\r
\r
Right-click Notepad and choose Run as administrator.\r
\r
In Notepad, click File then Open In the File name field, paste the following path in:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Now youll be able to edit and save changes to your HOSTS file.\r
\r
To map a domain, add a line based on the examples in the HOSTS file.\r
\r
- OS X & GNU/Linux\r
\r
The file is in /etc/hosts and you should edit it with administrator privileges.\r
\r
\`\`\`bash\r
# Add the following lines to the hosts file\r
## At school\r
##  - use your computer IP for the 'cliente' and 'servidor' entries.\r
##  - use the teacher's computer IP as the 'profesor' entry\r
## At home (IP address can change and probably will be something like 192.168.X.X)\r
##  - use your computer IP for the 'cliente', 'servidor' and 'profesor' entries.\r
\r
# In all the activities, we will always use these domain names \r
# making our apps work at home and at school without having to change any IP address.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.4 Servidor multihilo\r
\r
Si queremos que un servidor pueda atender varias peticiones de forma simultanea, debemos usar hilos para dotarle de esa capacidad.\r
\r
El flujo bsico ahora cambiara para adaptarse a este formato\r
\r
\`\`\`\r
while (true) {\r
\r
    Aceptar la conexin obteniendo un objeto de la clase Socket;\r
\r
    Crear un thread para que se encargue de la comunicacin con ese cliente, es decir, \r
    para que gestione el socket obtenido en el accept.;\r
}\r
\`\`\`\r
![Estados de un servidor multihilo](../../media/unit4/multithread_server_states.png)\r
\r
El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexin de nuevos clientes con los que volver a hacer lo mismo.\r
\r
El servidor multihilo se ayuda de una clase \`Worker\` que hereda de Thread, pudiendo as ejecutarse concurrentemente con el hilo principal.\r
\r
Esta clase \`Worker\` es la encargada de realizar toda la comunicacin con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe  la conexin de un cliente \`ServerSocket.accept()\`.\r
\r
\`\`\`java {6,20,24}\r
public static final int PORT = 4444;\r
public static void main(String[] args)  {\r
    // Establece el puerto en el que escucha peticiones\r
    ServerSocket socketServidor = null;\r
    try {\r
        socketServidor = new ServerSocket(PORT);\r
    } catch (IOException e) {\r
        System.out.println("No puede escuchar en el puerto: " + PORT);\r
        System.exit(-1);\r
    }\r
\r
    Socket socketCliente = null;\r
\r
    System.out.println("Escuchando: " + socketServidor);\r
    try {\r
        \r
        while (true) {\r
            // Se bloquea hasta que recibe alguna peticin de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexin aceptada: " + socketCliente);\r
            // Para seguir aceptando peticiones de otros clientes\r
            // se crea un nuevo hilo que se encargar de la comunicacin con el cliente\r
            new Worker(socketCliente).start();\r
        }\r
                        \r
    ...\r
}    \r
\`\`\`\r
\r
Y esta sera una implementacin estndar de un worker\r
\r
\`\`\`java{13,15,22,26}\r
public class Worker extends Thread {\r
\r
    private Socket socketCliente;\r
    private BufferedReader entrada = null;\r
    private PrintWriter salida = null;\r
\r
    ....\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Realizamos la comunicacin entre servidor y cliente\r
            // **** ES LO QUE CAMBIA EN CADA EJERCICIO ****\r
\r
            // Hacemos una recepcin de informacin desde el cliente\r
            String mensajeRecibido = entrada.readLine();\r
            System.out.println("<-- Cliente: " + mensajeRecibido);\r
            \r
            // Hacemos un envo al cliente\r
            String mensajeEnviado = "Mensaje enviado desde el servidor al cliente";\r
            salida.println(mensajeEnviado);\r
            System.out.println("--> Cliente: " + mensajeEnviado);\r
        }\r
        ....\r
}        \r
\`\`\`\r
\r
Quedando ahora la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/multithread_server_sequence.png)\r
\r
<div class="pagebreak"> </div>\r
\r
::: info Ejecucin de mltiples clientes desde lnea de comandos\r
Para poder lanzar varias aplicaciones java a la vez, la forma ms correcta de hacerlo es desde una terminal de comandos. Esto nos permite poder pasarle argumentos a todas las clases, no slo a la que est marcada como *principal* en el proyecto.\r
\r
Aqu tenemos dos posibilidades, **ejecutar las clases individualmente**, tal y como hacemos desde el IDE o bien **lanzar las clases desde un archivo JAR**.\r
\r
En ambos casos, necesitamos haber compilado y construido el proyecto (*F11  Shift+F11 en Netbeans*).\r
\r
Ejecucin de clases individuales\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener las clases compiladas.\r
- A continuacin, al igual que hacamos con los procesos, debemos ubicarnos en la carpeta \`build/classes\` del proyecto.\r
- Desde ah, ejecutaremos\r
    > build/classes$ java psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuacin del nombre de la clase son los parmetros que la clase recibir en el args[] de su mtodo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > build/classes$ java psp.actividades.U4AX_ClaseSCliente localhost 5566\r
\r
    Si queremos lanzar ms de un cliente, repetiremos el comando desde otra ventana de comandos.\r
\r
Lanzar las clases desde un archivo JAR\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener el proyecto construido\r
- A continuacin, y a diferencia del caso anterior, debemos ubicarnos en el directorio donde est el archivo JAR. Si no lo hemos movido, estar en la carpeta \`dist\` del proyecto.\r
- Desde ah, ejecutaremos, **para la clase principal del proyecto**\r
    > dist$ java -jar U4AX_ProyectoClienteServidor.jar 5566\r
\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuacin del nombre de la clase son los parmetros que la clase recibir en el args[] de su mtodo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseCliente localhost 5566\r
\r
    Si queremos lanzar ms de un cliente, repetiremos el comando desde otra ventana de comandos.\r
:::\r
`]},{title:"4.3 UDP Sockets",headers:[{level:2,title:"4.3.1. Client/Server communication using UDP sockets",slug:"_4-3-1-client-server-communication-using-udp-sockets",link:"#_4-3-1-client-server-communication-using-udp-sockets",children:[{level:3,title:"DatagramSocket",slug:"datagramsocket",link:"#datagramsocket",children:[]},{level:3,title:"DatagramPacket",slug:"datagrampacket",link:"#datagrampacket",children:[]},{level:3,title:"Programacin de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.3.2. Cliente UDP",slug:"_4-3-2-cliente-udp",link:"#_4-3-2-cliente-udp",children:[]},{level:2,title:"4.3.3 Servidor UDP",slug:"_4-3-3-servidor-udp",link:"#_4-3-3-servidor-udp",children:[]},{level:2,title:"4.3.4 Multicast socket",slug:"_4-3-4-multicast-socket",link:"#_4-3-4-multicast-socket",children:[]}],path:"/en/unit4/sockets-udp.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.3 UDP Sockets\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.3 UDP Sockets" />\r
\r
# 4.3 UDP Sockets\r
\r
[[toc]]\r
\r
## 4.3.1. Client/Server communication using UDP sockets\r
\r
Igual que en el apartado anterior, Oracle proporciona una gua son informacin bsica sobre el uso de los Sockets UDP. De nuevo, todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about datagrams](https://docs.oracle.com/javase/tutorial/networking/datagrams/index.html)\r
\r
::: info UDP - Protocolo sin conexin\r
El protocolo de comunicaciones con \`datagramas\` UDP, es un protocolo sin conexin, es decir, cada vez que se enven datagramas es necesario enviar el descriptor del socket local y la direccin del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicacin.\r
\r
Se trata de un servicio de transporte sin conexin. Son ms eficientes que TCP, pero no est garantizada la fiabilidad: los datos se envan y reciben en paquetes, cuya entrega no est garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envi.\r
:::\r
\r
La interfaz Java que da soporte a sockets TCP est constituida por las clases **DatagramPacket** y **DatagramSocket**.\r
\r
- DatagramSocket: es la clase utilizada para realizar el envo y la recepcin de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexin, slo se encarga de transportar los datos del origen al destino.\r
\r
    Lo nico que se hace es enviar los datos, mediante la creacin de un socket y utilizando los mtodos de envo y recepcin apropiados.\r
\r
    Esta clase proporciona los mtodos \`send\` y \`receive\`.\r
\r
- DatagramPackets: esta clase es la encargada de incluir la informacin que se quiere enviar/recibir y la informacin de direccionamiento, es decir, la direccin a la que se quiere enviar l informacin que contiene.\r
  \r
   DatagramPacket contiene la informacin relevante. Cuando se desea recibir un datagrama, ste deber almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no slo debe tener la informacin, sino que adems debe tener la direccin IP y el puerto de destino.\r
\r
::: warning Puertos duplicados UDP / TCP\r
Dado que la gestin de los puertos y el protocolo que se utiliza es diferente, podemos usar el mismo nmero de puerto para un servicio que use el protocolo TCP y otro servicio, en el mismo puerto, que use UDP.\r
\r
En realidad, un socket adems de IP_origen, Puerto_origen, IP_destino, Puerto_destino, tambin incluye el protocolo usado, por eso un socket con el mismo origen y destino, es diferente y puede ser usado a al vez por UDP y TCP\r
\r
**Socket = [Protocolo (TCP/UDP) + IP_origen + Puerto_origen + IP_destino + Puerto_destino]**\r
:::\r
\r
### DatagramSocket\r
\r
Esta clase proporciona los siguiente mtodos\r
\r
| Mtodo | Descripcin |\r
| --- | ----------- |\r
| public DatagramSocket () throws SocketException | Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible. |\r
| public DatagramSocket (int port) throws SocketException | dem, pero con la salvedad de que permite especificar el nmero de puerto asociado. |\r
| public DatagramSocket (int port, InetAddress ip) throws SocketException | Permite especificar, adems del puerto, la direccin local a la que se va a asociar el socket. |\r
| public int getLocalPort() | Retorna el nmero de puerto en el host local al que est conectado el socket. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Enva un DatagramPacket a travs del socket. |\r
| **public setSoTimeout(int timeout)** | Permite establecer un tiempo de espera lmite para que el mtodo receive se quede bloqueado esperando a recibir una respuesta por parte del otro extremo. Si no reciben datos en el tiempo fijado se lanza la excepcin \`InterruptedIOException\` |\r
\r
El DatagramSocket, cuando se utiliza en la parte receptora (la que vamos a llamar servidora) que ofrece el servicio para que los clientes se conecten, slo va a indicar el puerto al que esos clientes deben enviar sus solicitudes. En el caso de los procesos que acten como clientes, se usar el constructor sin parmetros para que sea el SO el que asigne un puerto libre.\r
\r
Por lo tanto, un mismo DatagramSocket al no incluir ninguna informacin de direccionamiento puede ser reutilizado para enviar y/o recibir datagramas a/desde diferentes destinos.\r
\r
### DatagramPacket\r
\r
La clase \`DatagramPacket\` como se ha indicado anteriormente, es un contenedor del mensaje y del destino de ese mensaje.\r
\r
![Datagram Packet](../../media/unit4/datagrampacket.svg)\r
\r
Esta clase proporciona los siguiente mtodos\r
\r
| Mtodo | Descripcin |\r
| --- | ----------- |\r
| public DatagramPacket(byte ibuf[], int  ilength)  | Implementa un DatagramPacket para la **recepcin** de paquetes de longitud ilength, siendo el valor de este parmetro menor o igual que ibuf.length. |\r
| public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)  | Implementa un DatagramPacket para el **envo** de paquetes de longitud ilength al nmero de puerto especificado en el parmetro iport, del host especificado en la direccin de destino que se le pasa por medio del parmetro iaddr. |\r
| public InetAddress getAddress () | Retorna la direccin IP del host al cual se le enva el datagrama o del que el datagrama se recibi. |\r
| public byte[] getData() | Retorna los **datos a recibir** o a enviar. |\r
| public int getLength() | Retorna la longitud de los datos a enviar o a recibir. |\r
| public int getPort() | Retorna el nmero de puerto de la mquina remota a la que se le va a enviar el datagrama o del que se recibi. |\r
\r
Como se intuye de la descripcin de los mtodos, la forma de crear el datagrama va a depender de si queremos enviar o recibir la informacin, ya que en cada uno de estas acciones tendremos que indicar dnde van dirigidos esos datos (envo) o bien esa informacin ya vendr incluida en el datagrama (recepcin) y podremos acceder a ella a travs de los mtodos getter de la clase.\r
\r
Es importante hacer ver que la informacin debe enviarse como un array de bytes y que se recibe de la misma forma, por lo que tendremos que usar los mtodos de String o de cualquiera de los otros tipos primitivos de Java para convertirlos a bytes.\r
\r
### Programacin de aplicaciones Cliente y/o Servidor\r
\r
En el caso de aplicaciones UDP, el protocolo de comunicacin no tiene sentido a nivel de capa de transporte, ya que slo se envan y reciben mensajes y hablamos de un \`protocolo no orientado a conexin\`, por lo tanto no sirve para realizar confirmaciones o dilogos entre la parte servidora y cliente.\r
\r
La parte del protocolo se delega en una capa superior, que ser la encargada de gestionar la comunicacin a un nivel de abstraccin mayor.\r
\r
De todas formas, la comunicacin entre ambas partes debe seguir estando sincronizada en los que a envos / respuestas se refiere para no dejar a la otra parte bloqueada en las lecturas.\r
\r
::: info Bloqueo de lecturas con timeout\r
Esta caracterstica, tambin disponible para los sockets TCP, permite evitar un bloqueo infinito de un hilo a la espera de recibir datos del otro extremo del socket.\r
\r
Es de especial importancia en la gestin de las comunicaciones UDP ya que, como hemos dicho, no tienen porqu seguir un protocolo preestablecido a nivel de transporte.\r
\r
Con el mtodo \`setSoTimeout\` de DatagramSocket podemos fijar un tiempo de espera mximo para la recepcin de datos a travs del socket.\r
:::\r
\r
## 4.3.2. Cliente UDP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser:\r
\r
1. El cliente crear un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.\r
2. Utilizar el mtodo send() del socket para enviar la peticin en forma de datagrama.\r
    - La informacin se envia en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
3. Permanece a la espera de recibir respuesta\r
4. El cliente recibe la respuesta del servidor mediante el mtodo receive() del socket.\r
    - La informacin se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
5. Cerrar y liberar los recursos.\r
\r
\`\`\`java{10,14,17,20,28,31}\r
public class BasicUDP_Client {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // IP y puerto al que se enva el Datagrama\r
        InetAddress destino = InetAddress.getLocalHost();\r
        int port = 12345; \r
        \r
        // Buffer para recibir el datagrama\r
        byte[] buffer = new byte[1024];\r
        \r
        // El mensaje a enviar en el Datagrama se convierte a bytes\r
        String mensajeEnviado = "Enviando Saludos !!";\r
        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\r
\r
        // Se preparara el DatagramPacket que se va a enviar\r
        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\r
        // En este caso, especificamos un puerto, aunque podramos dejarlo para\r
        // que el SO asigne uno libre\r
        DatagramSocket socket = new DatagramSocket(34567);\r
        \r
        System.out.println("Host destino : " + destino.getHostName());\r
        System.out.println("IP Destino : " + destino.getHostAddress());\r
        System.out.println("Puerto local del socket: " + socket.getLocalPort());\r
        System.out.println("Puerto al que envio: " + datagramaEnviado.getPort());\r
\r
        // Envo del Datagrama\r
        socket.send(datagramaEnviado);\r
        \r
        // Cierre y liberacin de recursos       \r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.3 Servidor UDP\r
\r
En los sockets UDP no se establece conexin. A pesar de que cuando los programamos s existen diferencias entre el servidor y el cliente, estas no son tan claras como con los sockets TCP. La funcionalidad y el cdigo que diferencia a un servidor de un cliente est ms diluido.\r
\r
> Podemos considerar servidor al que espera un mensaje y responde; y cliente al que inicia la comunicacin.\r
\r
Tanto uno como otro si desean ponerse en contacto necesitan saber en qu ordenador y en qu puerto est escuchando el otro.\r
\r
1. El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.\r
2. Permanece a la espera de recibir peticiones.\r
3. El servidor recibe las peticiones mediante el mtodo receive() del socket.\r
    - La informacin se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
4. En el datagrama recibido va incluido adems del mensaje, el puerto y la IP del cliente emisor de la peticin; lo que le permite al servidor conocer la direccin del emisor del datagrama. Utilizando el mtodo send() del socket puede enviar la respuesta al cliente emisor.\r
5. El servidor permanece a la espera de recibir ms peticiones.\r
6. Cerrar y liberar los recursos.\r
\r
\`\`\`java{6,10,18,20,21,33}\r
public class BasicUDP_Server {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // Buffer para recibir el datagrama\r
        byte[] bufer = new byte[1024];\r
\r
        // El Socket del servidor se asocia a un puerto para que los clientes\r
        // puedan enviar peticiones.\r
        DatagramSocket socket = new DatagramSocket(12345);\r
\r
        // Se espera la llegada de un DATAGRAMA\r
        // Al igual que con TCP, esta llamada a receive es bloqueante\r
        // y es la que tiene que marcar la sincronizacin entre lecturas y \r
        // escrituras de las app cliente / servidor\r
        System.out.println("Esperando Datagrama ................");\r
        // Se crea el objeto que almacenar el mensaje enviado por el cliente\r
        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\r
        // Se espera el mensaje y se le pasa el datagrama para que lo almacene ah\r
        socket.receive(datagramaRecibido);\r
        String mensajeRecibido = new String(datagramaRecibido.getData());\r
\r
        //Informacin recibida\r
        System.out.println("Nmero de Bytes recibidos: " + datagramaRecibido.getLength());\r
        System.out.println("Contenido del Paquete    : " + mensajeRecibido.trim());\r
\r
        System.out.println("Puerto origen del mensaje: " + datagramaRecibido.getPort());\r
\r
        System.out.println("IP de origen             : " + datagramaRecibido.getAddress().getHostAddress());\r
        System.out.println("Puerto destino del mensaje:" + socket.getLocalPort());\r
\r
        // Liberamos los recursos\r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor UDP](../../media/unit4/udp_process.png)\r
\r
Veamos ahora un ejemplo completo de C/S UDP\r
\r
\`\`\`java\r
public class BasicUDP_Client2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // FLUJO PARA ENTRADA ESTANDAR\r
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r
\r
        DatagramSocket clientSocket = new DatagramSocket();\r
        byte[] enviados = new byte[1024];\r
        byte[] recibidos = new byte[1024];\r
\r
        // DATOS DEL SERVIDOR al que enviar mensaje\r
        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\r
        int puerto = 9876; // puerto por el que escucha\r
\r
        // INTRODUCIR DATOS POR TECLADO\r
        System.out.print("Introduce mensaje: ");\r
        String cadena = in.readLine();\r
        enviados = cadena.getBytes();\r
\r
        // ENVIANDO DATAGRAMA AL SERVIDOR\r
        System.out.println("Enviando " + enviados.length + " bytes al servidor.");\r
        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\r
        clientSocket.send(envio);\r
\r
        // RECIBIENDO DATAGRAMA DEL SERVIDOR\r
        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\r
        System.out.println("Esperando datagrama....");\r
        clientSocket.receive(recibo);\r
        String mayuscula = new String(recibo.getData());\r
\r
        // OBTENIENDO INFORMACIN DEL DATAGRAMA\r
        InetAddress IPOrigen = recibo.getAddress();\r
        int puertoOrigen = recibo.getPort();\r
        System.out.println("\\tProcedente de: " + IPOrigen + ":" + puertoOrigen);\r
        System.out.println("\\tDatos: " + mayuscula.trim());\r
\r
        //cerrar socket\r
        clientSocket.close();\r
\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class BasicUDP_Server2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Puerto por el que escucha el servidor: 9876\r
        DatagramSocket serverSocket = new DatagramSocket(9876);\r
        byte[] recibidos = new byte[1024];\r
        byte[] enviados = new byte[1024];\r
        String cadena;\r
\r
        while (true) {\r
            System.out.println("Esperando datagrama.....");\r
\r
            //RECIBO DATAGRAMA\r
            recibidos = new byte[1024];\r
            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\r
            serverSocket.receive(paqRecibido);\r
            cadena = new String(paqRecibido.getData());\r
\r
            //DIRECCION ORIGEN\r
            InetAddress IPOrigen = paqRecibido.getAddress();\r
            int puerto = paqRecibido.getPort();\r
            System.out.println("\\tOrigen: " + IPOrigen + ":" + puerto);\r
            System.out.println("\\tMensaje recibido: " + cadena.trim());\r
\r
            //CONVERTIR CADENA A MAYSCULA\r
            String mayuscula = cadena.trim().toUpperCase();\r
            enviados = mayuscula.getBytes();\r
\r
            //ENVIO DATAGRAMA AL CLIENTE\r
            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\r
            serverSocket.send(paqEnviado);\r
\r
            // Condicin de finalizacin\r
            if (cadena.trim().equals("*")) {\r
                break;\r
            }\r
\r
        }//Fin de while\r
\r
        serverSocket.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.4 Multicast socket\r
\r
La clase MulticastSocket es til para enviar paquetes a mltiples destinos simultneamente.\r
\r
Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo nmero de puerto.\r
\r
Cuando se enva un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibirn el mensaje.\r
\r
La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el nmero de miembros del grupo ni sus direcciones IP.\r
\r
::: info Grupo multicast\r
\r
Un grupo multicast se especifica mediante una direccin IP de clase D y un nmero de puerto UDP estndar.\r
\r
Las direcciones desde la 224.0.0.0 a la 239.255.255.255 estn destinadas para ser direcciones de multicast.\r
\r
La direccin 224.0.0.0 est reservada y no debe ser utilizada.\r
:::\r
\r
Los mtodos que proporciona la clase MulticastSocket son\r
\r
| Mtodo | Descripcin |\r
| --- | ----------- |\r
|  MulticastSocket() throws IOException  | Construye un socket multicast dejando al SO que asigne un puerto libre. |\r
|  MulticastSocket(int port) throws IOException  | Construye un socket multicast y lo conecta al puerto local especificado. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Enva un DatagramPacket a travs del socket. |\r
| joinGroup( InetAddress multicastAddress) | Permite al socket unirse al grupo de multicast. A partir de ese momento podr recibir los mensajes que se envan a esa direccin. Un MulticastSocket puede estar unido a ms de un grupo multicast. |\r
| leaveGroup( InetAddress multicastAddress) | Permite al socket abandonar el grupo de multicast |\r
\r
Y a continuacin presentamos el esquema de llamadas seguido por un **servidor multicast**\r
\r
1. Se crea el socket multicast. No hace falta especificar puerto\r
    > MulticastSocket ms = new MulticastSocket();\r
\r
2. Se define el puerto multicast\r
    > int Puerto = 12345;\r
\r
3. Se crea el grupo multicast\r
    > InetAddress grupo = InetAddress.getByName(225.0.0.1);\r
\r
4. Se crea el datagrama\r
    > DatagramPacket paquete = new DatagramPacket(msg.getBytes(), msg.length(), grupo, Puerto);\r
\r
5. Se enva el paquete al grupo\r
    > ms.send(paquete);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
y el esquema de llamadas seguido por un **cliente multicast**\r
\r
1. Se crea un socket multicast en el puerto establecido\r
    > MulticastSocket ms = new MulticastSocket(12345);\r
\r
2. Se configura la IP del grupo al que nos conectaremos\r
    > InetAddress grupo = InetAddress.getByName(225.0.0.1);\r
\r
3. Se une al grupo\r
    > ms.joinGroup(grupo);\r
\r
4. Recibe el paquete del servidor multicast\r
\r
    > byte[] buf = new byte[1000];\r
DatagramPacket recibido = new DatagramPacket(buf, buf.length);\r
ms.receive(recibido);\r
\r
5. Salimos del grupo multicast:\r
    > ms.leaveGroup(grupo);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
Y ahora lo vemos todo junto con un ejemplo\r
\r
\`\`\`java\r
public class U4_BasicMulticastServer {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // Enviamos la informacin introducida por teclado hasta que se enve un *        \r
        Scanner in = new Scanner(System.in);\r
\r
        //Se crea el socket multicast.\r
        MulticastSocket ms = new MulticastSocket();\r
        // Se escoge un puerto para el server\r
        int puerto = 12345;\r
        // Se escoge una direccin para el grupo\r
        InetAddress grupoMulticast = InetAddress.getByName("225.0.0.1");\r
\r
        String cadena = "";\r
        while (!cadena.trim().equals("*")) {\r
\r
            System.out.print("Datos a enviar al grupo: ");\r
            cadena = in.nextLine();\r
\r
            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\r
            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\r
            ms.send(paquete);\r
        }\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class U4_BasicMulticastClient {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Se crea el socket multicast\r
        // El puerto debe ser el mismo en todos los clientes, ya que el \r
        // servidor multicast enva la informacin a la IP multicast y a un puerto\r
        int puerto = 12345;//Puerto multicast\r
        MulticastSocket ms = new MulticastSocket(puerto);\r
\r
        //Nos unimos al grupo multicast\r
        InetAddress grupo = InetAddress.getByName("225.0.0.1");\r
        ms.joinGroup(grupo);\r
        String msg = "";\r
\r
        while (!msg.trim().equals("*")) {\r
            // El buffer se crea dentro del bucle para que se sobrescriba \r
            // con cada nuevo mensaje\r
            byte[] buf = new byte[1000];\r
            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\r
            //Recibe el paquete del servidor multicast\r
            ms.receive(paquete);\r
            msg = new String(paquete.getData());\r
            System.out.println("Recibo: " + msg.trim());\r
        }\r
\r
        // Abandonamos grupo\r
        ms.leaveGroup(grupo);\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
::: info mezcla de sockets en una app\r
Ya hemos visto todo el abanico de posibilidades que tenemos para comunicar dos procesos en red.\r
\r
A partir de este momento, en nuestras aplicaciones no slo tenemos que elegir uno de ellos, sino que podemos tener varios sockets, de diferente tipo, para comunicar los clientes y los servidores.\r
\r
Se trata ahora de analizar en qu situacin es ms conveniente un tipo que otro y usarlo. Podemos ayudarnos de la creacin de hilos que estn "especializados" en el envo y/o recepcin de informacin de un socket, permitiendo que se intercambien varios mensajes a la vez.\r
:::\r
`]},{title:"4.4 Stateful protocols",headers:[{level:2,title:"4.4.1. Stateful and stateless protocols",slug:"_4-4-1-stateful-and-stateless-protocols",link:"#_4-4-1-stateful-and-stateless-protocols",children:[{level:3,title:"Stateless protocols",slug:"stateless-protocols",link:"#stateless-protocols",children:[]},{level:3,title:"Stateful protocols",slug:"stateful-protocols",link:"#stateful-protocols",children:[]}]},{level:2,title:"4.4.2 Programacin de servidores basados en estados",slug:"_4-4-2-programacion-de-servidores-basados-en-estados",link:"#_4-4-2-programacion-de-servidores-basados-en-estados",children:[{level:3,title:"Programacin de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.4.3. Ejemplo de servidor con estados",slug:"_4-4-3-ejemplo-de-servidor-con-estados",link:"#_4-4-3-ejemplo-de-servidor-con-estados",children:[{level:3,title:"Ejemplo del Worker que implementa el protocolo",slug:"ejemplo-del-worker-que-implementa-el-protocolo",link:"#ejemplo-del-worker-que-implementa-el-protocolo",children:[]}]},{level:2,title:"4.4.4. Ejemplo de cliente con estados",slug:"_4-4-4-ejemplo-de-cliente-con-estados",link:"#_4-4-4-ejemplo-de-cliente-con-estados",children:[{level:3,title:'Ejemplo de cliente "genrico" que implementa el protocolo',slug:"ejemplo-de-cliente-generico-que-implementa-el-protocolo",link:"#ejemplo-de-cliente-generico-que-implementa-el-protocolo",children:[]}]}],path:"/en/unit4/stateful-protocols.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.4 Stateful protocols\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.4 Stateful protocols" />\r
\r
# 4.4 Stateful protocols\r
\r
[[toc]]\r
\r
## 4.4.1. Stateful and stateless protocols\r
\r
Como ya hemos comentado anteriormente, un protocolo, aplicado al mundo de las comunicaciones informticas, es un conjunto de reglas que especifican la manera en la que se realiza la comunicacin entre dos interlocutores.\r
\r
Este conjunto de reglas establece el formato de los mensajes que se intercambian \`(texto, binario, JSON, XML, CSV, ...)\`, las acciones que cada uno de los extremos de la comunicacin deben realizar en cada momento \`(envo o recepcin)\` y, lo que nos ocupa en este apartado del tema, si las acciones dependen de acciones anteriores o no.\r
\r
### Stateless protocols\r
\r
En informtica, un protocolo sin estado es un protocolo de comunicaciones que trata cada peticin como una transaccin independiente que no tiene relacin con cualquier solicitud anterior, de modo que la comunicacin se compone de pares independientes de solicitud y respuesta.\r
[Wikipedia: Protocolo sin estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)\r
\r
El ejemplo ms conocido de protocolo sin estado es HTTP.1 El protocolo no proporciona medio alguno de almacenamiento de datos de un usuario entre las peticiones, dejando esta tarea a niveles superiores y haciendo necesario el reenvo de informacin de manera continua para simular un funcionamiento con estado (cookies, cabeceras, etc.).\r
\r
### Stateful protocols\r
\r
Un protocolo sin estado no requiere que el servidor retenga informacin de la sesin o de estado acerca de los intercambios de informacin durante la realizacin de mltiples peticiones. En contraste, un protocolo que requiere el mantenimiento del **estado interno en el servidor** se conoce como un **protocolo con estado**.\r
\r
Por lo tanto, un estado es una configuracin en un programa o mquina que depende de los estados anteriores y que determina el funcionamiento del sistema, en funcin de la entrada recibida y del estado actual en el que se encuentre el sistema.\r
\r
Poniendo una analoga, podemos tomar una solicitud a la administracin, donde debemos realizar varios pasos hasta resolver la solicitud.\r
\r
1. En primer lugar se rellena una instancia con los datos y se enva al departamento correspondiente.\r
2. Ese departamento comprobar la instancia recibida y contestar solicitando informacin adicional o confirmando que la solicitud se ha recibido correctamente.\r
3. En un proceso posterior, se solicita un pago de tasas al usuario.\r
4. El usuario tiene que realizar el pago de tasas y enviar el justificante.\r
5. Tras cotejar toda la informacin, se le solicita al usuario que aporte los documentos originales.\r
6. El usuario se persona para mostrar la documentacin original\r
7. Finalmente se resuelve la solicitud informando al usuario el resultado de la misma.\r
\r
Esto, que puede ser un procedimiento normal, refleja claramente un proceso en el que se siguen una serie de pasos y cuyo orden no se puede cambiar.\r
\r
Por ejemplo, no tendra sentido hacer el pago de las tasas (paso 4) sin antes haber presentado la solicitud (paso 1) o sin haber recibido la confirmacin de que la solicitud est completa.\r
\r
Esto mismo pasa con algunos protocolos de comunicacin.\r
\r
## 4.4.2 Programacin de servidores basados en estados\r
\r
Hay toda una teora matemtica, \`la teora de grafos\`, desarrollada en torno a esto, junto con un modelo computacional, \`los autmatas finitos\`, que estudian y optimizan el desarrollo de aplicaciones basadas en estados.\r
\r
La teora de grafos es una rama de las matemticas y las ciencias de la computacin que estudia las propiedades de los grafos\r
\r
La teora de grafos tiene sus fundamentos en las \`matemticas discretas\` y de las \`matemticas aplicadas\`. Esta teora requiere de diferentes conceptos de diversas reas como **combinatoria, lgebra, probabilidad, geometra de polgonos, aritmtica y topologa**. Actualmente ha tenido mayor influencia en el campo de la informtica, las ciencias de la computacin y telecomunicaciones. Debido a la gran cantidad de aplicaciones en la optimizacin de recorridos, procesos, flujos y algoritmos de bsquedas, entre otros\r
\r
Un autmata finito o mquina de estado finito es un modelo computacional que toma decisiones de computacin de forma automtica sobre una entrada para producir una salida.\r
\r
Este modelo est conformado por un alfabeto, un conjunto de estados finito, una funcin de transicin, un estado inicial y un conjunto de estados finales.\r
\r
La finalidad de los autmatas finitos, entre otras, es la de reconocer lenguajes regulares, que corresponden a los lenguajes formales ms simples segn la Jerarqua de Chomsky.\r
\r
### Programacin de aplicaciones Cliente y/o Servidor\r
\r
Como en todos los casos que hemos estudiado con anterioridad, el protocolo es la pieza comn entre los clientes y los servidores.\r
\r
Nuestros clientes podrn estar bien o mal programados, de hecho muchos de nuestros clientes son interactivos, por lo que podemos alterar el orden de los comandos a nuestro antojo, no siendo esto ningn problema.\r
\r
Debe ser el servidor el que tenga el control del proceso, el que asegure la integridad del sistema y de los datos, por lo tanto va a ser en la parte del servidor donde tengamos que realizar las modificaciones para adaptarlo al control y gestin de los estados.\r
\r
Esto no quita que los clientes deban seguir \`sincronizados\` con el servidor para evitar situaciones de interbloqueo, ya que de una forma u otra el cliente siempre debe seguir el protocolo, aunque no los estados tal y como hemos dicho.\r
\r
## 4.4.3. Ejemplo de servidor con estados\r
\r
Vamos a ver qu pasos debemos seguir para controlar los estados en el servidor y cmo adaptar un cliente.\r
\r
El ejemplo que vamos a utilizar es el de la actividad  \`U4A03_ProtocoloSaludo\`. Primero vamos a aclarar cmo debe funcionar este protocolo.\r
\r
Si el cliente est bien programado, el intercambio de informacin entre Cliente y Servidor se realiza en tres pasos\r
\r
1. Cliente enva "Hi Server!"\r
2. Servidor responde "Hi Client!"\r
3. Cliente responde "By Server!"\r
\r
Ante un funcionamiento normal, este protocolo es bastante fcil de implementar. Sin embargo,\r
\r
- Qu pasa si el cliente enva "By Server!" como primer mensaje?\r
- Qu debe responder el servidor si no recibe el mensaje que est esperando?\r
- Qu debe hacer el cliente si no recibe el mensaje que est esperando?\r
\r
Estas son las circunstancias a las que debemos responder con los estados del protocolo, indicando en cada caso qu debe hacer cada una de las partes. Todo depender de la funcionalidad que est implementando el protocolo.\r
\r
Cada caso es diferente, por ejemplo, si es importante hacer los tres pasos en orden, ante cualquier fallo se debe volver a empezar (un borrado en una BD, una autenticacin de tres vas). Si por el contrario, los dos primeros pasos se tienen que realizar de forma conjunta, pero el tercero es independiente, si el incumplimiento del protocolo se produce en ese momento, no es necesario que se repitan los dos primeros pasos, sino que slo ser necesario repetir el ltimo.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Estado Hi\\nEsperando al saludo\r
    Bye: Estado Bye\\nEsperando la despedida\r
    [*] -> Hi\r
    Hi -> Hi : Mensaje incorrecto\\nSe enva error al cliente\r
    Hi -> Bye : Se ha recibido el mensaje correcto\\nSe enva respuesta al cliente\r
    note left of Hi : Permanecemos en este estado\\nhasta que se reciba el mensaje correcto\r
    Bye -> Hi : Mensaje incorrecto\\nSe enva error al cliente\r
    Bye -> [*] : Se ha recibido el mensaje correcto\\nSe cierra la conexin con el cliente\r
-->\r
\r
### Ejemplo del Worker que implementa el protocolo\r
\r
\`\`\`java{12,17,34,50,61,71}\r
public class U4A03_SaludoWorker extends Thread {\r
\r
    Socket socketCliente;\r
    BufferedReader entrada;\r
    PrintWriter salida;\r
\r
    private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\r
    U4A03_SaludoWorker(Socket socketCliente) {\r
        this.socketCliente = socketCliente;\r
        // Inicializamos el valor del estado al estado inicial\r
        estado = Estados.HI;\r
    }\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Recibe lo que enva el cliente hasta que el mensaje sea\r
            // END OF TRANSMISSION\r
            while (estado != Estados.END) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
\r
                // Comprobamos si se ha cerrado el extremo cliente del socket\r
                // Y damos por concluida la comunicacin.\r
                if (str == null) {\r
                    estado = Estados.END;\r
                } else {\r
                    // Mostramos la informacin recibida por consola\r
                    System.out.println("CLIENTE > " + str);\r
                }\r
\r
                // Controlamos la respuesta en funcin del mensaje recibido y \r
                // el estado actual\r
                switch (estado) {\r
                    case HI:\r
                        if (messages[0].equals(str)) {\r
                            // Enviamos respuesta al cliente\r
                            salida.println(messages[1]);\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.BYE;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                        }\r
                        break;\r
                    case BYE:\r
                        if (messages[2].equals(str)) {\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.END;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                            estado = Estados.HI;\r
                        }\r
                        break;\r
                    case END:\r
                        // No sera necesario contemplarlo en este caso\r
                        // Pero s en otros en los que se tenga que enviar \r
                        // algn mensaje antes de salir.\r
                        break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("Error de comunicacin con el cliente");\r
        } catch (Exception e) {\r
            System.out.println(e.getLocalizedMessage());\r
            e.printStackTrace();\r
        } finally {\r
            try {\r
                entrada.close();\r
                System.out.println("Conexin cerrada: " + socketCliente);\r
                socketCliente.close();\r
            } catch (IOException e) {\r
                System.out.println("Error inesperado cerrando los recursos");\r
            }\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El cdigo corresponde al worker de un servidor multihilo. Analicemos ahora el cdigo por partes\r
\r
Es recomendable usar propiedades para guardar los mensajes que queramos comparar y tener un ENuM para definir los estados. Los \`enum\` en Java permiten ser usados en los bloques switch-case.\r
\r
La propiedad **estado** va a ser el punto central que controle el flujo de ejecucin del servidor.\r
\r
\`\`\`java:no-line-numbers {6}\r
private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\`\`\`\r
\r
En el constructor, adems de todas las propiedades, inicializamos el estado, asignndole el valor del estado inicial.\r
\r
\`\`\`java:no-line-numbers{4}\r
U4A03_SaludoWorker(Socket socketCliente) {\r
    this.socketCliente = socketCliente;\r
    // Inicializamos el valor del estado al estado inicial\r
    estado = Estados.HI;\r
}\r
\`\`\`\r
\r
El servidor estar ejecutndose hasta que se alcance el estado final\r
\r
\`\`\`java:no-line-numbers\r
// Recibe lo que enva el cliente hasta que el mensaje sea\r
// END OF TRANSMISSION\r
while (estado != Estados.END) {\r
\`\`\`\r
\r
En este ejemplo, el intercambio de informacin con el cliente se hace uno a uno, es decir se recibe un mensaje y se enva una respuesta, pero no tiene porqu ser as, se pueden recibir varios mensajes y no enviar respuesta, o cualquier combinacin de envo respuesta que nos imaginemos.\r
\r
El cdigo que sigue e un control para saber si el cliente ha cerrado el socket, as evitamos tener excepciones de tipo NullPointerException o dejar al servidor en un bucle infinito. Forzamos la salida cambiando el estado del protocolo.\r
\r
\`\`\`java:no-line-numbers{4}\r
// Comprobamos si se ha cerrado el extremo cliente del socket\r
// Y damos por concluida la comunicacin.\r
if (str == null) {\r
    estado = Estados.END;\r
} else {\r
    // Mostramos la informacin recibida por consola\r
    System.out.println("CLIENTE > " + str);\r
}\r
\`\`\`\r
\r
Este es el cdigo que implementa el diagrama de estados que he diseado para esta actividad.\r
Fijaos que el servidor tiene que realizar una comprobacin para cada lnea que sale de un estado. En este caso al ser slo dos lneas, sirve con un if-else, pero puede ser un nmero mayor de opciones.\r
\r
Adems, una de las opciones tiene un comportamiento totalmente diferente al resto, ya que **cuando se recibe el mensaje final, el protocolo no dice que enviemos una respuesta al cliente**.\r
\r
Esto \`debemos controlarlo en el cliente\`, porque si lo programamos de forma que enve un mensaje y espere una respuesta, puede quedarse bloqueado en la lectura. Aprovechando que este es el ltimo mensaje, ms adelante veremos cmo se ha solventado en el cliente.y las opciones que tenemos para evitar posibles bloqueos como este.\r
\r
\`\`\`java:no-line-numbers{16}\r
// Controlamos la respuesta en funcin del mensaje recibido y \r
// el estado actual\r
switch (estado) {\r
    case HI:\r
        if (messages[0].equals(str)) {\r
            // Enviamos respuesta al cliente\r
            salida.println(messages[1]);\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.BYE;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
        }\r
        break;\r
    case BYE:\r
        if (messages[2].equals(str)) {\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.END;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
            estado = Estados.HI;\r
        }\r
        break;\r
    case END:\r
        // No sera necesario contemplarlo en este caso\r
        // Pero s en otros en los que se tenga que enviar \r
        // algn mensaje antes de salir.\r
        break;\r
}\r
\`\`\`\r
\r
## 4.4.4. Ejemplo de cliente con estados\r
\r
Aunque un cliente interactivo como los que usamos para las pruebas no deberan cambiar su funcionalidad, s hay que hacer pequeos ajustes para adaptar su funcionamiento a las posibles respuestas y errores que enva el servidor.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/client_sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Envo mensaje\r
    Bye: Recibo mensaje\r
    [*] -> Hi\r
    Hi -> Bye : Se enva un mensaje\\nSe espera la respuesta del servidor\r
    Bye -> Hi : Se muestra la respuesta del servidor\r
    note left of Hi : Se envan mensajes\\nmientras el servidor mantenga\\nla conexin abierta   \r
    Hi -> [*] : Se ha detectado el cierre\\nde la conexin con el servidor\r
-->\r
\r
Como ya hemos dicho en el cdigo del servidor, si implementamos el protocolo como un cliente de envo-respuesta, hay un caso en el que no debemos esperar una respuesta. Este es el caso de la salida, en la que se enva un mensaje pero no esperamos respuesta por parte del servidor.\r
\r
Se puede pensar en poner una condicin de salida para cuando el cliente enva el ltimo mensaje, pero no podemos asegurar que ese mensaje cerrar la comunicacin, porque depender del estado en el que se encuentre el servidor.\r
\r
### Ejemplo de cliente "genrico" que implementa el protocolo\r
\r
\`\`\`java{39,41}\r
public class U4A03_SaludoClient {\r
\r
    private static final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est en la misma mquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket(args[0], Integer.parseInt(args[1]));\r
\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexin");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenva al servidor hasta que se enva \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
            // Recibe la respuesta del servidor por el InputStream\r
            linea = entrada.readLine();\r
            if (linea == null) {\r
                // Comprobamos si se ha cerrado el extremo servidor del socket\r
                // Y damos por concluida la comunicacin.\r
                break;\r
            } else {\r
                // Enva a la salida estndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            }\r
        } while (true);\r
\r
        // Libera recursos\r
        salida.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\`\`\`\r
\r
El cdigo corresponde a un cliente interactivo genrico, que va enviando mensajes y esperando la respuesta de los mismos sin hacer ningn tipo de control sobre lo que se enva o lo que recibe.\r
\r
Analicemos algunos aspectos del cdigo del cliente\r
\r
La parte que sigue es equivalente a la que hemos usado en el servidor. No modificamos el flujo envo-recepcin, pero s que comprobamos si el lado del servidor ha cerrado el socket (ha realizado todo el protocolo correctamente) para decidir que el cliente finalice su ejecucin.\r
\r
\`\`\`java:no-line-numbers{3}\r
// Recibe la respuesta del servidor por el InputStream\r
linea = entrada.readLine();\r
if (linea == null) {\r
    // Comprobamos si se ha cerrado el extremo servidor del socket\r
    // Y damos por concluida la comunicacin.\r
    break;\r
} else {\r
    // Enva a la salida estndar la respuesta del servidor\r
    System.out.println("SERVIDOR > " + linea);\r
}\r
} while (true);\r
\`\`\`\r
\r
::: warning Lectura con timeout\r
Otra manera distinta de hacer lo mismo es usando lecturas con timeout.\r
\r
En este ejemplo podramos haber comprobado si el mensaje enviado es el mensaje de finalizacin. Es ese caso, si todo ha ido bien, no deberamos esperar una respuesta por parte del server, pero si ha habido algn error, s debemos realizar una lectura del socket.\r
\r
Usando este cdigo\r
\r
\`\`\`java\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenva al servidor hasta que se enva \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
\r
            // Si enviamos el mensaje de salida, no hacemos una lectura indefinida\r
            if (linea.equals(messages[2])) {\r
                socketCliente.setSoTimeout(100);\r
            } else {\r
                socketCliente.setSoTimeout(0);\r
            }\r
\r
            try { \r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Enva a la salida estndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            } catch (SocketTimeoutException ste) {\r
                // Pasado el timeout no se ha recibido una respuesta\r
                // Podemos suponer que el server no enva respuesta\r
                // Eso indica que el protocolo se ha completado\r
                // Damos por concluida la comunicacin.\r
                break;\r
            }            \r
        } while (true);\r
\`\`\`\r
\r
fijamos un tiempo de espera pasado el cual se producir una \`SocketTimeoutException\` indicando que no se ha ledo nada del socket. Si por el contrario se lee informacin del socket, esta se muestra por la consola.\r
\r
En este caso en concreto, esta solucin no funciona porque el servidor ya ha cerrado el socket. Esto sera til cuando tengamos que hacer una \`lectura opcional\` en mitad de un protocolo, y servira tanto para un cliente como para un servidor.\r
:::\r
`]},{title:"4.1 TCP IP protocol stack",headers:[{level:2,title:"4.1.1. TCP/IP Layers",slug:"_4-1-1-tcp-ip-layers",link:"#_4-1-1-tcp-ip-layers",children:[]},{level:2,title:"4.1.2. Addresses and ports - Sockets",slug:"_4-1-2-addresses-and-ports-sockets",link:"#_4-1-2-addresses-and-ports-sockets",children:[{level:3,title:"IP Addresses",slug:"ip-addresses",link:"#ip-addresses",children:[]},{level:3,title:"Ports",slug:"ports",link:"#ports",children:[]},{level:3,title:"Sockets",slug:"sockets",link:"#sockets",children:[]}]},{level:2,title:"4.1.3 TCP vs UDP",slug:"_4-1-3-tcp-vs-udp",link:"#_4-1-3-tcp-vs-udp",children:[]}],path:"/en/unit4/tcp-ip.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.1 TCP IP protocol stack\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.1 TCP IP protocol stack" />\r
\r
# 4.1 TCP IP protocol stack\r
\r
[[toc]]\r
\r
## 4.1.1. TCP/IP Layers\r
\r
The TCP/IP Stack, or the internet protocol suite, is a set of communication protocols used by the Internet or similar networks.\r
\r
TCP/IP is the world's most widely-used non-proprietary protocol suite because it enables computers using diverse hardware and software platforms, on different types of networks, to communicate. The protocols work equally well in both LANs and WANs.\r
\r
TCP/IP is a collection of protocols named after its two best-known and most important protocols, the \`Transmission Control Protocol (TCP)\` and the \`Internet Protocol (IP)\`. As well as these relatively low-level protocols, TCP/IP includes several higher level protocols that facilitate common applications such as electronic mail, terminal emulation, and file transfer.\r
\r
::: info Protocol RFC\r
Each Internet protocol, together with any subsequent amendments, is described in a document known as a Request For Comments (RFC).\r
\r
A list of RFCs is available at: [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).\r
:::\r
\r
It is called a **stack** because it is typically designed as a hierarchy of layers, each supporting the one above it and using those below it. Each layer solves a specific set of problems involving the transmission of data and provides well-defined services to the layers above it.\r
\r
The TCP/IP model has four layers. From lowest to highest, these are the link layer, the internet layer, the transport layer, and the application layer, as shown below.\r
\r
![TCP/IP real communication flow](../../media/unit4/1-ip-real-communication-flow.gif)\r
\r
- The **link layer** provides the interface with the underlying network hardware and physical wired or wireless connection media.\r
- The **internetwork layer** provides addressing and routing functions that ensures messages are delivered to their destination. Internet Protocol (IP) is the most important protocol in this layer and probably on the whole stack.\r
- The **transport layer** oversees the end-to-end transfer of data, and can handle a number of data streams simultaneously. The main transport layer protocol is \`Transmission Control Protocol (TCP)\`, which provides a reliable, connection-oriented service. \`User Datagram Protocol (UDP)\` provides an unreliable, connectionless service.\r
- An **application layer** protocol is specific to a particular type of application (e.g. file transfer, electronic mail, network management etc.) and is sometimes embodied within the application's client software, although it could also be implemented within the operating system software. The interface between an application layer protocol and a transport layer protocol is defined with reference to \`port numbers\` and \`sockets\`.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.1-ip-protocols.png)\r
\r
## 4.1.2. Addresses and ports - Sockets\r
\r
### IP Addresses\r
\r
Each host on a TCP/IP network is assigned a unique IP address consisting of a network number and a host number. The network number identifies a specific network. The host number identifies a host on a network and is assigned by the network administrator.\r
\r
Ipv4 IP address are 32-bit addresses. The IP address is grouped into four binary octets (an octet is a group of eight bits) and is represented using dotted decimal notation. The minimum value for an octet is 0, and the maximum value is 255.\r
\r
> 192.168.0.100\r
>\r
> 127.0.0.1\r
>\r
> 10.1.100.1\r
\r
IPv6 addresses are typically composed of a 64-bit network prefix, and a 64-bit host part. IPv6 addresses are normally written as eight groups of four hexadecimal numbers. A group consisting solely of zeros can be omitted. Leading zeros in a group can also be omitted.\r
\r
So the addresses below are all valid and equivalent to each other\r
\r
> 2001:0db8:0000:0000:0000:0000:1428:57ab\r
>\r
> 2001:0db8:0000:0000:0000::1428:57ab\r
>\r
> 2001:0db8:0:0:0:0:1428:57ab\r
>\r
> 2001:0db8:0:0::1428:57ab\r
>\r
> 2001:0db8::1428:57ab\r
>\r
> 2001:db8::1428:57ab\r
\r
![Routing](../../media/unit4/data_transfer.gif)\r
\r
### Ports\r
\r
An application process running on one computer that wants to communicate with an application process running on another computer identifies itself using a 16-bit port number, which is subsequently used by the transport layer protocol (TCP or UDP) to deliver incoming messages.\r
\r
Port numbers go from 0 to 65535, and they are grouped in three ranges\r
\r
| Port group                      | Port range    | Description                                                    |\r
| ------------------------------- | ------------- | -------------------------------------------------------------- |\r
| Well know ports or system ports | 0 - 1023      | Used by standard protocols and services                        |\r
| Registered ports                | 1024- 49151   | Reserved by companies and organizations for their own services |\r
| Ephemeral ports                 | 49152 - 65535 | For free use by clients and servers                            |\r
\r
Common server applications such as Telnet and FTP use one or more of the well known port numbers (these range between 1 and 1023). Most server applications only use one port, although some (like FTP) use two. The use of a specific port number by server applications allows the client process to send a request to a server without having to first find out which port is being used by the server application.\r
\r
> HTTP requests, for example, are addressed by default to port 80 on the server.\r
\r
The clients themselves do not need to use a well known port, since they are initiating the communication. A client process is dynamically allocated a port number (in the range 1024 to 65535) by the client operating system. This number is subsequently included in all datagrams sent to the server.\r
\r
### Sockets\r
\r
A \`socket\` is essentially an addressable end point in a communication between two processes, and consists of a **unique combination of IP address, port number and transport layer protocol (usually TCP)**.\r
\r
When a client application wishes to communicate with a server application, the operating system creates a socket which is then used by the client application to receive incoming data from the server. The unique combination of transport protocol, IP address and port number allows the communication end point to be addressed by a process running on a remote server, and ensures that data is delivered to the process for which it is intended.\r
\r
The server application will have its own socket for communicating with the client, and a connection is established between client and server using the two socket addresses. The applications exchange information by writing to, or reading from, the sockets they have created.\r
\r
The connection used by a client process consists of two sockets, one at each end of the connection. The connection can thus be identified by a unique combination of four numbers - the source and destination IP addresses, together with the source and destination port numbers.\r
\r
It is possible for several client applications running on different computers to connect to the same destination socket on a server. So there is no confusion as to which computer a datagram is destined for, even if the source and destination ports are the same in each case.\r
\r
Using sockets, it is even possible for several client applications running on the same computer to connect to the same destination socket on a server. Datagrams sent to the client by the server contain the socket address for each client process, which includes the client process's individual port number, so there is no confusion as to which process a datagram is bound for.\r
\r
![TCP/IP logical communication flow](../../media/unit4/2-ip-logical-communication-flow.gif)\r
\r
As the real communication flow goes from one layer to the next or previous one, applications on each layer are abstracted from the underlying layers, so their communications flows to the same layer on the other side. In the TCP/IP stack different pieces of information are managed at each level as shown in the previous diagram.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.0-The-TCP-IP-UDP-IP-Stack_Q640.jpg)\r
\r
As stated before, sockets are the bridge between application layer and transport layer. That's the point where our applications are going to be developed and run, giving service to higher level protocols.\r
\r
## 4.1.3 TCP vs UDP\r
\r
The \`Transmission Control Protocol (TCP)\` is a widely used connection-oriented transport layer protocol that provides reliable transfer of data between two end points, and includes mechanisms to handle flow-control, segmentation, error recovery, and multiplexing.\r
\r
The TCP transport service offers the following features:\r
\r
- Full duplex communication: both ends of a connection can transmit simultaneously\r
- Timing: timers are used to ensure that data is transmitted in a timely fashion\r
- Sequencing: message blocks are given sequence numbers to enable messages to be reassembled in the correct order before being passed to the application layer protocols on the destination computer\r
- Flow control: the flow of data is regulated using buffers and windows\r
- Error handling: checksums are provided to enable transmission errors to be detected and dealt with\r
\r
![TCP/IP logical communication flow](../../media/unit4/5-Graphic-UDP-Vs-TCP.png)\r
\r
The \`User Datagram Protocol (UDP)\` is an unreliable, connectionless protocol that works at the transport layer of TCP/IP, and provides a datagram delivery service to applications with a minimum of overhead. UDP provides a very simple interface between the application layer and the internetwork layer.\r
\r
UDP does not provide any guarantee of delivery, nor does it provide error recovery or flow control. No connection is established, and hence no handshaking procedure is required. Packets may arrive out of order, not arrive at all, or be duplicated.\r
\r
UDP is the transport protocol for a variety of application-layer protocols, including Simple Network Management Protocol (SNMP), Dynamic Host Configuration Protocol (DHCP), Routing Information Protocol (RIP), and the Domain Name System (DNS), as well as streaming media applications such as Voice over IP (VoIP).\r
\r
![TCP/IP logical communication flow](../../media/unit4/7-TCP-vs-UDP-differences.png)\r
`]},{title:"5.2 FTP Client",headers:[{level:2,title:"5.2.1 Apache Common Net FTP",slug:"_5-2-1-apache-common-net-ftp",link:"#_5-2-1-apache-common-net-ftp",children:[]},{level:2,title:"5.2.2 FTP Server",slug:"_5-2-2-ftp-server",link:"#_5-2-2-ftp-server",children:[]},{level:2,title:"5.2.3 FTP Client",slug:"_5-2-3-ftp-client",link:"#_5-2-3-ftp-client",children:[{level:3,title:"5.2.3.1 Connect and login",slug:"_5-2-3-1-connect-and-login",link:"#_5-2-3-1-connect-and-login",children:[]},{level:3,title:"5.2.3.2 Change directories",slug:"_5-2-3-2-change-directories",link:"#_5-2-3-2-change-directories",children:[]},{level:3,title:"5.2.3.3 Upload files",slug:"_5-2-3-3-upload-files",link:"#_5-2-3-3-upload-files",children:[]},{level:3,title:"5.2.3.4 Download files",slug:"_5-2-3-4-download-files",link:"#_5-2-3-4-download-files",children:[]},{level:3,title:"5.2.3.5 Other operations",slug:"_5-2-3-5-other-operations",link:"#_5-2-3-5-other-operations",children:[]}]}],path:"/en/unit5/ftp.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.2 FTP Client\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.2 FTP Client" />\r
\r
# 5.2 FTP Client\r
\r
[[toc]]\r
\r
## 5.2.1 Apache Common Net FTP\r
\r
Apache Commons Net library implements the client side of many basic Internet protocols.\r
\r
The purpose of the library is to provide fundamental protocol access, not higher-level abstractions. Therefore, some of the design violates object-oriented design principles.\r
\r
Our philosophy is to make the global functionality of a protocol accessible (e.g., TFTP send file and receive file) when possible, but also provide access to the fundamental protocols where applicable so that the programmer may construct his own custom implementations (e.g, the TFTP packet classes and the TFTP packet send and receive methods are exposed).\r
\r
::: tip Apache Commons NET library\r
Supported protocols include:\r
\r
- FTP/FTPS\r
- FTP over HTTP (experimental)\r
- NNTP\r
- SMTP(S)\r
- POP3(S)\r
- IMAP(S)\r
- Telnet\r
- TFTP\r
- Finger\r
- Whois\r
- rexec/rcmd/rlogin\r
- Time (rdate) and Daytime\r
- Echo\r
- Discard\r
- NTP/SNTP\r
:::\r
\r
In Java, natively, it is possible to carry out file transfers using this protocol, but it is extremely hard to do so. The Apache Commons Net library provides classes and utilities to perform any operation on an FTP or FTPS server from a Java client.\r
\r
This library can be downloaded from the apache.org website through the following link: https://commo\r
ns.apache.org/proper/commons-net/\r
\r
## 5.2.2 FTP Server\r
\r
The FTP server is a program that runs on a computer and allows other computers to connect to it and transfer files using the FTP protocol.\r
\r
To make tests we are going to use the FileZilla FTP server, which can be downloaded from the [Filezilla site](https://filezilla-project.org/download.php?type=server).\r
\r
The installation is very simple, just follow the steps of the installation wizard. Once installed, we will have to configure the server, for this we will have to open the FileZilla Server Interface program, which will be in the Windows start menu.\r
\r
![FileZilla Server Interface](../../media/unit5/FileZilla-Server-Interface.png)\r
\r
Once you have installed the server, you will have to configure it. To do this, you will have to open the FileZilla Server Interface program, which will be in the Windows start menu and open the Server menu and select the option "Configure".\r
\r
Then, in the Users section, we will have to create a user, for this we will have to click on the "Add" button and fill in the fields with the data of the user that we want to create. Then change the Authentication type to "Require a password to login" and enter the password that we want to assign to the user.\r
\r
Then, in the Mounting Points section, we will have to add a new mounting point, for this we will have to click on the "Add" button and fill in the fields with the data of the mounting point that we want to create. In the "Native path" field we will have to select the directory that we want to share.\r
\r
::: tip Virtual Paths vs Native Paths\r
Virtual paths are used to map a directory on the server to a virtual directory. This allows you to create a virtual directory structure that is different from the actual directory structure on the server. For example, you can map the directory "C:\\My Documents" to the virtual directory "/Documents". When a client connects to the server and changes to the "/Documents" directory, the client will actually be in the "C:\\My Documents" directory on the server.\r
:::\r
\r
Once we have created the user and the mounting point, we will have to click on the "OK" button to save the changes.\r
\r
## 5.2.3 FTP Client\r
\r
The main classes and methods in the org.apache.commons.net.ftp package are shown below.\r
\r
### 5.2.3.1 Connect and login\r
\r
\`\`\`java\r
public class ApacheFTPClient {\r
\r
    private String server;\r
    private int port;\r
    private String user;\r
    private String password;\r
    private FTPClient ftp;\r
\r
    public ApacheFTPClient(String server, int port, String user, String password) {\r
        this.server = server;\r
        this.port = port;\r
        this.user = user;\r
        this.password = password;\r
    }\r
\r
    void open() throws IOException {\r
        ftp = new FTPClient();\r
\r
        ftp.connect(server, port);\r
        int reply = ftp.getReplyCode();\r
        if (!FTPReply.isPositiveCompletion(reply)) {\r
            ftp.disconnect();\r
            throw new IOException("Exception in connecting to FTP Server");\r
        }\r
\r
        ftp.login(user, password);\r
    }\r
\r
    void close() throws IOException {\r
        ftp.disconnect();\r
    }\r
\r
    public static void main(String[] args) throws IOException {\r
        ApacheFTPClient client = new ApacheFTPClient("localhost", 21, "alumnodam", "psp");\r
        client.open();\r
        client.close();\r
    }\r
}\r
\`\`\`\r
\r
In the previous example we can see how to connect to an FTP server using the Apache Commons Net library.\r
\r
1. To do this, we will have to create an instance of the **FTPClient** class and call the connect method, passing as parameters the server and the port to which we want to connect.\r
1. Then we will have to check that the connection has been established correctly, for this we will have to call the *getReplyCode* method and check that the value returned by this method is positive.\r
1. Finally, we will have to call the login method, passing as parameters the user and the password with which we want to log in.\r
\r
### 5.2.3.2 Change directories\r
\r
In the FTP protocol, the local directory is the directory on the client's computer and the remote directory is the directory on the server. Both the local and remote directories are called working directories and both can be changed with the **changeWorkingDirectory** method for the remote files and the **File** methods to set the origin for the local files.\r
\r
To show the current working directory, we can use the **printWorkingDirectory** method and to show the contents of the current working directory, we can use the **listFiles** method or the **listNames** method.\r
\r
\`\`\`java\r
    // Get the current remote working directory\r
    String workingDirectory = ftp.printWorkingDirectory();\r
    \r
    // Show contents of current remote working directory\r
    for (String name : ftp.listNames()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Change the current remote working directory\r
    ftp.changeWorkingDirectory(fileName)\r
\`\`\`\r
\r
To show the current local working directory, we have to manage it with the File class and its methods. We can also rely on the System class and its methods as we studied in the process management unit.\r
\r
\`\`\`java\r
    // Get the current local working directory\r
    String workingDirectory = System.getProperty("user.dir");\r
    \r
    // Show contents of current local working directory\r
    File file = new File(workingDirectory);\r
    for (String name : file.list()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Change the current local working directory\r
    System.setProperty("user.dir", fileName);\r
\`\`\`\r
\r
### 5.2.3.3 Upload files\r
\r
In FTP files can be upload in two different ways:\r
\r
ASCII mode: The file is uploaded as text, with the line endings converted to the network standard.\r
\r
\`\`\`java\r
    public boolean sendTextFile(String fileName) throws FileNotFoundException, IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        InputStream input = new FileInputStream(file);\r
        boolean upload = ftp.storeFile(fileRemote, input);\r
        input.close();\r
        return upload;\r
    }\r
\`\`\`\r
\r
Binary mode: The file is uploaded as is, without any conversion.\r
\r
\`\`\`java\r
public boolean sendBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        InputStream input = new FileInputStream(file);\r
        OutputStream output = ftp.storeFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        input.close();\r
        output.close();\r
        boolean upload = ftp.completePendingCommand();\r
\r
        return upload;\r
    }\r
\`\`\`\r
\r
### 5.2.3.4 Download files\r
\r
As with the upload, files can be downloaded in two different ways:\r
\r
ASCII mode: The file is downloaded as text, with the line endings converted to the local standard.\r
\r
\`\`\`java\r
    public boolean getTextFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        OutputStream output = new FileOutputStream(file);\r
        boolean download = ftp.retrieveFile(fileRemote, output);\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
Binary mode: The file is downloaded as is, without any conversion.\r
\r
\`\`\`java\r
    public boolean getBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        OutputStream output = new FileOutputStream(file);\r
        InputStream input = ftp.retrieveFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        boolean download = ftp.completePendingCommand();\r
        input.close();\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
### 5.2.3.5 Other operations\r
\r
Other operations that can be performed on the FTP server are:\r
\r
Show file information and file properties\r
\r
\`\`\`java\r
    public void showFileInfo(String fileName) throws IOException {\r
        FTPFile[] files = ftp.listFiles(fileName);\r
        for (FTPFile file : files) {\r
            System.out.println(file.getName());\r
            System.out.println(file.getTimestamp().getTime());\r
            System.out.println(file.getSize());\r
            if (f.getType() == FTPFile.FILE_TYPE) {\r
                tipo = "File";\r
            }\r
            if (f.getType() == FTPFile.DIRECTORY_TYPE) {\r
                tipo = "Folder";\r
            }\r
        }\r
    }    \r
\`\`\`\r
\r
Add and remove remote FTP directories\r
\r
\`\`\`java\r
    public void addRemoteDirectory(String directory) throws IOException {\r
        ftp.makeDirectory(directory);\r
    }\r
\r
    public void removeRemoteDirectory(String directory) throws IOException {\r
        ftp.removeDirectory(directory);\r
    }\r
\`\`\`\r
\r
Create and remove remote FTP files\r
\r
\`\`\`java\r
    public void addRemoteFile(String fileName) throws IOException {\r
        ftp.storeFile(fileName, new ByteArrayInputStream(new byte[0]));\r
    }\r
\r
    public void removeRemoteFile(String fileName) throws IOException {\r
        ftp.deleteFile(fileName);\r
    }\r
\`\`\`\r
\r
Rename remote FTP files and directories\r
\r
\`\`\`java\r
    public void renameRemoteFile(String oldName, String newName) throws IOException {\r
        ftp.rename(oldName, newName);\r
    }\r
\`\`\`\r
`]},{title:"5.4 Annex I - GMail configurations",headers:[{level:2,title:"5.4.1 Common Exceptions when using Gmail SMTP",slug:"_5-4-1-common-exceptions-when-using-gmail-smtp",link:"#_5-4-1-common-exceptions-when-using-gmail-smtp",children:[{level:3,title:"5.4.1.1 Two-way authentication",slug:"_5-4-1-1-two-way-authentication",link:"#_5-4-1-1-two-way-authentication",children:[]},{level:3,title:"5.4.1.2 Less secure apps",slug:"_5-4-1-2-less-secure-apps",link:"#_5-4-1-2-less-secure-apps",children:[]}]}],path:"/en/unit5/gmail_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.4 Annex I - GMail configurations\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.4 Annex I - GMail configurations" />\r
\r
# 5.4 Annex I - GMail configurations\r
\r
[[toc]]\r
\r
## 5.4.1 Common Exceptions when using Gmail SMTP\r
\r
While sending an email with any of the above methods, you might get the following exceptions, even your Gmail credentials are correct.\r
\r
:::danger Google security\r
It's important to check your account security. Change the following settings only if you are absolutely sure of what you are doing.\r
\r
Do not share any of the password because your account can be used without your permission.\r
:::\r
\r
### 5.4.1.1 Two-way authentication\r
\r
\`\`\`java\r
Error while trying to send mail: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
The exception (jakarta.mail.AuthenticationFailedException) talks about the Application-specific password required. This is because your Gmail account is configured for 2-step verification so your direct Gmail password wont work here due to security reasons. To rectify this, you need to follow the below steps.\r
\r
1. Sign in with your Google account\r
2. Go to your Google account or just click on the link [Google account security settings](https://myaccount.google.com/?pli=1)\r
![Google settings](../../media/unit5/Google-Settings-1.1.png)\r
3. Click on Security from the left menu.\r
4. Scroll a bit down to reach the Signing in to Google section  most probably 3rd section from the top.\r
5. Here you can see 2-Step Verification is turned On.\r
![Google settings](../../media/unit5/Google-Settings-1.2.png)\r
6. Click on App Password just below it. Google will ask you to re-enter the password.\r
7. On the next screen, you need to select the App and Device.\r
8. From the Select app dropdown, just select Other (Custom name).\r
9. Give an appropriate name like Web and press Generate button.\r
![Google settings](../../media/unit5/Google-Settings-1.3.png)\r
10. You will a generated password on the screen with a popup.\r
11. Save and use this password for all your Java mail code.\r
\r
### 5.4.1.2 Less secure apps\r
\r
\`\`\`java\r
Error while trying to send mail: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
1. Sign in with your Google account\r
1. Go to your Google account or just click on the link [Google less secure apps settings](https://www.google.com/settings/security/) to advance until step 5.\r
![Google settings](../../media/unit5/Google-Settings-1.1.png)\r
1. Click on Security from the left menu.\r
1. Scroll a bit down to reach the Less secure applications".\r
1. You will find it disabled. Enter the section to turn it On.\r
![Google settings](../../media/unit5/Google-Settings-2.3.png)\r
1. Save and use your account password for all your Java mail code.\r
\r
<!-- References\r
Jakarta Mail Tutorials\r
https://mailtrap.io/blog/jakarta-mail-tutorial/\r
https://mailtrap.io/blog/sending-email-using-java/\r
https://www.opensource-techblog.com/use-java-mail-api-to-send-email-with-gmail-smtp-example.html\r
\r
Modify pom.xml to make dependencies be copied along with the jar file\r
https://www.baeldung.com/executable-jar-with-maven\r
-->\r
`]},{title:"5 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit5/",pathLocale:"/en/",extraFields:[`---\r
title: 5 Introduction\r
---\r
\r
# Unit 5. Network Services\r
\r
Services are helpers used in a system to manage a collection of resources and provide their functionality to users and applications.\r
\r
Access to services consists of the set of operations offered, for example, a file service offers read, write, and delete file operations.\r
\r
All Internet services implement a client-server relationship. There are many libraries to work with the most common services. In this unit we are going to focus on the FTP (file transfer), SMTP service (mail sending) and POP3/IMAP (mail reading).\r
\r
In addition, there are other approaches, also based on the client-server architecture that allow access to systems. Among the most used, is what is called \`Rest API\`, which is still a service over *HTTP* that allows you to interact with  the backend of the  systems, no matter the architecture and languages used in the frontend.\r
\r
We are going to analyze in this unit other approaches such as queue systems, based on the MQ protocol, or \`serverless systems\`  offered by the main cloud computing platforms (Azure Functions, AWS Lambda and Google Cloud Functions).\r
\r
## Goals\r
\r
Goals of this unit:\r
\r
- Use Java libraries to use the most important TCP/IP application protocols.\r
- Test network communication services.\r
- Allow cloud operations easily.\r
- Create applications that allow asynchronous communication between clients and between clients and servers.\r
`]},{title:"5.1 Mail",headers:[{level:2,title:"5.1.1 Jakarta Mail",slug:"_5-1-1-jakarta-mail",link:"#_5-1-1-jakarta-mail",children:[{level:3,title:"Library usage",slug:"library-usage",link:"#library-usage",children:[]}]},{level:2,title:"5.1.2 Jakarta Mail API Core Classes",slug:"_5-1-2-jakarta-mail-api-core-classes",link:"#_5-1-2-jakarta-mail-api-core-classes",children:[{level:3,title:"jakarta.mail.Session",slug:"jakarta-mail-session",link:"#jakarta-mail-session",children:[]},{level:3,title:"jakarta.mail.Message",slug:"jakarta-mail-message",link:"#jakarta-mail-message",children:[]},{level:3,title:"jakarta.mail.Address",slug:"jakarta-mail-address",link:"#jakarta-mail-address",children:[]},{level:3,title:"jakarta.mail.Authenticator",slug:"jakarta-mail-authenticator",link:"#jakarta-mail-authenticator",children:[]},{level:3,title:"jakarta.mail.Transport",slug:"jakarta-mail-transport",link:"#jakarta-mail-transport",children:[]}]},{level:2,title:"5.1.3 Send basic emails in Jakarta Mail",slug:"_5-1-3-send-basic-emails-in-jakarta-mail",link:"#_5-1-3-send-basic-emails-in-jakarta-mail",children:[{level:3,title:"Preparing session",slug:"preparing-session",link:"#preparing-session",children:[]},{level:3,title:"Message composition (plain text)",slug:"message-composition-plain-text",link:"#message-composition-plain-text",children:[]},{level:3,title:"Send message",slug:"send-message",link:"#send-message",children:[]}]},{level:2,title:"5.1.4 Send HTML messages",slug:"_5-1-4-send-html-messages",link:"#_5-1-4-send-html-messages",children:[]},{level:2,title:"5.1.5 Send Email with Attachments",slug:"_5-1-5-send-email-with-attachments",link:"#_5-1-5-send-email-with-attachments",children:[]},{level:2,title:"5.1.6 Send HTML emails with images",slug:"_5-1-6-send-html-emails-with-images",link:"#_5-1-6-send-html-emails-with-images",children:[{level:3,title:"CID (Content-ID) image embedding",slug:"cid-content-id-image-embedding",link:"#cid-content-id-image-embedding",children:[]},{level:3,title:"Inline embedding (Base64 encoding)",slug:"inline-embedding-base64-encoding",link:"#inline-embedding-base64-encoding",children:[]},{level:3,title:"Linked images",slug:"linked-images",link:"#linked-images",children:[]}]},{level:2,title:"5.1.7 Read emails in Jakarta Mail",slug:"_5-1-7-read-emails-in-jakarta-mail",link:"#_5-1-7-read-emails-in-jakarta-mail",children:[]}],path:"/en/unit5/mail.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.1 Mail\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.1 Mail" />\r
\r
# 5.1 Mail\r
\r
[[toc]]\r
\r
## 5.1.1 Jakarta Mail\r
\r
When scouring the Internet for tutorials on sending emails using Java, there is a high chance every single one will mention something called \`Jakarta Mail\` or \`Java Mail\`.\r
\r
For a long time, the Java Enterprise Edition (commonly known as Java EE), has been the de facto platform for developing mission-critical applications.\r
\r
Recently, in order to stir the creation of cloud-native applications, several prominent software vendors joined hands to transfer Java EE technologies to the Eclipse Foundation, which is a not-for-profit organization tasked with stewarding the activities of the Eclipse open source software community.\r
\r
>**Consequently, the Java EE has been rebranded to Jakarta EE.**\r
\r
In spite of the name change, all the main classes and properties definitions still remain the same for both Jakarta Mail and JavaMail.\r
\r
::: tip Jakarta vs Java Mail\r
To avoid confusion, its important to note that JavaMail is only the former name of Jakarta Mail and the two represent the same software.\r
:::\r
\r
So, Jakarta Mail, or JavaMail as some still like to call it, is an API for sending and receiving emails via **SMTP**, **POP3**, as well as **IMAP** and is the most popular option that also supports both TLS and SSL authentication. It is platform-independent, protocol-independent, and built into the Jakarta EE platform.\r
\r
You can also find Jakarta Mail as an optional package for use with the Java SE platform.\r
\r
### Library usage\r
\r
>[JakartaMail API](https://jakarta.ee/specifications/mail/2.1/jakarta-mail-spec-2.1) is the Jakarta Mail API specification. The reference implementation of this specification can be found in the GitHub repository [Jakarta Mail Specification](https://jakartaee.github.io/mail-api/).\r
\r
::: danger JavaMail API\r
As the name suggests, JavaMail API is an API, not an implementation. So you cant use it directly in your project. Instead, you need to use an implementation of the Jakarta Mail API, such as the reference implementation of the Jakarta Mail API specification. \r
:::\r
\r
You can also find the jakarta.mail-api-X.Y.Z.jar file in the Maven repository and add it with \`Maven\` dependencies:\r
\r
\`\`\`xml:no-line-numbers\r
    <dependencies>\r
        <dependency>\r
            <groupId>org.eclipse.angus</groupId>\r
            <artifactId>angus-mail</artifactId>\r
            <version>2.0.2</version>\r
            <type>jar</type>\r
        </dependency>        \r
        <dependency>\r
            <groupId>jakarta.mail</groupId>\r
            <artifactId>jakarta.mail-api</artifactId>\r
            <version>2.1.2</version>\r
            <type>jar</type>\r
        </dependency>\r
    </dependencies>\r
\`\`\`\r
\r
::: info Implementaciones de Jakarta Mail\r
In the previous example we have used the Jakarta AngusMail implementation, but you can use others like the Oracle one, just changing the dependency.\r
\r
\`\`\`xml:no-line-numbers\r
        <dependency>\r
            <groupId>com.sun.mail</groupId>\r
            <artifactId>jakarta.mail</artifactId>\r
            <version>2.0.1</version>\r
        </dependency>      \r
\`\`\`\r
\r
As it is an implementation of the API proposed by Jakarta, the code should work without changes.\r
:::\r
\r
## 5.1.2 Jakarta Mail API Core Classes\r
\r
The Jakarta Mail API has a wide range of classes and interfaces that can be used for sending, reading, and performing other actions with email messagesjust like in a typical mailing system.\r
\r
Although there are several packages in the Jakarta Mail Project, two of the most frequently used ones are \`jakarta.mail\` and \`jakarta.mail.internet\`.\r
\r
The **jakarta.mail** package provides classes that model a mail system and the **jakarta.mail.internet** package provides classes that that are focused to Internet mail systems.\r
\r
Here is a description of the core classes in each of the packages:\r
\r
### jakarta.mail.Session\r
\r
The Session class, which is not subclassed, is the *top-level class of the Jakarta Mail API*. Its a multi-threaded object that acts as the connection factory for the Jakarta Mail API. apart from collecting the mail APIs properties and defaults, **it is responsible for configuration settings and authentication**.\r
\r
To get the Session object, you can call either of the following two methods:\r
\r
- getDefaultInstance(), which returns the default session\r
- getInstance(), which returns a new session\r
  \r
### jakarta.mail.Message\r
\r
The Message class is an *abstract class* that models an email message; its subclasses support the actual implementations. Usually, its \`MimeMessage subclass\` *(jakarta.mail.internet.MimeMessage)* is used for actually crafting the details of the email message to be sent. **A MimeMessage is an email message that uses the MIME (Multipurpose Internet Mail Extension) formatting style** defined in the RFC822.\r
\r
Here are some of the commonly used methods of the MimeMessage class:\r
|Method |Description |\r
|:---|:---|\r
|setFrom(Address addresses) | Its used to set the From header field.|\r
|setRecipients(Message.RecipientType type, String addresses) | Its used to set the stated recipient type to the provided addresses. The possible defined address types are TO (Message.RecipientType.TO), CC (Message.RecipientType.CC), and BCC (Message.RecipientType.BCC).|\r
|setSubject(String subject) | Its used to set the emails subject header field.|\r
|setText(String text) | Its used to set the provided String as the emails content, using MIME type of text/plain. |\r
|setContent(Object message, String contentType) | Its used to set the emails content, and can be used with a MIME type other than text/html.|\r
\r
### jakarta.mail.Address\r
\r
The Address class is an *abstract class* that models the addresses (To and From addresses) in an email message; its subclasses support the actual implementations. Usually, its \`InternetAddress subclass\`, which denotes an Internet email address, is commonly used.\r
\r
### jakarta.mail.Authenticator\r
\r
The Authenticator class is an *abstract class* that is used to get authentication to access the mail server resourcesoften by requiring the users information. Usually, its \`PasswordAuthentication subclass\` is commonly used.\r
\r
### jakarta.mail.Transport\r
\r
The Transport class is an *abstract class* that uses the \`SMTP protocol\` for submitting and transporting email messages.\r
\r
## 5.1.3 Send basic emails in Jakarta Mail\r
\r
Essentially, here are the steps for sending an email message using the Jakarta Mail API:\r
\r
1. Configure the SMTP server details using a **Java Properties object**. You can get SMTP server details from your email service provider.\r
1. Create a Session object by calling the getInstance() method. Then, pass the \`accounts username and password\` to PasswordAuthentication. When creating the session object, you should always register the Authenticator with the Session.\r
1. Once the Session object is created, the next step is to create the email message to be sent. To do this, start by passing the created session object in the MimeMessage class constructor.\r
1. Next, after creating the message object, set the From, To, and Subject fields for the email message.\r
1. Use the setText() method to set the content of the email message.\r
1. Use the Transport object to send the email message.\r
1. Add Exceptions to retrieve the details of any possible errors when sending the message.\r
\r
### Preparing session\r
\r
The very first step is to get the mail session object. The Session class is a singleton class. So you cant directly create an instance of it. You need to call one of the overloaded static methods, usually \`getInstance()\`.\r
\r
::: info Properties Files/Objects\r
A property file is a text file containing key-value pairs for the configuration settings of a project.\r
\r
It can be created on-the-fly as in the next examples, but it can also be read from a file in the project (this is the preferred way).\r
\r
Here you can find some links to take a look on how to use and access these files\r
\r
- [Java Properties Files y como usarlos - Arquitectura Java](https://www.arquitecturajava.com/java-properties-files-y-como-usarlos/)\r
- [Getting started with Java properties - Baeldung](https://www.baeldung.com/java-properties)\r
- [Properties class in Java - javaTpoint](https://www.javatpoint.com/properties-class-in-java)\r
\r
![http://www.instanceofjava.com/2018/01/how-to-read-values-from-properties-file.html](../../media/unit5/propertiesfile.png)\r
\r
In the previous image you can see where to place the properties file in a \`Maven\` project.\r
:::\r
\r
\`\`\` java\r
// Prepare SMTP configuration into a Property object\r
final Properties prop = new Properties();\r
prop.put("mail.smtp.username", "usuario@gmail.com");\r
prop.put("mail.smtp.password", "passwordEmail");\r
prop.put("mail.smtp.host", "smtp.gmail.com");\r
prop.put("mail.smtp.port", "587");\r
prop.put("mail.smtp.auth", "true");\r
prop.put("mail.smtp.starttls.enable", "true"); // TLS\r
\r
// Create the Session with the user credentials\r
Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
    @Override\r
    protected PasswordAuthentication getPasswordAuthentication() {\r
        return new PasswordAuthentication(prop.getProperty("mail.smtp.username"), \r
                    prop.getProperty("mail.smtp.password"));\r
    }\r
});\r
\`\`\`\r
\r
In the above code, we have just created the Session object with properties and the Authenticator object.\r
\r
The properties are as follows.\r
\r
- mail.smtp.username  Username of SMTP server\r
- mail.smtp.password  Password of SMTP server\r
- mail.smtp.host  Host of SMTP server\r
- mail.smtp.port  Port\r
- mail.smtp.auth  Is Authentication is required.\r
- mail.smtp.starttls.enable  TLS enable or not.\r
\r
The Authenticator is an abstract class. Its object is created by providing an anonymous implementation of getPasswordAuthentication() method. The PasswordAuthentication class is used as a placeholder for storing user credentials.\r
\r
Here you can find a sample code to read the properties from a file in the project.\r
\r
\`\`\`java\r
    private void loadSMTPConfiguration() {\r
        try ( InputStream input = this.getClass().getResourceAsStream("/" + propertiesFile)) {\r
\r
            smtpConfiguration = new Properties();\r
            // load a properties file\r
            smtpConfiguration.load(input);\r
\r
            // get the property value and print it out\r
            smtpConfiguration.forEach((key, value) -> System.out.println("Key : " + key + ", Value : " + value));\r
\r
        } catch (IOException ex) {\r
            System.err.println("Cant open properties file: " + ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }\r
    }    \r
\`\`\`\r
\r
The content of the properties file could be something like this\r
\r
\`\`\`txt\r
# Data to send emails from a GMAIL account\r
mail.from=cuenta@iesdoctorbalmis.com  cuenta@gmail.com\r
mail.smtp.username=cuenta@iesdoctorbalmis.com\r
mail.smtp.password=***contrasea de la cuenta habilitando apps poco seguras o contrasea de app con 2FA***\r
\r
\r
mail.smtp.host=smtp.gmail.com\r
mail.smtp.port=587\r
mail.smtp.auth=true\r
mail.smtp.starttls.enable=true\r
\`\`\`\r
\r
### Message composition (plain text)\r
\r
Next, we will compose the email message. The jakarta.mail.Message class represents a message in Java mail API. Since its an abstract class, we will use its concrete implementation \`jakarta.mail.internet.MimeMessage\` class. Java Mail API allows sending mail either in plain text or in HTML content. Lets start by sending a plain text message.\r
\r
\`\`\`java{8}\r
// Prepare the MimeMessage\r
Message message = new MimeMessage(mailSession);\r
// Set From and subject email properties\r
message.setFrom(new InternetAddress("no-reply@gmail.com"));\r
message.setSubject("Sending Mail with pure Java Mail API ");\r
\r
// Set to, cc & bcc recipients        \r
InternetAddress[] toEmailAddresses = \r
        InternetAddress.parse("user1@gmail.com, user2@gmail.com");\r
InternetAddress[] ccEmailAddresses = \r
        InternetAddress.parse("user21@gmail.com, user22@gmail.com");\r
InternetAddress[] bccEmailAddresses = \r
        InternetAddress.parse("user31@gmail.com");\r
            \r
message.setRecipients(Message.RecipientType.TO,toEmailAddresses);\r
message.setRecipients(Message.RecipientType.CC,ccEmailAddresses);\r
message.setRecipients(Message.RecipientType.BCC,bccEmailAddresses);\r
\r
/* Mail body with plain Text */\r
message.setText("Hello User," \r
        + "\\n\\n If you read this, means mail sent with Java Mail API is successful");\r
\r
\`\`\`\r
\r
> **To send an email in plain text, just pass the text in the message.setText() method.**\r
\r
### Send message\r
\r
So far, we created a session and compose the message. Now its time to send the message to the recipients. We will use jakarta.mail.Transport class for the same. It provides overloaded \`send()\` methods.\r
\r
\`\`\`java\r
    // Send the configured message in the session\r
    Transport.send(message);\r
\`\`\`\r
\r
## 5.1.4 Send HTML messages\r
\r
In terms of usability, HTML content is far superior to plain text. So, most of the time, we send emails in HTML content. Java Mail API supports sending emails in HTML content. To send an email with HTML content, you need to replace the message.setText() method with below code.\r
\r
\`\`\`java\r
...\r
message.setContent("Just discovered that Jakarta Mail is fun and easy to use", \r
"text/html");\r
...\r
\`\`\`\r
\r
> well be using the **setContent()** method to set content and specify \`"text/html\` in the second argument, indicating the message has HTML content.\r
\r
## 5.1.5 Send Email with Attachments\r
\r
Apart from the previously mentioned steps, here are the differing steps involved in using the Jakarta Mail API for sending email attachments:\r
\r
1. Create an instance of the \`MimeMultipart\` object that will be used for wrapping the MimeBodyPart body parts. **A Multipart acts like a container that keeps multiple body parts**, and it comes with methods for getting and setting its various subparts.\r
1. Then, set the first part of the multipart object by passing the actual message to it.\r
1. Next, set the second and next parts of the multipart object by adding the attachment.\r
1. Include the multipart in the message to be sent.\r
1. Send the message\r
\r
![Multipart MIME Message structure](../../media/unit5/e-mail_multipart_structure.png)\r
\r
\`\`\`java{2,5,9,12,16,19}\r
 // create an instance of multipart object\r
Multipart multipart = new MimeMultipart();\r
\r
// create the 1st message body part\r
MimeBodyPart messageBodyPart = new MimeBodyPart();\r
// Add a plain message (HTML can also be added with setContent)\r
messageBodyPart.setText("Please find the attachment sent using Jakarta Mail");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// 2nd. bodyPart with an attached file\r
messageBodyPart = new MimeBodyPart();\r
String filename = "C:/temp/file1.pdf";\r
messageBodyPart.attachFile(filename);\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
::: info Test emails\r
You can use [YopMail](http://www.yopmail.com/en/) to test your email sending code. Its a free service that provides disposable email addresses. You can use any email address of your choice to receive emails. The service is free and can be used to receive emails anonymously.\r
:::\r
\r
## 5.1.6 Send HTML emails with images\r
\r
To add an image to your HTML email in Jakarta Mail, you can choose any of the three common options:\r
\r
- CID image embedding\r
- inline embedding or Base64 encoding\r
- linked images.\r
  \r
### CID (Content-ID) image embedding\r
\r
To do CID image embedding, you need to create a MIME \`multipart/related\` message using the following code:\r
\r
\`\`\`java{2,5,17}\r
// 1st part of the message. An HTML code with a CID referenced image\r
Multipart multipart = new MimeMultipart("related");\r
MimeBodyPart htmlPart = new MimeBodyPart();\r
//add reference to your image to the HTML body <img src="cid:some-image-cid" alt="img" />\r
String messageBody = "<p></p><img src=\\"cid:my-test-image-cid\\" alt=\\"embedded img\\" /></p>";\r
htmlPart.setText(messageBody, "utf-8", "html");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(htmlPart);\r
\r
// 2nd part of the message. The image with special CID header markers\r
MimeBodyPart imgPart = new MimeBodyPart();\r
// imageFile is the file containing the image\r
imgPart.attachFile(imageFile);\r
// or, if the image is in a byte array in memory, use\r
// imgPart.setDataHandler(new DataHandler(\r
//      new ByteArrayDataSource(bytes, "image/whatever")));\r
imgPart.setContentID("<my-test-image-cid>");\r
// Add the multipart object to the message\r
multipart.addBodyPart(imgPart);\r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
### Inline embedding (Base64 encoding)\r
\r
For inline embedding or Base64 encoding, you should include the encoded image data in the HTML body similar to this:\r
\r
\`\`\`html\r
<img src="data:image/jpeg;base64,base64-encoded-data-here" />\r
\`\`\`\r
\r
::: warning HTML size\r
Each Base64 digit represents 6 bits of data, so your actual image code will be pretty long.\r
\r
As this affects the overall size of the HTML message, its better not to use inline large images.\r
:::\r
\r
To Base 64 encode/decode a stream we can use the \`java.util.Base64\` class.\r
\r
 \`\`\`java\r
byte[] fileContent = new FileInputStream(imageFile).readAllBytes();\r
String base64EncodedData = Base64.getEncoder().encodeToString(fileContent);\r
 \`\`\`\r
\r
:::tip Base64 encoding\r
Base64 is such a good option to send binary data over text protocols like HTTP without data loose.\r
\r
This operation could be applied for any binary files or binary arrays. It's useful when we need to transfer binary content in JSON format such as from mobile app to REST endpoint.\r
\r
[Image to Base64 String Conversion - Baeldung](https://www.baeldung.com/java-base64-image-string)\r
:::\r
\r
### Linked images\r
\r
Lastly, we have linked images that are essentially images hosted on some external server that you then create a link to.\r
You can do that using the img tag in the HTML body like so\r
\r
\`\`\`html\r
<img src="/wp-content/uploads/2018/11/blog/-illustration-email-embedding-images.png" alt="img" />\r
\`\`\`\r
\r
::: warning Debug Jakarta Mail\r
Debugging plays a critical role in testing of email sending.\r
\r
In Jakarta Mail, its pretty straightforward. Set debug to true in the properties of your email code:\r
\r
> props.put("mail.debug", "true");\r
\r
As a result, you will get a step by step description of how your code is executed. If any problem with sending your message appears, you will instantly understand what happened and at which stage.\r
:::\r
\r
## 5.1.7 Read emails in Jakarta Mail\r
\r
The Jakarta Mail API also provides support for reading emails. To read emails, you need to use the \`javax.mail.Store\` class. The Store class is an abstract class that models a message store and its access protocol, and its subclassed by the \`POP3Store\` and \`IMAPStore\` classes.\r
\r
Reading emails stored on an IMAP server consists of the following steps:\r
\r
- Creation of the IMAP session (Session), indicating the protocol, the host name, the port, if it uses\r
SSL and the associated trusted server.\r
- Configuration and obtaining of the warehouse (Store).\r
- Obtaining the connection through the store, indicating the account identifier and password.\r
- Obtaining the folder to be read.\r
- Opening of the folder.\r
- Getting the messages\r
- Message processing\r
- Closing of the folder and the store.\r
- Closing of the session and the connection.\r
\r
\`\`\`java\r
    // Prepare IMAP configuration into a Property object\r
    final Properties prop = new Properties();\r
    prop.put("mail.imap.host", "imap.gmail.com");\r
    prop.put("mail.imap.port", "993");\r
    prop.put("mail.imap.ssl.enable", "true");\r
    prop.put("mail.imap.auth", "true");\r
\r
    // Create the Session with the user credentials\r
    Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
        @Override\r
        protected PasswordAuthentication getPasswordAuthentication() {\r
            return new PasswordAuthentication(prop.getProperty("mail.imap.username"), \r
                        prop.getProperty("mail.imap.password"));\r
        }\r
    });\r
\r
    // Get the Store object and connect to the current host using the specified username and password.\r
    Store store = mailSession.getStore("imap");\r
    store.connect(prop.getProperty("mail.imap.host"), \r
            prop.getProperty("mail.imap.username"), \r
            prop.getProperty("mail.imap.password"));\r
\r
    // Get the folder and open it\r
    Folder folder = store.getFolder("INBOX");\r
    folder.open(Folder.READ_ONLY);\r
\r
    // Get the messages\r
    Message[] messages = folder.getMessages();\r
\r
    // Process the messages\r
    for (int i = 0; i < messages.length; i++) {\r
        Message message = messages[i];\r
        System.out.println("Message " + (i + 1));\r
        System.out.println("From: " + message.getFrom()[0]);\r
        System.out.println("Subject: " + message.getSubject());\r
        System.out.println("Sent Date: " + message.getSentDate());\r
        System.out.println("Text: " + message.getContent().toString());\r
    }\r
\r
    // Close the folder and store objects\r
    folder.close(false);\r
    store.close();\r
\`\`\`\r
`]},{title:"5.3 Auxiliary classes for networking",headers:[{level:2,title:"5.3.1 java.net.NetworkInterface",slug:"_5-3-1-java-net-networkinterface",link:"#_5-3-1-java-net-networkinterface",children:[]},{level:2,title:"4.2.2 java.net.InterfaceAddress",slug:"_4-2-2-java-net-interfaceaddress",link:"#_4-2-2-java-net-interfaceaddress",children:[]},{level:2,title:"4.2.3. java.net.InetAddress",slug:"_4-2-3-java-net-inetaddress",link:"#_4-2-3-java-net-inetaddress",children:[]},{level:2,title:"4.2.4 java.net.URL",slug:"_4-2-4-java-net-url",link:"#_4-2-4-java-net-url",children:[]},{level:2,title:"4.2.5 java.net.URLConnection",slug:"_4-2-5-java-net-urlconnection",link:"#_4-2-5-java-net-urlconnection",children:[]}],path:"/en/unit5/urls.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.3 Auxiliary classes for networking\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.3 Auxiliary classes for networking" />\r
\r
# 5.3 Auxiliary classes for networking\r
\r
[[toc]]\r
\r
## 5.3.1 java.net.NetworkInterface\r
\r
This class represents network interface, both software as well as hardware, its name, list of IP addresses assigned to it and all related information. It can be used in cases when we want to specifically use a particular interface for transmitting our packet on a system with multiple NICs.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html)\r
\r
::: info What is a Network Interface?\r
A network interface can be thought of as a point at which your computer connects to the network. It is not necessarily a piece of hardware but can also be implemented in a software. For example a loopback interface which is used for testing purposes.\r
:::\r
\r
| Method                                                            | Description                                                                                                                                                                                         |\r
| ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public static Enumeration getNetworkInterfaces()                  | Returns all the network interfaces on the system.                                                                                                                                                   |\r
| public List getInterfaceAddresses()                               | Returns a list of all interface addresses on this interface.                                                                                                                                        |\r
| public Enumeration getInetAddresses()                             | Returns an enumeration of all InetAddresses bound to this network interface, if security manager allows it.                                                                                         |\r
| public String getName()                                           | Returns the name of this network interface.                                                                                                                                                         |\r
| public int getIndex()                                             | Returns the index assigned to this network interface by the system. Indexes can be used in place of long names to refer to any interface on the device.                                             |\r
| public String getDisplayName()                                    | This method returns the name of network interface in a readable string format.                                                                                                                      |\r
| public static NetworkInterface getByName(String name)             | Finds and returns the network interface with the specified name, or null if none exists.                                                                                                            |\r
| public static NetworkInterface getByIndex(int index)              | Performs similar function as the previous function with index used as search parameter instead of name.                                                                                             |\r
| public static NetworkInterface getByInetAddress(InetAddress addr) | This method is widely used as it returns the network interface the specified inetaddress is bound to. If an InetAddress is bound to multiple interfaces, any one of the interfaces may be returned. |\r
| public boolean isUp()                                             | Returns a boolean value indicating if this network interface is up and running.                                                                                                                     |\r
\r
\`\`\`java\r
// Java program to illustrate various java.net.NetworkInterface class methods.\r
\r
public class NetworkInterfaceExample\r
{\r
    public static void main(String[] args) throws SocketException,\r
                                                UnknownHostException\r
    {\r
\r
        // getNetworkInterfaces() returns a list of all interfaces\r
        // present in the system.\r
        ArrayList<NetworkInterface> interfaces = Collections.list(\r
                                            NetworkInterface.getNetworkInterfaces());\r
\r
        System.out.println("Information about present Network Interfaces...\\n");\r
        for (NetworkInterface iface : interfaces)\r
        {\r
            // isUp() method used for checking whether the interface in process\r
            // is up and running or not.\r
            if (iface.isUp())\r
            {\r
                // getName() method\r
                System.out.println("Interface Name: " + iface.getName());\r
\r
                // getDisplayName() method\r
                System.out.println("Interface display name: " + iface.getDisplayName());\r
\r
                // getHardwareAddress() method\r
                System.out.println("Hardware Address: " +\r
                                Arrays.toString(iface.getHardwareAddress()));\r
\r
                // getParent() method\r
                System.out.println("Parent: " + iface.getParent());\r
\r
                // getIndex() method\r
                System.out.println("Index: " + iface.getIndex());\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInterface addresses: ");\r
\r
                // getInterfaceAddresses() method\r
                for (InterfaceAddress addr : iface.getInterfaceAddresses())\r
                {\r
                    System.out.println("\\t\\t" + addr.getAddress().toString());\r
                }\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInetAddresses associated with this interface: ");\r
\r
                // getInetAddresses() method returns list of all\r
                // addresses currently bound to this interface\r
                Enumeration<InetAddress> en = iface.getInetAddresses();\r
                while (en.hasMoreElements())\r
                {\r
                    System.out.println("\\t\\t" + en.nextElement().toString());\r
                }\r
\r
                // getMTU() method\r
                System.out.println("\\tMTU: " + iface.getMTU());\r
\r
                // getSubInterfaces() method\r
                System.out.println("\\tSubinterfaces: " +\r
                                Collections.list(iface.getSubInterfaces()));\r
\r
                // isLoopback() method\r
                System.out.println("\\tis loopback: " + iface.isLoopback());\r
\r
                // isVirtual() method\r
                System.out.println("\\tis virtual: " + iface.isVirtual());\r
\r
                // isPointToPoint() method\r
                System.out.println("\\tis point to point: " + iface.isPointToPoint());\r
\r
                // supportsMulticast() method\r
                System.out.println("Supports Multicast: " + iface.supportsMulticast());\r
\r
            }\r
        }\r
\r
        // getByIndex() method returns network interface\r
        // with the specified index\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
\r
        // toString() method is used to display textual\r
        // information about this network interface\r
        System.out.println("Network interface 1: " + nif.toString());\r
\r
        // getByName() method returns network interface\r
        // with the specified name\r
        NetworkInterface nif2 = NetworkInterface.getByName("eth0");\r
        InetAddress ip = InetAddress.getByName("localhost");\r
\r
        // getbyInetAddress() method\r
        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\r
        System.out.println("\\nlocalhost associated with: " + nif3);\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.2 java.net.InterfaceAddress\r
\r
This class represents a network interface address. Every device that has an IP address has an IP address on the network interface.\r
\r
In short it's an IP address, a subnet mask and a broadcast address when the address is an IPv4 one. An IP address and a network prefix length in the case of IPv6 address.\r
\r
> [java.net.InterfaceAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html)\r
\r
| Method                                | Description                                                                                                                                                                     |\r
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public InetAddress getAddress()       | Returns an InetAddress for this address.                                                                                                                                        |\r
| public InetAddress getBroadcast()     | Returns the InetAddress for the broadcast address for this interface address. As only IPv4 addresses have broadcast addresses, null would be returned on using an IPv6 address. |\r
| public short getNetworkPrefixLength() | Returns the prefix length for this interface address, i.e. subnet mask for this address.                                                                                        |\r
\r
\`\`\`java\r
// Java program to illustrate methods of java.net.InterfaceAddress class\r
\r
public class InterfaceaddressExample\r
{\r
    public static void main(String[] args) throws SocketException\r
    {\r
        // Modify according to your system\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
        List<InterfaceAddress> list = nif.getInterfaceAddresses();\r
\r
        for (InterfaceAddress iaddr : list)\r
        {\r
            // getAddress() method\r
            System.out.println("getAddress() : " + iaddr.getAddress());\r
\r
            // getBroadcast() method\r
            System.out.println("getBroadcast() : " + iaddr.getBroadcast());\r
\r
            // getNetworkPrefixLength() method\r
            System.out.println("PrefixLength : " + iaddr.getNetworkPrefixLength());\r
\r
            // hashCode() method\r
            System.out.println("Hashcode : " + iaddr.hashCode());\r
\r
            // toString() method\r
            System.out.println("toString() : " + iaddr.toString());\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.3. java.net.InetAddress\r
\r
Java InetAddress class represents an IP address. The java.net.InetAddress class provides methods to get the IP of any host name for example www.google.com, www.facebook.com, etc.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)\r
\r
An instance of InetAddress represents the IP address with its corresponding host name. There are two types of addresses: Unicast and Multicast. The Unicast is an identifier for a single interface whereas Multicast is an identifier for a set of interfaces.\r
\r
::: warning Local Name Resolver (hosts file)\r
You should know that DNS translates domain names like into IP addresses. But did you know that theres a file on your system that can override that?\r
Its called your hosts file and lets you map specific domain names to an IP address of your choosing. Your HOSTS file only affects your computer, so you can use it to create custom URLs for IP addresses on your network, or you can use it to redirect certain websites.\r
\r
As you can imagine, editing the HOSTS file can easily break your internet if its modified incorrectly or maliciously. So, its not particularly easy for a normal user to edit. This is a good thing.\r
\r
- Windows\r
\r
The HOSTS file is normally stored in a plain text file in the Windows System folder.\r
\r
Hit the start menu or press the Windows key and start typing Notepad.\r
\r
Right-click Notepad and choose Run as administrator.\r
\r
In Notepad, click File then Open In the File name field, paste the following path in:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Now youll be able to edit and save changes to your HOSTS file.\r
\r
To map a domain, add a line based on the examples in the HOSTS file.\r
\r
- OS X & GNU/Linux\r
\r
The file is in /etc/hosts and you should edit it with administrator privileges.\r
\r
\`\`\`bash\r
# Add the following lines to the hosts file\r
## At school\r
##  - use your computer IP for the 'cliente' and 'servidor' entries.\r
##  - use the teacher's computer IP as the 'profesor' entry\r
## At home\r
##  - use your computer IP for the 'cliente', 'servidor' and 'profesor' entries.\r
\r
# In all the activities, we will always use these domain names \r
# making our apps work at home and at school without having to change any IP address.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
| Method                                                                       | Description                                                                      |\r
| ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\r
| public static InetAddress getByName(String host) throws UnknownHostException | It returns the instance of  InetAddress containing LocalHost IP and name.        |\r
| public static InetAddress getLocalHost() throws UnknownHostException         | It returns the instance of InetAdddress  containing local host name and address. |\r
| public String getHostName()                                                  | It returns the host name of the IP address.                                      |\r
| public String getHostAddress()                                               | It returns the IP address in string format.                                      |\r
| public boolean isReachable(int timeout)                                      | This method tests whether that address is reachable.                             |\r
\r
\`\`\`java\r
\r
class InetAddressExample {\r
    public static void main(String[] args)\r
        throws UnknownHostException\r
    {\r
        // To get and print InetAddress of Local Host\r
        InetAddress address1 = InetAddress.getLocalHost();\r
        System.out.println("InetAddress of Local Host : "\r
                        + address1);\r
\r
        // To get and print InetAddress of Named Host\r
        InetAddress address2\r
            = InetAddress.getByName("45.22.30.39");\r
        System.out.println("InetAddress of Named Host : "\r
                        + address2);\r
\r
        // To get and print ALL InetAddresses of Named Host\r
        InetAddress address3[]\r
            = InetAddress.getAllByName("172.19.25.29");\r
        for (int i = 0; i < address3.length; i++) {\r
            System.out.println(\r
                "ALL InetAddresses of Named Host : "\r
                + address3[i]);\r
        }\r
\r
        // To get and print InetAddresses of\r
        // Host with specified IP Address\r
        byte IPAddress[] = { 125, 0, 0, 1 };\r
        InetAddress address4\r
            = InetAddress.getByAddress(IPAddress);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address : "\r
            + address4);\r
\r
        // To get and print InetAddresses of Host\r
        // with specified IP Address and hostname\r
        byte[] IPAddress2\r
            = { 105, 22, (byte)223, (byte)186 };\r
        InetAddress address5 = InetAddress.getByAddress(\r
            "gfg.com", IPAddress2);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address and hostname : "\r
            + address5);\r
    }\r
}\r
\r
\`\`\`\r
\r
::: question Host seeker (U4S4_HostSeeker)\r
Your computer is connected to a LAN (Local Area Network) and probably it is using private IP addresses.\r
\r
Addresses can be one of class C (192.168.X.Y), class B (172.17.X.Y) or class A (10.X.Y.Z). That depends on the network mask or network prefix used for the network interface configuration.\r
\r
You can also check it using Linux **ifconfig** command or Windows **ipconfig** command.\r
\r
Write a program to know which hosts are up and running in your network, that is, which hosts are reachable from you computer by using one of the interfaces.\r
\r
First, you can write specific code to test your network.\r
Once your app is working, try to make it generic and reusable by making it work in any network, detecting the network prefix and checking all the possible IPs in a network.\r
\r
The app will get a Network interface card name as argument and will check only the IPv4 addresses attached to that interface. We can know if an IP is IPv4 or IPv6 using the operator \`nstanceof\` with Inet4Address and  Inet6Address subclasses of InetAddress\r
:::\r
\r
::: details Code for the example\r
\r
\`\`\`java\r
public class U4S4_HostSeeker {\r
\r
    private final int timeout = 10;\r
    private String interfaceName;\r
    private String ipAddress;\r
    private String networkMask;\r
\r
    private ArrayList<String> reachableIps = new ArrayList<>();\r
\r
    public static void main(String[] args)\r
            throws UnknownHostException, IOException {\r
\r
        U4S4_HostSeeker seeker = new U4S4_HostSeeker(args);\r
        System.out.println("Scanning...");\r
        seeker.processNetwork();\r
        seeker.listResults();\r
    }\r
\r
    public U4S4_HostSeeker(String[] args) throws SocketException, UnknownHostException {\r
        NetworkInterface networkCard = null;\r
\r
        switch (args.length) {\r
            case 1 -> {\r
                // Get the interface from the name\r
                interfaceName = args[0];\r
                                \r
                networkCard = NetworkInterface.getByName(interfaceName);\r
\r
                // Get the IP and the mask from the NetworkInterface\r
                List<InterfaceAddress> cardAddresses = networkCard.getInterfaceAddresses();\r
                for (InterfaceAddress ifAddr : cardAddresses) {\r
                    if (ifAddr.getAddress() instanceof Inet4Address) {\r
                        ipAddress = ifAddr.getAddress().getHostAddress();\r
                        networkMask = Integer.toString(ifAddr.getNetworkPrefixLength());\r
                    }\r
                }\r
\r
            }\r
            case 2 -> {\r
                // Get the IP and mask\r
                ipAddress = args[0];\r
                networkMask = args[1];\r
\r
                // Get the interface name from the assigned IP\r
                networkCard = NetworkInterface.getByInetAddress(InetAddress.getByName(ipAddress));\r
                interfaceName = networkCard.getName();\r
            }\r
            default -> {\r
                // In order to find the right interface name... run the app with no args\r
                NetworkInterface.networkInterfaces().forEach((t) -> {\r
                    try {\r
                        if (t.isUp())\r
                            System.out.println(t.getName() + " --> " + t.getDisplayName() + " : " + t.inetAddresses().findFirst().toString());\r
                    } catch (SocketException ex) {\r
                        Logger.getLogger(U4S4_HostSeeker.class.getName()).log(Level.SEVERE, null, ex);\r
                    }\r
                });\r
                \r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker IP maskLength");\r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker interfaceName");\r
                throw new AssertionError();\r
            }\r
        }\r
\r
    }\r
\r
    private void processNetwork() throws IOException {\r
        String baseAddress;\r
        String[] addressParts = ipAddress.split("\\\\.");\r
        switch (networkMask) {\r
            case "24" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + "." + addressParts[2] + ".";\r
                checkClassCNetwork(baseAddress);\r
\r
            }\r
            case "16" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + ".";\r
                checkClassBNetwork(baseAddress);\r
            }\r
            case "8" -> {\r
                baseAddress = addressParts[0] + ".";\r
                checkClassANetwork(baseAddress);\r
\r
            }\r
            default ->\r
                throw new AssertionError();\r
        }\r
    }\r
\r
    // Check for /24 networks \r
    private void checkClassCNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        System.out.println("Checking network " + baseAddress + "0...");\r
        for (int i = 1; i < 255; i++) {\r
            InetAddress tempIP = InetAddress.getByName(baseAddress + i);\r
            if (tempIP.isReachable(timeout)) {\r
                addReachableIp(tempIP.getHostAddress());\r
            }\r
        }\r
    }\r
\r
    // Check for /16 networks \r
    private void checkClassBNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class C adresses: " + baseAddress + i + ".xxx");\r
            checkClassCNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    // Check for /8 networks \r
    private void checkClassANetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class B adresses: " + baseAddress + i + ".xxx");\r
            checkClassBNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    private /*synchronized*/ void addReachableIp(String ip) {\r
        reachableIps.add(ip);\r
    }\r
\r
    private void listResults() {\r
        System.out.println("Reachable IPs:");\r
        for (String ip : reachableIps) {\r
            System.out.println("--> " + ip);\r
        }\r
    }\r
}\r
   \r
\`\`\`\r
\r
:::\r
\r
## 4.2.4 java.net.URL\r
\r
The Java URL class represents an URL. URL is an acronym for Uniform Resource Locator.\r
\r
> [java.net.URL specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html)\r
\r
It points to a resource on the World Wide Web. For example:\r
\r
> http://psp2dam.github.io/psp_pages/\r
\r
A URL contains many information:\r
\r
- **Protocol**: In this case, \`http\` is the protocol.\r
- **Server name or IP Address**: In this case, \`psp2dam.github.io\` is the server name.\r
- **Port Number**: It is an optional attribute. Many times it is derived from the protocol, by chosing its standard default port. In the example the port is missing but it is set to \`80\`.\r
- **File Name or directory name**: In this case, only the path (directory) is specified in the URL. Depending on the server configuration the file name can take a default value. In the example \`index.html\` is the file name.\r
\r
| Constructor                                                                        | Description                                                                                               |\r
| ---------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\r
| URL(String spec)                                                                   | Creates an instance of a URL from the String representation.                                              |\r
| URL(String protocol, String host, int port, String file)                           | Creates an instance of a URL from the given protocol, host, port number, and file.                        |\r
| URL(String protocol, String host, int port, String file, URLStreamHandler handler) | Creates an instance of a URL from the given protocol, host, port number, file, and handler.               |\r
| URL(String protocol, String host, String file)                                     | Creates an instance of a URL from the given protocol name, host name, and file name.                      |\r
| URL(URL context, String spec)                                                      | Creates an instance of a URL by parsing the given spec within a specified context.                        |\r
| URL(URL context, String spec, URLStreamHandler handler)                            | Creates an instance of a URL by parsing the given spec with the specified handler within a given context. |\r
\r
The java.net.URL class provides many methods. The important methods of URL class are given below.\r
\r
| Method                                | Description                                                                                    |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------- |\r
| public String getProtocol()           | it returns the protocol of the URL.                                                            |\r
| public String getHost()               | it returns the host name of the URL.                                                           |\r
| public String getPort()               | it returns the Port Number of the URL.                                                         |\r
| public String getFile()               | it returns the file name of the URL.                                                           |\r
| public String getAuthority()          | it returns the authority of the URL.                                                           |\r
| public String toString()              | it returns the string representation of the URL.                                               |\r
| public String getQuery()              | it returns the query string of the URL.                                                        |\r
| public String getDefaultPort()        | it returns the default port of the URL.                                                        |\r
| public URLConnection openConnection() | it returns the instance of URLConnection i.e. associated with this URL.                        |\r
| public InputStream openStream()       | it opens a connection to this URL and returns an InputStream for reading from that connection. |\r
| public boolean equals(Object obj)     | it compares the URL with the given object.                                                     |\r
| public Object getContent()            | it returns the content of the URL.                                                             |\r
| public String getRef()                | it returns the anchor or reference of the URL.                                                 |\r
| public URI toURI()                    | it returns a URI of the URL.                                                                   |\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args) throws MalformedURLException{  \r
\r
    URL url=new URL("http://psp2dam.github.io/psp_pages");  \r
  \r
    System.out.println("Protocol: "+url.getProtocol());  \r
    System.out.println("Host Name: "+url.getHost());  \r
    System.out.println("Port Number: "+url.getPort());  \r
    System.out.println("File Name: "+url.getFile());  \r
}   \r
\`\`\`\r
\r
Let us see another example URL class in Java.\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args){    \r
    URL url=new URL("https://www.google.com/search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8");    \r
        \r
    System.out.println("Protocol: "+url.getProtocol());    \r
    System.out.println("Host Name: "+url.getHost());    \r
    System.out.println("Port Number: "+url.getPort());    \r
    System.out.println("Default Port Number: "+url.getDefaultPort());    \r
    System.out.println("Query String: "+url.getQuery());    \r
    System.out.println("Path: "+url.getPath());    \r
    System.out.println("File: "+url.getFile());      \r
}    \r
\`\`\`\r
\r
\`\`\`bash:no-line-numbers{3}\r
Protocol: https\r
Host Name: www.google.com\r
Port Number: -1\r
Default Port Number: 443\r
Query String: q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
Path: /search\r
File: /search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
\`\`\`\r
\r
## 4.2.5 java.net.URLConnection\r
\r
The Java URLConnection class represents a communication link between the URL and the application. It can be used to read and write data to the specified resource referred by the URL.\r
\r
> [java.net.URLConnection specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html)\r
\r
URLConnection is an abstract class. The two subclasses \`HttpURLConnection\` and \`JarURLConnection\` makes the connection between the client Java program and URL resource on the internet.\r
\r
With the help of URLConnection class, a user can read and write to and from any resource referenced by an URL object. Once a connection is established and the Java program has an URLConnection object, we can use it to read or write or get further information like content length, etc.\r
\r
The URLConnection class provides many methods. We can display all the data of a webpage by using the getInputStream() method. It returns all the data of the specified URL in the stream that can be read and displayed.\r
\r
| Method                                | Description                                                                                    |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------- |\r
| void connect() | It opens a communications link to the resource referenced by this URL, if such a connection has not already been established. |\r
| Object getContent() | It retrieves the contents of the URL connection. |\r
| String getContentEncoding() | It returns the value of the content-encoding header field. |\r
| int getContentLength() | It returns the value of the content-length header field. |\r
| long getContentLengthLong() | It returns the value of the content-length header field as long. |\r
| String getContentType() | It returns the value of the date header field. |\r
| long getDate() | It returns the value of the date header field. |\r
| boolean getDoInput() | It returns the value of the URLConnection's doInput flag.|\r
| boolean getDoInput() | It returns the value of the URLConnection's doOutput flag.|\r
| String getHeaderField(int n) | It returns the value of nth header field|\r
| String getHeaderField(String name) | It returns the value of the named header field.|\r
| String getHeaderFieldKey(int n) | It returns the key for the nth header field.|\r
| Map<String, List&lt;String&gt;> getHeaderFields() | It returns the unmodifiable Map of the header field.|\r
| long getIfModifiedSince() | It returns the value of the object's ifModifiedSince field.|\r
| InputStream getInputStream() | It returns an input stream that reads from the open condition.|\r
| long getLastModified() | It returns the value of the last-modified header field.|\r
| OutputStream getOutputStream() | It returns an output stream that writes to the connection.|\r
| URL getURL() | It returns the value of the URLConnection's URL field.|\r
| void setDoInput(boolean doinput) | It sets the value of the doInput field for this URLConnection to the specified value.|\r
|void setDoOutput(boolean dooutput) | It sets the value of the doOutput field for the URLConnection to the specified value.|\r
\r
::: info How to get the object of URLConnection Class\r
The openConnection() method of the URL class returns the object of URLConnection class.\r
:::\r
\r
\`\`\`java{11}\r
// URLConnectionExample\r
public static void main(String[] args) throws MalformedURLException, IOException{\r
\r
    // Creating an object of URL class\r
\r
    // Custom input URL is passed as an argument\r
    URL u = new URL("www.google.com");\r
\r
    // Creating an object of URLConnection class to\r
    // communicate between application and URL\r
    URLConnection urlconnect = u.openConnection();\r
\r
    // Creating an object of InputStream class\r
    // for our application streams to be read\r
    InputStream stream\r
        = urlconnect.getInputStream();\r
\r
    BufferedReader in =  \r
        new BufferedReader(\r
            new InputStreamReader(stream));\r
    // Till the time URL is being read\r
    String line;\r
    while ((line = in.readLine()) != null) {\r
\r
        // Continue printing the stream\r
        System.out.println(line);\r
    }\r
}\r
\`\`\`\r
\r
::: warning MalformedURLException\r
If you test the previous code, you will get a \`MalformedURLException\` exception.\r
What should you change to make it work?\r
:::\r
\r
::: question Images downloader (U4S7_ImagesDownloader)\r
Create an application to download images from a URL.\r
The image URL must be given as an application argument and the image has to be saved in a images folder on the root of your project.\r
:::\r
\r
::: details Code for the example\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
`]},{title:"6.4 Encriptacin asimtrica",headers:[{level:2,title:"6.4.1. Clave pblica y clave privada",slug:"_6-4-1-clave-publica-y-clave-privada",link:"#_6-4-1-clave-publica-y-clave-privada",children:[]},{level:2,title:"6.4.2. Firma digital",slug:"_6-4-2-firma-digital",link:"#_6-4-2-firma-digital",children:[{level:3,title:"Integridad",slug:"integridad",link:"#integridad",children:[]},{level:3,title:"Autenticacin y no repudio",slug:"autenticacion-y-no-repudio",link:"#autenticacion-y-no-repudio",children:[]}]},{level:2,title:"6.4.3 Certificados digitales",slug:"_6-4-3-certificados-digitales",link:"#_6-4-3-certificados-digitales",children:[{level:3,title:"Claves digitales",slug:"claves-digitales",link:"#claves-digitales",children:[]},{level:3,title:"Infraestructura de clave pblica (PKI)",slug:"infraestructura-de-clave-publica-pki",link:"#infraestructura-de-clave-publica-pki",children:[]}]},{level:2,title:"6.4.4. Generacin de pares de claves",slug:"_6-4-4-generacion-de-pares-de-claves",link:"#_6-4-4-generacion-de-pares-de-claves",children:[{level:3,title:"Tipos de ficheros para certificados digitales",slug:"tipos-de-ficheros-para-certificados-digitales",link:"#tipos-de-ficheros-para-certificados-digitales",children:[]},{level:3,title:"Generacin de claves desde Java",slug:"generacion-de-claves-desde-java",link:"#generacion-de-claves-desde-java",children:[]}]},{level:2,title:"6.4.5. Cifrado y descifrado usando un par de claves",slug:"_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",link:"#_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",children:[]},{level:2,title:"6.2.3. Cifrado asimtrico con GnuPG",slug:"_6-2-3-cifrado-asimetrico-con-gnupg",link:"#_6-2-3-cifrado-asimetrico-con-gnupg",children:[]}],path:"/en/unit6/asymmetric-keys.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.4 Encriptacin asimtrica\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.4 Encriptacin asimtrica" />\r
\r
# 6.4 Encriptacin asimtrica\r
\r
[[toc]]\r
\r
## 6.4.1. Clave pblica y clave privada\r
\r
La criptografa asimtrica o **criptografa de clave pblica** supuso una autntica revolucin en su momento. Permita el intercambio seguro de informacin (confidencialidad, autenticacin y no repudio) entre interlocutores que no compartan ningn secreto.\r
\r
Se cre en los aos 70 a partir del trabajo de *Diffie y Hellman* por una parte y de *Rivest, Shamir y Adleman* por otra.\r
\r
Se basa en la existencia de un par de claves, una pblica y otra privada, entre las cuales existe una relacin matemtica, de manera que es muy difcil obtener la clave privada a partir de la pblica. Sin embargo, es muy sencillo obtener la clave pblica a partir de la privada.\r
\r
::: info Algoritmo RSA\r
En la familia de algoritmos RSA (Rivest, Shamir y Adleman) la clave pblica consiste en un nmero que es el producto de dos factores primos muy grandes (mayores que 10^100) y la clave privada se deriva de la factorizacin de dicho nmero, es decir, los dos factores primos.\r
\r
Requiere poco procesamiento multiplicar dos nmeros primos tan grandes, pero requiere una cantidad enorme de clculos encontrar la factorizacin del nmero.\r
:::\r
\r
A diferencia del cifrado simtrico, el el cifrado asimtrico se usan funciones diferentes para cifrar y descifrar los mensajes.\r
\r
- Para **encriptacin** se usa la **clave pblica**. Cualquiera puede tener acceso a la clave pblica, mediante la cual, usando la funcin de cifrado, se encripta la informacin dirigida a un destinatario concreto (el propietario de la clave privada asociada).\r
- Para **desencriptacin** se usa la **clave privada**, que debe mantenerse a buen recaudo ya que slo con esa clave y la funcin de descifrado se puede desencriptar un mensaje cifrado con la clave pblica correspondiente.\r
\r
Entre los algoritmos de cifrado asimtrico ms utilizados se encuentran\r
\r
- Rivest Shamir Adleman (RSA). Basado en la factorizacin de nmeros primos grandes.\r
- Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).\r
- Elliptical Curve Cryptography (ECC). Est basado en las matemticas de las curvas elpticas\r
- the Diffie-Hellman exchange method.\r
- TLS/SSL protocol.\r
\r
![cifrado asimtrico](../../media/unit6/asymmetric-encryption-primitive.png)\r
\r
## 6.4.2. Firma digital\r
\r
Con la firma digital Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
![cifrado asimtrico](../../media/unit6/proceso-firma-digital.png)\r
\r
El proceso bsico que se sigue para la firma electrnica es el siguiente:\r
\r
1. El usuario dispone de un documento electrnico (una hoja de clculo, un pdf, una imagen, incluso un formulario en una pgina web) y de un **certificado** (clave pblica y clave privada) que le pertenece y le identifica.\r
2. La aplicacin o dispositivo digital utilizados para la firma realiza un **resumen del documento**. El resumen de un documento de gran tamao puede llegar a ser tan solo de unas lneas. Este resumen es nico y cualquier modificacin del documento implica tambin una modificacin del resumen.\r
3. La aplicacin utiliza la clave privada para codificar el resumen.\r
4. La aplicacin crea otro documento electrnico que contiene ese resumen codificado. Este nuevo documento es la firma electrnica.\r
\r
El resultado de todo este proceso es un documento electrnico obtenido a partir del documento original y de las claves del firmante. La firma electrnica, por tanto, es el mismo documento electrnico resultante.\r
\r
![verificacin de firma digital](../../media/unit6/digital-signature-sign-verify.png)\r
\r
### Integridad\r
\r
Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificacin respecto al momento en el que se firm, garantizando de esta forma la integridad de la informacin firmada.\r
\r
### Autenticacin y no repudio\r
\r
Por las caractersticas de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave pblica, que el mensaje recibido lo gener el propietario de la clave privada.\r
\r
Con esta caracterstica se puede probar y demostrar que el mensaje lo firm el emisor y no cualquier otra persona, garantizando por un lado la autora y por otro evitando que el emisor niegue haber generado esa informacin.\r
\r
## 6.4.3 Certificados digitales\r
\r
Un certificado digital es un documento electrnico expedido por una **Autoridad de Certificacin** e identifica a una persona (fsica o jurdica) con un par de claves.Tiene como misin validar y certificar que una firma electrnica se corresponde con una persona o entidad concreta.\r
\r
Contiene la informacin necesaria para firmar electrnicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiracin y organismo que lo expide.\r
\r
La Autoridad de Certificacin da fe de que la firma electrnica se corresponde con un usuario concreto. Esa es la razn por la que los certificados estn firmados, a su vez, por la Autoridad de Certificacin.\r
\r
### Claves digitales\r
\r
En un certificado, las claves digitales son los elementos esenciales para la firma e identificacin del firmante. Existen dos claves, la **clave privada** y **clave pblica**, y trabajan de forma complementaria. *Lo que cifra o codifica una clave slo lo puede descifrar o decodificar la otra*.\r
\r
La diferencia entre ellas es que la clave privada est pensada para que nunca salga del certificado y est siempre bajo el control del firmante. En cambio, la clave pblica se puede repartir o enviar a otros usuarios.\r
\r
En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la pblica y del Certificado Pblico para referirse al certificado que slo contiene la clave pblica.\r
\r
::: info Creacin de Certificados digitales\r
Obtener el Certificado Digital depende de si el certificado est contenido en una tarjeta, como el DNIe, o de si el certificado se guarda en un fichero software.\r
\r
En ambos procesos hay un paso que es la identificacin del responsable o usuario del certificado, lo cual requiere que ste **se persone en las oficinas de una Autoridad de Registro**. Estas oficinas corroboran la identidad.\r
:::\r
\r
### Infraestructura de clave pblica (PKI)\r
\r
Una infraestructura de clave pblica (PKI) es una combinacin de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecucin con garantas de operaciones criptogrficas, cumpliendo los requisitos de integridad, confidencialidad, autenticacin y no repudio.\r
\r
Una PKI permite establecer y gestionar asociaciones entre claves pblicas e identidades de personas y organizaciones.\r
\r
La cuestin entonces es determinar si un certificado es vlido o de confianza, ol o que es lo mismo, si representa a la persona u organizacin que aparece como titular y propietario  del certificado.\r
\r
Para dar por vlido un certificado digital su firma digital debe ser vlida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qu emisores son de confianza.\r
\r
::: warning Autenticidad de los certificados\r
Los certificados deben estar firmados por una AC por dos motivos\r
\r
1. Garantizar su integridad, de forma que cualquier intento de modificacin del certificado lo invalide.\r
2. Identificar al creador del certificado digital. Todo el sistema est basado en una relacin de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones pblicas o privadas de reconocido prestigio\r
:::\r
\r
En nuestro sistema podemos ver y modificar qu entidades de certificacin consideramos como seguras, es decir, que los certificados que stas hayan firmado los tomaremos como vlidos.\r
\r
[Autoridades de confianza para apps de Azure](https://docs.microsoft.com/es-es/exchange/trusted-root-certification-authorities-for-federation-trusts-exchange-2013-help)\r
\r
En Windows, si ejecutamos \`certmgr.msc\` podemos acceder a la configuracin de certificados del sistema. En OSX lo podemos hacer con la aplicacin \`Llavero\`.\r
\r
Para nuestra navegacin, la informacin de qu certificados considera el navegador como seguros, depende de en qu AC confiemos (por defecto en la instalacin vienen configurados los ms comunes)\r
\r
[Ver certificados y AC en Chrome](https://www.adminfacil.es/como-ver-los-certificados-instalados-en-google-chrome/)\r
\r
::: danger Certificados autofirmados\r
**Hemos de tener en cuenta que, con herramientas como las que proporciona Java, SSH o GnuPG cualquiera puede generar un certificado digital con la informacin que quiera**\r
\r
Para las pruebas vamos a firmar nuestros propios certificados. Incluso dentro de una compaa podemos ejercer nosotros mismos como Autoridad de Certificacin de Confianza, firmando nuestros certificados.\r
\r
Debemos preparar la configuracin de nuestros sistemas para que **confen** en esos certificados autofirmados, asumiendo el riesgo que esto conlleva.\r
:::\r
\r
## 6.4.4. Generacin de pares de claves\r
\r
La generacin y gestin de pares de claves implica dos aspectos fundamentales.\r
\r
Por un lado, tenemos la creacin de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuacin, se pueden generar desde una aplicacin, igual que hacemos con las claves simtricas.\r
\r
Por otro lado, tenemos la gestin del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados \`keyrings\` a los que puede acceder una aplicacin y desde los que gestionamos las relaciones de confianza.\r
\r
El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generacin de nmeros aleatorios para satisfacer unos requisitos mnimos de seguridad.\r
\r
::: info SecureRandom\r
La generacin de nmeros aleatorios juega un papel fundamental en la criptografa, siendo uno de los **Engine** que proporciona el JCA junto con un amplio grupo de algoritmos.\r
\r
La clase **SecureRandom** genera nmero aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto simtricas como asimtricas\r
:::\r
\r
### Tipos de ficheros para certificados digitales\r
\r
Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el estndar X.509. Generalmente uncertificado no contiene slo la clave, sino que tiene informacin adicional.\r
\r
Esxiten dos posibles codificaciones para almacenar certificados X.509\r
\r
- der: Es una codificacin binaria\r
- dem: Es una codificacin en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado\r
\r
Veamos un ejemplo de certificado con codificacin dem\r
\r
\`\`\`sh\r
-----BEGIN CERTIFICATE----- \r
MIIDijCCAvOgAwIBAgIJAKRvtQxONVZoMA0GCSqGSIb3DQEBBAUAMIGLMQswCQYD \r
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxl \r
MSAwHgYDVQQKExdBcnViYSBXaXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFD \r
MSMwIQYDVQQDExpteXNlcnZlci5hcnViYW5ldHdvcmtzLmNvbTAeFw0wODA0MzAy \r
MzM3MDJaFw0xMDA0MzAyMzM3MDJaMIGLMQswCQYDVQQGEwJVUzETMBEGA1UECBMK \r
Q2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxlMSAwHgYDVQQKExdBcnViYSBX \r
aXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFDMSMwIQYDVQQDExpteXNlcnZl \r
ci5hcnViYW5ldHdvcmtzLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA \r
zRwqc9prVXycGhHcsAjGPzC2MKU4DhXSr86Z89Jk8/cXEJBJ0C/NgdAqqDgxneUh \r
nVyxGxODa7BNGAWSagdCsKLrbkchr479E3xLfgdc3UzAJITLGCXGiQ66NwQDyM5I \r
G/xKYm4oqgyOE/lFTTkK0M8V0NmmJynyOCYC/AwQKjMCAwEAAaOB8zCB8DAdBgNV \r
HQ4EFgQUM5btT6IlPGkLTTPvFccTVURO1p0wgcAGA1UdIwSBuDCBtYAUM5btT6Il \r
PGkLTTPvFccTVURO1p2hgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD \r
YWxpZm9ybmlhMRIwEAYDVQQHEwlTdW5ueXZhbGUxIDAeBgNVBAoTF0FydWJhIFdp \r
cmVsZXNzIE5ldHdvcmtzMQwwCgYDVQQLEwNUQUMxIzAhBgNVBAMTGm15c2VydmVy \r
LmFydWJhbmV0d29ya3MuY29tggkApG+1DE41VmgwDAYDVR0TBAUwAwEB/zANBgkq \r
hkiG9w0BAQQFAAOBgQBp71WeF6dKvqUSO1JFsVhBeUesbEgx9+tx6eP328uL0oSC \r
fQ6EaiXZVbrQt+PMqG0F80+4wxVXug9EW5Ob9M/opaCGI+cgtpLCwSf6CjsmAcUc \r
b6EjG/l4HW2BztYJfx15pk51M49TYS7okDKWYRT10y65xcyQdfUKvfDC1k5P9Q== \r
-----END CERTIFICATE-----\r
\`\`\`\r
\r
Adems de la codificacin, tenemos formatos de fichero estndar para guardar los certificados usando una de las codificaciones anteriores\r
\r
- cer, crt, der: Contienen certificados X.509 estndares codificados como \`der\`\r
- p12: Realmente hace referencia a toda una familia de estndares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, adems de los datos del certificado, una clave privada. Si contiene la clave privada, sta estar protegida por una contrasea que ser necesaria para acceder a la clave privada. [PKCS en Wikipedia](https://es.wikipedia.org/wiki/PKCS)\r
\r
### Generacin de claves desde Java\r
\r
Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde cdigo\r
\r
1. El primer paso para obtener un par de claves es obtener un objeto *keyPairGenerator* para el algoritmo que queramos utilizar.\r
2. A continuacin se inicializa el generador del par de claves llamando a alguna de las versiones del mtodo *initialize*. En nuestro caso indicaremos el tamao de clave para el algoritmo seleccionado y un generador de nmeros aleatorios.\r
3. El ltimo paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.\r
4. A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer ser guardarlas en sendos archivos.\r
\r
A continuacin podemos ver un ejemplo de generacin de claves, almacenamiento de las claves en un fichero y visualizacin de la clave obtenida.\r
\r
\`\`\`java{14,15,18-20,39,52}\r
public class U6S4_1_GenerateRsaKeyPair {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            // Elijo un algoritmo de generacin de nmeros aleatorios de los denominados\r
            // altamente seguros para generar el par de claves\r
            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\r
            // Preparo el generados de claves para usar el algortimo RSA\r
            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\r
            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\r
\r
            // Creo el par de claves y lo guardo en objetos\r
            KeyPair parClaves = genParClaves.generateKeyPair();\r
            PublicKey clavePublica = parClaves.getPublic();\r
            PrivateKey clavePrivada = parClaves.getPrivate();\r
\r
            // Guardamos la clave pblica en un archivo y la visualizamos\r
            // La clave se guarda con codificacin DER y en formato X.509\r
            guardaClavePublicaX509(clavePublica);\r
            \r
            // Guardamos la clave privada en un archivo y la visualizamos\r
            // La clave se guarda con codificacin DER y en formato PKCS#8\r
            guardaClavePrivadaPKCS8(clavePrivada);\r
            \r
\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algortimo en ningn Provider");\r
        }\r
\r
    }\r
\r
    private static void guardaClavePublicaX509(PublicKey clavePublica) {\r
        try (FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\r
            publicKeyFile.write(clavePublica.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\r
                    codificacionClavePublica.getFormat(), ficheroClavePublica);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave pblica en " + ficheroClavePublica);\r
        }                \r
    }\r
\r
    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\r
        try (FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\r
            privateKeyFile.write(clavePrivada.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\r
                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave privada en " + ficheroClavePrivada);\r
        }        \r
    }\r
\r
    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\r
        System.out.println("Clave guardada en formato " + formatoClave \r
                + " en fichero " + ficheroClave);\r
        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll("(.{76})", "$1\\n"));\r
    }\r
}\r
\`\`\`\r
\r
Esta sera la salida proporcionada\r
\r
\`\`\`sh\r
Clave guardada en formato X.509 en fichero claves/clavepublica.der\r
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4UFRgEIm3lFKO75QmqTPvkDs0fM6NUm2FHQcA\r
cQHawLx9/WKXh9xkx/xYZZcc4L2YQYcwTu4jfk889iGKGLn2Kh4ywBY+g8uZ6ljM5PT6f95dU6Zd\r
xATWOn1qsizBubf7kKhBL7xDnKU5do3XYzrSjme+9uIsgS7HQ7K0MbKrpQIDAQAB\r
\r
Clave guardada en formato PKCS#8 en fichero claves/claveprivada.pkcs8\r
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALhQVGAQibeUUo7vlCapM++QOzR8\r
zo1SbYUdBwBxAdrAvH39YpeH3GTH/FhllxzgvZhBhzBO7iN+Tzz2IYoYufYqHjLAFj6Dy5nqWMzk\r
9Pp/3l1Tpl3EBNY6fWqyLMG5t/uQqEEvvEOcpTl2jddjOtKOZ7724iyBLsdDsrQxsqulAgMBAAEC\r
gYA97xBLL4N3YqnTSgIYc6b2Cxs56e5mYppWrohZx5996GHuXCSzEn4mh2TuN0Tt+T78WJiazQsM\r
djceHv7qLqDd2kWn3IR0gX207KxwjG0I/sAP2z/i9NZ7DPL+FUv8lmeYUfDj8h3wkyhmBqn+tan1\r
0xIOcZUrr/yRhrjZLI1SCQJBAPEc4uWSbyBLHVC6SNga7XWNmwi8Mq4PZJdhW9RJWDxg9zOlC/HV\r
rV60ddbfW/ldIqCH33DUge5U5YhD6Mla/XMCQQDDsahcwTksp2bJowMTRgFHT094sihtSlQ7sgdI\r
uAemuMvBmVTHleFBWMqz1rAN6A/76yef3WK4I+nsmeCGa+yHAkEA7BR1kYT8q+kATi/n7TkIcoZx\r
W28yTD2kJ5jbWhNqgswKn5WmCWdH9qfJjddrbdEke3wuaoKYqeyURgUAJE+kQwJADhEsQBanrH0Q\r
F3h/VRhYKS8bUFrGKy0Hpw7iFSkda6+m/fCutnYgrhja4ViSaT2AQKSjwYsheIkkXJynFiKV6wJA\r
PUHXqlvfgPr4w2U+Ddq7h/gp59kO0uojGrEBO0B2wt3PuuSQlZlMN97Ly9QmB6LYRtw6woCZZZOD\r
ePqA7rf8IA==\r
\`\`\`\r
\r
En el ejemplo anterior en lugar de utilizar clases estndar para volcar el contenido binario de las claves a un archivo en formato raw, se utilizan clases codificadoras para generar ficheros binarios en formatos estndares, tanto para la clave pblica como para la privada.\r
\r
Esto tiene la enorme ventaja de que se pueden utilizar las claves generadas con herramientas estndar como openssl. Adems, facilita la tarea ya que las claves pblica y privada para criptografa asimtrica son objetos compuestos.\r
\r
::: info Codificacin Base64\r
Base64 es un grupo de esquemas de codificacin de binario a texto que representa los datos binarios mediante una cadena.\r
\r
Los esquemas de codificacin Base64 son comnmente usados cuando se necesita codificar datos binarios para que sean almacenados y transferidos sobre un medio diseado para tratar con datos textuales. Esto es para asegurar que los datos se mantienen intactos y sin modificaciones durante la transmisin.\r
\r
Los valores codificados en Base64 como texto se muestran en filas de 76 caracteres como mximo, para mejor legibilidad, y siguiendo convenciones habituales.\r
\r
Para verlos en pantalla se aade un salto de lnea despus de cada grupo de 76 caracteres usando  \`replaceAll("(.{76})", "$1\\n")\`.\r
:::\r
\r
Las claves que se han guardado con el programa tienen las siguientes caractersticas:\r
\r
- La clave pblica se guarda en un fichero \`clavepublica.der\`, con el formato de la estructura *SubjectPublicKeyInfo* en formato *ASN.1* definido en el estndar *X.509*, y con codificacin *DER (binaria)*. Para eso se ha utilizado la clase codificadora **X509EncodedKeySpec**.\r
- La clave privada se guarda en un fichero \`claveprivada.pkcs8\`, en formato *PKCS#8*, y con codificacin *DER (binaria)*. Para eso se ha utilizado la clase codificadora **PKCS8EncodedKeySpec**.\r
\r
::: info Codificaciones por defecto\r
Las codificaciones usadas en el programa coinciden con las codificacione por defecto que usan las clases PrivateKey y PublicKey, como se puede ver en los valores proporcionados por los mtodos getFormat() y getEncoded().\r
:::\r
\r
## 6.4.5. Cifrado y descifrado usando un par de claves\r
\r
Aunque ya hemos visto que las claves se pueden generar desde cdigo, lo normal es que una vez hayamos generado un par de claves, estas se puedan reutilizar desde las aplicaciones para cifrar y descifrar informacin.\r
\r
Si hemos guardado las claves en archivos, el primer paso que tendremos que realizar es recuperar esas claves para poder realizar las operaciones criptogrficas con ellas.\r
\r
::: question Prueba de claves online\r
Podemos probar las claves generadas con una herramienta online.\r
\r
[Online RSA tool](https://www.devglan.com/online-tools/rsa-encryption-decryption)\r
\r
Prueba a copiar el contenido (en Base64) de las claves pblica y privada para hacer un cifrado y un descifrado de la informacin.\r
\r
Tambin puedes probar a simular una firma digital, realizando el cifrado con la clave privada y el descifrado con la clave pblica.\r
:::\r
\r
Veamos un ejemplo de cmo se hace todo este proceso en Java\r
\r
\`\`\`java{23-25,38-40,76-78,108-110}\r
public class U6S4_2_RsaKeyPairEncrypt {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            //////////////////////////////////////////////////\r
            // CIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave pblica de un archivo\r
            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\r
\r
            // Preparamos la informacin que queremos cifrar\r
            String textoEnClaro = "Quiero cifrar este mensaje de prueba";\r
            byte[] mensajeEnClaro = textoEnClaro.getBytes("UTF-8");\r
            \r
            // Realizamos el proceso de cifrado con clave pblica\r
            // Los pasos son exactamente los mismos que con el cifrado simtrico\r
            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\r
            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\r
            // Visualizamos el mensaje cifrado en modo texto\r
            MostrarMensajeBase64(mensajeCifrado);\r
            \r
            //////////////////////////////////////////////////\r
            // DESCIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave privada de un archivo\r
            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\r
\r
            // Realizamos el proceso de descifrado con clave privada\r
            // Los pasos son exactamente los mismos que con el cifrado simtrico\r
            // Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\r
            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\r
            // Visualizamos el mensaje descifrado\r
            System.out.println("Texto descifrado:\\n" + new String(mensajeDescifrado, "UTF-8"));\r
                        \r
        } catch (UnsupportedEncodingException ex) {\r
            System.out.println("Codificacin de caracteres UTF-8 no soportada");\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo " + algoritmoClaveAsimetrica + " en ningn Provider");\r
        } catch (NoSuchPaddingException ex) {\r
            System.err.println("El relleno especificado para el algoritmo no est permitido");\r
        } catch (InvalidKeyException ex) {\r
            System.err.println("Especificacin de clave no vlida");\r
        } catch (IllegalBlockSizeException ex) {\r
            System.err.println("Tamao de bloque no vlido");\r
        } catch (BadPaddingException ex) {\r
            System.err.println("Excepcin con el relleno usado por el algoritmo");\r
        }\r
    }\r
\r
    private static PublicKey leerClavePublica(String ficheroClave) {\r
        byte[] clavePublicaEncoded;\r
\r
        // Leemos la informacin del archivo\r
        try (FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePublicaEncoded = publicKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave pblica.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave pblica.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes ledos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\r
            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\r
\r
            // Devolvemos la clave pblica generada\r
            return clavePublica;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo " + algoritmoClaveAsimetrica + " en ningn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
\r
    private static PrivateKey leerClavePrivada(String ficheroClave) {\r
        byte[] clavePrivadaEncoded;\r
\r
        // Leemos la informacin del archivo\r
        try (FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePrivadaEncoded = privateKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave privada.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave privada.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes ledos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\r
            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\r
\r
            // Devolvemos la clave pblica generada\r
            return clavePrivada;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo " + algoritmoClaveAsimetrica + " en ningn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
    \r
    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\r
        System.out.println("Mensaje cifrado visualizado como texto en Base64:");                \r
        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll("(.{76})", "$1\\n"));\r
    }    \r
}\r
\`\`\`\r
\r
Y esta es la salida proporcionada\r
\r
\`\`\`sh\r
Mensaje cifrado visualizado como texto en Base64:\r
EV+7WrEf+4CYwckys9blk6DXnLHUm4i0k+4BIp3oNmPdo2skYY8bQsAhXToBx2gi/rMIK9wiJTH0\r
yg99jpyaLeUgtga8PxWx1plgvxohzO/lALkf5AFRUczZh8F5QvOXCi93v2ycZCZXq7QmZTopkEQh\r
ARSezD/1Al2UYPc2X68=\r
\r
Texto descifrado:\r
Quiero cifrar este mensaje de prueba\r
\`\`\`\r
\r
::: warning Cifrado siempre diferente, descifrado siempre igual\r
El resultado de cifrar un mensaje con la misma clave pblica no siempre es igual, aunque al descifrar los mensajes con la clave privada siempre se obtiene el mensaje original.\r
\r
Esto es debido a que, para aumentar la variabilidad (**entropa**) del mensaje cifrado al mensaje que se cifra se le aade una parte aleatoria (**salt**) que se descarta cuando se descifra.\r
:::\r
\r
En el cdigo podemos observar cmo los procesos para cargar la clave desde un archivo usan las mismas clases que cuando se generaron, siendo el cdigo muy parecido.\r
\r
En cuanto al cifrado y descifrado se realiza con el *Engine Cipher* usando la misma secuencia de llamadas que con el cifrado simtrico.\r
\r
## 6.2.3. Cifrado asimtrico con GnuPG\r
\r
Con la suite GnuPG tambin podemos generar pares de claves y cifrar y descifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informacin de los algoritmos disponibles para cada tipo de servicio. En concreto, de resmenes, en mi versin instalada:\r
\r
Clave pblica: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\r
:::\r
\r
Para generar las claves, ejecutamos los siguientes comandos.\r
Debemos tener en cuenta que las claves generadas se aaden a nuestro anillo de claves (almacn de seguridad de claves en las que confiamos).\r
\r
\`\`\`bash\r
gpg --gen-key\r
gpg --list-keys \r
# El formato corto equivalente es gpg -k\r
gpg --list-secret-keys \r
# El formato corto equivalente es gpg -K\r
\r
#Extraer las claves pblicas y privadas\r
# En un archivo binario\r
gpg --output tunombre.pub --export IDdeLaClavePblica\r
# En un archivo ASCII\r
gpg --armor --output tunombre.asc --export IDdeLaClavePblica\r
\r
gpg --export-secret-keys -a IDdeLaClavePblica > tunombre.priv\r
\r
# Importar una clave pblica\r
gpg --import clavepublica.asc\r
# Importar una clave privada\r
gpg --allow-secret-key-import --import claveprivada.priv\r
\`\`\`\r
\r
Para cifrar y descifrar un archivo con las claves generadas, ejecutamos los siguientes comandos\r
\r
\`\`\`bash\r
# Cifrar\r
gpg --output archivo.cifrado --encrypt --recipient IDdeLaClavePblica archivo\r
# Descifrar\r
gpg --output archivo --decrypt archivo.cifrado\r
\`\`\`\r
`]},{title:"6.2 Hash functions",headers:[{level:2,title:"6.2.1. Hash functions",slug:"_6-2-1-hash-functions",link:"#_6-2-1-hash-functions",children:[]},{level:2,title:"6.2.2. MessageDigest",slug:"_6-2-2-messagedigest",link:"#_6-2-2-messagedigest",children:[]},{level:2,title:"6.2.3. MessageDigest with GnuPG",slug:"_6-2-3-messagedigest-with-gnupg",link:"#_6-2-3-messagedigest-with-gnupg",children:[]}],path:"/en/unit6/hash-functions.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.2 Hash functions\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.2 Hash functions" />\r
\r
# 6.2 Hash functions\r
\r
[[toc]]\r
\r
## 6.2.1. Hash functions\r
\r
A **message digest**, better known as **hash functions**, is a digital mark of a block of data. There are a large number of algorithms designed to process these summaries, the two best known are SHA-1 and MD5.\r
\r
From a digest we can highlight the following characteristics:\r
\r
- For the same algorithm, the digest always has the same size, regardless of the size of the data used to generate it.\r
- It is impossible to recover the original information from a digest.\r
- The digest should not reveal anything about the data used to generate it.\r
- It is computationally unfeasible to find two messages that have the same digest value. Mathematically it is highly unlikely, but not impossible.\r
- A small change in the summarized data generates a completely different digest.\r
\r
Digests are used to generate unique and reliable identifiers. Sometimes they are called *checksum*, since they are used to check if a download has been done correctly, generating its summary and comparing it with the one generated by the original file.\r
\r
::: warning A hash is not used to encrypt\r
It is important to note that, because it is impossible to obtain the data that generated a digest from the digest itself, the digest cannot be used to encrypt information.\r
\r
On the other side, it is a mechanism that is used to compare. Its most widespread use is with passwords, since in the databases a summary is saved instead of the password in clear. In this way, when a password is received, its digest is generated and compared with the stored value.\r
:::\r
\r
## 6.2.2. MessageDigest\r
\r
The *MessageDigest* class allows applications to implement cryptographically secure summary algorithms such as SHA-256 or SHA-512\r
\r
To generate a hash with JCA, proceed as follows:\r
\r
1. An object of the *MesageDigest* class is created with the static method *getInstance()* of the same class, specifying the name of the algorithm. Optionally, the name of the provider can be specified.\r
2. Data is added with the *update()* method. A byte or byte array can be added. This method can be invoked several times to add new data.\r
3. The hash value is obtained with the *digest()* method.\r
4. If you wanted to calculate a new hash, the *reset()* method would be invoked to start the process again.\r
\r
Next we can see an example\r
\r
\`\`\`java\r
public class U6S2_MessageDigest {\r
\r
    public static void main(String[] args) {\r
        String plaintext = "Esto es un texto plano.";\r
        try {\r
            // Obtenemos un ENGINE que implementa el algoritmo especificado\r
            // Se puede indicar cualquier algoritmo disponible en el sistema\r
            // SHA-224, SHA-512, SHA-256, SHA3-224, ...\r
            MessageDigest m = MessageDigest.getInstance("SHA-256");\r
\r
            // Opcional - Reinicia el objeto para un nuevo uso \r
            // Por si queremos poner este cdigo en un bucle y procesar ms\r
            // de un mensaje\r
            m.reset();\r
\r
            // Realiza el resumen de los datos pasados por parmetro\r
            // Si queremos procesar la informacin poco a poco, \r
            // debemos ir llamando al mtodo update para cada bloque de datos\r
            m.update(plaintext.getBytes());\r
\r
            // Completa el clculo del valor del hash y devuelve el resumen\r
            byte[] digest = m.digest();\r
\r
            // Mensaje de resumen\r
            System.out.println("Resumen (raw data): " + new String(digest));\r
\r
            // Mensaje en formato hexadecimal\r
            System.out.println("Resumen (hex data): " + toHexadecimal(digest));\r
            \r
            \r
            // Informacin del proceso\r
            System.out.println("=> Algoritmo: " + m.getAlgorithm() + ", Provider: " + m.getProvider().getName() + " " + m.getProvider().getVersionStr());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo MD5 en ningn Provider");\r
        }\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
}\r
\`\`\`\r
\r
and this would be the output provided\r
\r
\`\`\`sh\r
Resumen (raw data): Y"3\x1B\`bbs?;~E\r
Resumen (hex data): FB59D31122913314111B92CD60628ED7E7DE62733F3B10DEDAF303AAABE57E45\r
=> Algoritmo: SHA-256, Provider: SUN 11\r
\`\`\`\r
\r
## 6.2.3. MessageDigest with GnuPG\r
\r
With the GnuPG suite we can generate summaries of files using the algorithms provided by the suite.\r
\r
::: info Algorithms available for GnuPG\r
To see the list of available algorithms we have to show the help of the command\r
\r
> gpg --help\r
\r
and at the top we see the information of the algorithms available for each type of service. Specifically, of summaries, in my installed version:\r
\r
Summary: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\r
:::\r
\r
To generate a summary of a file, we run the command as follows\r
\r
\`\`\`sh\r
gpg --print-md SHA256 filename.ext\r
\`\`\`\r
\r
`]},{title:"6 Introduction",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/en/unit6/",pathLocale:"/en/",extraFields:[`---\r
title: 6 Introduction\r
---\r
\r
# Unit 6. Secure programming techniques\r
\r
Cryptography is a term derived from the Greek word *kryptos* which means hidden and *grafos* which means writing. The objective of cryptography is to hide the meaning of a message by encrypting or encoding the message.\r
\r
Cryptographic techniques are used to protect the confidentiality, integrity and authenticity of information. Cryptography is used to protect information in transit or stored in a computer system. Cryptography is also used to protect the identity of users and to protect the integrity of programs and data.\r
\r
Of all the techniques of secure programming, we are going to study in this topic\r
\r
- Hash functions\r
- **Symmetric encryption** or hidden key\r
- **Asymmetric encryption** or private key\r
\r
We will also study how to use secure communication channels for our applications, using secure sockets using SSL/TLS.\r
\r
In addition, we will see a security tool that incorporates Java, security policies.\r
\r
## Objetivos\r
\r
Goals of this unit:\r
\r
- Identify principles and practices of secure programming.\r
- Analyze cryptographic techniques and practices.\r
- Define security policies.\r
- Use cryptographic algorithms.\r
- Use secure sockets for transmitting information.\r
- Study the operation of TLS/SSL over the TCP protocol\r
- Know generic tools in cryptography\r
`]},{title:"6.5 Comunicaciones seguras en Java",headers:[{level:2,title:"6.5.1. Protocolo SSL (Secure Sockets Layer)",slug:"_6-5-1-protocolo-ssl-secure-sockets-layer",link:"#_6-5-1-protocolo-ssl-secure-sockets-layer",children:[]},{level:2,title:"6.5.2. JSSE",slug:"_6-5-2-jsse",link:"#_6-5-2-jsse",children:[{level:3,title:"SSLSocket y SSLServerSocket",slug:"sslsocket-y-sslserversocket",link:"#sslsocket-y-sslserversocket",children:[]},{level:3,title:"keytool: certificados, confianza y almacenes de claves",slug:"keytool-certificados-confianza-y-almacenes-de-claves",link:"#keytool-certificados-confianza-y-almacenes-de-claves",children:[]}]},{level:2,title:"6.5.3. Servidor y Cliente SSL",slug:"_6-5-3-servidor-y-cliente-ssl",link:"#_6-5-3-servidor-y-cliente-ssl",children:[]}],path:"/en/unit6/jsse.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.5 Comunicaciones seguras en Java\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.5 Comunicaciones seguras en Java" />\r
\r
# 6.5 Comunicaciones seguras en Java\r
\r
[[toc]]\r
\r
## 6.5.1. Protocolo SSL (Secure Sockets Layer)\r
\r
SSL es el protocolo habitualmente usado para encriptar la comunicacin cliente-servidor. Casi todo el trfico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.\r
\r
La implementacin de SSL es una extensin de los sockets que permite establecer un canal (stream) de comunicacin. Dicha comunicacin se inicia con un **handshake** durante el cual, el cliente y el servidor construyen una session-key (clave simtrica encriptada con par de claves asimtricas) compartida para verificar su identidad mutua.\r
\r
## 6.5.2. JSSE\r
\r
JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementacin para Java de los protocolos SSL y TSL e incluye funcionalidad de\r
\r
- encriptacin de datos\r
- autenticacin de servidores\r
- integridad de mensajes\r
- autenticacin de clientes\r
\r
Con JSSE, los programadores  pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicacin, tales como HTTP, Telnet o FTP, a travs de TCP/IP.\r
\r
Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.\r
\r
### SSLSocket y SSLServerSocket\r
\r
Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente.\r
\r
JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creacin de sockets seguros. No tienen constructor, se obtienen a travs del mtodo esttico getDefault().\r
\r
Para obtener un socket servidor seguro o *SSLServerSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
SSLServerSocket servidorSSL = (SSLServerSocket) = sfact.createServerSocket(puerto);\r
\`\`\`\r
\r
El mtodo **createServerSocket(int puerto)** devuelve un socket de servidor enlazado al puerto especificado.\r
\r
Para crear un *SSLSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
SSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\r
\`\`\`\r
\r
El mtodo createSocket (String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.\r
\r
### keytool: certificados, confianza y almacenes de claves\r
\r
Cuando dos socket SSL, uno cliente y otro servidor, intentan establecer conexin, tienen que "presentarse" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno confa en el otro, la conexin se establece, en caso contrario, no se establece.\r
\r
Para establecer esa confianza se debe crear un certificado en el servidor y aadirlo a los certificados de confianza del cliente.\r
\r
- El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta **keytool**, que viene incluida en el JDK de Java. La herramienta guardar la pareja de claves en un almacn (el cual tiene su propia clave).\r
- Despus generaremos un certificado a partir de esa pareja.\r
- El cdigo del servidor necesitar indicar el fichero donde se almacenan las claves y la clave para acceder a ese almacn.\r
- El cliente necesitar indicar que confa en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almacn de claves del cliente.\r
\r
::: info Seguridad mutua\r
Aunque no suele hacerse tambin podra hacerse a la inversa y obligar al cliente a tener un certificado que el servidor pudiera importar, lo que aumentara la seguridad.\r
:::\r
\r
Vamos a ver cmo realizar estas operaciones previas con la herramienta **keytool**\r
\r
Primero las acciones a realizar en el servidor\r
\r
\`\`\`sh:no-line-numbers\r
# El servidor genera una pareja de claves que se almacena en un\r
# fichero llamado "clavesservidor". Dentro del fichero se indica\r
# un alias para poder referirnos a esa clave fcilmente\r
# keytool -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
What is your first and last name?\r
  [Unknown]:  Vicente Martinez\r
What is the name of your organizational unit?\r
  [Unknown]:  Dpto. Informatica\r
What is the name of your organization?\r
  [Unknown]:  IES Doctor Balmis\r
What is the name of your City or Locality?\r
  [Unknown]:  Alicante\r
What is the name of your State or Province?\r
  [Unknown]:  Alicante\r
What is the two-letter country code for this unit?\r
  [Unknown]:  ES\r
Is CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES correct?\r
  [no]: yes\r
\r
# El servidor genera su "certificado", es decir un fichero que\r
# de alguna forma indica quien es l. El certificado se almacena\r
# en un fichero llamado clavesservidor y a partir de l queremos\r
# generar el certificado de un alias creado previamente con nombre servidor\r
# keytool -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
Enter keystore password:\r
Certificate stored in file <servidor.cer>\r
\`\`\`\r
\r
En la carpeta donde hemos ejecutado el comando keytool, se ha creado el almacn de claves en un fichero llamado **ClavesServidor** y el certificado exportado en el archivo **servidor.cer**\r
\r
y a continuacin las que habra que realizar en el cliente para generar el almacn de confianza que, en nuestro caso contenga el mismo certificado que hemos exportado del servidor.\r
\r
\`\`\`sh:no-line-numbers\r
# Se importa el certificado del servidor indicando que pertenece a\r
# la lista de certificados confiables.\r
# keytool -importcert -trustcacerts -alias servidor -file servidor.cer -keystore clavescliente  -storepass 87654321\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -importcert -trustcacerts -alias servidor -file servidor.cer -keystore CertificadosConfianzaCliente -storepass 87654321\r
Owner: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Issuer: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Serial number: 4eb6f2a5\r
Valid from: Mon Jan 24 00:20:24 CET 2022 until: Sun Apr 24 01:20:24 CEST 2022\r
Certificate fingerprints:\r
         SHA1: DD:A2:75:4C:1C:BC:39:60:BE:B1:20:67:E1:5C:45:8C:48:B5:1F:54\r
         SHA256: 82:C8:56:C2:DB:DE:8C:73:A9:21:C6:7D:DE:1F:39:4F:79:CC:5F:D5:10:BC:61:DA:E3:EE:E1:1D:21:EA:D2:33\r
Signature algorithm name: SHA256withRSA\r
Subject Public Key Algorithm: 2048-bit RSA key\r
Version: 3\r
\r
Extensions:\r
\r
#1: ObjectId: 2.5.29.14 Criticality=false\r
SubjectKeyIdentifier [\r
KeyIdentifier [\r
0000: 16 AE 35 7C 58 97 B1 95   91 9B FA 6C 2A 80 D2 90  ..5.X......l*...\r
0010: 1C 50 7F C0                                        .P..\r
]\r
]\r
\r
Trust this certificate? [no]:  yes\r
Certificate was added to keystore\r
\`\`\`\r
\r
En esta ocasin tambin se crea, en la carpeta donde se ha ejecutado el comando keytool, un fichero **CertificadosConfianzaCliente** con el/los certificados de confianza para el cliente.\r
\r
## 6.5.3. Servidor y Cliente SSL\r
\r
En le siguiente ejemplo podemos observar como la inicializacin del ServerSocket es diferente, pero a partir de que se llama al mtodo accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del cdigo es igual que con la clase Socket.\r
\r
\`\`\`java{5,16,17,24}\r
public class U6S5_SSLServer {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteConectado = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante cdigo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicacin\r
        // System.setProperty("javax.net.ssl.keyStore", System.getProperty("user.dir") + "\\\\ClavesServidor");\r
        // System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
        \r
        // Inicializacin del ServerSocket SSL\r
        int puerto = 6000;\r
        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\r
\r
        for (int i = 1; i < 5; i++) {\r
\r
            System.out.println("Esperando al cliente " + i);\r
\r
            // Se espera la conexin de un cliente con accept\r
            clienteConectado = (SSLSocket) servidorSSL.accept();\r
            // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
            // el cdigo del ejemplo\r
            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\r
            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\r
\r
            // El cliente enva un mensaje\r
            System.out.println("Recibiendo del CLIENTE: " + i + " \\n\\t" + flujoEntrada.readUTF());\r
\r
            // El Servidor responde con un saludo\r
            flujoSalida.writeUTF("Saludos al cliente del servidor");\r
        }\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteConectado.close();\r
        servidorSSL.close();\r
    }\r
}\r
\`\`\`\r
\r
En el cliente el proceso es el mismo, tras la llamada al mtodo createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.\r
\r
\`\`\`java{5,12,13,19,20}\r
public class U6S5_SSLClient {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteSSL = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante cdigo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicacin\r
        // System.setProperty("javax.net.ssl.trustStore", System.getProperty("user.dir") + "/CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
        // Inicializacin del ServerSocket SSL\r
        int puerto = 6000;\r
        String host = "localhost";\r
\r
        System.out.println("Programa Cliente iniciado....");\r
        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\r
\r
        // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
        // el cdigo del ejemplo\r
        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\r
        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\r
\r
        // Envo un saludo al servidor\r
        flujoSalida.writeUTF("Saludos al SERVIDOR DESDE EL CLIENTE");\r
\r
        // El Servidor responde con un mensaje\r
        System.out.println("Recibiendo del SERVIDOR: \\n\\t" + flujoEntrada.readUTF());\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteSSL.close();\r
    }\r
\r
    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException {\r
\r
        //------------------------------------------------------------------------------\r
        //Ejemplo de la mltiple informacin sobre la sesin SSL\r
        // que se puede obtener a partir \r
        SSLSession session = ((SSLSocket) cliente).getSession();\r
        System.out.println("Host: " + session.getPeerHost());\r
        System.out.println("Cifrado: " + session.getCipherSuite());\r
        System.out.println("Protocolo: " + session.getProtocol());\r
\r
        System.out.println("IDentificador:" + new BigInteger(session.getId()));\r
\r
        System.out.println("Creacin de la sesin: " + session.getCreationTime());\r
\r
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\r
        System.out.println("Propietario: " + certificate.getSubjectDN());\r
        System.out.println("Algoritmo: " + certificate.getSigAlgName());\r
        System.out.println("Tipo: " + certificate.getType());\r
        System.out.println("Emisor: " + certificate.getIssuerDN());\r
        System.out.println("Nmero Serie: " + certificate.getSerialNumber());\r
        //-----------------------------------------------------------------------------\r
    }\r
}\r
\`\`\`\r
\r
Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Exception in thread "main" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\r
\`\`\`\r
\r
Para ejecutar el programa servidor es necesario indicar el certificado que se utilizar.\r
\r
Lo podemos indicar a la hora de ejecutar el programa, aadiendo a la lnea de comandos\r
\r
\`\`\` sh\r
 java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\r
\`\`\`\r
\r
y en el programa cliente es necesario indicar la ubicacin de los certificados de confianza\r
\r
\`\`\` sh\r
java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\r
\`\`\`\r
\r
o bien, en las opciones de ejecucin del IDE\r
\r
![Netbeans: Opciones de la JVM](../../media/unit6/VM_Options.png)\r
\r
::: info Parmetros de JVM vs hardcoded\r
En el cdigo anterior hay unas lneas comentadas que especifican cmo podemos configurar el valor de las propiedades desde cdigo mediante el uso del mtodo System.setProperty(String propiedad, String valor), evitando as tener que indicarlas como parmetros de ejecucin de cliente y servidor (mejor opcin).\r
\r
En el programa servidor incluiramos las siguientes lneas:\r
\r
System.setProperty("javax.net.ssl.keyStore", "ClavesServidor");\r
System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
\r
Y en el programa cliente seran estas:\r
\r
System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
\r
Adems del nombre, podemos indicar la ruta donde se encuentran los almacenes, recordando que NO ES RECOMENDABLE el uso de barras invertidas para indicar rutas.\r
:::\r
\r
Una vez hechos los cambios, bien en las opciones de la JVM o bien en el cdigo de las aplicaciones, la salida que obtendremos ser esta\r
\r
<CodeGroup>\r
<CodeGroupItem title="Servidor" active>\r
\r
\`\`\`sh:no-line-numbers\r
Esperando al cliente 1\r
Recibiendo del CLIENTE: 1 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 2\r
Recibiendo del CLIENTE: 2 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 3\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Cliente">\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Recibiendo del SERVIDOR: \r
	Saludos al cliente del servidor\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
</CodeGroup>\r
\r
::: warning Default trusted certificates\r
Whenever Java attempts to connect to another application over SSL (e.g.: HTTPS, IMAPS, LDAPS), it will only be able to connect to that application if it can trust it. The way trust is handled in the Java world is that you have a keystore (typically $JAVA_HOME/lib/security/cacerts), also known as the truststore. This contains a list of all known Certificate Authority (CA) certificates, and Java will only trust certificates that are signed by one of those CAs or public certificates that exist within that keystore.\r
\r
If -Djavax.net.ssl.trustStore has been configured, it will override the location of the default truststore, which will need to be checked.\r
:::`]},{title:"6.6 Anexo I - Logs library Log4Java2",headers:[{level:2,title:"6.6.1 Registros o logs",slug:"_6-6-1-registros-o-logs",link:"#_6-6-1-registros-o-logs",children:[]},{level:2,title:"6.6.2. Configuracin automtica de Log4j2",slug:"_6-6-2-configuracion-automatica-de-log4j2",link:"#_6-6-2-configuracion-automatica-de-log4j2",children:[]},{level:2,title:"6.6.3. Niveles de registro",slug:"_6-6-3-niveles-de-registro",link:"#_6-6-3-niveles-de-registro",children:[]},{level:2,title:"6.6.4. Ejemplo de uso de Log4j2",slug:"_6-6-4-ejemplo-de-uso-de-log4j2",link:"#_6-6-4-ejemplo-de-uso-de-log4j2",children:[]},{level:2,title:"6.6.5. Configuracin de Log4j2",slug:"_6-6-5-configuracion-de-log4j2",link:"#_6-6-5-configuracion-de-log4j2",children:[]},{level:2,title:"6.6.6 Appenders",slug:"_6-6-6-appenders",link:"#_6-6-6-appenders",children:[]},{level:2,title:"6.6.7. Loggers",slug:"_6-6-7-loggers",link:"#_6-6-7-loggers",children:[]},{level:2,title:"6.6.8. Layouts",slug:"_6-6-8-layouts",link:"#_6-6-8-layouts",children:[]},{level:2,title:"6.6.9. Actividades",slug:"_6-6-9-actividades",link:"#_6-6-9-actividades",children:[]},{level:2,title:"6.6.10. Bibliografa",slug:"_6-6-10-bibliografia",link:"#_6-6-10-bibliografia",children:[]}],path:"/en/unit6/log4j_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.6 Anexo I - Logs library Log4Java2\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.6 Annex I - Logs library Log4Java2" />\r
\r
# 6.6 Anexo I - Log4Java2 - Gestor de logs\r
\r
[[toc]]\r
\r
## 6.6.1 Registros o logs\r
\r
El registro es el proceso de escribir mensajes de registro en cualquier archivo, base de datos, consola, etc. para mantener un registro de eventos que ocurren en un sistema. El registro es una parte esencial de cualquier aplicacin para depurar y monitorear el sistema.\r
\r
El software con suficiente registro y monitorizacin le permitir detectar posibles incidentes cuando su cdigo se despliegue en un entorno de produccin. \`Log4j\` se utiliza para gestionar el registro de informacin en una aplicacin.\r
\r
Adems, en trminos de seguridad, el registro es una parte esencial de cualquier aplicacin. Si su aplicacin se ve comprometida, el registro le ayudar a rastrear el origen de un ataque, accesos indebidos, accesos no autorizados y a tomar medidas para evitar que vuelva a ocurrir.\r
\r
Hasta ahora hemos usado la instruccin SOP \`System.out.println()\` para imprimir mensaje de registro. Este sistema tiene algunas desventajas:\r
\r
- Podemos imprimir mensajes de registro solo en la consola. Por lo tanto, cuando se cierre la consola, perderemos -dos los registros.\r
- No podemos almacenar mensajes de registro en ningn lugar permanente. Estos mensajes se imprimirn uno por uno en la consola porque es un entorno de un solo hilo.\r
- No podemos configurar diferentes niveles de registro como INFO, DEBUG, ERROR, etc.\r
- No podemos configurar el formato de registro, como la fecha, la hora, el nombre de la clase, el nombre del mtodo y que se aplique a todos los mensajes de registro.\r
- No podemos configurar el destino de registro, como la consola, el archivo, la base de datos, etc.\r
\r
Para solventar estos problemas, se utiliza el framework Log4j. Log4j es un framework de cdigo abierto proporcionado por Apache solo para proyectos de Java.\r
\r
!!! note Versiones Log4j2\r
    Log4j es un sistema de registro donde la API (llamada Log4j API) y su implementacin (llamada Log4j Core) estn separadas claramente la una de la otra.\r
\r
    Esto permite que la API de Log4j proporcione una interfaz que sea fcil de usar de una manera correcta y a prueba de futuro. Consulta las pginas de [API de Java](https://logging.apache.org/log4j/2.x/manual/api.html), [API de Kotlin](https://logging.apache.org/log4j/kotlin/index.html) y [API de Scala](https://logging.apache.org/log4j/scala/latest/) para obtener ms informacin.\r
\r
    \r
Para usar Log4j2 en nuestro cdigo solo necesitamos agregar las siguientes [libreras / dependencias](https://logging.apache.org/log4j/2.x/download.html) en nuestro proyecto:\r
\r
\`\`\`bash\r
log4j-api-<version>.jar\r
log4j-core-<version>.jar\r
\`\`\`\r
\r
## 6.6.2. Configuracin automtica de Log4j2\r
\r
Podemos configurar Log4j2 con nuestra aplicacin utilizando un archivo de configuracin escrito en formato XML, JSON, YAML o propiedades. Tambin podemos hacerlo mediante cdigo pero, por ahora, nos vamos a centrar en la configuracin utilizando archivos de configuracin.\r
\r
Log4j tiene la capacidad de configurarse automticamente durante la inicializacin. Tiene un orden para buscar el archivo de configuracin en la aplicacin. Log4j proporcionar una configuracin predeterminada si no puede localizar un archivo de configuracin.\r
\r
## 6.6.3. Niveles de registro\r
\r
Los niveles de registro son un mecanismo para categorizar los registros. Los niveles se utilizan para identificar la gravedad de un evento. Podemos configurar fcilmente los niveles para especificar qu detalles de registro queremos ver. Log4j proporciona los siguientes niveles:\r
\r
1. ALL: Para registrar todos los eventos.\r
2. TRACE: Un mensaje de depuracin detallado, que captura tpicamente el flujo a travs de la aplicacin.\r
3. DEBUG: Un evento de depuracin general.\r
4. INFO: Un evento con fines informativos.\r
5. WARN: Un evento que podra posiblemente llevar a un error.\r
6. ERROR: Un error en la aplicacin, posiblemente recuperable.\r
7. FATAL: Un error grave que impedir que la aplicacin contine.\r
8. OFF: No se registrarn eventos.\r
\r
Log4j sigue el siguiente orden:\r
\r
> ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL\r
\r
Si especificamos el nivel de registro como INFO, se registrarn todos los eventos INFO, WARN, ERROR y FATAL. Si especificamos el nivel de registro como WARN, se registrarn todos los eventos WARN, ERROR y FATAL. En trminos simples, se considerarn todos los niveles por debajo del nivel especificado, incluido el nivel especificado.\r
\r
## 6.6.4. Ejemplo de uso de Log4j2\r
\r
\`\`\`java\r
package psp.examples.u06.log4j2;\r
\r
import org.apache.logging.log4j.LogManager;\r
import org.apache.logging.log4j.Logger;\r
\r
public class ModuleA {\r
\r
    private static final Logger logger = LogManager.getLogger();\r
    \r
    // Log messages\r
    public static void main(String[] args) {\r
        logger.debug("It is a debug logger.");\r
        logger.error("It is an error logger.");\r
        logger.fatal("It is a fatal logger.");\r
        logger.info("It is a info logger.");\r
        logger.trace("It is a trace logger.");\r
        logger.warn("It is a warn logger.");\r
    }\r
}\r
\`\`\`\r
\r
La salida obtenida ser la siguiente:\r
\r
\`\`\`bash\r
11:14:47.469 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\r
11:14:47.471 [main] FATAL psp.examples.u06.log4j2.ModuleA - It is a fatal logger.\r
\`\`\`\r
\r
Aunque hemos usado todos los niveles, en la consola solo vemos dos niveles. En realidad, cuando no proporcionamos ningn archivo de configuracin, por defecto Log4j utiliza una configuracin predeterminada. La configuracin predeterminada, proporcionada en la clase DefaultConfiguration, configurar:\r
\r
- Un **\`ConsoleAppender\`** para el logger por defecto, es decir, los registros se imprimirn en la consola.\r
- Un **\`PatternLayout\`** configurado con el patrn:\r
  " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n " asociado al ConsoleAppender\r
\r
!!! tip Nivel de registro por defecto\r
    Por defecto, Log4j asigna el logger raz al nivel Level.ERROR y esos logs se imprimirn en la consola estndar.\r
\r
!!! info Patrn por defecto\r
    Vamos a entender el formato de patrn en el que se imprimen los logs. Dado que no hemos pasado ningn archivo de configuracin, utiliza el formato por defecto que se muestra a continuacin.\r
\r
    > " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n "\r
\r
    - \`%d{HH:mm:ss.SSS}\` is execution timestamp i.e. 18:07:15.984\r
    - \`[%t]\` is thread name i.e. [main] \r
    - \`%-5level\` is level name i.e. ERROR\r
    - \`%logger{36}\` is logger name which we are creating as first step i.e. psp.examples.u06.log4j2\r
    - \`%msg%n\` is message i.e.  It is an error logger  followed by a new line character.\r
\r
## 6.6.5. Configuracin de Log4j2\r
\r
Para configurar Log4j2, necesitamos un archivo de configuracin. Log4j2 admite la configuracin en formato XML, JSON, YAML y propiedades.\r
\r
Log4j2 tiene una arquitectura de registro bastante compleja, sin embargo la mayora de los usuarios solo requieren estos elementos:\r
\r
- **Loggers**: Son el punto de entrada del pipeline de registro, que se utiliza directamente en el cdigo. Su configuracin debe especificar qu nivel de mensajes registran y a qu \`*appenders*\` envan los mensajes. Los cubriremos mientras configuramos los \`*loggers*\`.\r
- **Appenders**: Son el punto de salida del pipeline de registro. Deciden a qu recurso (consola, archivo, base de datos o similar) se enva el evento de registro. Los ms comunes son el \`*console appender*\` y el \`*file appender*\`.\r
- **Layouts**: Indican a los \`*appenders*\` cmo formatear el evento de registro: texto, JSON, XML o similar. Los ms comunes son \`*Pattern Layout*\` y \`*JSON Template Layout*\`.\r
\r
A continuacin se muestra un ejemplo de configuracin en formato XML.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuracin, hemos configurado un \`ConsoleAppender\` que imprimir los mensajes de registro en la consola. Hemos configurado el nivel de registro raz como \`error\`, por lo que solo se imprimirn los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscar los archivos de configuracin en el siguiente orden:\r
\r
1. Primero comprobar si se ha especificado un archivo de configuracin en la propiedad del sistema \`log4j.configurationFile\`. Si no se ha especificado, buscar los archivos de configuracin en el siguiente orden:\r
2. Si no encuentra la propiedad del sistema buscar los archivos de configuracin en el \`classpath\` en el siguiente orden:\r
\r
   - \`log4j2-test.xml\`\r
   - \`log4j2-test.json\`\r
   - \`log4j2-test.yaml\`\r
   - \`log4j2-test.yml\`\r
   - \`log4j2-test.properties\`\r
   - \`log4j2.xml\`\r
   - \`log4j2.json\`\r
   - \`log4j2.yaml\`\r
   - \`log4j2.yml\`\r
   - \`log4j2.properties\`\r
\r
Se puede ampliar la informacin en la [documentacin oficial de Log4j2](https://logging.apache.org/log4j/2.x/manual/configuration.html).\r
\r
## 6.6.6 Appenders\r
\r
> [Documentacin Appenders](https://logging.apache.org/log4j/2.x/manual/appenders.html)\r
\r
Podemos especificar destinos para mantener los registros de eventos. Podemos querer imprimir esos registros en la consola o en cualquier archivo externo. Los \`appenders\` suelen ser responsables de escribir los datos de eventos en el destino objetivo. Podemos usar varios *appenders* en una misma configuracin.\r
\r
Los \`appenders\` ms comunes son:\r
\r
- **ConsoleAppender**: Imprime los mensajes de registro en la consola.\r
- **FileAppender**: Imprime los mensajes de registro en un archivo.\r
- **RollingFileAppender**: Imprime los mensajes de registro en un archivo y crea un nuevo archivo cuando el tamao del -chivo alcanza un lmite.\r
- **DBAppender**: Imprime los mensajes de registro en una base de datos.\r
- **SMTPAppender**: Enva los mensajes de registro por correo electrnico.\r
- **SocketAppender**: Enva los mensajes de registro a un servidor remoto.\r
- **SyslogAppender**: Enva los mensajes de registro a un servidor Syslog.\r
- **JMSAppender**: Enva los mensajes de registro a un servidor JMS.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration xmlns="https://logging.apache.org/xml/ns"\r
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r
               xsi:schemaLocation="\r
                   https://logging.apache.org/xml/ns\r
                   https://logging.apache.org/xml/ns/log4j-config-2.xsd">\r
  <Appenders>\r
    <Console name="CONSOLE">\r
      <PatternLayout pattern="%p - %m%n"/>\r
    </Console>\r
    <File name="MAIN" fileName="logs/main.log">\r
      <JsonTemplateLayout/>\r
    </File>\r
    <File name="DEBUG_LOG" fileName="logs/debug.log">\r
      <PatternLayout pattern="%d [%t] %p %c - %m%n"/>\r
    </File>\r
  </Appenders>\r
  <Loggers>\r
    <Root level="INFO">\r
      <AppenderRef ref="CONSOLE" level="WARN"/>\r
      <AppenderRef ref="MAIN"/>\r
    </Root>\r
    <Logger name="org.example" level="DEBUG">\r
      <AppenderRef ref="DEBUG_LOG"/>\r
    </Logger>\r
  </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En el ejemplo anterior se han configurado tres \`appenders\`:\r
\r
- Un \`ConsoleAppender\` llamado CONSOLE con un \`PatternLayout\`.\r
  En este caso la salida se mostrar en la consola y se imprimir el nivel de log y el mensaje. Por ejemplo, \`INFO - It is an info logger\`.\r
- Un \`FileAppender\` llamado MAIN con un \`JsonTemplateLayout\`.\r
  En este caso la salida se escribir en el archivo \`logs/main.log\` en formato JSON. Por ejemplo, \`{"level":"INFO","message":"It is an info logger"}\`.\r
- Un \`FileAppender\` llamado DEBUG_LOG con un \`PatternLayout\`.\r
    En este caso la salida se escribir en el archivo \`logs/debug.log\` con el formato de fecha, hilo, nivel de log, clase y mensaje. Por ejemplo, \`2021-09-15 11:14:47,471 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\`\r
\r
## 6.6.7. Loggers\r
\r
> [Documentacin Loggers](https://logging.apache.org/log4j/2.x/manual/configuration.html#configuring-loggers)\r
\r
Los \`loggers\` se utilizan directamente en el cdigo para registrar mensajes.\r
\r
Los \`loggers\` se configuran en el archivo de configuracin de Log4j2. y se pueden configurar para enviar mensajes de registro a uno o varios \`appenders\`.\r
\r
En el ejemplo anterior, se han configurado dos \`loggers\`:\r
\r
- Un \`logger\` raz con nivel de log INFO y dos \`appenders\` asociados: CONSOLE y MAIN.\r
  En este caso, los mensajes de log con nivel INFO o superior se enviarn al \`appender\` MAIN, es decir, al archivo \`logs/main.log\`.\r
  Los mensajes de log con nivel WARN o superior se enviarn tambin al \`appender\` CONSOLE, es decir, a la consola.\r
- Un \`logger\` con nombre \`org.example\` con nivel de log DEBUG y un \`appender\` asociado: DEBUG_LOG.\r
  En este caso, los mensajes de log con nivel DEBUG o superior se enviarn al \`appender\` DEBUG_LOG.\r
\r
!!! question Un mismo mensaje, diferentes salidas\r
    Fjate en la siguiente tabla con los mensajes que se enviaran a cada \`appender\` en funcin del nivel de log, del \`logger\` que lo genere y de los \`appenders\`.\r
\r
    | Logger name | Log event level | Appenders |\r
    |-------------|-----------------|-----------|\r
    | org.example.foo | WARN | CONSOLE, MAIN, DEBUG_LOG |\r
    | org.example.foo | DEBUG | MAIN, DEBUG_LOG |\r
    | org.example.foo | TRACE | none |\r
    | com.example | WARN | CONSOLE, MAIN |\r
    | com.example | INFO | MAIN |\r
    | com.example | DEBUG | none |\r
\r
    Si un logger no tiene un nivel de log configurado se heredar el nivel de log del logger padre. Si no se ha configurado ningn nivel de log, se heredar el nivel de log del logger raz.\r
\r
## 6.6.8. Layouts\r
\r
> [Documentacin Layouts](https://logging.apache.org/log4j/2.x/manual/layouts.html)\r
\r
Los \`layouts\` se utilizan para dar formato a los mensajes de log. Log4j2 proporciona varios \`layouts\` predefinidos que se pueden utilizar para dar formato a los mensajes de log.\r
\r
Los \`layouts\` ms comunes son:\r
\r
- **PatternLayout**: Es el \`layout\` ms comnmente utilizado. Permite configurar el formato de los mensajes de log utilizando un patrn.\r
- **JsonTemplateLayout**: Es un \`layout\` que genera mensajes de log en formato JSON.\r
- **YamlLayout**: Es un \`layout\` que genera mensajes de log en formato YAML.\r
- **HtmlLayout**: Es un \`layout\` que genera mensajes de log en formato HTML.\r
- **CsvLogLayout**: Es un \`layout\` que genera mensajes de log en formato CSV.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuracin, hemos configurado un \`ConsoleAppender\` que imprimir los mensajes de registro en la consola. Hemos configurado el nivel de registro raz como \`error\`, por lo que solo se imprimirn los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscar los archivos de configuracin en el siguiente orden:\r
\r
Un ejemplo de configuracin de Log4j2 con un \`JsonTemplateLayout\` sera el siguiente:\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <JsonTemplateLayout eventTemplateUri="classpath:log4j2/templates/JsonEventLayout.json"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
Donde un posible contenido para el archivo \`JsonEventLayout.json\` podra ser el siguiente:\r
\r
\`\`\`json\r
{\r
  "timeMillis": "\${timeMillis}",\r
  "thread": "\${thread}",\r
  "level": "\${level}",\r
  "loggerName": "\${loggerName}",\r
  "message": "\${message}",\r
  "thrown": "\${thrown}"\r
}\r
\`\`\`\r
\r
## 6.6.9. Actividades\r
\r
Puedes probar a realizar las siguientes actividades para practicar con Log4j2:\r
\r
1. Escribe un programa simple utilizando Log4j2 que imprima TODOS los niveles de error en la consola.\r
2. Utilizando el programa del ejercicio 1, genera un archivo de configuracin manual para imprimir los errores FATALES en SYSTEM_ERR y el resto de los niveles de error en SYSTEM_OUT. (Aade comentarios en el XML con \`<!--Tu comentario-->\`)\r
3. Utilizando el programa del ejercicio 1, genera un archivo de configuracin manual en el que los errores FATALES vayan a un archivo de texto, los errores de nivel ERROR aparezcan en rojo en la consola (SYSTEM_ERR) y el resto aparezcan en la consola normal (SYSTEM_OUT).\r
4. Utilizando el archivo anterior (ejercicio 3) cambia el Patrn de Salida para que lo primero que aparezca en la lnea de LOG sean tus iniciales.\r
\r
!!! tip Guardar los registros en una base de datos\r
    Log4j2 tambin permite guardar los registros en una base de datos.\r
    Investiga cmo se puede hacer y realiza un ejemplo de cmo guardar los registros en una base de datos MySQL.\r
\r
## 6.6.10. Bibliografa\r
\r
- [Log4j2 - Documentacin oficial](https://logging.apache.org/log4j/2.x/)\r
- [Tutorial de 7 partes de MakeSeleniumEasy sobre Log4j2](http://makeseleniumeasy.com/2021/03/11/log4j2-tutorial-1-introduction-to-apache-log4j2/)\r
- [Log4j2 - Tutorialspoint](https://www.tutorialspoint.com/log4j/log4j_logging_files.htm)\r
`]},{title:"6.1 Security",headers:[{level:2,title:"6.1.1. Digital security",slug:"_6-1-1-digital-security",link:"#_6-1-1-digital-security",children:[]},{level:2,title:"6.1.2. Seguridad en Java",slug:"_6-1-2-seguridad-en-java",link:"#_6-1-2-seguridad-en-java",children:[]},{level:2,title:"6.1.2. Security in Java",slug:"_6-1-2-security-in-java",link:"#_6-1-2-security-in-java",children:[{level:3,title:"JCA: Engines, algorithms and providers",slug:"jca-engines-algorithms-and-providers",link:"#jca-engines-algorithms-and-providers",children:[]}]},{level:2,title:"6.1.3. Providers",slug:"_6-1-3-providers",link:"#_6-1-3-providers",children:[{level:3,title:"6.1.4. Engines",slug:"_6-1-4-engines",link:"#_6-1-4-engines",children:[]},{level:3,title:"6.1.5 Algorithms",slug:"_6-1-5-algorithms",link:"#_6-1-5-algorithms",children:[]}]}],path:"/en/unit6/security.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.1 Security\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.1 Security" />\r
\r
# 6.1 Security\r
\r
[[toc]]\r
\r
## 6.1.1. Digital security\r
\r
Fundamental aspects of security in digital communications are:\r
\r
- **Integrity**: It allows to ensure that the data received by a receiver are identical to those sent by the sender. That is, it has not been modified at any intermediate point in **the channel, which as we know, is a shared and therefore, insecure channel**. Modifications can be caused by failures in transmission through the channel or by an intentional action of a third party.\r
- **Confidentiality**: It ensures that the transmitted data is intelligible only to the recipient of the message. Due to the characteristics of the medium, we cannot prevent the message from reaching other recipients, but what we can prevent is that they can see the original content of the message. This is achieved by encrypting the message.\r
- **Authentication**: It allows to ensure to the receiver of a message that the sender of the message is who he says he is and not any other. This is achieved with certificates and digital signature.\r
- **Non-repudiation**: It is a consequence of the previous characteristic, since a receiver can demonstrate that the message was sent by a sender unequivocally.\r
\r
## 6.1.2. Seguridad en Java\r
\r
## 6.1.2. Security in Java\r
\r
[oracle Security Developers Guide](https://docs.oracle.com/en/java/javase/11/security/java-cryptography-architecture-jca-reference-guide.html)\r
\r
From the point of view of security, the set of security classes distributed with the Java 2 SDK can be divided into two subsets:\r
\r
- Classes related to access control and permission management.\r
- Classes related to Cryptography.\r
\r
Java includes APIs for accessing general-purpose cryptographic functions, known as the **Java Cryptography Architecture (JCA)** and the **Java Cryptography Extension (JCE)**.\r
\r
The JCA is made up of the basic classes related to cryptography distributed with the JDK and the support for encryption is provided by the JCE extension package.\r
\r
Java also includes a set of packages for secure Internet communication, known as the **Java Secure Socket Extension (JSSE)**. It implements a Java version of the SSL and TLS protocols, and also includes features such as data encryption, server authentication, message integrity, and client authentication.\r
\r
Finally, Java includes an interface that allows Java applications to access authentication and access control services, the **Java Authentication and Authorization Service (JAAS)**. It can be used for two purposes: user authentication to know who is running Java code; and user authorization to ensure that whoever runs it has the necessary permissions to do so.\r
\r
### JCA: Engines, algorithms and providers\r
\r
Java has a Provider Architecture, which allows multiple implementations of cryptographic algorithms to coexist (i.e. multiple implementations of the JCE). The Java 2 platform substantially extends the JCA, among other things the certificate management infrastructure has been improved to support X.509 V3 certificates.\r
\r
To understand how the JCA works we have to define some basic terms:\r
\r
#### Engine\r
\r
In the context of the JCA we use the term engine to refer to an abstract representation of a cryptographic service that does not have a concrete implementation. A cryptographic service is always associated with an algorithm or type of algorithm and can have any of the following functions:\r
\r
- Provide cryptographic operations (such as those used in signing and digesting messages)\r
- Generate or provide the cryptographic material (keys or parameters) necessary to perform the operations.\r
- Generate objects (key stores or certificates) that group cryptographic keys in a secure manner.\r
\r
#### Algorithm\r
\r
An algorithm is an implementation of an engine. For example, the MD5 algorithm is an implementation of the message digest engine. The internal implementation may vary depending on the code provided by the MD5 class.\r
\r
#### Provider\r
\r
A provider is responsible for providing the implementation of one or more algorithms to the programmer (i.e. giving him access to a specific internal implementation of the algorithms).\r
\r
## 6.1.3. Providers\r
\r
The JCA defines the concept of provider through the Provider class of the java.security package. It is an abstract class that must be redefined by specific provider classes.\r
\r
The constructor of a provider class adjusts the values of several properties that the Java security API needs to locate the algorithms or other facilities implemented by the provider.\r
\r
The Provider class has methods to access the name of the provider, the version number and other information about the implementations of the algorithms for key generation, conversion and management and the generation of signatures and digests.\r
\r
If a programmer wants to know the available providers, he can use the methods\r
\r
- getProvider("name") to know if a specific provider is installed\r
- getProviders() that returns a vector of strings with the names of the providers\r
\r
::: info java.security file\r
%JAVA_HOME%/conf/security/java.security is the file that contains the security configuration information used by the JCA classes.\r
\r
All the providers and algorithms that are available are declared there, as well as the order in which the classes will look for them.\r
:::\r
\r
To understand how providers work we will give an example. Suppose a program needs an implementation of the MD5 algorithm. To obtain it the programmer needs to create an instance of it and will do so by writing the following line of code:\r
\r
\`\`\`java\r
MessageDigest m = MessageDigest.getInstance("MD5");\r
\`\`\`\r
\r
Internally, the getInstance() method requests the java.security.Security class to provide it with the requested object. Since no provider has been specified, the Security class queries all the available providers, requesting an implementation of the "MD5" algorithm, until it finds one or runs out of providers. The query is made according to the list of providers in the java.security file, which by default only contains the entry:\r
\r
Security.provider.1=sun.security.provider.Sun\r
\r
### 6.1.4. Engines\r
\r
In the JDK the JCA defines the following Engine classes\r
\r
| JCA Class | Function |\r
|---|---|\r
|java.security.MessageDigest | Calculation of message summary (hash).|\r
|java.security.Signature| Data signing and signature verification.|\r
|java.security.KeyPairGenerator | Generate key pairs (public and private) for an algorithm.|\r
|java.security.KeyFactory| Convert cryptographic key formats, key specifications and vice versa|\r
|java.security.certificate.CertificateFactory| Create public key certificates and revocation lists (CRLs).|\r
|java.security.KeyStore | Create and manage a key store (keystore).|\r
|java.security.AlgorithmParameters | Manage the parameters of an algorithm, including encoding and decoding.|\r
|java.security.AlgorithmParameterGenerator | Generate a set of parameters for an algorithm.|\r
|java.security.SecureRandom | Generate random or pseudo-random numbers.|\r
\r
To instantiate an engine class you must invoke the static method *getInstance()*, if you pass an algorithm name it will try to obtain an implementation of some provider.\r
\r
### 6.1.5 Algorithms\r
\r
As with command line tools, we need to know which algorithms are available for use by applications on our virtual machine.\r
\r
The following program allows us to know which providers and algorithms we have installed on our system.\r
\r
In addition, if we invoke it with the -l option it will tell us which algorithms they implement (reading the provider's properties)\r
\r
All the information shown is extracted from the *java.security* file\r
\r
\`\`\`java\r
class U6_S1_1_InfoProveedoresJCA {\r
\r
    public static void main(String[] args) {\r
        boolean listarProps = false;\r
        if (args.length > 0 && args[0].equals("-l")) {\r
            listarProps = true;\r
        }\r
        System.out.println("------------------------------------");\r
        System.out.println("Proveedores instalados en su sistema");\r
        System.out.println("------------------------------------");\r
        int i = 0;\r
        for (Provider proveedor: Security.getProviders()) {\r
            System.out.println("Nm. proveedor : " + (i + 1));\r
            System.out.println("Nombre         : " + proveedor.getName());\r
            System.out.println("Versin        : " + proveedor.getVersion());\r
            System.out.println("Informacin    :\\n  " + proveedor.getInfo());\r
            System.out.println("Propiedades    :");\r
            if (listarProps) {\r
                Enumeration propiedades = proveedor.propertyNames();\r
                while (propiedades.hasMoreElements()) {\r
                    String clave = (String) propiedades.nextElement();\r
                    String valor = proveedor.getProperty(clave);\r
                    System.out.println("  " + clave + " = " + valor);\r
                }\r
            }\r
            System.out.println("------------------------------------");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
The following program allows us to check the properties of algorithms available in our system.\r
\r
\`\`\`java\r
class U6_S1_2_ProbarAlgoritmosJCA {\r
\r
    public static void main(String[] args) {\r
        if (args.length != 1) {\r
            System.out.println("Uso: java ProbarAlgoritmosJCA <algoritmo>");\r
            System.exit(1);\r
        }\r
        try {\r
            MessageDigest md = MessageDigest.getInstance(args[0]);\r
            System.out.println("Algoritmo: " + md.getAlgorithm());\r
            System.out.println("Proveedor: " + md.getProvider().getName());\r
            System.out.println("Info     : " + md.toString());\r
            System.out.println("Tamao   : " + md.getDigestLength());\r
            System.out.println("Bloque   : " + md.getBlockSize());\r
            System.out.println("Entrada  : " + md.getInputSize());\r
            System.out.println("Salida   : " + md.getOutputSize());\r
            System.out.println("Implement: " + md.getClass().getName());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.out.println("Algoritmo no disponible");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
\r
`]},{title:"6.3 Encriptacin simtrica",headers:[{level:2,title:"6.3.1. Clave secreta",slug:"_6-3-1-clave-secreta",link:"#_6-3-1-clave-secreta",children:[]},{level:2,title:"6.3.2. Cipher",slug:"_6-3-2-cipher",link:"#_6-3-2-cipher",children:[{level:3,title:"Transformaciones bsicas en Java",slug:"transformaciones-basicas-en-java",link:"#transformaciones-basicas-en-java",children:[]}]},{level:2,title:"6.3.3. Clases stream para cifrado y descifrado simtrico",slug:"_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",link:"#_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",children:[]},{level:2,title:"6.3.4. Cifrado simtrico con GnuPG",slug:"_6-3-4-cifrado-simetrico-con-gnupg",link:"#_6-3-4-cifrado-simetrico-con-gnupg",children:[]}],path:"/en/unit6/symmetric-key.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.3 Encriptacin simtrica\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.3 Encriptacin simtrica" />\r
\r
# 6.3 Encriptacin simtrica\r
\r
[[toc]]\r
\r
## 6.3.1. Clave secreta\r
\r
Ahora nos interesa no slo verificar la integridad de la informacin intercambiada, sino tambin mantener su privacidad, es decir, que no sea "comprensible" durante la transmisin, intercambio o almacenamiento. \r
\r
Tenemos un conjunto de algoritmos denominados de **clave simtrica** (tambin conocidos como de clave secreta) en los que, mediante la aplicacin de una clave conocida tanto por el emisos como por el receptor, la informacin se **encripta o cifra** de forma que slo pueda ser **desencriptada o descifrada** utilizando el mismo algoritmo y la misma clave.\r
\r
::: info El cdigo Enigma\r
Como ejemplo de sistema simtrico est Enigma. Este fue un sistema empleado por Alemania durante la Segunda Guerra Mundial, en el que las claves se distribuan a diario en forma de libros de cdigos. \r
\r
Cada da, un operador de radio, receptor o transmisor, consultaba su copia del libro de cdigos para encontrar la clave del da. Todo el trfico enviado por ondas de radio durante aquel da era cifrado y descifrado usando las claves del da.\r
\r
Inglaterra us mquinas para descifrar las claves durante aquella guerra y aunque el citado sistema alemn, Enigma, estaba provisto de un amplio abanico de claves, los ingleses disearon mquinas de cmputo especializado, los Bombes, para comprobar las claves de modo mecnico hasta que la clave del da era encontrada. \r
\r
Esto significaba que algunas veces encontraban la clave del da pocas horas despus de que sta fuera puesta en uso, pero tambin que otros das no podan encontrar la clave correcta. \r
\r
Los Bombes no fueron mquinas de cmputo general, sino las precursoras de los ordenadores (computadoras) actuales.\r
:::\r
\r
Entre los algoritmos de cifrado simtrico ms utilizados se encuentran\r
\r
- DES\r
- 3DES o Tiple DES\r
- RC5\r
- AES\r
- Blowfish\r
- IDEA\r
\r
![cifrado simtrico](../../media/unit6/symmetric-encryption-primitive.png)\r
\r
## 6.3.2. Cipher\r
\r
Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *SecretKey* a partir de un KeyGenerator obtenido con el mtodo esttico *getInstance()*, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. As podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave ser diferente.\r
3. Se crea un objeto de tipo Cipher indicando qu algoritmo vamos a usar. Y despus, con el mtodo *init()* se indica qu vamos a hacer (cifrar/descifrar) y con qu clave.\r
4. Se aaden datos con el mtodo *update()*. Se puede aadir un byte o un array de bytes. Este mtodo se puede invocar varias veces para ir aadiendo nuevos datos.\r
5. Se obtiene el valor cifrado con el mtodo *doFinal()*.\r
6. Si se quisiera descifrar, slo hay que volver a invocar al mtodo *init()* indicando en este caso que queremos descifrar.\r
\r
A continuacin podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S3_1_SecretKeyEncrypt {\r
\r
    public static void main(String[] args) {\r
        SecretKey claveSecreta = null;\r
        \r
        try {\r
\r
            //Generamos clave secreta\r
            // Podemos crear una nueva clave\r
            claveSecreta = getNewKey();\r
            // O bien usar una clave guardada en algn almacn, fichero, etc.\r
            claveSecreta = getKeyFromData();\r
\r
            System.out.println("Clave usada: " + claveSecreta.getFormat());\r
            //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
            Cipher c = Cipher.getInstance("DESede"); // AES/ECB/PKCS5Padding\r
            // Configuramos el modo de CIFRADO\r
            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\r
\r
            // Aqu leemos la informacin que queremos cifrar\r
            // Puede ser una cadena o leerla de un archivo\r
            byte[] textoPlano = "Texto que queremos cifrar para la prueba".getBytes();\r
            \r
            // Si queremos ir cifrando poco a poco, vamos haciendo llamadas\r
            // al mtodo update\r
            // c.update(textoPlano);\r
            // Se realiza el proceso final de cifrado de la informacin\r
            byte[] textoCifrado = c.doFinal(textoPlano);\r
            System.out.println("Texto cifrado con clave secreta (raw):\\n" + new String(textoCifrado));\r
            System.out.println("Texto cifrado con clave secreta (hex):\\n" + toHexadecimal(textoCifrado));\r
                        \r
            \r
            // El proceso de descifrado es equivalente\r
            // Cambiamos el modo de ENCRYPT a DECRYPT\r
            // Usamos la misma clave\r
            // Pasamos el texto cifrado para obtener el original\r
            c.init(Cipher.DECRYPT_MODE, claveSecreta);\r
            byte[] textoOriginal = c.doFinal(textoCifrado);\r
            //Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\r
            System.out.println("Texto descifrado:\\n" + new String(textoOriginal));\r
            \r
        } catch (Exception e) {\r
            e.printStackTrace();\r
        }\r
    }\r
\r
    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
    \r
            KeyGenerator kg = KeyGenerator.getInstance("DESede");\r
            kg.init(112);\r
            SecretKey clave = kg.generateKey();\r
            \r
            return clave;\r
    }\r
\r
    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // Clave obtenida usando un generador de nmero aleatorios seguro\r
        KeyGenerator genClaves = KeyGenerator.getInstance("DESede");\r
        // Utilizamos un algoritmo de generacin de aleatorios        \r
        SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");\r
        genClaves.init(srand);\r
        \r
        SecretKey clave = genClaves.generateKey();\r
        System.out.println("Formato de clave: " + clave.getFormat());\r
        \r
        /*\r
        SecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance("DESede");\r
        DESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\r
        byte[] valorClave = keySpec.getKey();\r
        */\r
        \r
        return clave;\r
    }\r
    \r
    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        SecretKeySpec keySpec = new SecretKeySpec (valorClave, "DESede");\r
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");\r
        SecretKey clave = keyFactory.generateSecret(keySpec);\r
        \r
        return clave;\r
    }\r
\r
    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        Key clave = new SecretKeySpec(valorClave, "AES");\r
\r
        return clave;\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
    \r
}\r
\`\`\`\r
\r
y esta sera la salida proporcionada\r
\r
\`\`\`sh\r
Texto cifrado con clave secreta:\r
D0A61CD14B5844AD98B2C7BA795B327ACA0795B658C6F93EC6E1586A246BE71AC180B574207E8C4FFEB959B7D4642FCB\r
Texto descifrado:\r
Texto que queremos cifrar para la prueba\r
\`\`\`\r
\r
Hay que tener en cuenta que en el ejemplo la clave se est usando primero para cifrar y luego para descifrar. Si esto lo hacemos en programas separados, los programas que quieran comunicarse debern tener acceso a la clave.\r
\r
Lo que se suele hacer es almacenar la clave en un archivo y, cuando se necesita para cifrar o descifrar, se lee con un mtodo similar al mtodo *getKeyFromData()* del ejemplo anterior.\r
\r
### Transformaciones bsicas en Java\r
\r
En la siguiente tabla tenemos los algoritmos, modos y tipos de relleno, junto con la longitud de clave empleada, de los algoritmos de cifrado simtrico m'as comunes.\r
\r
|Transformacin (algoritmo/modo/relleno)|Key Size|\r
|---|---|\r
|AES/CBC/NoPadding|128|\r
|AES/CBC/PKCS5Padding|128|\r
|AES/ECB/NoPadding|128|\r
|AES/ECB/PKCS5Padding|128|\r
|DES/CBC/NoPadding|56|\r
|DES/CBC/PKCS5Padding|56|\r
|DES/ECB/NoPadding|56|\r
|DES/ECB/PKCS5Padding|56|\r
|DESede/CBC/NoPadding|168|\r
|DESede/CBC/PKCS5Padding|168|\r
|DESede/ECB/NoPadding|168|\r
|DESede/ECB/PKCS5Padding|168|\r
|RSA/ECB/PKCS1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-1AndMGF1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-256AndMGF1Padding|1024, 2048|\r
\r
\r
## 6.3.3. Clases stream para cifrado y descifrado simtrico\r
\r
Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete *java.crypto* pero por lo dems funcionan exactamente igual que las clases Stream del paquete *java.io*, de las que adems son clases descendientes y y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.\r
\r
| Clase |Ejemplo |\r
| --- | --- |\r
| CipherInputStream | CipherInputStream (InputStream is, Cipher c) |\r
| CipherOutputStream | CipherOutputStream (OutputStream os, Cipher c) |\r
\r
Por lo tanto, cuando tenemos que leer o escribir informacin, podemos aadir un envoltorio ms al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher.\r
\r
El uso ms comn es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la informacin de forma cifrada/descifrada.\r
\r
::: warning Tamao de bloque\r
Muchos de los algoritmos de cifrado simtrico trabajan con bloques de datos, por lo que no debemos intentar cifrar o descifrar ms informacin de la que permite el tamao de bloque.\r
\r
La clase Cipher tiene un mtodo **getBlockSize()** que nos devuelve el tamao de bloque que permite el algoritmo configurado en su mtodo **init()**.\r
:::\r
\r
Veamos un ejemplo de cmo quedara el wrapper\r
\r
\`\`\`java\r
public class U6S3_2_StreamCrypto {\r
\r
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\r
        File file;\r
        String filePath = "a.txt";\r
\r
        file = new File(filePath);\r
\r
        //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding"); //DESede\r
        // Configuramos el modo de CIFRADO\r
        byte[] valorClave = "12345678123456781234567812345678".getBytes();\r
\r
        // CIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.ENCRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (OutputStream outputStream = new BufferedOutputStream(\r
                new CipherOutputStream(new FileOutputStream(file), c))) {\r
            for (int i = 0; i < 10; i++) {\r
                outputStream.write(new String("Hello World\\n").getBytes());\r
            }\r
\r
        }\r
\r
        // DESCIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.DECRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (InputStream inputStream = new BufferedInputStream(\r
                new CipherInputStream(new FileInputStream(file), c))) {\r
\r
            System.out.println("Contenido del fichero (descifrado):\\n" + new String(inputStream.readAllBytes()));\r
        }\r
\r
    }\r
}\r
\`\`\`\r
\r
## 6.3.4. Cifrado simtrico con GnuPG\r
\r
Con la suite GnuPG tambin podemos cifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informacin de los algoritmos disponibles para cada tipo de servicio. En concreto, de resmenes, en mi versin instalada:\r
\r
Cifrado: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\r
         CAMELLIA128, CAMELLIA192, CAMELLIA256\r
:::\r
\r
Para cifrar y descifrar un archivo, ejecutamos los siguientes comandos\r
\r
\`\`\`sh\r
gpg --symmetric --cipher-algo 3DES filename.ext\r
gpg --decrypt filename.ext.gpg\r
\`\`\`\r
\r
Vemos que para el cifrado nos solicita una clave y que con el parmetro *--cipher-algo* indicamos qu algoritmo de encriptacin queremos utilizar.\r
\r
El cifrado genera un archivo filename.ext.gpg.\r
\r
Para el descifrado, no hace falta indicar el algoritmo, aunque se puede volver a usar el parmetro *--cipher-algo* y la clave se queda en una cache de GnuPG durante un tiempo, por lo que no siempre la solicita.\r
`]},{title:"1.2 Concurrencia",headers:[{level:2,title:"1.2.1. Concurrencia vs Paralelismo",slug:"_1-2-1-concurrencia-vs-paralelismo",link:"#_1-2-1-concurrencia-vs-paralelismo",children:[{level:3,title:"Monoproceso",slug:"monoproceso",link:"#monoproceso",children:[]},{level:3,title:"Multiprogramacin",slug:"multiprogramacion",link:"#multiprogramacion",children:[]},{level:3,title:"Paralelismo",slug:"paralelismo",link:"#paralelismo",children:[]}]},{level:2,title:"1.2.2. Sistemas distribuidos",slug:"_1-2-2-sistemas-distribuidos",link:"#_1-2-2-sistemas-distribuidos",children:[]},{level:2,title:"1.2.3. Ventajas e inconvenientes",slug:"_1-2-3-ventajas-e-inconvenientes",link:"#_1-2-3-ventajas-e-inconvenientes",children:[]},{level:2,title:"1.2.4. Condiciones de Bernstein",slug:"_1-2-4-condiciones-de-bernstein",link:"#_1-2-4-condiciones-de-bernstein",children:[]}],path:"/es/unit1/concurrency.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.2 Concurrencia\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.2. Concurrencia" />\r
\r
# 1.2. Concurrencia\r
\r
[[toc]]\r
\r
Segn el diccionario de la [RAE](https://dle.rae.es/concurrencia?m=form) una de las acepciones de concurrencia es\r
> Coincidencia, concurso simultneo de varias circunstancias.\r
\r
Si cambiamos circunstancias por \`procesos\`, ya tendramos una definicin cercana a lo que significa concurrencia en el mundo digital\r
\r
Si nos fijamos, no es la primera vez que surge la palabra \`proceso\` en este texto, y es que los procesos son una pieza fundamental del puzle, por no decir la parte ms importante.\r
\r
## 1.2.1. Concurrencia vs Paralelismo\r
\r
Ahora que ya sabemos qu es un proceso, vamos a ver la relacin que stos tienen con el hardware en el que se ejecutan.\r
\r
### Monoproceso\r
\r
Por mucho que tengamos varios procesos procesos ejecutndose a la vez, si slo tenemos un microprocesador para atenderlos a todos, estas tareas nunca van a poder ejecutarse a la vez.\r
\r
Una posibilidad sera la ejecucin secuencias de las tareas en el sistema. Se empieza a ejecutar una tarea y, hasta que esta no finaliza, el sistema no empieza a ejecutar la siguiente. Esto se correspondera con sistemas que slo son capaces de hacer una tarea a la vez, algo raro hoy en da.\r
\r
![Secuential execution of tasks (monoprocessor system)](./../../media/unit1/gantt_sequential.svg)\r
\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Secuential execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1       :done, t1, 0, 4s\r
Process 2     : active, t2, after t1, 5s\r
Process 3     : crit, t3, after t2, 2s\r
Process 4    : t4, after t3, 5s\r
\`\`\`\r
-->\r
\r
### Multiprogramacin\r
\r
Para que los procesos no tengan que esperar a que todos los dems se ejecuten, los sistemas aprovechan y exprimen los recursos al mximo, permitiendo la ilusin de que varios procesos se ejecutan de forma simultnea. Esto es lo que se conoce como \`multitarea\`.\r
\r
En estos sistemas, se aprovecha el diseo de los sistemas operativos modernos, y de las operaciones que realizan los procesos que no requieren el uso del procesador (esperar a una operacin de E/S, una interaccin con el usuario, la recepcin de informacin desde la red, etc.) para poder ejecutar otros procesos. La ejecucin se multiplexa en el tiempo.\r
\r
![Concurrent execution of tasks (monoprocessor system)](./../../media/unit1/gantt_concurrent.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Concurrent execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 3  :crit, t3, after t2, 2s\r
Process 4  : t4, after t3, 1s\r
Process 1  :done, t5, after t4, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 4  : t7, after t6, 3s\r
Process 2  :active, t8, after t7, 2s\r
Process 4  : t9, after t8, 1s\r
\`\`\`\r
-->\r
\r
Como se puede observar en las dos imgenes anteriores (aunque se trata slo de un modelo), el tiempo de uso total del procesador es igual en ambos casos, es decir, que el sistema tardar el mismo tiempo en completar todas las tareas. Sin embargo, la sensacin es que todas las tareas se estn realizando a la vez.\r
\r
### Paralelismo\r
\r
Con el avance de la tecnologa ahora la gran mayora de dispositivos, desde los equipos de escritorio, porttiles, dispositivos mviles, ... hasta los dispositivos IoT, tienen capacidades de multiproceso, es decir, tienen ms de un procesador para poder realizar varias tareas a la vez de forma real, no simulada.\r
A este tipo de ejecucin es a lo que llamamos \`paralelismo\`.\r
\r
![Parallel execution of tasks (dual processor system)](./../../media/unit1/gantt_parallel.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Parallel execution of tasks (dual processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 1  :done, t5, after t2, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 2  :active, t8, after t6, 2s\r
section Processor 2\r
Process 3  :crit, t3, 0, 2s\r
Process 4  : t4, after t3, 1s\r
Process 4  : t7, after t4, 3s\r
Process 4  : t9, after t7, 1s\r
\`\`\`\r
-->\r
\r
En este caso, a mayor nmero de unidades de proceso, menor tiempo tardarn las tareas en completarse y mayor ser la sensacin de rapidez que notar el usuario. Este es uno de los retos de los sistemas operativos, planificar adecuadamente las tareas para minimizar los tiempos de ejecucin, de espera y el uso de los recursos del sistema, el procesador principalmente.\r
\r
::: question ncleos vs hilos\r
Si habis comprado un procesador hace poco, o estis al da en cuanto al hardware, sabris que una de las caractersticas de los procesadores es su **nmero de ncleos** (4, 8, 16).\r
\r
Pero adems, al nmero de ncleos lo acompaa otra caracterstica que es el nmero de **hilos o threads**, que suele ser el doble que el de ncleos.\r
\r
Qu implicacin tienen los threads de un procesador con respecto a la concurrencia? Si un equipo tiene 8 ncleos / 16 hilos significa eso que puede ejecutar 16 procesos a la vez?\r
:::\r
\r
## 1.2.2. Sistemas distribuidos\r
\r
> "Un sistema distribuido es una coleccin de computadores independientes que aparecen ante los usuarios como un nico sistema coherente"\r
>\r
> "Andrew S. Tanembaum"\r
\r
Posiblemente el ejemplo ms famoso y conocido de sistema distribuido sea \`Internet\`.Internet aparece ante los usuarios como un enorme repositorio de documentos, es decir, como un nico sistema capaz de proveer casi cualquier tipo de informacin o servicio que se necesite. No obstante, sabemos que est compuesta por millones de equipos ubicados en localizaciones diferentes e interconectados entre s.\r
\r
Nace de la necesidad de compartir recursos. Actualmente el mximo exponente de este tipo de sistemas es el \`Cloud Computing\` o servicios en la nube. Un sistema es distribuido cuando los componentes software estn distribuidos en la red, se comunican y coordinan mediante el paso de mensajes.\r
\r
Las caractersticas de este tipo de sistemas son::\r
\r
- Concurrencia: ejecucin de programas concurrentes.\r
- Inexistencia de un reloj global. Implica sincronizarse con el paso de mensajes.\r
- Fallos independientes: cada componente del sistema puede fallar sin que perjudique la ejecucin de los dems.\r
\r
## 1.2.3. Ventajas e inconvenientes\r
\r
Ventajas del procesamiento paralelo:\r
\r
- Ejecucin simultnea de tareas.\r
- Disminuye el tiempo total de ejecucin\r
- Resuelve problemas complejos y de grandes dimensiones.\r
- Utilizacin de recursos no locales distribuidos en la red\r
- Disminucin de costos, aprovechando los recursos distribuidos, no es necesario gastar en un nico supercomputador, se puede alcanzar el mismo poder de computacin con equipos ms modestos distribuidos.\r
\r
Inconvenientes del procesamiento paralelo:\r
\r
- Los compiladores y entornos de programacin para sistemas paralelos son ms complicados de desarrollar.\r
- Los programas paralelos son ms difciles de escribir\r
- Hay mayor consumo de energa\r
- Mayor complejidad en el acceso a datos\r
- Complejidad a la hora de la comunicacin y sincronizacin de las diferentes subtareas. <Badge type="danger" text="cuidado" vertical="middle" />\r
\r
Ventajas de la programacin distribuida\r
\r
- Se comparten recursos y datos\r
- Crecimiento bajo demanda\r
- Mayor flexibilidad para distribuir la carga\r
- Alta disponibilidad\r
- Soporte de aplicaciones distribuidas\r
- Filosofa abierta y heterognea\r
\r
::: question Escalado de sistemas\r
Con escalado nos referimos a la posibilidad de incrementar las capacidades de un sistema.\r
\r
Investiga las diferencias, ventajas e inconvenientes del \`escalado horizontal\` y el \`escalado vertical\`.\r
:::\r
\r
Inconvenientes de la programacin distribuida\r
\r
- Aumenta la complejidad\r
- Se necesita software nuevo especializado\r
- Problemas derivados de las comunicaciones (perdidas, saturaciones, etc.)\r
- Problemas de seguridad, ataques DDoS\r
\r
Ejemplos de utilizacin de la programacin paralela y distribuida\r
\r
- Estudios meteorolgicos\r
- Estudios del genoma humano\r
- Modelado de la biosfera\r
- Predicciones ssmicas\r
- Simulacin de molculas\r
\r
::: info Ejemplo de programacin paralela y distribuida\r
[Bsqueda de inteligencia extraterrestre - Proyecto SETI](https://setiathome.berkeley.edu/sah_about.php)\r
:::\r
\r
## 1.2.4. Condiciones de Bernstein\r
\r
Una vez que sabemos qu es un programa concurrente y las distintas arquitecturas hardware que pueden soportarlo, vamos a ver qu partes de un programa se pueden ejecutar de forma concurrente y cules no.\r
\r
Si observamos el siguiente cdigo, queda claro que la primera instruccin se debe ejecutar antes que la segunda para que el resultado sea siempre el mismo (para los mismos datos de entrada).\r
\r
\`\`\`java\r
x = x + 1;\r
y = x + 1;\r
\`\`\`\r
\r
Sin embargo, en un cdigo como el siguiente el orden en el que se ejecuten las instrucciones no influye en el resultado final (valor de las variables). En este caso se pueden ejecutar las tres sentencias a la vez incrementando la velocidad de procesamiento.\r
\r
\`\`\`java\r
x = 1;\r
y = 2;\r
z = 3;\r
\`\`\`\r
\r
A.J. Bernstein defini unas condiciones para determinar si dos conjuntos de instrucciones S<sub>i</sub> y S<sub>j</sub> se pueden ejecutar concurrentemente.\r
\r
Para poder determinar si dos conjuntos de instrucciones se pueden ejecutar concurrentemente, se definen en primer lugar los siguientes conjuntos\r
\r
- L(S<sub>k</sub>) = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...} como el conjunto de lectura formado por todas las variables cuyos valores se leen durante la ejecucin de las instrucciones del conjunto k.\r
- E(S<sub>k</sub>) = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, ...} como el conjunto de escritura formado por todas las variables cuyos valores se actualizan durante la ejecucin de las instrucciones del conjunto k.\r
\r
Para que dos conjuntos de instrucciones S<sub>i</sub> y S<sub>j</sub> se puedan ejecutar concurrentemente, se deben cumplir estas tres condiciones de forma simultnea.\r
\r
- L(S<sub>i</sub>)  E(S<sub>j</sub>)\r
- E(S<sub>i</sub>)  L(S<sub>j</sub>)\r
- E(S<sub>i</sub>)  E(S<sub>j</sub>)\r
  \r
::: question Cuales de estas instrucciones se pueden ejecutar de forma concurrente\r
\r
\`\`\`java\r
a = x + y;\r
b = z - 1;\r
c = a - b;\r
w = c + 1;\r
\`\`\`\r
\r
:::\r
\r
Primero deberamos obtener los conjuntos L y E para cada sentencia\r
\r
> L(S<sub>1</sub>) = {x, y}\r
>\r
> E(S<sub>1</sub>) = {a}\r
\r
> L(S<sub>2</sub>) = {z}\r
>\r
> E(S<sub>2</sub>) = {b}\r
\r
> L(S<sub>3</sub>) = {a, b}\r
>\r
> E(S<sub>3</sub>) = {c}\r
\r
>L(S<sub>4</sub>) = {c}\r
>\r
> E(S<sub>4</sub>) = {w}\r
\r
Y ahora aplicarlas entre cada par de sentencias\r
\r
> L(S<sub>1</sub>)  E(S<sub>2</sub>) = \r
> E(S<sub>1</sub>)  L(S<sub>2</sub>) = \r
> E(S<sub>1</sub>)  E(S<sub>2</sub>) =          // S se pueden ejecutar concurrentemente\r
\r
> L(S<sub>1</sub>)  E(S<sub>3</sub>) = \r
> E(S<sub>1</sub>)  L(S<sub>3</sub>) = {a}  \r
> E(S<sub>1</sub>)  E(S<sub>3</sub>) =          // NO se pueden ejecutar concurrentemente\r
\r
> L(S<sub>1</sub>)  E(S<sub>4</sub>) = \r
> E(S<sub>1</sub>)  L(S<sub>4</sub>) = \r
> E(S<sub>1</sub>)  E(S<sub>4</sub>) =          // S se pueden ejecutar concurrentemente\r
\r
> L(S<sub>2</sub>)  E(S<sub>3</sub>) = \r
> E(S<sub>2</sub>)  L(S<sub>3</sub>) = {b] \r
> E(S<sub>2</sub>)  E(S<sub>3</sub>) =          // NO se pueden ejecutar concurrentemente\r
\r
> L(S<sub>2</sub>)  E(S<sub>4</sub>) = \r
> E(S<sub>2</sub>)  L(S<sub>4</sub>) = \r
> E(S<sub>2</sub>)  E(S<sub>4</sub>) =          // S se pueden ejecutar concurrentemente\r
\r
> L(S<sub>3</sub>)  E(S<sub>4</sub>) = \r
> E(S<sub>3</sub>)  L(S<sub>4</sub>) = {c}  \r
> E(S<sub>3</sub>)  E(S<sub>4</sub>) =          // NO se pueden ejecutar concurrentemente\r
`]},{title:"1 Introduccin",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit1/",pathLocale:"/es/",extraFields:[`---\r
title: 1 Introduccin\r
---\r
# Tema 1. Programacin concurrente\r
\r
En este primer tema vamos a conocer los conceptos bsicos relacionados con la programacin concurrente, as como la mayora de la terminologa que vamos a trabajar y utilizar durante todo el curso.\r
\r
En un mundo en el que cada vez los dispositivos electrnicos son cada vez ms potentes, y veloces, el software debe ser capaz de aprovechar las caractersticas que le ofrecen tanto el hardware como los sistemas operativos.\r
\r
Son muchas las tareas que requieren de un procesamiento rpido de cantidades ingentes de datos. Un par de ejemplos los tenemos en las aplicaciones \`Big Data\` e \`Inteligencia artificial\`. Estos dos campos son unos de los mximos exponentes en cuanto a programacin concurrente.\r
\r
::: details Qu es para ti concurrencia?\r
Vamos a discutirlo en clase.\r
Iremos desgranando y definiendo el concepto a lo largo del tema\r
:::\r
\r
## Objetivos\r
\r
Los objetivos que alcanzaremos tras esta unidad son:\r
\r
- Diferenciar entre programa y proceso\r
- Comprender qu es la concurrencia\r
- Conocer el concepto, diferencias y relacin existente entre las dos unidades bsicas de ejecucin: procesos e hilos.\r
- Tener nociones sobre programacin concurrente\r
- Entender el funcionamiento concurrente del SO y del hardware\r
`]},{title:"1.3 Procesos en el SO",headers:[{level:2,title:"1.3.1. El kernel del SO",slug:"_1-3-1-el-kernel-del-so",link:"#_1-3-1-el-kernel-del-so",children:[]},{level:2,title:"1.3.2. Control de procesos en GNU/Linux",slug:"_1-3-2-control-de-procesos-en-gnu-linux",link:"#_1-3-2-control-de-procesos-en-gnu-linux",children:[{level:3,title:"Comandos para saber el pid de los procesos",slug:"comandos-para-saber-el-pid-de-los-procesos",link:"#comandos-para-saber-el-pid-de-los-procesos",children:[]},{level:3,title:"Comandos para ver los procesos activos",slug:"comandos-para-ver-los-procesos-activos",link:"#comandos-para-ver-los-procesos-activos",children:[]},{level:3,title:"Control de procesos",slug:"control-de-procesos",link:"#control-de-procesos",children:[]}]},{level:2,title:"1.3.3. Estados de un proceso",slug:"_1-3-3-estados-de-un-proceso",link:"#_1-3-3-estados-de-un-proceso",children:[]},{level:2,title:"1.3.4 Planificacin de procesos",slug:"_1-3-4-planificacion-de-procesos",link:"#_1-3-4-planificacion-de-procesos",children:[]},{level:2,title:"1.3.5. Algoritmos de planificacin de procesos",slug:"_1-3-5-algoritmos-de-planificacion-de-procesos",link:"#_1-3-5-algoritmos-de-planificacion-de-procesos",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",link:"#fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",link:"#sjf-shortest-job-first",children:[]},{level:3,title:"Planificacin por prioridad",slug:"planificacion-por-prioridad",link:"#planificacion-por-prioridad",children:[]},{level:3,title:"Round Robin",slug:"round-robin",link:"#round-robin",children:[]},{level:3,title:"Procesos con operaciones de E/S o bloqueos",slug:"procesos-con-operaciones-de-e-s-o-bloqueos",link:"#procesos-con-operaciones-de-e-s-o-bloqueos",children:[]}]}],path:"/es/unit1/operatingsystem.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.3 Procesos en el SO\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.3. Procesos en el SO" />\r
\r
# 1.3. Procesos en el Sistema Operativo\r
\r
[[toc]]\r
\r
## 1.3.1. El kernel del SO\r
\r
El \`kernel o ncleo de un SO\` se encarga de la funcionalidad bsica del sistema, el responsable de la gestin de los recursos del ordenador, se accede al ncleo a travs de las llamadas al sistema, es la parte ms pequea del sistema en comparacin con la interfaz. El resto del sistema operativo se le denomina como programas del sistema.\r
\r
Todos los programas que se ejecutan en el ordenador se organizan como un conjunto de procesos. Es el sistema operativo el que decide parar la ejecucin , por ejemplo, porque lleva mucho tiempo en la CPu, y decide cul ser el siguiente proceso que pasar a ejecutarse.\r
\r
Cuando se suspende la ejecucin de un proceso, luego deber reiniciarse en el mismo estado en el que se encontraba antes de ser suspendido. Esto implica que debemos almacenar en algn sitio la informacin referente a ese proceso para poder luego restaurarla tal como estaba antes. Esta informacin se almacena en el \`PCB\` (Bloque de control de procesos).\r
\r
Estos \`cambios de contexto\`, que es como se conoce al reemplazo de un proceso por otro, son bastante costosos (en tiempo y recursos) por toda la informacin que hay que guardar. Ya veremos ms adelante que existe otra unidad de ejecucin, los \`hilos\`, que solucionan en parte este problema.\r
\r
![Process Control Block](./../../media/unit1/process_control_blocks.gif)\r
\r
## 1.3.2. Control de procesos en GNU/Linux\r
\r
Los sistemas Linux identifican a los procesos por su PID (Process ID) as como por su PPID (Parent PID). De esta forma, los procesos pueden clasificarse en:\r
\r
- Procesos padre: Son procesos que crean otros procesos durante su ejecucin\r
- Procesos hijos: son procesos creados por otros procesos\r
\r
Cuando se arranca el sistema, el kernel lanza el proceso **init** que es la madre de todos los dems procesos. Al ser el primero que se lanza es el nico que no tiene padre. El proceso init se encarga de gestionar todos los dems procesos que se van ejecutando en el SO.\r
\r
::: info proceso init\r
El proceso init tiene el pid 1 y, como ya hemos dicho no tiene padre.\r
\r
Este proceso se utiliza como padre "adoptivo" para todos aquellos procesos que se quedan hurfanos.\r
:::\r
\r
### Comandos para saber el pid de los procesos\r
\r
El comando \`pidof cmdname\` nos dice el nombre de todos los procesos asociados a ese comando. Es importante recordar que cada vez que ejecutamos un comando, se crea un nuevo proceso.\r
\r
Las variables $$ y $PPID nos indican el pid del proceso actual y su ppid respectivamente.\r
\r
\`\`\`bash\r
# pidof systemd\r
1\r
# pidof top\r
2060\r
# pidof httpd\r
2103 2102 2101 2100 2099 1076\r
# Process pid\r
echo $$\r
2109\r
# Process parent pid\r
echo $PPID\r
2106\r
\`\`\`\r
\r
### Comandos para ver los procesos activos\r
\r
El principal comando para conocer los procesos que se estn ejecutando en un equipo es el comando \`ps\`. Con este comando podemos ver parte de la informacin asociada a un proceso.\r
\r
El comando ps tiene mltiples opciones que nos permiten ver ms o menos informacin de los procesos, as como los procesos de nuestro usuario o del resto de usuarios, estadsticas sobre el uso de recursos de cada proceso, etc.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD\r
root         1     0  0   223   576   5 11:00 ?        00:00:00 /init\r
root         7     1  0   223    80   3 11:00 ?        00:00:00 /init\r
root         8     7  0   223    80   1 11:00 ?        00:00:00 /init\r
vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash\r
vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF\r
vicente@Desktop-Vicente:~$ ps -auxf\r
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r
root         1  0.0  0.0    892   576 ?        Sl   11:00   0:00 /init\r
root         7  0.0  0.0    892    80 ?        Ss   11:00   0:00 /init\r
root         8  0.0  0.0    892    80 ?        S    11:00   0:00  \\_ /init\r
vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash\r
vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf\r
\`\`\`\r
\r
::: info Useful ps examples for Linux process monitoring\r
[https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/](https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/)\r
:::\r
\r
El otro comando que nos permite ver la informacin, en este caso en tiempo real, de los procesos que se estn ejecutando en l mquina junto con los recursos que estn consumiendo, es el comando \`top\`.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00\r
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie\r
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r
MiB Mem :  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache\r
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem\r
\r
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r
    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init\r
    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init\r
    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init\r
    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash\r
   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top\r
\`\`\`\r
\r
::: info top examples in Linux\r
[https://www.tecmint.com/12-top-command-examples-in-linux/](https://www.tecmint.com/12-top-command-examples-in-linux/)\r
:::\r
\r
### Control de procesos\r
\r
Linux tiene varios comandos para controlar los procesos, entre los que cabe destacar el comando \`kill\`.\r
\r
La forma de controlar los procesos es envindoles seales. Hay multitud de seales que se pueden enviar a un proceso. Sin embargo, para responder a una seal, los procesos deben estar programados para gestionarlas.\r
\r
\`\`\`bash\r
# Get Firefox PID after it freezes\r
$ pidof firefox\r
2687\r
# Send the SIGKILL (9) signal to end the process immediately\r
$ kill 9 2687\r
\`\`\`\r
\r
::: info How to control Linux process Using kill, pkill and killall\r
[https://www.tecmint.com/how-to-kill-a-process-in-linux/](https://www.tecmint.com/how-to-kill-a-process-in-linux/)\r
:::\r
\r
Otra forma de influir en la ejecucin de los procesos es mediante la prioridad. En los sistemas Linux todos los procesos tienen una cierta prioridad. Esto influye a la hora de obtener tiempo de CPU por lo que podemos conseguir que un proceso se ejecute ms o menos rpido que los dems.\r
\r
Un usuario con privilegios de *root* puede modificar los valores de prioridad de los procesos. Este valor lo podemos ver en la columna NI (nice) del comando top. Este valor influye en la columna PR que indica la prioridad que le da el sistema a un proceso.\r
\r
El rango de asignacin de prioridad disponible es de -20 a 19 , siendo -20 la mayor prioridad y 19 la menor. Con el comando \`nice\` podemos asegurarnos que en momentos de usos elevados de CPU los procesos adecuados reciban el mayor % de la misma.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ nice\r
0\r
vicente@Desktop-Vicente:~$ nice -n 10 bash\r
vicente@Desktop-Vicente:~$ nice\r
10\r
vicente@Desktop-Vicente:~$\r
\`\`\`\r
\r
::: tip Control de procesos en Windows\r
En los sistemas operativos Windows, la mayora de estas acciones se pueden realizar desde el administrador de tareas, aunque tambin tenemos los comandos **tasklist** y **taskkill** para hacerlo desde consola\r
\r
*tasklist /svc /fi imagename eq svchost.exe*\r
Con esta instruccin sabremos que servicios se estn ejecutando bajo el proceso svchost.exe, es el nombre de proceso de host genrico para servicios que se ejecutan desde bibliotecas de vnculos dinmicos (DLL), hay tantos para evitar riesgos ya que si estuviera todo en uno, un posible fallo podra colapsar el sistema.\r
:::\r
\r
## 1.3.3. Estados de un proceso\r
\r
El siguiente diagrama muestra los tres posibles estados en los que se puede encontrar un proceso. Las lneas que conectan los estados representan las posibles transiciones que se pueden dar.\r
\r
En todo momento un procesos estar en una de los tres estados. Como ya hemos visto, en los sistemas monoprocesador, un nico proceso podr estar en estado de ejecucin en un momento dado. El resto de procesos estar o bien en espera o bien bloqueados.\r
\r
Para cada uno de los estados se gestiona una lista de procesos que administra el kernel del SO. Los procesos permanecern en la cola hasta que se produzca algn evento.\r
\r
![Estados de un proceso](./../../media/unit1/estados_proceso.png)\r
\r
- **Nuevo**. El fichero es creado a partir de un ejecutable.\r
- **Listo**. Est parado temporalmente y listo para ejecutarse cuando se le d la oportunidad. El sistema operativo todava no le asigno un procesador para ejecutarse. El planificador del S.O. ser el responsable de seleccionar el proceso para que pase a estado de ejecucin.\r
- **En ejecucin**. Est usando el procesador. El sistema operativo utiliza el mecanismo de interrupciones para controlar su ejecucin. Si el proceso necesitase un recurso, incluyendo la realizacin de operaciones de E/S, llamar a la llamada al sistema correspondiente. Si un proceso se ejecuta durante el mximo tiempo permitido por la poltica del sistema, salta un temporizador que lanza una interrupcin. Si el sistema es de tiempo compartido, lo para y lo pasa a estado de listo.\r
- **Bloqueado**. El proceso se encuentra bloqueado esperando a a que ocurra algn suceso. Por ejemplo puede estar esperando a que termine alguna operacin de E/S, o bien a sincronizarse con otro proceso. Cuando ocurre el evento que lo desbloquea, el proceso queda pendiente de ser planificado por el S.O. no pasa directamente a ejecucin.\r
- **Terminado**. El proceso termina y libera su imagen de memoria. Es el propio proceso el que debe llamar al sistema para indicar que ha terminado, aunque el sistema puede finalizarlo con una excepcin (que es una interrupcin especial).\r
\r
Transiciones entre estados:\r
\r
- **De ejecucin a bloqueado**: un proceso pasa de ejecucin a bloqueado cuando espera la ocurrencia de un evento externo.\r
- **De bloqueado a listo**: cuando ocurre el evento externo que esperaba\r
- **De listo a ejecucin**: cuando el sistema le otorga un tiempo de CPU.\r
- **De ejecucin a listo**: cuando se le acaba el tiempo asignado por el S.O.\r
\r
## 1.3.4 Planificacin de procesos\r
\r
Uno de los objetivos de los sistemas operativos es la multiprogramacin, es decir, admitir varios procesos en memoria para maximizar el uso del procesador. Esto funciona ya que los procesos se irn intercambiando el uso del procesador para su ejecucin de forma concurrente. Para ello, el sistema operativo organiza los procesos en varias colas pasndolos de unas colas a otras\r
\r
- Cola de procesos: contiene todos los procesos del sistema\r
- Cola de procesos preparados: todos los procesos listos esperando para ejecutarse.\r
- Varias colas de dispositivos: procesos que estn esperando alguna operacin de E/S.\r
\r
![Colas de procesos del planificador](./../../media/unit1/process_queues.gif)\r
\r
El planificador es el encargado de seleccionar los movimientos de los procesos entre las distintas colas. Existe una planificacin a corto plazo y otra a largo plazo, veamos cada una:\r
\r
- Corto plazo: selecciona los procesos de la cola de preparados para pasarlos a ejecucin, se invoca con mucha frecuencia, del orden de milisegundos, por lo que el algoritmo debe ser muy sencillo.\r
  - Planificacin sin desalojo: un proceso en ejecucin slo se saca si termina o bien se queda bloqueado.\r
  - Planificacin apropiativa: solo se saca un proceso de ejecucin si termina, se bloquea o por ltimo aparece un proceso con mayor prioridad.\r
  - Tiempo compartido: cada cierto tiempo (cuanto), se desaloja un proceso y se mete otro, Se considera que todos los procesos tienen la misma prioridad.\r
- Largo plazo: selecciona que procesos nuevos pasan a la cola de preparados. Hace un control del grado de multiprogramacin del proceso para tomar sus decisiones.\r
\r
::: warning Cambios de contexto\r
El cambio de contexto que se hace al cambiar un proceso es tiempo perdido, ya no se hace trabajo til. Cambiar el estado del proceso, el estado del procesador (cambio valores de registro) e informacin de la gestin de memoria, por muy rpido que se haga si se hace con mucha frecuencia puede provocar una ralentizacin del sistema, por eso tener muchos programas abiertos provoca una disminucin importante en el rendimiento del sistema.\r
:::\r
\r
## 1.3.5. Algoritmos de planificacin de procesos\r
\r
Los algoritmos de planificacin se utilizan para intentar mejorar el rendimiento del sistema y, por ende, la experiencia de usuario.\r
\r
Para establecer parmetros objetivos que permitan comparar los diferentes resultados, vamos a tomar como referencia los siguientes criterios:\r
\r
- **Tiempo de espera**: tiempo que un proceso permanece en la cola de preparados o de bloqueados esperando a ser ejecutado.\r
- **Tiempo de retorno**: tiempo transcurrido entre la llegada de un proceso y su finalizacin.\r
- **Uso de CPU**: % de tiempo que la CPU est siendo utilizada\r
  \r
> En un sistema con 1 unidad de proceso  \r
> ![Uso 1 CPU](./../../media/unit1/uso1cpu.gif)\r
<!--$\\frac{\\#\\ instantes\\ de\\ tiempo\\ que \\ el\\ procesador\\ esta\\ ocupado}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ultimo\\ proceso}$\\  \\ x \\ 100-->\r
> En un sistema con N unidades de proceso  \r
> ![Uso 2 CPU](./../../media/unit1/uso2cpu.gif)\r
<!--$\\frac{\\sum_{n=1}^{N}\\#\\ instantes\\ de\\ tiempo\\ que\\ el \\ procesador_n\\ esta\\ ocupado}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ultimo\\ proceso\\ *\\ N}$ x100-->\r
\r
- **Rendimiento/Productividad (throughput)**: nmero de procesos que se completan por unidad de tiempo\r
![Rendimiento](./../../media/unit1/rendimiento.gif)\r
<!-- $\\frac{nmero\\ de\\ procesos}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ltimo\\ proceso}$-->\r
\r
| Procesos | LLegada | Tiempo uso CPU | Prioridad |\r
| :------: | :-----: | :------------: | :-------: |\r
|    P1    |    0    |       10       |     5     |\r
|    P2    |    1    |       6        |    10     |\r
|    P3    |    2    |       3        |     7     |\r
\r
Con esta informacin, vamos a ver cmo se comportan los diferentes algoritmos\r
\r
### FCFS - First Come First Served\r
\r
En esta poltica de planificacin, el procesador ejecuta cada proceso hasta que termina o pasa al estado de bloqueado, por tanto, los procesos que estn en la cola de procesos preparados permanecern en el orden en que lleguen hasta que les toque su ejecucin. Este mtodo se conoce tambin como FIFO (Fist In, First Out).\r
\r
Se trata de una poltica muy simple y sencilla de llevar a la prctica, pero muy pobre en cuanto a su comportamiento.\r
\r
La cantidad de tiempo de espera de cada proceso depende del nmero de procesos que se encuentren en la cola en el momento de su peticin de ejecucin y del tiempo que cada uno de ellos tenga en uso al procesador, y es independiente de las necesidades del propio proceso.\r
\r
![FCFS monoprocessor](./../../media/unit1/fcfs-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 2     : active,t2, after t1, 6s\r
Process 3     : crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       9       |        15         |           |\r
|    P3    |      14       |        17         |           |\r
|          |\r
|  Medias  |      7,6      |        14         |   100%    |     0,15      |\r
\r
![FCFS dual processor](./../../media/unit1/fcfs-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### SJF - Shortest Job First\r
\r
Este algoritmo siempre prioriza los procesos ms cortos primero independientemente de su llegada y en caso de que los procesos sean iguales utilizara el mtodo FIFO anterior, es decir, el orden segn entrada. Este sistema tiene el riesgo de poner siempre al final de la cola los procesos ms largos por lo que nunca se ejecutarn, esto se conoce como \`inanicin\`.\r
\r
![SJF monoprocessor](./../../media/unit1/sjf-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title SJF (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |      12       |        18         |           |\r
|    P3    |       8       |        11         |           |\r
|          |\r
|  Medias  |      6,6      |        13         |   100%    |     0,15      |\r
\r
![SJF dual processor](./../../media/unit1/sjf-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### Planificacin por prioridad\r
\r
Cada proceso tiene una prioridad, ejecutndose primero el que tenga mayor prioridad, independientemente de su llegada y en caso de que las prioridades sean iguales utilizar el mtodo FIFO anterior, es decir, el orden segn entrada.\r
\r
Como ocurra con SJF, con este algoritmo son los procesos de prioridad ms baja los que tienen riesgo de\r
inanicin.\r
\r
![Prioridad monoprocessor](./../../media/unit1/prioridad-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |      12       |        18         |           |\r
|    P3    |       8       |        11         |           |\r
|          |\r
|  Medias  |      6,6      |        13         |   100%    |     0,15      |\r
\r
![Prioridad dual processor](./../../media/unit1/prioridad-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### Round Robin\r
\r
Este algoritmo de planificacin es uno de los ms complejos y difciles de implementar, asigna a cada proceso un tiempo equitativo tratando a todos los procesos por igual y con la misma prioridad.\r
\r
Este algoritmo es circular, volviendo siempre al primer proceso una vez terminado con el ltimo. Para controlar que todos los procesos tienen su tiempo de CPU este mtodo asigna a cada proceso un intervalo de tiempo llamado \`quantum\`.\r
\r
Se pueden dar dos casusticas con este mtodo :\r
\r
- El proceso, o lo que le queda por ejecutar, es menor que el quantum: Al terminar antes se planifica un nuevo proceso.\r
- El proceso, o lo que le queda por ejecutar, es mayor que el quantum: Al terminar el quantum se expulsa el proceso dando paso al siguiente proceso en la lista. Al terminar la iteracin se volver para terminar el primer proceso expulsado.\r
\r
![RR monoprocessor](./../../media/unit1/roundrobin-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 2s\r
Process 2     : active,t2, after t1, 2s\r
Process 3     : crit, t3, after t2, 2s\r
Process 1      :done, t4, after t3, 2s\r
Process 2     : active,t5, after t4, 2s\r
Process 3     : crit, t6, after t5, 1s\r
Process 1      :done, t7, after t6, 2s\r
Process 2     : active,t8, after t7, 2s\r
Process 1      :done, t9, after t8, 2s\r
Process 1      :done, t10, after t9, 2s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       9       |        19         |           |\r
|    P2    |       8       |        14         |           |\r
|    P3    |       6       |         9         |           |\r
|          |\r
|  Medias  |      7,6      |        14         |   100%    |     0,15      |\r
\r
![RR dual processor](./../../media/unit1/roundrobin-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1_1, 0, 2s\r
Process 3     :crit, t3_1, after t1_1, 2s\r
Process 1     :done, t1_2, after t3_1, 2s\r
Process 3     :crit, t3_2, after t1_2, 1s\r
Process 1     :done, t1_3, after t3_2, 2s\r
Process 1     :done, t1_4, after t1_3, 2s\r
Process 1     :done, t1_5, after t1_4, 2s\r
section Processor 2\r
.     :active, ., 0, 0s\r
Process 2     :active, t2_1, 1, 2s\r
Process 2     :active, t2_2, after t2_1, 2s\r
Process 2     :active, t2_3, after t2_2, 2s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       3       |        13         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       2       |         5         |           |\r
|          |\r
|  Medias  |      1,6      |       7,6         |    73%    |      0,23     |\r
\r
::: question Planificador combinado\r
En realidad, no se usa una nica estrategia de planificacin, sino que lo ms comn es que se combinen varias de ellas. De hecho en Round-Robin hemos usado tambin FCFS.\r
\r
Te atreves a ver cmo sera una planificacin Round-Robin con prioridad? Ten en cuenta que funcionar con el quantum y a la hora de escoger el siguiente proceso a ejecutar, se basar en la prioridad de los que haya en la lista.\r
:::\r
\r
### Procesos con operaciones de E/S o bloqueos\r
\r
En los ejemplos anteriores hemos visto que todos los procesos pasan su tiempo en el procesador, pero esto no es un reflejo de la realidad, ms bien al contrario. Los procesos en determinados momentos deben dejar el procesador para esperar una entrada de usuario, leer o almacenar informacin en disco, o simplemente esperar a que otro proceso termine una accin y le enve un dato que necesita para continuar.\r
\r
En esos instantes, el proceso deja el procesador libre para que otros puedan hacer uso de l. En el momento en que ha terminado su espera o bloqueo, se vuelve a poner en cola de preparado para seguir ejecutndose.\r
\r
En el siguiente grfico tenemos una especificacin de la actividad de 2 procesos en el que, antes de realizar el ltimo paso de ambos, debe haber acabado la operacin de E/S que realiza el proceso1.\r
\r
![Procesos con E/S](./../../media/unit1/operaciones_es.svg)\r
<!--\r
\`\`\`mermaid\r
graph LR\r
\r
subgraph Process 2\r
    p2_1["run for 2"]--p2_2["E/S for 3"]--p2_3["run for 4"]--p2_5["run for 3"]\r
end\r
subgraph Process 1\r
    p1_1["run for 3"]--p1_2["E/S for 1"]--p1_3["run for 5"]--p1_4["E/S for 2"]--p1_5["run for 4"]\r
    p1_4--p2_5\r
end\r
\`\`\`\r
-->\r
\r
Veamos cmo se materializa esto en una ejecucin de los procesos, suponiendo que ambos llegan a la vez a la cola.\r
\r
![RR dual processor](./../../media/unit1/roundrobin-3.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Task 1\r
P1 runs 2 (exits because of q expiration)      :done, t1_1, 0, 2s\r
P1 runs 1 (exits and has to wait 1 for E/S)      :done, t1_2, after t2_1, 1s\r
E/S :crit, es1_1, after t1_2, 1s\r
P1 runs 2 (exits because of q expiration)      :done, t1_3, after es1_1, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_4, after t2_2, 2s\r
P1 runs 2 (exits and has to wait 1 for E/S)      :done, t1_5, after t2_3, 1s\r
E/S :crit, es1_2, after t1_5, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_6, after es1_2, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_7, after t2_4, 2s\r
\r
section Task 2 \r
P2 runs 2 (exits and has to wait 3 for E/S) :active, t2_1, after t1_1, 2s\r
E/S :crit, es2_1, after t2_1, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_2, after t1_3, 2s\r
P2 runs 2 (exits because of q expiration)      :active, t2_3, after t1_4, 2s\r
Locked waiting :crit, es2_2, after t2_3, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_4, after t1_6, 2s\r
P2 runs 2 (ends execution)      :active, t2_5, after t1_7, 1s\r
'''\r
-->\r
`]},{title:"1.1 Procesos, programas, hilos",headers:[{level:2,title:"1.1.1. Procesos y programas",slug:"_1-1-1-procesos-y-programas",link:"#_1-1-1-procesos-y-programas",children:[]},{level:2,title:"1.1.2. Programacin concurrente",slug:"_1-1-2-programacion-concurrente",link:"#_1-1-2-programacion-concurrente",children:[{level:3,title:"Para qu?",slug:"para-que",link:"#para-que",children:[]},{level:3,title:"Comunicacin y sincronizacin entre procesos",slug:"comunicacion-y-sincronizacion-entre-procesos",link:"#comunicacion-y-sincronizacion-entre-procesos",children:[]}]},{level:2,title:"1.1.3. Servicios e hilos",slug:"_1-1-3-servicios-e-hilos",link:"#_1-1-3-servicios-e-hilos",children:[{level:3,title:"Programa secuencial (Arquitectura Von Neumann)",slug:"programa-secuencial-arquitectura-von-neumann",link:"#programa-secuencial-arquitectura-von-neumann",children:[]},{level:3,title:"Programa concurrente",slug:"programa-concurrente",link:"#programa-concurrente",children:[]},{level:3,title:"Hilos vs procesos",slug:"hilos-vs-procesos",link:"#hilos-vs-procesos",children:[]}]}],path:"/es/unit1/process.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.1 Procesos, programas, hilos\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.1. Procesos, programas, hilos" />\r
\r
# 1.1. Procesos, Programas, hilos\r
\r
[[toc]]\r
\r
## 1.1.1. Procesos y programas\r
\r
Un \`programa\` no es ms que un conjunto de instrucciones u rdenes que le indican a un dispositivo qu acciones debe realizar con los datos recibidos.\r
\r
::: tip Caja negra\r
Segn la visin de un sistema como caja negra, un programa le indica al sistema cmo obtener unos datos de salida a partir de unos datos de entrada.\r
:::\r
\r
Sin embargo, un \`proceso\` es un programa en ejecucin. Esto es, un proceso es una entidad activa y un programa es una entidad pasiva.\r
\r
El proceso, por tanto, est representado por el contador del programa, el valor de los registros, la pila, el *cdigo ejecutable*, su estado, ... todo lo necesario para la ejecucin del programa por parte del SO.\r
\r
![Proceso en memoria](./../../media/unit1/proceso_memoria.png)\r
\r
Cada proceso es una entidad independiente. Cuando un programa se ejecuta, el sistema operativo crea un proceso. Si ese mismo programa se vuelve a ejecutar, se creara un proceso distinto, teniendo en memoria dos instancias del mismo programa. Pero es importante recalcar que los dos procesos son independientes.\r
\r
## 1.1.2. Programacin concurrente\r
\r
Podemos decir que dos procesos son concurrentes cuando la primera instruccin de uno de los procesos se ejecuta despus de la primera y antes de la ltima de otro proceso.\r
\r
La planificacin alternando los instantes de ejecucin, \`multitarea\`, hace que los procesos se ejecuten de forma concurrente. Tambin la disponibilidad de varias unidades de proceso, \`multiproceso\`, permite la ejecucin simultnea o paralela de procesos en el sistema.\r
\r
![Concurrencia vs paralelismo](./../../media/unit1/concurrencia_vs_paralelismo.jpg)\r
\r
::: tip Concurrencia\r
A los dos escenarios descritos anteriormente es a lo que vamos a denominar, de forma general, **concurrencia**.\r
:::\r
\r
### Para qu?\r
\r
Las principales razones por las que se utiliza una estructura concurrente son:\r
\r
- Optimizar la utilizacin de los recursos: Podremos simultanear las operaciones de E/S en los procesos. La CPU estar menos tiempo ociosa.\r
- Proporcionar interactividad a los usuarios (y animacin grfica).\r
- Mejorar la disponibilidad: Servidor que no realice tareas de forma concurrente, no podr atender peticiones de clientes simultneamente.\r
- Conseguir un diseo conceptualmente ms comprensible y mantenible: El diseo concurrente de un programa nos llevar a una mayor modularidad y claridad.\r
- Aumentar la proteccin: Tener cada tarea aislada en un proceso permitir depurar la seguridad de cada proceso y poder finalizarlo en caso de mal funcionamiento sin que suponga la cada del sistema.\r
\r
Adems, los actuales avances tecnolgicos hacen necesario tener en cuenta la concurrencia en el diseo de las aplicaciones para aprovechar su potencial. Los nuevos entornos hardware son:\r
\r
- Microprocesadores con mltiples ncleos que comparten la memoria principal del sistema.\r
- Entornos multiprocesador con memoria compartida.\r
- Entornos distribuidos y servicios cloud.\r
\r
### Comunicacin y sincronizacin entre procesos\r
\r
Cuando varios procesos se ejecutan concurrentemente puede haber procesos que colaboren para un determinado fin mientras que puede haber otros que compitan por los recursos del sistema.\r
\r
En ambos casos se hace necesaria la introduccin de mecanismos de comunicacin y sincronizacin entre procesos.\r
\r
:::info Programacin concurrente\r
Precisamente del estudio de esos **mecanismos de sincronizacin y comunicacin** trata la programacin concurrente y este mdulo de PSP.\r
:::\r
\r
Si pensamos en la forma en la que un proceso puede comunicarse con otro, se nos plantean estas dos:\r
\r
- Intercambio de mensajes: Es la forma que se utiliza habitualmente cuando los procesos se encuentran en mquinas diferentes. Los procesos intercambian informacin siguiendo un protocolo previamente establecido.\r
- Recursos (o memoria) compartidos: Slo se puede utilizar cuando los dos procesos se encuentran en la misma mquina y permite la sincronizacin de los procesos en funcin del valor o estado de un recurso compartido.\r
\r
Tambin podemos ver el tipo de comunicacin en funcin de la sincrona que mantengan los procesos durante la comunicacin:\r
\r
- Sncrona: El emisor queda bloqueado hasta que el receptor recibe el mensaje. Ambos\r
se sincronizan en el momento de la recepcin del mensaje.\r
- Asncrona: El emisor contina con su ejecucin inmediatamente despus de emitir el\r
mensaje, sin quedar bloqueado.\r
\r
## 1.1.3. Servicios e hilos\r
\r
Un programa, como ya hemos dicho, se compone de un conjunto de sentencias (operaciones y verificaciones) y un flujo de ejecucin. La lnea de flujo de control establece, de acuerdo con la estructura del propio programa y de los datos que maneja, el orden en que deben ejecutarse las sentencias.\r
\r
Atendiendo al nmero de lneas de flujo de control que tiene un programa, los procesos pueden ser:\r
\r
- Secuenciales: Poseen un nico flujo de control (monohilo)\r
- Concurrentes: Poseen varios hilos de ejecucin (multihilo).\r
\r
### Programa secuencial (Arquitectura Von Neumann)\r
\r
Cuando empezamos a programar, usamos el estilo de programacin clsico, en el que se sigue el modelo conceptual de Von Neumann\r
\r
Los programas secuenciales presentan una lnea simple de control de flujo. Las operaciones de este tipo de programas estn estrictamente ordenados como una secuencia temporal lineal.\r
\r
El comportamiento del programa es solo funcin de la naturaleza de las operaciones individuales que constituye el programa y del orden en que se ejecutan (determinado por el conjunto de entradas que recibe).\r
\r
En los programas secuenciales, el tiempo que tarda cada operacin en ejecutarse no tiene consecuencias sobre el resultado.\r
\r
![Sequential flowchart example](./../../media/unit1/sequential_flowchart.png)\r
\r
La comprobacin del correcto funcionamiento (\`verificacin\` o \`depuracin\`) de un programa secuencial es sencilla:\r
\r
- Cada sentencia produce la respuesta correcta.\r
- Las sentencias se ejecutan en el orden esperado.\r
\r
De aqu surgen algunos de los mtodos bsicos de pruebas de sistemas, como el de *caja blanca*.\r
\r
### Programa concurrente\r
\r
En los programas concurrentes existen mltiples lneas de control de flujo. Las sentencias que constituyen el programa no se ejecutan siguiendo un orden que corresponda a una secuencia temporal lineal.\r
\r
En los programas concurrentes el concepto de secuencialidad entre sentencias continua siendo muy importante. Sin embargo en los programas concurrentes es de orden parcial, mientras que, tal y como hemos comentado anteriormente, en los programas secuenciales era de orden estricto.\r
\r
![Concurrent flowchat example](./../../media/unit1/concurrent_flowchart.png)\r
\r
En los programas concurrentes la *secuencializacin* entre procesos concurrentes se llama **sincronizacin**.\r
\r
Este orden parcial implica que los programas concurrentes no tienen porqu ser deterministas, es decir, que ante el mismo conjunto de datos de entrada no siempre se va a obtener el mismo resultado.\r
\r
::: danger Indeterminismo\r
Que existan diferentes salidas para el mismo conjunto de datos de entrada no significa necesariamente que un programa concurrente sea incorrecto.\r
:::\r
\r
Si observamos el siguiente ejemplo de pseudocdigo\r
\r
\`\`\`java {16-17,25-28}\r
public class TestClass {\r
    int x;\r
\r
    public void testMethod1() {\r
        for (int i=1; i <= 5; i++) {\r
            x++;\r
        }\r
    }\r
    public void testMethod2() {\r
        for (int j=1; j <= 5; j++) {\r
            x++;\r
        }\r
    }\r
    public void sequential() {\r
        x = 0;\r
        testMethod1();\r
        testMethod2();\r
        System.out.println(x);\r
    }\r
    public void parallel() {\r
        x = 0;\r
        // cobegin-coend means that both methods are run simultaneously\r
        // These sentences doesn't exist in Java. They are used for \r
        // sample purposes\r
        cobegin\r
            testMethod1();\r
            testMethod2();\r
        coend\r
        System.out.println(x);\r
    }\r
}\r
\`\`\`\r
\r
::: question\r
Qu valor tendr x tras ejecutar el mtodo sequential?\r
\r
Qu valor tendr x tras ejecutar el mtodo parallel?\r
:::\r
\r
::: info Resea histrica\r
La naturaleza y los modelos de interaccin entre procesos de un programa concurrente fueron estudiados y descritos por **Dijkstra** (1968), Brinch **Hansen** (1973) y **Hoare** (1974).\r
\r
Estos trabajos constituyeron los principios en que se basaron los sistemas operativos multiproceso de la dcada de los 70 y 80.\r
:::\r
\r
El indeterminismo inherente a los programas concurrentes hace que su anlisis y validacin sea ms complejo. No obstante, para la comprobacin del correcto funcionamiento (\`verificacin\` o \`depuracin\`) de un programa concurrente se requiere comprobar los mismos aspectos que en los programas secuenciales, pero con los siguientes nuevos aspectos:\r
\r
- Las sentencias se pueden validar individualmente solo si no estn acopladas por variables compartidas.\r
- Cuando existen variables compartidas, los efectos de interferencia entre las sentencias concurrentes pueden ser muy variados y la validacin es muy difcil. <Badge type="danger" text="cuidado" vertical="middle" />\r
- Siempre que la secuencialidad entre tareas se lleve a cabo por sentencias explcitas de **sincronizacin**, el tiempo es un elemento que no influye sobre el resultado\r
\r
::: warning Importante\r
Estos tres aspectos que se acaban de describir forman la base de toda la programacin concurrente.\r
\r
:eye: Conocerlos, entenderlos y saber aplicarlos es a lo que dedicaremos una parte importante de este curso.\r
:::\r
\r
### Hilos vs procesos\r
\r
Un hilo no es ms que cada una de esas lneas de flujo que puede tener un proceso ejecutndose de forma concurrente. Un procesos es una unidad pesada de ejecucin.\r
\r
As, un proceso estar formado por, al menos, un hilo de ejecucin, el hilo principal. Si el proceso tiene varios hilos, cada uno es una unidad de ejecucin ligera.\r
\r
| Procesos                         | Hilos                                               |\r
| :------------------------------- | :-------------------------------------------------- |\r
| Constan de uno o ms hilos       | Un hilo siempre existe dentro de un proceso         |\r
| Son independientes unos de otros | Comparten los recursos del proceso de forma directa |\r
| Son gestionados por el SO        | Son gestionados por el proceso                      |\r
| Se comunican a travs del SO     | La comunicacin la controla el proceso              |\r
\r
![Threads vs Processes](./../../media/unit1/threads_vs_process.jpg)\r
\r
En la imagen anterior se puede observar la relacin existente entre la creacin de un thread y la de su proceso asociado.\r
\r
- El proceso define un espacio de memoria en el que reside. Los hilos comparten ese espacio de memoria. Dentro de ese espacio de memoria cada hilo tiene su espacio reservado, pero todos pueden compartir la memoria global del proceso y los recursos (ficheros, sockets, etc.) que el proceso tenga abiertos.\r
- Como ya hemos visto, cada proceso tiene su PCB con informacin relativa al proceso.\r
- Los hilos, de forma similar, tienen su TCB (Thread Control Block) en el que guardan la informacin especfica de cada hilo (Contador de programa, puntero a la pila, estado del thread, registros y un puntero al PCB).\r
\r
::: info Servicios\r
Un servicio es un proceso que, normalmente, es cargado durante el arranque del sistema operativo. Al no necesitar interaccin con el usuario, los servicios suelen ejecutarse en forma de **demonios*, quedan su ejecucin en *segundo plano*.\r
\r
Recibe el nombre de servicio ya que es un proceso que queda a la espera de que otro le pida que realice una tarea. Como deben atender las solicitudes de varios procesos, los servicios suelen ser programas multihilo.\r
:::\r
`]},{title:"2.4 Anexo I - Propiedades del sistema y programacin en consola",headers:[{level:2,title:"I.1 Propiedades del sistema y comandos del sistema",slug:"i-1-propiedades-del-sistema-y-comandos-del-sistema",link:"#i-1-propiedades-del-sistema-y-comandos-del-sistema",children:[]},{level:2,title:"I.2 Formato de salida por consola",slug:"i-2-formato-de-salida-por-consola",link:"#i-2-formato-de-salida-por-consola",children:[]},{level:2,title:"I.2 Console I/O format",slug:"i-2-console-i-o-format",link:"#i-2-console-i-o-format",children:[{level:3,title:"Salida por consola",slug:"salida-por-consola",link:"#salida-por-consola",children:[]},{level:3,title:"Entrada por consola",slug:"entrada-por-consola",link:"#entrada-por-consola",children:[]},{level:3,title:"Formato de cadena",slug:"formato-de-cadena",link:"#formato-de-cadena",children:[]},{level:3,title:"Formato numrico",slug:"formato-numerico",link:"#formato-numerico",children:[]},{level:3,title:"Uso de colores en la salida por consola",slug:"uso-de-colores-en-la-salida-por-consola",link:"#uso-de-colores-en-la-salida-por-consola",children:[]}]}],path:"/es/unit2/console_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.4 Anexo I - Propiedades del sistema y programacin en consola\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.4 Anexo I - Propiedades del sistema y programacin en consola" />\r
\r
# 2.4 Anexo I - Propiedades del sistema y programacin en consola\r
\r
[[toc]]\r
\r
## I.1 Propiedades del sistema y comandos del sistema\r
\r
Si tenemos pensado desarrollar aplicaciones que funcionen en diferentes SO tendremos que enfrentarnos a la problemtica del funcionamiento diferente de los distintos SO.\r
\r
Vamos a ver algunos ejemplos que pueden servir como gua para otros problemas similares a los expuestos.\r
\r
::: danger File separator\r
Para indicar las rutas en un sistema los sistemas UNIX emplean el carcter  **/** como separador mientras que los sistemas Windows usan el carcter **\\\\** . En resumen, / en *X y \\ en Windows.\r
\r
Cmo podemos hacer entonces que nuestras aplicaciones sean independientes del SO en el que se ejecutan?\r
\r
Para este tipo de cuestiones vamos a utilizar de forma recurrente las propiedades del sistema mediante \`System.getProperty(String propName)\`. Estas propiedades se configuran con el propio sistema operativo, aunque las podemos modificar usando los parmetros de ejecucin de la mquina virtual\r
\r
> String separator = System.getProperty("file.separator");\r
\r
o\r
\r
> -Dfile.separator\r
\r
Aunque siempre es una buena prctica usar el carcter **/** en las rutas ya que Java es capaz de convertirlas al sistema en el que se ejecuta.\r
:::\r
\r
Si lo que queremos es ejecutar un comando del SO, tenemos que hacerlo, al igual que si lo hacemos manualmente, a travs del shell del sistema, donde volvemos a encontrar la dicotoma entre sistemas UNIX y sistemas Windows.\r
\r
Vamos a ver el cdigo que, a travs de las propiedades del sistema, nos permite obtener un listado de los archivos existentes en la carpeta personal del usuario.\r
\r
\`\`\`java\r
// Primero obtenemos la carpeta del usuario\r
String homeDirectory = System.getProperty("user.home");\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info Modo shell no interactivo\r
Como se puede observar, tanto para Windows como UNIX se ha usado el modificador **c** del comando. Este modificador indica que se abra un shell, se ejecute el comando recibido y se cierre el proceso del shell.\r
:::\r
\r
A continuacin podemos ver un ejemplo de respuesta ante la pulsacin de un botn, en una app grfica, para abrir una pgina en el navegador. Tenemos cmo se hara en sistemas *X y comentado una de las formas de hacerlo en Windows.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Vamos a crear nuestro primer programa en Java, que no va a ser tan sencillo como pueda parecer\r
\r
Usando mtodos de las clases System y Runtime hacer un programa que muestre\r
\r
- todas las propiedades establecidas en el sistema operativo y sus valores.\r
- memoria total, memoria libre, memoria en uso y los procesadores disponibles\r
\r
Mira los mtodos que proporcionan las clases Runtime y System. Intenta obtener una lista u otra estructura de datos que te permita recorrer las propiedades para ir mostrando sus nombres y valores.\r
:::\r
\r
::: details Solucin propuesta para la actividad anterior\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
## I.2 Formato de salida por consola\r
\r
## I.2 Console I/O format\r
\r
::: warning Codificacin de caracteres\r
One aspect to take into account when working with streams is the encoding of the information exchanged between processes, which depends on the operating system we are working on. Most systems (GNU/Linux, Mac OS, Android, iOS...) use UTF-8 encoding, based on the Unicode standard. \r
\r
For its part, MS Windows uses its own formats, incompatible with the rest, such as Windows-1252. So to correctly handle data in Java when using more advanced inter-process communication mechanisms, it will be necessary to take into account the type of encoding that the system itself uses.\r
\r
Un aspecto a tener en cuenta cuando trabajamos con flujos es la codificacin de la informacin intercambiada entre procesos, que depende del sistema operativo en el que estemos trabajando. La mayora de los sistemas (GNU/Linux, Mac OS, Android, iOS...) utilizan la codificacin UTF-8, basada en el estndar Unicode.\r
\r
Por su parte, MS Windows utiliza sus propios formatos, incompatibles con el resto, como Windows-1252. Por lo que para manejar correctamente los datos en Java al usar mecanismos de comunicacin entre procesos ms avanzados, ser necesario tener en cuenta el tipo de codificacin que utiliza el propio sistema.\r
\r
\`\`\`java\r
// Getting the default encoding\r
System.out.println(System.getProperty("file.encoding"));\r
// Setting the encoding\r
System.setProperty("file.encoding", "UTF-8");\r
\r
// Reading with a specific encoding\r
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));\r
// Writing with a specific encoding\r
PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out, "UTF-8"));\r
\r
// Stdin with a specific encoding\r
Scanner scanner = new Scanner(System.in, "UTF-8");\r
// Stdout with a specific encoding\r
System.out.println(new String("Hello, World!".getBytes("UTF-8")));\r
\`\`\`\r
\r
:::\r
\r
### Salida por consola\r
\r
En Java, podemos usar el objeto \`System.out\` para imprimir en la consola. Podemos usar el mtodo \`println\` para imprimir una lnea en la consola.\r
\r
\`\`\`java:no-line-numbers\r
System.out.println("Hola, Mundo!");\r
\`\`\`\r
\r
### Entrada por consola\r
\r
En Java, podemos usar el objeto \`System.in\` para leer de la consola. Podemos usar la clase \`Scanner\` para leer de la consola.\r
\r
\`\`\`java:no-line-numbers\r
Scanner scanner = new Scanner(System.in);\r
String nombre = scanner.nextLine();\r
\`\`\`\r
\r
### Formato de cadena\r
\r
En Java, podemos usar la clase \`String\` para formatear la salida. Podemos usar el mtodo \`format\` para formatear la salida. Este mtodo es similar al mtodo \`printf\` en C.\r
\r
\`\`\`java:no-line-numbers\r
String.format("El valor de PI es %.2f", Math.PI);\r
\`\`\`\r
\r
### Formato numrico\r
\r
Todos los lenguajes de programacin tienen varias formas de mostrar la informacin al usuario. Cuando se trata de mostrar informacin a a travs de la consola, tenemos un par de alternativas para formatear la informacin numrica.\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Si usamos la clase NumberFormat o cualquiera de sus descendientes podemos controlar con bastante precisin cmo se vern los nmeros, usando patrones.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Si usamos hashes en vez de ceros permitimos que .30 se vea como 0.3\r
// (los dgitos adicionales son opcionales)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Heredado de la sintaxis de la funcin printf de C, podemos utilizar la sintaxis de java.util.Formatter para configurar cmo ser visualizada la informacin.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// % rellena con hasta 10 posiciones los nmeros\r
// para justificarlos a la derecha.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
### Uso de colores en la salida por consola\r
\r
Hay una forma sencilla de mostrar informacin por consola usando diferentes colores. Os dejo un ejemplo de cdigo con la definicin de algunos colores y la forma de usarlos.\r
\r
\`\`\`java:no-line-numbers\r
public class UsarColoresEnConsola {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hola" \r
                            + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Adis" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
`]},{title:"2.5 Anexo II - Curl",headers:[{level:2,title:"I.1 Cmo obtener curl",slug:"i-1-como-obtener-curl",link:"#i-1-como-obtener-curl",children:[]},{level:2,title:"II2 Realizando una peticin GET",slug:"ii2-realizando-una-peticion-get",link:"#ii2-realizando-una-peticion-get",children:[]},{level:2,title:"II.2 Puntos finales y rutas",slug:"ii-2-puntos-finales-y-rutas",link:"#ii-2-puntos-finales-y-rutas",children:[]},{level:2,title:"II.3 Mtodos HTTP y cabeceras",slug:"ii-3-metodos-http-y-cabeceras",link:"#ii-3-metodos-http-y-cabeceras",children:[]},{level:2,title:"II.4 Authentication",slug:"ii-4-authentication",link:"#ii-4-authentication",children:[]},{level:2,title:"II.5 References",slug:"ii-5-references",link:"#ii-5-references",children:[]}],path:"/es/unit2/curl_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.5 Anexo II - Curl\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.5 Anexo II - Curl" />\r
\r
# 2.5 Anexo II - Curl\r
\r
 Curl est diseado para funcionar como una forma de verificar la conectividad a las URL y como una gran herramienta para transferir datos. Tiene especial relevancia e inters cunado se trata de usar servicios basados en API REST, tanto para comprobar su funcionamiento durante la fase de pruebas o bien para cuando el sistema ya est en produccin.\r
\r
Curl es una herramienta de lnea de comandos que nos permite hacer peticiones HTTP desde la consola. Su principal uso es obtener una respuesta de un sitio web (pro ejemplo, para saber que no est cado) o para comprobar tiempos de respuesta.\r
\r
::: info curl means ...\r
La herramienta fu pensada para subir y descargar informacin usando una URL. Es una aplicacin cliente (de ah la 'c'), y a su vez es un cliente de URLs. Por lo tanto, 'c' de cliente y URL: cURL.\r
\r
En ingls "curl" se pronuncia con un sonido inicial /k/, rimando con la pronunciacin de la palabra girl.\r
\r
Por el contrario, si lo deletreamos como c-URL, entonces us significado tambin adquiere un sentido lgico, ver-URL (see-URL), lo cual tambin es una buena definicin de la utilidad de esta herramienta.\r
:::\r
\r
Curl funciona con protocolos que permiten la transferencia de datos en una o dos direcciones. Soporta protocolos basados en una "URI" y que estn descritos en una RFC, por lo que curl funciona principalmente con URLs (URIs en realidad) como el origen y/o destino de las transferencias e intercambios de informacin que realiza.\r
\r
Actualmente curl ofrece soporte para los siguiente protocolos:\r
\r
>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP.\r
\r
## I.1 Cmo obtener curl\r
\r
curl es una utilidad libre, abierta y disponible en varios formatos. Podemos descargarla y configurarla en la mayora de los sistemas operativos y arquitecturas hardware. Algunos SO ya la incluyen en sus distribuciones.\r
\r
La fuente principal de informacin y descarga siempre debera ser el [sitio oficial de CURL](http://curl.se) donde podemos descargar, entre otros, los instaladores para nuestros sistemas.\r
\r
- Linux (Ubuntu / Debian). curl viene instalado por defecto. De todas formas, podemos actualizarlo e instalarlo usando el gesto de paquetes APT\r
  > apt install curl\r
- Windows 10 viene con la herramienta curl instalada en sus sistemas desde la versin 1804\r
    > podemos descargar e instalar la ltima versin oficial de curl para windows desde [curl windows binaries](http://curl.se/windows)\r
- MacOS tambin trae de serie la herramienta curl desde hace ya bastantes aos. Si necesitamos actualizar la versin que tenemos en el sistema, se recomienda instalar homebrew (un gesto de paquetes para macOS)\r
    > brew install curl\r
\r
## II2 Realizando una peticin GET\r
\r
La sintaxis bsica de Curl se ve as:\r
\r
curl [OPTIONS] [URL]\r
El uso ms simple de Curl es mostrar el contenido de una pgina. El siguiente comando mostrar la pgina de inicio de testdomain.com.\r
\r
> curl testdomain.com\r
\r
Esto generar el cdigo fuente completo de la pgina de inicio del dominio. Si no se especifica ningn protocolo, curl lo interpretar a HTTP.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl http://www.net.net\r
<head><title>Document Moved</title></head>\r
<body><h1>Object Moved</h1>This document may be found <a HREF="http://net.net">here</a></body>\r
\r
\`\`\`\r
\r
Si no se indica lo contrario, curl realiza una solicitud HTTP con el mtodo GET a la URL indicada. La salida del programa para el comando enviado ser el cuerpo de la respuesta HTTP, en el caos anterior, el cdigo HTML de la URL solicitada.\r
\r
Si en vez de mostrar la salida recibida por pantalla nos interesa guardar la informacin en un archivo, podemos usar el parmetro \`-o (--output)\`:\r
\r
> curl -o output.html www.net.net\r
>\r
> // Es equivalente a hacer esto en el SO\r
>\r
> curl www.net.net > output.html\r
\r
Como hemos visto en la sintaxis, por norma general la URL debe ponerse al final del comando. Opcionalmente podemos especificar la URL en cualquier lugar del comando si usamos el modificador \`-s (--silent)\`, pudiendo as alterar el orden de los argumentos de curl.\r
\r
curl -s http://www.net.net -o output.html\r
\r
En los ejemplos anteriores, el resultado que estamos obteniendo no es el deseado ya que el recurso se ha cambiado de ubicacin o bien el sitio nos est redirigiendo a otra URI. Si usamos el parmetro \`-L (--location)\`  podemos hacer que curl siga las redirecciones y obtenga el contenido final que buscamos.\r
\r
\`\`\`bash:no-line-numbers{1,3,5}\r
$> curl http://www.dataden.tech\r
Redirecting\r
$> curl -L http://www.dataden.tech\r
<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.dataden.tech/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTYzMzM4OTE3OSwiaWF0IjoxNjMzMzgxOTc5LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIycWxmMGdkZmg2YWlzaHMxdjgwdWx0aTQiLCJuYmYiOjE2MzMzODE5NzksInRzIjoxNjMzMzgxOTc5NzgzNzQ1fQ.y5LwDoSoZCpe2tzro_FbX7cSGIw4nx1XweNBqjpLXoo&sid=da601018-2557-11ec-a001-58f389072b17');<\/script></body></html>\r
$> curl -L http://www.net.net\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        <body>\r
                <!-- Begin: Google Analytics -->\r
                <script>\r
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r
                  ga('create', 'UA-32196-28', 'auto');\r
                  ga('send', 'pageview');\r
                <\/script>\r
                <!-- End: Google Analytics -->\r
                <center>\r
                        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\r
                        <font face="impact, Arial, Helvetica, sans-serif" size="14">\r
                                NET.NET\r
                        </font>\r
                        <br /><br /><br /><br />\r
                        <font face="Arial, Helvetica, sans-serif" size="1">\r
                                <a href="http://who.godaddy.com/whoischeck.aspx?domain=NET.NET" target="_blank">NET.NET</a> is the first and the best domain name on the Internet!\r
                                <br />\r
                                Coming Soon...\r
                        </font>\r
                </center>\r
        </body>\r
</html>\r
\`\`\`\r
\r
De momento slo hemos obtenido el HTML del recurso solicitado. Si queremos ver las cabeceras HTTP de nuestra solicitud y de la respuesta recibida podemos usar el parmetro \`-v (--verbose)\` que mostrar toda la informacin que intercambia el protocolo HTTP..\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl -v  http://www.net.net\r
*   Trying 34.250.90.28:80...\r
* TCP_NODELAY set\r
* Connected to net.net (34.250.90.28) port 80 (#0)\r
> GET / HTTP/1.1\r
> Host: net.net\r
> User-Agent: curl/7.68.0\r
> Accept: */*\r
>\r
* Mark bundle as not supporting multiuse\r
< HTTP/1.1 200 OK\r
< Cache-Control: private\r
< Content-Type: text/html\r
< Server: Microsoft-IIS/10.0\r
< Set-Cookie: ASPSESSIONIDASRSRRAR=IMFFLMBBBIFJNLNDHLOACDAI; path=/\r
< X-Powered-By: ASP.NET\r
< Date: Mon, 04 Oct 2021 21:40:49 GMT\r
< Content-Length: 1080\r
<\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        ...\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver las cabeceras de nuestra solicitud (REQUEST) precedidas del caracter \`>\` mientras que las cabeceras de la respuesta (RESPONSE) se muestran precedidas dek caracter \`<\`.\r
\r
::: info formato corto y largo de los parmetros\r
Como ya hemos visto, los parmetros sirven para modificar el comportamiento por defecto de curl en funcin de las necesidades.\r
\r
Los parmetros de una sola letra son rpidos de usar y recordar, pero tenemos un nmero limitado de parmetros de este tipo por lo que no podemos tener uno para cada opcin.\r
Los parmetros que usan palabras estn para solucionar la falta de opciones con formato corto. Por otro lado, su uso hace que los comandos sean ms legibles, por este motivo la mayora de parmetros cortos tienen su equivalente largo.\r
\r
En el formato corto, los parmetros estn formados por un guin seguido de la letra correspondiente a la opcin. Se puede usar un guin para cada opcin, o incluir varias opciones detrs de un nico guin.\r
\r
> $> curl -v -L http://example.com\r
> $> curl -vL http://example.com\r
\r
En el formato largo, los parmetros se preceden de dos guiones y la palabra o palabras que forman la opcin. Tras cada doble guin slo se puede indicar una opcin.\r
\r
> $> curl --verbose --location http://example.com\r
\r
:::\r
\r
Por ltimo, aunque ya hemos visto como obtener la informacin de las cabeceras, podemos visualizar la informacin de la respuesta de forma completa usando la opcin \`-i (--include)\` or obtener slo las cabeceras de la respuesta con el uso de la opcin \`-I (--head)\`. Esto slo afecta al informacin de la respuesta (HTTP RESPONSE) y en el primer caso veremos  la respuesta completa (headers & data) o slo los headers con la segunda opcin.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$>  curl -I https://jsonplaceholder.typicode.com/todos/1\r
HTTP/2 200\r
date: Mon, 04 Oct 2021 21:57:55 GMT\r
content-type: application/json; charset=utf-8\r
content-length: 83\r
x-powered-by: Express\r
x-ratelimit-limit: 1000\r
x-ratelimit-remaining: 999\r
x-ratelimit-reset: 1631546224\r
vary: Origin, Accept-Encoding\r
access-control-allow-credentials: true\r
cache-control: max-age=43200\r
pragma: no-cache\r
expires: -1\r
x-content-type-options: nosniff\r
etag: W/"53-hfEnumeNh6YirfjyjaujcOPPT+s"\r
via: 1.1 vegur\r
cf-cache-status: HIT\r
age: 10926\r
accept-ranges: bytes\r
expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"\r
report-to: {"endpoints":[{"url":"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=LxJlkSosQdWmBFBOx1fB6zrbjSbU0iStl7jjtlVL27CtOEPxem%2Ffl9y%2BCajMUopcZINOEsaufiU8A2glOLEmNpO5a40%2FyWb%2B4dBuspS8VGWnCRW4jxBBmh%2F3FbupAEaxy66TUPariKJLqe3PL5iq"}],"group":"cf-nel","max_age":604800}\r
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}\r
server: cloudflare\r
cf-ray: 6991ab2c1a5037c7-MAD\r
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400\r
\`\`\`\r
\r
Para acabar, y como curiosidad, aadiendo la opcin \`-w "%{time_total}\\n"\` podremos ver el tiempo total que se ha tardado en recibir la respuesta del servidor.\r
\r
## II.2 Puntos finales y rutas\r
\r
El trmino tcnico \`endpoint\` hace referencia la la URL que se utiliza URL para hacer una peticin. Para un mismo servicio, esta URL suele ser siempre la misma y es una de las caractersticas de las API REST.\r
\r
Para un API, los *puntos finales* son URLs y se describen en la documentacin de la APU de forma que los programadores sepan cmo usarla y acceder a los recursos y servicios que proporciona.\r
\r
En el siguiente ejemplo tenemos una API con el siguiente endpoint.\r
\r
> GET https://my-api.com/Library/Books\r
\r
Esto devolvera una lista completa de los libros que hay en la biblioteca.\r
\r
Una ruta ("route") no es ms que la parte de la URL que completa al endpoint y que se utiliza para seleccionar y/o acceder a diferentes componentes del servicio o API.\r
\r
> GET https://my-api.com/Library/Books/341\r
\r
El ejemplo anterior devolvera el libro con identificador 341 de los que hay en la biblioteca.\r
\r
Como ejemplo en [SWAPI (Star Wars API)](https://swapi.dev/) el endpoint es \`https://swapi.dev/api/\`. Este es el punto de entrada para todas las peticiones.\r
\r
Adems, hay muchas rutas dependiendo de la informacin que queramos recuperar/aadir/modificar/borrar..\r
\r
\`\`\`java:no-line-numbers\r
$> curl https://swapi.dev/api/people/1\r
$> curl https://swapi.dev/api/planet/3\r
$> curl https://swapi.dev/api/vehicles\r
\`\`\`\r
\r
## II.3 Mtodos HTTP y cabeceras\r
\r
Todas las peticiones HTTP tienen un mtodo asociado, tambin llamado verbo. Por defecto ya hemos visto que se usa GET, pero tambin tenemos POST, HEAD y PUT que se utilizan bastante.\r
\r
POST es el mtodo HTTP que se ide para enviar y recibir informacin de una aplicacin web y es el que utilizan, entre otros, los formularios web.\r
\r
Cuando los datos de un formulario se envan desde un navegador se mandan \`URL encoded\`, como una serie de pares nombre=valor separados con smbolos ampersand (&).\r
\r
Para enviar datos con curl lo indicamos con la opcin \`-d (--data)\` con el siguiente formato:\r
\r
> curl -d 'name=admin&shoesize=12' http://example.com/\r
\r
Curl es capaz de seleccionar el mtodo HTTP que debe utilizar en funcin de las opciones que recibe. Si utilizamos \`-d\` curl har un POST, con \`-I\` har un HEAD, etc. Con la opcin \`-X (--request)\` podemos indicar qu mtodo queremos que use curl.\r
\r
> curl -X POST -d 'imageSize=big&imageType=jpg' http://example.org/\r
\r
Si usamos la opcin POSTing with curl's \`-d\` ya hemos visto que por defecto se hace POST. Adems de eso, se incluye una cabecera para indicar el formato de los datos enviados \`Content-Type: application/x-www-form-urlencoded\`. Esto es lo que hace un navegador cuando enviamos un formulario.\r
\r
Puede ocurrir que los datos que estamos enviando no tengan ese formato, bien porque estemos subiendo algn archivo, enviando informacin binaria, usando JSON, XML, ... en estos casos podemos, a travs de la misma cabecera Content-Type, indicar el formato de la informacin que estamos enviando.\r
\r
Por ejemplo si queremos enviar informacin en formato jSON:\r
\r
> curl -X "POST" -d '{"imageSize":"big","imageType":"jpg","scale":"false"}' -H 'Content-Type: application/json' https://example.com\r
\r
## II.4 Authentication\r
\r
Cada solicitud HTTP puede ser autenticada. Un servidor o proxy puede necesitar que el usuario confirme su identidad o que tiene los permisos necesarios para acceder a una URL para realizar una accin. En ese caso se le enviar al cliente una respuesta en la que se le indique que debe proporcionar informacin de autenticacin en la cabecera HTTP para que se le permita completar esa solicitud.\r
\r
En curl, la forma de realizar una peticin HTTP autenticadaes con la opcin \`-u (--user)\` y proporcionando un usuario y contrasea (separados por \`:\`).\r
\r
> curl --user daniel:secret http://example.com/\r
\r
Esto har que curl utilice el mtodo de autenticacin HTTP por defecto, denominado "Basic"\r
\r
Otras aplicaciones hacen uso de una clave secreta \`secret key\` o testigos de autorizacin \`Authorization token\`. Esta informacin nos la proporciona del servicio cuando lo creamos y configuramos.\r
\r
[Trello API Introduction](https://developer.atlassian.com/cloud/trello/guides/rest-api/api-introduction/)\r
\r
[Azure Translator API Reference](https://docs.microsoft.com/es-es/azure/cognitive-services/translator/reference/v3-0-translate)\r
\r
Por ejemplo, si queremos usar el servicio \`translate\` de Azure tendremos que obtener una *secret key* y utilizarla en la cabecera de cada solicitud que realicemos\r
\r
\`\`\`java:no-line-numbers\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Ocp-Apim-Subscription-Key: <here goes your susbcription key>" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
Otras veces, para no enviar siempre la secret key, solicitamos una autorizacin temporal, obteniendo un \`Authorization token\` que podemos usar para acceder al servicio durante un breve perodo de tiempo. Una vez que el token expire, debemos solicitar otro.\r
Para el envo de tokens se utiliza la cabecera \`Authorization: Bearer <token>\`.\r
\r
\`\`\`java:no-line-numbers{1,3,5}\r
$> curl -X POST "https://api.cognitive.microsoft.com/sts/v1.0/issueToken" \r
        -H "Ocp-Apim-Subscription-Key: <here goes the secret key>" -d {}\r
eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE\r
$> curl -X POST \r
"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" \r
-H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzMwMTUxNywiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.0hyyBNr22E2sIO_ZBlTiBePXM_KE_5hQOCeHxz3US44" \r
-H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
{"error":{"code":401000,"message":"The request is not authorized because credentials are missing or invalid."}}\r
$> curl -X POST \r
"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" \r
-H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE" \r
-H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
## II.5 References\r
\r
[Everything curl](https://everything.curl.dev/) es un libro gratuito que cubre con detalle prcticamente todo lo que hay que saber sobre curl.\r
\r
[freecodecamp.org](https://www.freecodecamp.org/news/how-to-start-using-curl-and-why-a-hands-on-introduction-ea1c913caaaa/)\r
\r
[Sitio oficial de curl](https://curl.se/)\r
`]},{title:"2 Introduccin",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit2/",pathLocale:"/es/",extraFields:[`---\r
title: 2 Introduccin\r
---\r
\r
# Tema 2. Programacin de procesos\r
\r
Una vez hemos aprendido a diferenciar entre programas, procesos e hilos, en este segundo tema vamos a aprender cmo desde un programa creado por nosotros podemos lanzar otros programas, es decir, desde un proceso en ejecucin, podemos crear otro proceso.\r
\r
Adems de lanzarlos, al establecerse una relacin padre-hijo estos procesos pueden comunicarse entre s intercambiando informacin. De esta forma nuestros programas podrn lanzar otras aplicaciones, comandos del SO e incluso otras aplicaciones nuestras, permitiendo cierto grado de sincronizacin y comunicacin entre ellas.\r
\r
## Objetivos\r
\r
Los objetivos que alcanzaremos tras esta unidad son:\r
\r
- Conocer las clases de Java para la creacin de procesos\r
- Monitorizar y controlar el ciclo de vida de un proceso\r
- Controlar la comunicacin entre procesos padre/hijo\r
- Usar mtodos para la sincronizacin entre procesos y subprocesos\r
- Entender el mecanismo de comunicacin mediante tuberas (pipes)\r
- Aprender la sintaxis y uso del comando curl para probar API REST desde un programa\r
- Crear programas que ejecuten tareas en paralelo.\r
`]},{title:"2.3 Gestin de la E-S de un proceso",headers:[{level:2,title:"2.3.1  Redireccin de la E/S estndar",slug:"_2-3-1-redireccion-de-la-e-s-estandar",link:"#_2-3-1-redireccion-de-la-e-s-estandar",children:[{level:3,title:"getInputStream()",slug:"getinputstream",link:"#getinputstream",children:[]},{level:3,title:"getErrorStream()",slug:"geterrorstream",link:"#geterrorstream",children:[]},{level:3,title:"getOutputStream()",slug:"getoutputstream",link:"#getoutputstream",children:[]},{level:3,title:"Heredar la E/S del proceso padre",slug:"heredar-la-e-s-del-proceso-padre",link:"#heredar-la-e-s-del-proceso-padre",children:[]}]},{level:2,title:"2.3.2 Redireccin de las Entradas y Salidas Estndar",slug:"_2-3-2-redireccion-de-las-entradas-y-salidas-estandar",link:"#_2-3-2-redireccion-de-las-entradas-y-salidas-estandar",children:[]}],path:"/es/unit2/iostreams.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.3 Gestin de la E-S de un proceso\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.3 Gestin de la E-S de un proceso" />\r
\r
# 2.3 Gestin de la E-S de un proceso\r
\r
[[toc]]\r
\r
## 2.3.1  Redireccin de la E/S estndar\r
\r
Ya hemos comentado que un subproceso no tiene terminal o consola en el que poder mostrar su informacin. Toda la E/S por defecto *(stdin -> teclado, stdout y stderr -> pantalla)* por defecto se redirige al proceso padre. Es el proceso padre el que puede usar estos streams para recoger o enviar informacin al proceso hijo.\r
\r
::: danger Cdigo del proceso hijo\r
En ningn momento, cuando estamos programando un proceso, debemos pensar si va a ser lanzado como padre o como hijo.\r
\r
Es ms, todos los programas que hacemos son lanzados como hijos por el IDE (Netbeans) y eso no hace que cambiemos nuestra forma de programarlos.\r
\r
Un proceso que vayamos a lanzar como hijo debera funcionar perfectamente como proceso independiente y puede ser ejecutado directamente sin tener que hacerle ningn tipo de cambio.\r
:::\r
\r
Este intercambio de informacin nos da mucha flexibilidad y proporciona una forma de control y comunicacin sobre el proceso hijo.\r
\r
En la relacin padre-hijo que se crea entre procesos los descriptores tambin se redirigen desde el hijo hacia el padre, usando 3 tuberas (pipes), una por cada stream de E/S por defecto. Esas tuberas pueden usarse de forma similar a cmo se hace en los sistemas Linux.\r
\r
<!--![alt_text](./../../media/unit2/pipe_with_two.jpg)-->\r
\r
![alt_text](./../../media/unit2/ProcessIO.png)\r
\r
### getInputStream()\r
\r
No slo es importante recoger el valor de retorno de un comando, sino que muchas veces nos va a ser de mucha utilidad el poder obtener la informacin que el proceso genera por la salida estndar o por la salida de error.\r
\r
Para esto vamos a utilizar el mtodo \`public abstract InputStream getInputStream()\` de la clase \`Process\` para leer el stream de salida del proceso, es decir, para leer lo que el comando ejecutado (proceso hijo) ha enviado a la consola.\r
\r
\`\`\`java{3}\r
Process p = pbuilder.start();\r
BufferedReader processOutput = \r
    new BufferedReader(new InputStreamReader(p.getInputStream()));\r
\r
String linea;    \r
while ((linea = processOutput.readLine()) != null) {\r
    System.out.println("> " + linea);        \r
}            \r
processOutput.close();    \r
\`\`\`\r
\r
![alt_text](./../../media/unit2/Java_Stream_Readers_BufferedReaders.jpg)\r
\r
::: warning Charsets y encodings\r
Desde el inicio de la informtica los juegos de caracteres y las codificaciones han supuesto un autntico quebradero de cabeza para los programadores, especialmente cuando trabajamos con juegos de caracteres no anglosajones. Pues bien, la consola de Windows no iba a ser una excepcin.\r
\r
La consola de windows, conocida como *"DOS prompt"* o *cmd*, es la forma de ejecutar programas y comandos DOS en Windows, por lo tanto esos programas mantienen la codificacin de DOS. A Microsoft no le gustan hacer cambios que pierdan la compatibilidad hacia atrs, es decir, que sean compatibles con versiones anteriores, as que cuando hagamos una aplicacin que trabaje con la consola debemos tener en cuenta esta circunstancia.\r
\r
En Wikipedia comentan que la codificacin  **CP850** tericamente ha sido ampliamente reemplazada por **Windows-1252** y posteriormente Unicode, pero an as **CP850** sigue presente en la consola de comandos.\r
\r
Por lo tanto, si queremos mostrar informacin de la consola en nuestras aplicaciones, debemos trabajar con el charset adecuado, a saber, CP-850.\r
\r
Para usar un encoding concreto, la clase InputStreamReader, que pasa de gestionar bytes a caracteres, tiene un constructor que permite especificar el tipo de codificacin usado en el stream de bytes que recibimos, as que que debemos usar este constructor cuando trabajemos con aplicaciones de consola.\r
\r
\`\`\`java:no-line-numbers\r
new InputStreamReader(p.getInputStream(), "CP850");\r
\`\`\`\r
\r
> Adems, para usar una codificacin universal, podemos forzar que Netbeans, o mejor dicho la mquina virtual que usa Netbeans, utilice **por defecto el charset \`UTF-8\`**. Para hacerlo, debemos modificar el archivo de configuracin de Netbeans \`C:/Program Files/Netbeans-xx.x/netbeans/etc/netbeans.conf\`, y modificar la directiva \`netbeans_default_option\` aadiendo al final **-J-Dfile.encoding=UTF-8**.\r
\r
:::\r
\r
### getErrorStream()\r
\r
Curiosamente, o no tanto, adems de la salida estndar, tambin podemos obtener la salida de error (stderr) que genera el proceso hijo para procesarla desde el padre.\r
\r
Si la salida de error ha sido previamente redirigida usando el mtodo \`ProcessBuilder.redirectErrorStream(true)\` entonces la salida de error y la salida estndar llegan juntas con getInputStream() y no es necesario hacer un tratamiento adicional.\r
\r
Si por el contrario queremos hacer un tratamiento diferenciado de los dos tipos de salida, podemos usar un esquema similar al usado anteriormente, con la salvedad de que ahora en vez de llamar a \`getInputStream()\` lo hacemos con \`getErrorStream()\`.\r
\r
\`\`\`java{3}\r
Process p = pbuilder.start();\r
BufferedReader processError = \r
    new BufferedReader(new InputStreamReader(p.getErrorStream()));\r
// En este ejemplo, por ver una forma diferente de recoger la informacin,\r
// en vez de leer todas las lneas que llegan, recogemos la primera lnea\r
// y suponemos que nos han enviado un entero.    \r
int value = Integer.parseInt(processError.readLine());\r
processError.close();\r
\`\`\`\r
\r
::: info Patrn de diseo Decorator o Wrapper\r
En ambos tipos de streams de entrada (input y error) estamos recogiendo la informacin de un objeto de tipo BufferedReader. Podramos usar directamente el InputStream que nos devuelven los mtodos de Process, pero tendramos que encargarnos nosotros de convertir los bytes a caracteres, de leer el stream carcter a carcter y de controlar el flujo al no disponer de un buffer.\r
\r
Todo esto nos lo podemos ahorrar usando clases que gestionan el flujo a un nivel de concrecin ms alto, usando sin llegar a ser conscientes otro patrn de diseo bastante comn, **Patrn de diseo Decorator** tambin llamado **wrapper o envoltorio**.\r
\r
> Decorator es un patrn de diseo estructural que te permite aadir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades.\r
\r
[Refactoring.Guru patrones de diseo](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
Vamos a ver un ejemplo completo de uso de todas las funcionalidad anteriores\r
\r
\`\`\`java{5,8,10,14,17}\r
import java.io.*;\r
public class Ejercicio2 {\r
    public static void main(String[] args) {\r
        String comando = "notepad";\r
        ProcessBuilder pbuilder = new ProcessBuilder (comando);\r
        Process p = null;\r
        try {\r
            p = pbuilder.start();\r
            // 1- Procedemos a leer lo que devuelve el proceso hijo\r
            InputStream is = p.getInputStream();\r
            // 2- Lo convertimos en un InputStreamReader\r
            // De esta forma podemos leer caracteres en vez de bytes\r
            // El InputStreamReader nos permite gestionar diferentes codificaciones\r
            InputStreamReader isr = new InputStreamReader(is);\r
            // 2- Para mejorar el rendimiento hacemos un wrapper sobre un BufferedReader\r
            // De esta forma podemos leer enteros, cadenas o incluso lneas.\r
            BufferedReader br = new BufferedReader(isr);\r
\r
            // A Continuacin leemos todo como una cadena, lnea a lnea\r
            String linea;\r
            while ((linea = br.readLine()) != null) \r
                System.out.println(linea);\r
        } catch (Exception e) {\r
            System.out.println("Error en: "+comando);\r
            e.printStackTrace();\r
        } finally {\r
            // Para finalizar, cerramos los recursos abiertos\r
            br.close();\r
            isr.close();\r
            is.close();\r
        }    \r
    }\r
}\r
\`\`\`\r
\r
### getOutputStream()\r
\r
No slo podemos recoger la informacin que enva el proceso hijo sino que, adems, tambin podemos enviar informacin desde el proceso padre al proceso hijo, usando el ltimo de los tres streams que nos queda, el \`stdin\`.\r
\r
Igual que con las entradas que llegan desde el proceso hijo, podemos enviar la informacin usando directamente el OutputStream del proceso, pero lo haremos de nuevo con un Decorator.\r
\r
En este caso, el *wrapper* de mayor nivel nivel para usar un OutputStream es la clase PrintWriter que nos ofrece mtodos similares a los de \`System.out.printxxxxx\` para gestionar el flujo de comunicacin con el proceso hijo.\r
\r
\`\`\`java{4}\r
PrintWriter toProcess = new PrintWriter(\r
    new BufferedWriter(\r
        new OutputStreamWriter(\r
            p.getOutputStream(), "UTF-8")), true);\r
toProcess.println("sent to child");\r
\`\`\`\r
\r
### Heredar la E/S del proceso padre\r
\r
Con el mtodo \`inheritIO()\` podemos redireccionar todos los flujos de E/S del proceso hijo a la E/S estndar del proceso padre.\r
\r
\`\`\`java{3}\r
ProcessBuilder processBuilder = new ProcessBuilder("/bin/sh", "-c", "echo hello");\r
\r
processBuilder.inheritIO();\r
Process process = processBuilder.start();\r
\r
int exitCode = process.waitFor();\r
\`\`\`\r
\r
En el ejemplo anterior, tras invocar al mtodo inheritIO() podemos ver la salida del comando ejecutado en la consola del proceso padre dentro del IDE Netbeans.\r
\r
::: warning salo para depurar la comunicacin/sincronizacin padre-hijo\r
Este mtodo es til para depurar, pero no se recomienda para cdigo de produccin. Es mejor usar los mtodos getInputStream() y getErrorStream() para leer las salidas y errores del subproceso, y el mtodo getOutputStream() para escribir en el subproceso.\r
:::\r
\r
\r
<!--\r
### Pipelines\r
\r
Java 9 introdujo el concepto de \`pipelines\` en el API de ProcessBuilder:\r
\r
\`\`\`java:no-line-numbers\r
public static List<Process> startPipeline(List<ProcessBuilder> builders)\r
\`\`\`\r
\r
El mtodo \`startPipeline\` usa un lista de objetos ProcessBuilder. Este mtodo esttico se encarga de lanzar un proceso para cada uno de los ProcessBuilder recibidos. Y lo que automatiza es la creacin de tuberas encadenadas (pipeline) haciendo que la salida de cada proceso est enlazada con la entrada del siguiente..\r
\r
Por ejemplo, si queremos realizar este tipo de operaciones tan comunes en shellscript:\r
\r
> find . -name *.java -type f | wc -l\r
\r
Lo que haremos ser crear un ProcessBuilder para cada uno de los comandos, y  pasrselos todos al mtodo startPipeline para que los ejecute y los encadene.\r
\r
\`\`\`java\r
List builders = Arrays.asList(\r
    new ProcessBuilder("find", "src", "-name", "*.java", "-type", "f"), \r
    new ProcessBuilder("wc", "-l"));\r
\r
List processes = ProcessBuilder.startPipeline(builders);\r
Process last = processes.get(processes.size() - 1);\r
\r
// Desde el proceso padre podemos recoger la salida del ltimo proceso para \r
// el resultado final del pipeline\r
\`\`\`\r
\r
El ejemplo anterior busca todos los archivos .java  dentro del directorio src, encadena la salida hacia el comando wc para contar cuantos ficheros ha encontrado, siendo este el resultado final del pipeline.\r
-->\r
\r
## 2.3.2 Redireccin de las Entradas y Salidas Estndar\r
\r
En un sistema real, probablemente necesitemos guardar los resultados de un proceso en un archivo de log o de errores para su posterior anlisis. Afortunadamente lo podemos hacer sin modificar el cdigo de nuestras aplicaciones usando los mtodos que proporciona el API de ProcessBuilder para hacer exactamente eso.\r
\r
Por defecto, tal y como ya hemos visto, los procesos hijos reciben la entrada a travs de una tubera a la que podemos acceder usando el OutputStream que nos devuelve \`Process.getOutputStream()\`.\r
\r
Sin embargo, tal y como veremos a continuacin, esa entrada estndar se puede cambiar y redirigirse a otros destinos como un fichero usando el mtodo \`redirectOutput(File)\`. Si modificamos la salida estndar, el mtodo getOutputStream() devolver *ProcessBuilder.NullOutputStream*.\r
\r
::: info Redireccin antes de ejecutar\r
Es importante fijarse en qu momento se realiza cada accin sobre un proceso.\r
\r
Antes hemos visto que los flujos de E/S se consultan y gestionan una vez que el proceso est en ejecucin, por lo tanto los mtodos que nos dan acceso a esos *streams* son mtodos de la clase \`Process\`.\r
\r
Si lo que queremos es redirigir la E/S, como vamos a ver a continuacin, lo haremos mientras preparamos el proceso para ser ejecutado. De forma que cuando se lance sus streams de E/S se modifiquen. Por eso en esta ocasin los mtodos que nos permiten redireccionar la E/S de los procesos son mtodos de la clase \`ProcessBuilder\`.\r
::::\r
\r
Vamos a ver con un ejemplo cmo hacer un programa que muestre la versin de Java. Ahora bien, en esta ocasin la salida se va a guardar en un archivo de log en vez de enviarla al padre por la tubera de salida estndar:\r
\r
\`\`\`java{7}\r
ProcessBuilder processBuilder = new ProcessBuilder("java", "-version");\r
\r
// La salida de error se enviar al mismo sitio que la estndar\r
processBuilder.redirectErrorStream(true);\r
\r
File log = folder.newFile("java-version.log");\r
processBuilder.redirectOutput(log);\r
\r
Process process = processBuilder.start();\r
\`\`\`\r
\r
En el ejemplo anterior podemos observar como se crea un archivo temporal llamado *java-version.log* e indicamos a ProcessBuilder que la salida la redirija a este archivo.\r
\r
Es lo mismo que si llamsemos a nuestra aplicacin usando el operador de redireccin de salida:\r
\r
> java ejemplo-java-version > java-version.log\r
\r
::: tip Cdigo del proceso hijo\r
Si el proceso hijo que lanzamos, en vez de ser un comando del sistema, es otra clase java, en ningn momento tenemos que modificar el cdigo de este proceso para que funcione como hijo.\r
\r
Por lo tanto, el proceso hijo seguir haciendo\r
\r
> System.out.println("Versin de Java: " + System.getProperty("java.version"));\r
\r
y ser el sistema operativo el que se encargue de redirigir las salidas o entradas al fichero, o donde se haya configurado con los mtodos de redireccin de la clase \`ProcessBuilder\`.\r
:::\r
\r
Ahora vamos a fijarnos en una variacin del ejemplo anterior. Lo que queremos hacer ahora es aadir (\`append to\`) informacin al archivo de log file en vez de sobrescribir el archivo cada vez que se ejecuta el proceso. Con sobrescribir nos referimos a crear el archivo vaco si no existe, o bien borrar el contenido del archivo si ste ya existe.\r
\r
\`\`\`java{3}\r
File log = tempFolder.newFile("java-version-append.log");\r
processBuilder.redirectErrorStream(true);\r
processBuilder.redirectOutput(Redirect.appendTo(log));\r
\`\`\`\r
\r
Otra vez ms, es importante hacer notar la llamada a  \`redirectErrorStream(true)\`. En el caso de que se produzca algn error, se mezclarn con los mensajes de salida en el fichero..\r
\r
En el APi de ProcessBuilder encontramos mtodos para redireccionar tambin la salida de error estndar y la entrada estndar de los procesos.\r
\r
- redirectError(File)\r
- redirectInput(File)\r
\r
Para hacer las redirecciones tambin podemos utilizar la clase \`ProcessBuilder.Redirect\` como parmetro para las versiones sobrecargadas de los mtodos anteriores, utilizando uno de los siguientes valores\r
\r
| Valor                   | Significado                                                              |\r
| ----------------------- | ------------------------------------------------------------------------ |\r
| Redirect.DISCARD        | La informacin se descarta                                               |\r
| Redirect.to(File)       | La informacin se guardar en el fichero indicado. Si existe, se vaca.  |\r
| Redirect.from(File)     | La informacin se leer del fichero indicado                             |\r
| Redirect.appendTo(File) | La informacin se aadir en el fichero indicado. Si existe, no se vaca |\r
\r
Estos valores son campos estticos de la clase Redirect y pueden ser usados como parmetros para los mtodos sobrecargados redirectOutput, redirectError y redirectInput.\r
\r
\`\`\`java\r
File log = folder.newFile("sampleInputData.csv");\r
processBuilder.redirectInput(Redirect.from(log));\r
\`\`\`\r
`]},{title:"2.1 Comunicacin entre procesos",headers:[{level:2,title:"2.1.1. Comunicacin mediante E/S",slug:"_2-1-1-comunicacion-mediante-e-s",link:"#_2-1-1-comunicacion-mediante-e-s",children:[{level:3,title:"Redireccin de la entrada estndar",slug:"redireccion-de-la-entrada-estandar",link:"#redireccion-de-la-entrada-estandar",children:[]},{level:3,title:"Redireccin de la salida estndar",slug:"redireccion-de-la-salida-estandar",link:"#redireccion-de-la-salida-estandar",children:[]},{level:3,title:"Redireccin de la salida de error estndar",slug:"redireccion-de-la-salida-de-error-estandar",link:"#redireccion-de-la-salida-de-error-estandar",children:[]}]},{level:2,title:"2.1.2. Redireccin de la salida de un proceso a la entrada de otro proceso",slug:"_2-1-2-redireccion-de-la-salida-de-un-proceso-a-la-entrada-de-otro-proceso",link:"#_2-1-2-redireccion-de-la-salida-de-un-proceso-a-la-entrada-de-otro-proceso",children:[]},{level:2,title:"2.1.3. Comunicacin mediante seales",slug:"_2-1-3-comunicacion-mediante-senales",link:"#_2-1-3-comunicacion-mediante-senales",children:[]},{level:2,title:"2.1.4. Comunicacin mediante sockets",slug:"_2-1-4-comunicacion-mediante-sockets",link:"#_2-1-4-comunicacion-mediante-sockets",children:[]}],path:"/es/unit2/ipc.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.1 Comunicacin entre procesos\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Comunicacin entre procesos" />\r
\r
# 2.1. Comunicacin entre procesos\r
\r
[[toc]]\r
\r
La comunicacin entre procesos, IPC (Inter Process Communication), es una de las caractersticas principales de los sistemas operativos. En este apartado nos vamos a centrar en la comunicacin de procesos que estn en el mismo dispositivo.\r
\r
## 2.1.1. Comunicacin mediante E/S\r
\r
La comunicacin entre procesos se puede realizar de muchas formas, pero una de las ms sencillas y comunes es la comunicacin mediante la entrada y salida estndar.\r
\r
::: info E/S en Java\r
En Java, la comunicacin mediante la entrada y salida estndar se realiza mediante los flujos de entrada y salida estndar, \`System.in\` y \`System.out\` respectivamente.\r
:::\r
\r
Todo proceso tiene tres flujos de entrada y salida estndar que se pueden usar para la comunicacin con otros procesos. Estos flujos son:\r
\r
- **stdin** (entrada estndar): por donde el proceso recibe datos. Por defecto se corresponde con el teclado y el identificador del fichero asociado es 0.\r
- **stdout** (salida estndar): por donde el proceso enva datos. Por defecto se corresponde con la consola y el identificador del fichero asociado es 1.\r
- **stderr** (salida de error estndar): por donde el proceso enva mensajes de error. Por defecto se corresponde con la consola y el identificador del fichero asociado es 2.\r
\r
Un mecanismo IPC, relativamente sencillo, es la comunicacin de procesos mediante la redireccin de las salidas y entradas estndar a/desde otras fuentes.\r
\r
::: warning Redireccin de E/S\r
La redireccin de la entrada y salida estndar se puede hacer en la lnea de comandos de los sistemas UNIX y Windows. En Java, se puede hacer mediante la clase \`ProcessBuilder\` que veremos en la siguiente seccin de la unidad\r
:::\r
\r
### Redireccin de la entrada estndar\r
\r
La redireccin de la entrada estndar se puede hacer mediante el operador \`<\` en sistemas UNIX y Windows.\r
\r
\`\`\`bash\r
$> java MiClase < entrada.txt\r
\`\`\`\r
\r
En el ejemplo anterior, el programa \`MiClase\` recibe la entrada estndar desde el fichero \`entrada.txt\` en vez de desde el teclado.\r
\r
> Cuando se redirige la entrada estndar, el programa no tiene que hacer nada especial para leer de un fichero en vez de del teclado. El sistema operativo se encarga de redirigir la entrada estndar del programa al fichero que se le indica.\r
\r
### Redireccin de la salida estndar\r
\r
La redireccin de la salida estndar se puede hacer mediante los operadores \`>\` y \`>>\` en sistemas UNIX y Windows.\r
\r
\`\`\`bash\r
$>  java MiClase > salida.txt\r
$>  java MiClase >> salida2.txt\r
\`\`\`\r
\r
En el ejemplo anterior, la salida estndar del programa \`MiClase\` se redirige al fichero \`salida.txt\` en vez de a la consola. Si el fichero \`salida.txt\` no existe, lo crea, y si el fichero ya existe, sobrescribe su valor.\r
\r
Si el operador es \`>>\`, la salida se aade al final del fichero en vez de sobrescribirlo.\r
\r
> Cuando se redirige la salida estndar, el programa no tiene que hacer nada especial para escribir en un fichero en vez de en la consola. El sistema operativo se encarga de redirigir la salida estndar del programa al fichero que se le indica.\r
\r
### Redireccin de la salida de error estndar\r
\r
La redireccin de la salida de error estndar se puede hacer mediante el operador \`2>\` en sistemas UNIX y Windows.\r
\r
\`\`\`bash\r
$> java MiClase 2> error.txt\r
$> java MiClase 2>> error2.txt\r
\`\`\`\r
\r
En el ejemplo anterior, la salida de error estndar del programa \`MiClase\` se redirige al fichero \`error.txt\` en vez de a la consola.\r
\r
Si el operador es \`2>>\`, la salida de error se aade al final del fichero en vez de sobrescribirlo.\r
\r
> Cuando se redirige la salida de error, el programa no tiene que hacer nada especial para escribir en un fichero en vez de en la consola. El sistema operativo se encarga de redirigir la salida de error del programa al fichero que se le indica.\r
\r
## 2.1.2. Redireccin de la salida de un proceso a la entrada de otro proceso\r
\r
La redireccin de la salida estndar a la entrada estndar de otro proceso se puede hacer mediante el operador \`|\` en sistemas UNIX y Windows.\r
\r
Las tuberas (pipes) permiten conectar la salida estndar de un proceso con la entrada estndar de otro, estableciendo as una relacin de productor-consumidor.\r
El uso de tuberas sigue la siguiente sintaxis:\r
\r
\`\`\`bash\r
$> java MiClase | java MiClase2\r
\`\`\`\r
\r
En el ejemplo anterior, la salida estndar del programa \`MiClase\` se redirige a la entrada estndar del programa \`MiClase2\`.\r
\r
> Cuando se redirige la salida estndar de un proceso a la entrada estndar de otro, el sistema operativo se encarga de conectar los flujos de salida y entrada de los procesos.\r
\r
## 2.1.3. Comunicacin mediante seales\r
\r
Las seales son una forma de comunicacin entre procesos que se basa en la interrupcin de la ejecucin de un proceso para que realice una accin determinada.\r
\r
Las seales son eventos asncronos que se envan a un proceso para notificarle de un evento. Las seales pueden ser enviadas por el propio proceso, por otro proceso o por el sistema operativo.\r
\r
Las seales se pueden enviar a un proceso mediante la lnea de comandos o mediante un programa. En sistemas UNIX, se pueden enviar seales a un proceso mediante el comando \`kill\`.\r
\r
\`\`\`bash\r
$> kill -s SIGUSR1 1234\r
\`\`\`\r
\r
En el ejemplo anterior, se enva la seal \`SIGUSR1\` al proceso con PID \`1234\`.\r
\r
Las seales en el shell de Windows se pueden enviar mediante el comando \`taskkill\`.\r
\r
\`\`\`bash\r
$> taskkill /pid 1234 /f\r
\`\`\`\r
\r
En el ejemplo anterior, se enva la seal de finalizacin forzada al proceso con PID \`1234\`.\r
\r
::: tip Seales\r
Os dejo un enlace a la [lista de seales de UNIX](https://en.wikipedia.org/wiki/Signal_(IPC)).\r
\r
Y un artculo de ampliacin sobre [Gestin de procesos en Windows](https://openwebinars.net/blog/gestion-de-procesos-y-servicios-desde-shell-script-en-windows/).\r
:::\r
\r
## 2.1.4. Comunicacin mediante sockets\r
\r
Los sockets se pueden usar para la comunicacin entre procesos en el mismo dispositivo o en dispositivos diferentes.\r
\r
Los sockets los estudiaremos en la Unidad 4, donde veremos cmo se pueden usar para la comunicacin entre procesos en dispositivos diferentes.\r
`]},{title:"2.2 Gestin de procesos en Java - ProcessBuilder y Process",headers:[{level:2,title:"2.2.1 Preparacin y configuracin de un proceso",slug:"_2-2-1-preparacion-y-configuracion-de-un-proceso",link:"#_2-2-1-preparacion-y-configuracion-de-un-proceso",children:[{level:3,title:"Modificar el comando en tiempo de ejecucin",slug:"modificar-el-comando-en-tiempo-de-ejecucion",link:"#modificar-el-comando-en-tiempo-de-ejecucion",children:[]},{level:3,title:"Configuraciones adicionales de un proceso",slug:"configuraciones-adicionales-de-un-proceso",link:"#configuraciones-adicionales-de-un-proceso",children:[]}]},{level:2,title:"2.2.2 Acceso al proceso una vez en ejecucin",slug:"_2-2-2-acceso-al-proceso-una-vez-en-ejecucion",link:"#_2-2-2-acceso-al-proceso-una-vez-en-ejecucion",children:[]},{level:2,title:"2.2.3 Lanzar una clase Java como proceso desde otra clase java en el mismo proyecto",slug:"_2-2-3-lanzar-una-clase-java-como-proceso-desde-otra-clase-java-en-el-mismo-proyecto",link:"#_2-2-3-lanzar-una-clase-java-como-proceso-desde-otra-clase-java-en-el-mismo-proyecto",children:[]},{level:2,title:"2.2.4 Informacin de los procesos en Java",slug:"_2-2-4-informacion-de-los-procesos-en-java",link:"#_2-2-4-informacion-de-los-procesos-en-java",children:[{level:3,title:"Obtener informacin desde el propio proceso",slug:"obtener-informacion-desde-el-propio-proceso",link:"#obtener-informacion-desde-el-propio-proceso",children:[]},{level:3,title:"Obtener informacin de un proceso lanzado",slug:"obtener-informacion-de-un-proceso-lanzado",link:"#obtener-informacion-de-un-proceso-lanzado",children:[]}]}],path:"/es/unit2/processbuilder.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.2 Gestin de procesos en Java - ProcessBuilder y Process\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="2.2 Gestin de procesos en Java - ProcessBuilder y Process" />\r
\r
# 2.2 Gestin de procesos en Java - ProcessBuilder y Process\r
\r
[[toc]]\r
\r
## 2.2.1 Preparacin y configuracin de un proceso\r
\r
En el paquete \`java.lang\` tenemos dos clases para la gestin de procesos.\r
\r
* \`java.lang.ProcessBuilder\` [Referencia API Java](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html)\r
* \`java.lang.Process\` [Referencia API Java](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessBuilder.html)\r
\r
Las instancias de **ProcessBuilder** gestionan los atributos de los procesos, mientras que las instancias de **Process** controlan la ejecucin de esos mismos procesos cuando se ejecutan.\r
\r
Antes de ejecutar un nuevo proceso, podemos configurar los parmetros de ejecucin del mismo usando la clase \`ProcessBuilder\`.\r
\r
ProcessBuilder es una clase auxiliar de la clase Process, que veremos ms adelante, y se utiliza para controlar algunos parmetros de ejecucin que afectarn al proceso. A travs de la llamada al mtodo \`start\` se crea un nuevo proceso en el sistema con los atributos definidos en la instancia de ProcessBuilder.\r
\r
\`\`\`java\r
    ProcessBuilder pb = new ProcessBuilder("CMD", "/C", "DIR");\r
    Process p = pb.start();\r
\`\`\`\r
\r
Si llamamos varias veces al mtodo start, se crearn tantos nuevos procesos como llamadas hagamos, todos ellos con los mismos atributos.\r
\r
La clase ProcessBuilder define un par de constructores:\r
\r
\`\`\`java:no-line-numbers\r
ProcessBuilder(List<String> command)\r
ProcessBuilder(String... command)\r
\`\`\`\r
\r
El funcionamiento de ambos es el mismo. En el primer constructor se pasa el comando a ejecutar y la lista de argumentos como una lista de cadenas. Por contra, en el segundo constructor, el comando y sus argumentos se pasan a travs de un nmero variable de cadenas (String ... es lo que en Java se llama varargs). La versin que utilicemos depende del formato en que tengamos los datos.\r
\r
::: danger Argumentos y parmetros\r
Si queremos lanzar un programa con parmetros (modificadores que hacen que cambie la forma de funcionar un programa como -h /s ...) el comando no puede ser pasado al constructor directamente como un nico string, debe ser preprocesado para convertirlo en una lista y que funcione.\r
\r
\`\`\`java\r
// Formas diferentes de pasar el comando a los constructores de ProcessBuilder\r
// 1 forma: usando una cadena. Falla con parmetros\r
// Slo funciona con programas que tengan argumentos\r
String command1 = "notepad.exe prueba1.txt"\r
ProcessBuilder pb = new ProcessBuilder(command1);\r
\r
// 2 forma: usando un array de cadenas. Funciona con parmetros\r
String[] command2 = {"cmd", "/c", "dir", "/o"};\r
ProcessBuilder pb = new ProcessBuilder(command2);\r
\r
// 3 forma: usando una cadena y dividindola para convertirla en una lista\r
String command3 =  "c:/windows/system32/shutdown -s -t 0";  \r
// La expresin regular \\s significa partir por los espacios en blanco\r
ProcessBuilder pb = new ProcessBuilder(command3.split("\\\\s"));\r
// ESTA ES LA MEJOR FORMA PARA QUE FUNCIONE EN TODOS LOS CASOS\r
\`\`\`\r
\r
:::\r
\r
::: warning Apagar el sistema operativo\r
El comando \`shutdown -s\` sirve para apagar el sistema. En windows es necesario proporcionar la ruta completa al comando, por ejemplo C:\\Windows\\System32\\shutdown.\r
\r
Podemos usar como parmetro -s para apagar el sistema, , -r para reiniciar , -h para hibernar y -t para indicar un tiempo de espera antes de apagar.\r
\r
[Referencia del comando shutdown de Windows](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown)\r
:::\r
\r
::: question Activity psp.activities.U2A1_Shutdowner\r
Crea una nuevo proyecto Java (package psp.actividades y como clase principal U2A1_Shutdowner). \r
Usando la lnea de comandos, pide al usuario qu accin quiere realizar (apagar, reiniciar o suspender) y cunto tiempo quiere dejar antes de realizar la accin de apagado del sistema..\r
\r
Busca informacin sobre el funcionamiento del comando shutdown en GNU/Linux y haz que tu aplicacin funcione para ambos sistemas..\r
\r
La aplicacin tiene que preparar el comando correcto para la seleccin que haya hecho el usuario y para el sistema operativo en el que la est ejecutando.\r
\r
Muestra por consola el resultado del mtodo ProcessBuilder.command() de forma legible.\r
:::\r
\r
:::details Solucin de U2A1_Shutdowner\r
\r
\`\`\`java\r
public class U2A1_Shutdowner {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Ask for the required information to prepare the command\r
        Scanner keyboard = new Scanner(System.in);\r
        \r
        System.out.print("Select your option (s-shutdown / r-reboot / h-hibernate): ");\r
        String shutdownOption = keyboard.nextLine();        \r
        \r
        System.out.print("How much seconds will the command wait to be run? (0 means immediately): ");\r
        String shutdownTime = keyboard.nextLine();        \r
        \r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "C:/Windows/System32/shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        } else {\r
            command = "shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder shutdowner = new ProcessBuilder(command.split("\\\\s"));\r
        //shutdowner.start();\r
        \r
        // Show the command to be run\r
        System.out.print("El comando a ejecutar es:  ");\r
        for (String commandPart: shutdowner.command()) {\r
            System.out.print(commandPart + " ");\r
        }\r
        System.out.println("");\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
### Modificar el comando en tiempo de ejecucin\r
\r
Puede ser que todo el comando, o parte del mismo, no lo tengamos en el momento de llamar a los constructores de ProcessBuilder. Se puede cambiar, modificar y consultar a posteriori con el mtodo \`command\`\r
\r
Al igual que con los constructores, tenemos dos versiones del mtodo command\r
\r
\`\`\`java:no-line-numbers\r
    command(List<String> command)\r
    command(String... command)\r
\`\`\`\r
\r
y la tercera forma de este mtodo (sin parmetros) sirve para obtener una lista del comando pasado al constructor o puesto con alguna de las formas anterior del mtodo command. Lo interesante es que una vez que tenemos la lista, podemos modificarla usando los mtodos de la clase List.\r
\r
En el siguiente ejemplo, en el momento de definir el comando, nos falta saber la ltima parte, el directorio temporal. Adems, si queremos hacer que la ejecucin sea multiplataforma, el shell a ejecutar tampoco lo sabemos.\r
Dependiendo del SO se aaden dos valores al principio y un valor al final, con el mtodo add de la clase List.\r
\r
\`\`\`java\r
// Sets and modifies the command after ProcessBuilder object is created\r
String command = "java -jar install.jar -install"; // tmp dir is missing\r
ProcessBuilder pbuilder = new ProcessBuilder(command.split("\\\\s"));\r
if (isWindows) {\r
    pbuilder.command().add(0, "cmd"); // Sets the 1st element\r
    pbuilder.command().add(1, "/c"); // Sets the 2nd element\r
    pbuilder.command().add("c:/temp"); // Sets the last element\r
    // Command to run cmd /c java -jar install.jar -install c:/temp\r
} else {\r
    pbuilder.command().add(0, "sh"); // Sets the 1st element\r
    pbuilder.command().add(1, "-c"); // Sets the 2nd element\r
    pbuilder.command().add("/tmp"); // Sets the last element\r
    // Command to run: sh -c java -jar install.jar -install /tmp\r
}\r
\r
// Starts the process\r
pbuilder.start();\r
\`\`\`\r
\r
### Configuraciones adicionales de un proceso\r
\r
Algunos de los atributos que podemos configurar para un proceso son:\r
\r
* Establecer el directorio de trabajo donde el proceso se ejecutar\r
  \r
  Podemos cambiar el directorio de trabajo por defecto llamando al mtodo \`directory\` y pasndole un objeto de tipo File. **Por defecto, el directorio de trabajo se establece al valor de la variable del sistema user.dir**. Este directorio es el punto de partida para acceder a ficheros, imgenes y todos los recursos que necesite nuestra aplicacin.\r
\r
    \`\`\`java\r
    // Cambia el directorio de trabajo a la carpeta personal del usuario\r
    pbuilder.directory(new File(System.getProperty("user.home")));\r
    \`\`\`\r
\r
* Configurar o modificar variables de entorno para el proceso con el mtodo \`environment()\`\r
\r
    \`\`\`java\r
    // Retrieve and modify the process environment\r
    Map<String, String> environment = pbuilder.environment();\r
    // Get the PATH environment variable and add a new directory\r
    String systemPath = environment.get("path") + ";c:/users/public";\r
    environment.replace("path", systemPath);\r
    // Add a new environment variable and use it as a part of the command\r
    environment.put("GREETING", "Hola Mundo");\r
    processBuilder.command("/bin/bash", "-c", "echo $GREETING");\r
    \`\`\`\r
\r
    \`\`\`java\r
    // Indicamos el directorio donde se encuentra el ejecutable\r
    File directorio = new File ("bin");\r
    pb.directory(directorio);\r
\r
    // Mostramos la informacin de las variables de entorno\r
    Map variablesEntorno = pb.environment();\r
    System.out.println(variablesEntorno);\r
\r
    // Mostramos el nombre del proceso y sus argumentos\r
    List command = pb.command();\r
    Iterator iter = l.iterator();\r
    while (iter.hasNext()) {\r
        System.out.println(iter.next());\r
    }\r
    \`\`\`\r
\r
    ::: info Variables de entorno vs Propiedades del sistema\r
    Con la clase Runtime accedemos a las variables del sistema mientras que con ProcessBuilder lo hacemos a las propiedades del sistema, que son diferentes.\r
    :::\r
\r
* Redireccionar la entrada y salida estndar\r
* Heredar la E/S estndar del proceso padre usando el mtodo ProcessBuilder.inheritIO()\r
  \r
  *Estas dos configuraciones se vern en el siguiente apartado.*\r
\r
::: question Actividad psp.activities.U2A2_DirectorioTrabajo\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A2_DirectorioTrabajo y como clase principal psp.activities.U2A2_WorkingDirectory)\r
Escribe un programa que ejecute el comando ls o dir.\r
Modifica el valor de la propiedad user.dir.\r
En la misma aplicacin, cambiar el directorio de trabajo a la carpeta c:/temp o /tmp, dependiendo del sistema operativo.\r
\r
Muestra el valor devuelto por el mtodo directory()\r
\r
* Despus de crear la instancia de ProcessBuilder\r
* Despus de cambiar el valor de user.dir\r
* Despus de cambiar el directorio de trabajo al directorio temporal del sistema.\r
\r
*En este momento tu programa todava no mostrar ningn listado.*\r
:::\r
\r
::: details Solucin de U2A2_DirectorioTrabajo\r
\r
\`\`\`java\r
public class U2A2_WorkingDirectory {\r
\r
    public static void main(String[] args) throws IOException, InterruptedException {\r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "cmd /c dir";\r
        } else {\r
            command = "sh -c ls";\r
        }\r
               \r
        //1st - Default working directory\r
        \r
        // Prepare the process \r
        ProcessBuilder commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir\r
        commander.start().waitFor();\r
        \r
        \r
        //2nd - Change user.dir but not the working directory\r
        \r
        // Change the user.dir system property\r
        System.setProperty("user.dir", System.getProperty("user.home"));\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir        \r
        commander.start().waitFor();\r
        \r
        \r
        // 3rd - Change the working directory\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        commander.directory(new File(System.getProperty("user.home")));             \r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
\r
        // Launch the process and show its result\r
        // Working directory is user.home and the process is run on it\r
        commander.start().waitFor();        \r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.2 Acceso al proceso una vez en ejecucin\r
\r
LA clase \`Process\` es una clase abstracta definida en el paquete java.lang y contiene la informacin del proceso en ejecucin. Tras invocar al mtodo \`start\` de ProcessBuilder, ste devuelve una referencia al proceso en forma de objeto Process.\r
\r
Los mtodos de la clase Process pueden ser usados para realizar operaciones de E/S desde el proceso, para comprobar su estado, su valor de retorno, para esperar a que termine de ejecutarse y para forzar la terminacin del proceso. Sin embargo estos mtodos no funcionan sobre procesos especiales del SO como pueden ser servicios, shell scripts, demonios, etc.\r
\r
> [Especificacin java.lang.Process](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Process.html)\r
\r
::: warning Entrada / Salida desde el proceso hijo\r
Curiosamente  **los procesos lanzados con el mtodo start() no tienen una consola asignada.**. Por contra, estos procesos redireccionan los streams de E/S estndar (stdin, stdout, stderr) al proceso padre. Si se necesita, se puede acceder a ellos a travs de los streams obtenidos con los mtodos definidos en la clase Process como getInputStream(), getOutputStream() y  getErrorSteam(). Esta es la forma de enviar y recibir informacin desde los subprocesos.\r
:::\r
\r
Los principales mtodos de esta clase son:\r
\r
| Mtodo                                       | Descripcin                                                                                                                                                                                                                                                                                                      |\r
| :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| int exitValue()                              | Cdigo de finalizacin devuelto por el proceso hijo (ver Info ms abajo)                                                                                                                                                                                                                                         |\r
| Boolean isAlive()                            | Comprueba si el proceso todava est en ejecucin                                                                                                                                                                                                                                                                |\r
| int waitFor()                                | hace que el proceso padre se quede esperando a que el proceso hijo termine. El entrono que devuelve es el cdigo de finalizacin del proceso hijo                                                                                                                                                                |\r
| Boolean waitFor(long timeOut, TimeUnit unit) | El funcionamiento es el mismo que en el caos anterior slo que en esta ocasin podemos especificar cunto tiempo queremos esperar a que el proceso hijo termine. El mtodo devuelve true si el proceso termina antes de que pase el tiempo indicado y false si ha pasado el tiempo y el proceso no ha terminado. |\r
| void destroy()                               | Estos dos mtodos se utilizan para matar al proceso. El segundo lo hace de forma forzosa.                                                                                                                                                                                                                        |\r
| Process destroyForcibly()                    |\r
\r
 Veamos un sencillo ejemplo. Una vez lanzado el programa espera durante 10 segundos y a continuacin mata el proceso.\r
\r
\`\`\`java\r
public class ProcessDemo {\r
\r
   public static void main(String[] args) throws Exception {\r
\r
      ProcessBuilder pb = new ProcessBuilder("C:/Program Files (x86)/Notepad++/notepad++.exe");\r
      // Effectively launch the process\r
      Process p = pb.start();\r
      // Check is process is alive or not\r
      boolean alive = p.isAlive();\r
      // Wait for the process to end for 10 seconds.\r
      if (p.waitFor(10, TimeUnit.SECONDS)) {\r
          System.out.println("Process has finished");\r
      } else {\r
          System.out.println("Timeout. Process hasn't finished");\r
      }\r
      // Force process termination.\r
      p.destroy();\r
      // Check again if process remains alive\r
      alive = p.isAlive();\r
      // Get the process exit value\r
      int status = p.exitValue();        \r
   }\r
}\r
\`\`\`\r
\r
::: info Cdigos de terminacin\r
Un cdigo de salida (exit code o a veces tambin return code) es el valor que un proceso le devuelve a su proceso padre para indicarle cmo ha acabado. Si un proceso acaba con un valor de finalizacin 0 es que todo ha ido bien, cualquier otro valor entre 1 to 255 indica alguna causa de error.\r
:::\r
\r
::: question Actividad psp.activities.U2A3_ExitValue\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A3_ExitValue y como clase principal psp.activities.U2A3_ExitValue).\r
Prepara un programa que ejecute varios comandos (notepad, calc, comandos shell) uno detrs de otro, de forma secuencial y haz que tu programa obtenga el cdigo de finalizacin de cada uno de ellos.\r
Para cada programa imprime el nombre y su cdigo de finalizacin.\r
\r
Prueba a poner aplicaciones que no existan o comandos con parmetros incorrectos.\r
\r
Qu hace Netbeans si pones System.exit(10) para acabar tu programa?. Fjate en la consola.\r
Qu hace Netbeans si pones System.exit(0) para acabar tu programa.?\r
Cul es entonces el valor por defecto?\r
:::\r
\r
::: details Solucin de U2A3_ExitValue\r
\r
\`\`\`java\r
public class U2A3_ExitValue {\r
\r
    public static void main(String[] args) {\r
        do {\r
            // Cdigo para pedir un programa/comando a ejecutar\r
            Scanner teclado = new Scanner(System.in);\r
            System.out.println("Introduce el programa / comando que quieres ejecutar (intro para acabar): ");\r
            String comando = teclado.nextLine();\r
            \r
            if (comando.equals("")) System.exit(0);\r
\r
            try {\r
                // Preparamos el entrono de ejecucin del proceso\r
                // Como no sabemos el contenido del comando, forzamos su conversin\r
                // a una lista para que no haya problemas con su ejecucin\r
                ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
\r
                // Lanzamos el proceso hijo\r
                Process p = pb.start();          \r
\r
                // Esperamos a que acabe para recoger el valor de salida\r
                int exitValue = p.waitFor();\r
\r
                if (exitValue == 0) {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
                } else {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Cdigo (" + exitValue + ")");\r
                }\r
\r
            } catch (InterruptedException | IOException ex) {\r
                System.err.println(ex.getLocalizedMessage());\r
                ex.printStackTrace();\r
            }                       \r
        } while (true);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
::: danger Gestin de excepciones\r
La llamada al mtodo **waitFor** hace que el proceso padre se bloquee hasta que el proceso hijo termina o bien hasta que el bloqueo es interrumpido por alguna seal del sistema (Excepcin) que recibe el proceso padre.\r
\r
Es mejor gestionar las excepciones lo ms cerca posible del origen en vez de pasarlas a niveles superiores.\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.3 Lanzar una clase Java como proceso desde otra clase java en el mismo proyecto\r
\r
Para las actividades os pedir que programis tanto el proceso padre como el proceso hijo. Para hacer eso, una de las clases tendr que lanzar a la otra.\r
\r
Para hacer esto, ambas clases deben tener un mtodo main. As que en las propiedades del proyecto Netbeans deberemos seleccionar cul de las clases se ejecutar primero, normalmente la clase \`Lanzador o Launcher\` (proceso padre).\r
\r
![Seleccionar clase principal](../../media/unit2/seleccionmain.png)\r
\r
Antes de que una clase pueda lanzar a otra, al menos la segunda (proceso hijo) debe estar compilada, es decir, el archivo .class debe haberse creado dentro del directorio build/classes.\r
\r
![Seleccionar directorio de trabajo ](../../media/unit2/comandotree.png)\r
\r
Entonces y slo entonces, previa configuracin de los parmetros de ejecucin del proceso tal y como se muestra en el ejemplo, se podr ejecutar una clase desde otra.\r
\r
::: info Directorio de trabajo\r
\r
Si nos fijamos en la estructura de directorios de un proyecto y entendemos cmo se invocan unas clases a otras, entenderemos porqu el directorio de trabajo debe ser *build/classes*.\r
\r
En Java, cuando se ejecuta una clase \`java paquete.clase\`, la MV Java espera encontrar los directorios que forman el paquete (psp/u2/actividad10) a partir del punto donde se est invocando el comando. Por eso, para que pueda encontrar la clase (el archivo .class), debemos ubicarnos previamente en el directorio \`build/classes\`\r
\`\`\`java\r
// Prepare the environment and the command\r
ProcessBuilder pb = new ProcessBuilder("java", "psp.u2.actividad10.Sumador");\r
pb.directory(new File("build/classes"));\r
Process p = pb.start();\r
\`\`\`\r
\r
:::\r
\r
::: question Actividad psp.activities.U2A4_Lanzador\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A3_Lanzador y como clase principal psp.activities.*U2A4_Lanzador*).\r
\r
Ahora, en el mismo proyecto y dentro del mismo paquete crea otra clase, U2A4_Lanzado, con un mtodo main que recibir el nombre del programa que debe ejecutar como parmetro del mtodo main(args). Haz que esta aplicacin cree un nuevo proceso para ejecutar el programa recibido como parmetro.\r
\r
La clase terminar devolviendo como cdigo de finalizacin el que el programa lanzado le haya devuelto a ella.\r
\r
> Mtodo System.exit()\r
>\r
> * Cero. El cdigo cero debe devolverse cuando la ejecucin del proceso haya ido bien, esto es, que ha terminado su ejecucin sin problemas.\r
> * Distinto de cero. AUn cdigo distinto de cero indica una terminacin con errores. Java nos permite usar cdigos diferentes para los diferentes tipos de error.\r
\r
Por ltimo, podemos hacer que U2A4_Lanzador pregunte al usuario qu aplicacin quiere ejecutar y pasrsela a la clase U2A4_Lanzado.\r
\r
En Lanzador recoge el cdigo de finalizacin de Lanzado y muestra un mensaje indicando si el proceso termin bien o con errores.\r
:::\r
\r
::: details Solucin de U2A4_Lanzador\r
\r
\`\`\`java\r
public class U2A4_Launcher {\r
\r
    public static void main(String[] args) {\r
\r
        // Cdigo para pedir un programa/comando a ejecutar\r
        Scanner teclado = new Scanner(System.in);\r
        System.out.println("Introduce el programa / comando que quieres ejecutar: ");\r
        String comando = teclado.nextLine();\r
\r
        try {\r
            // Preparamos el entrono de ejecucin del proceso\r
            // Como no sabemos el contenido del comando, forzamos su conversin\r
            // a una lista para que no haya problemas con su ejecucin\r
            comando = "java psp.activities.U2A4_Commander " + comando;\r
            ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
            pb.directory(new File("build/classes"));\r
\r
            // Lanzamos el proceso hijo\r
            Process p = pb.start();          \r
\r
            // Esperamos a que acabe para recoger el valor de salida\r
            int exitValue = p.waitFor();\r
\r
            if (exitValue == 0) {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
            } else {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Cdigo (" + exitValue + ")");                \r
            }\r
        } catch (InterruptedException | IOException ex) {\r
            System.err.println(ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }                       \r
    }\r
}\r
\r
public class U2A4_Commander {\r
\r
    public static void main(String[] args) throws Exception {       \r
        // Lectura de informacin desde los parmetros de entrada \r
        // Se supone que recibimos: args[0] args[1] args[2] ..... args[args.length-1 --> comando a ejecutar\r
        String comando = "";\r
        for (int i = 0; i < args.length; i++) {\r
            comando += args[i] + " ";\r
        }\r
        comando.trim();\r
                \r
        ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));            \r
\r
        // Lanzamos el proceso hijo\r
        Process p = pb.start();          \r
\r
        // Esperamos a que acabe para recoger el valor de salida\r
        int exitValue = p.waitFor();\r
\r
        System.exit(exitValue);\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
::: warning Programacin de clases "hijas"\r
Debemos tener en cuenta que una clase se puede ejecutar de forma independiente o puede ser llamada desde otro proceso.\r
\r
Por eso, el cdigo de las clases, hijas o padres, se hace sin tener en cuenta cmo van a ser llamadas. Debe ser **independiente** tal y como lo son unos procesos de otros.\r
\r
As, en el anterior proyecto yo podra ejecutar la clase psp.activities.U2A4_Commander de forma independiente, pasndole el nombre de los programas.\r
\r
Puedo hacerlo invocndola desde lnea de comandos o desde Netbeans:\r
- java psp.activities.U2A4_Commander programa1 programa2 programa3\r
- En las propiedades del proyecto, en el apartado Run, seleccionando U2A4_Commander como clase principal y poniendo como Arguments: programa1 programa2 programa3\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.4 Informacin de los procesos en Java\r
\r
Una vez que un proceso est en ejecucin podemos obtener informacin acerca de ese proceso usando los mtodos de la clase \`java.lang.ProcessHandle.Info\`:\r
\r
* el comando usado para lanzar el proceso\r
* Los argumentos/parmetros que recibi el proceso\r
* El instante de tiempo en el que se inici el proceso\r
* El tiempo de CPU que ha usado el proceso y el usuario que lo ha lanzado\r
\r
### Obtener informacin desde el propio proceso\r
\r
Aqu tenemos un sencillo ejemplo de cmo hacerlo para obtener informacin del proceso actual.\r
\r
\`\`\`java{2-3}\r
// Get information about the current process\r
ProcessHandle processHandle = ProcessHandle.current();\r
ProcessHandle.Info processInfo = processHandle.info();\r
\r
System.out.println("PID: " + processHandle.pid());\r
System.out.println("Arguments: " + processInfo.arguments());\r
System.out.println("Command: " + processInfo.command());\r
System.out.println("Instant: " + processInfo.startInstant());\r
System.out.println("Total CPU duration: " + processInfo.totalCpuDuration());\r
System.out.println("User: " + processInfo.user());\r
\`\`\`\r
\r
### Obtener informacin de un proceso lanzado\r
\r
En el ejemplo anterior hemos obtenido la informacin del proceso actual (\`ProcessHandle.current()\`), as que si estamos en el proceso padre, slo podemos mostrar su informacin, pero no la de su hijo.\r
\r
Tambin es posible acceder a la informacin de un proceso lanzado (proceso hijo). En este caso necesitamos la instancia de \`java.lang.Process\` para llamar a su mtodo \`toHandle()\` y obtener la instancia de  \`java.lang.ProcessHandle\` del proceso hijo..\r
\r
\`\`\`java{3-4}\r
// Get information about a child process from parent\r
Process process = processBuilder.inheritIO().start();\r
ProcessHandle childProcessHandle = process.toHandle();\r
ProcessHandle.Info childProcessInfo = childProcessHandle.info();\r
\`\`\`\r
\r
A partir de ah, el cdigo para acceder a la informacin y detalles del proceso hijo es idntico al ejemplo anterior.\r
`]},{title:"2.1 Creacin de procesos en Java con Runtime",headers:[{level:2,title:"2.1.1. Creacin rpida de procesos",slug:"_2-1-1-creacion-rapida-de-procesos",link:"#_2-1-1-creacion-rapida-de-procesos",children:[]},{level:2,title:"2.1.2 Propiedades del sistema y comandos del sistema",slug:"_2-1-2-propiedades-del-sistema-y-comandos-del-sistema",link:"#_2-1-2-propiedades-del-sistema-y-comandos-del-sistema",children:[]}],path:"/es/unit2/runtime.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.1 Creacin de procesos en Java con Runtime\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Creacin de procesos con Java con Runtime" />\r
\r
# 2.1. Creacin rpida de procesos con Java con Runtime\r
\r
[[toc]]\r
\r
## 2.1.1. Creacin rpida de procesos\r
\r
La clase java.lang.Runtime se usa principalmente para interactuar con el JRE de Java. Esta clase proporciona mtodos para lanzar procesos, llamar al recolector de basura (Garbage Collector), saber la cantidad de memoria disponible y libre, etc.\r
\r
> [Especificacin java.lang.Runtime](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html)\r
\r
Cada aplicacin en Java tiene acceso a una nica instancia de *java.lang.Runtime* a travs del mtodo \`Runtime.getRuntime()\` que devuelve la instancia **singleton** de la clase Runtime.\r
\r
::: question Patrones de diseo: Singleton\r
Qu son los patrones de diseo? Qu es y para qu se usa el patrn de diseo singleton?\r
\r
Investiga cmo realizar una clase que siga el patrn de diseo singleton.\r
\r
[Refactoring.Guru Patrones de diseo](https://refactoring.guru/es/design-patterns/java)\r
:::\r
\r
El mtodo que nos interesa a nosotros para la creacin de procesos es\r
\r
> public Process exec(String command) throws IOException\r
\r
Veamos un ejemplo sencillo de uso de este mtodo\r
\r
\`\`\`java\r
public static void main(String[] args) throws IOException {\r
    // Launch notepad app\r
    Runtime.getRuntime().exec("notepad.exe");\r
\r
    // This way always works\r
    // String separator = System.getProperty("file.separator");\r
    // Runtime.getRuntime()\r
    //    .exec("c:"+separator+"windows"+separator+"notepad.exe");\r
\r
    // This way used to work (UNIX style paths)\r
    // Runtime.getRuntime().exec("c:/windows/notepad.exe");\r
}\r
\`\`\`\r
\r
Se puede observar que en el parmetro que pasamos al mtodo \`exec\` indicamos el programa que queremos ejecutar. En este caso, como el *notepad* se encuentra en el PATH del sistema, no es necesario indicar la ruta donde se encuentra el programa. En otro caso, s tendramos que hacerlo.\r
\r
<div class="pagebreak"></div>\r
\r
## 2.1.2 Propiedades del sistema y comandos del sistema\r
\r
Si tenemos pensado desarrollar aplicaciones que funcionen en diferentes SO tendremos que enfrentarnos a la problemtica del funcionamiento diferente de los distintos SO.\r
\r
Vamos a ver algunos ejemplos que pueden servir como gua para otros problemas similares a los expuestos.\r
\r
::: danger File separator\r
Para indicar las rutas en un sistema los sistemas UNIX emplean el caracter  **/** como separador mientras que los sistemas Windows usan el caracter **\\\\** . En resumen, / en *X y \\ en Windows.\r
\r
Cmo podemos hacer entonces que nuestras aplicaciones sean independientes del SO en el que se ejecutan?\r
\r
Para este tipo de cuestiones vamos a utilizar de forma recurrente las propiedades del sistema mediante \`System.getProperty(String propName)\`. Estas propiedades se configuran con el propio sistema operativo, aunque las podemos modificar usando los parmetros de ejecucin de la mquina virtual\r
\r
> String separator = System.getProperty("file.separator");\r
\r
o\r
\r
> -Dfile.separator\r
\r
Aunque siempre es una buena prctica usar el caracter **/** en las rutas ya que Java es capaz de convertirlas al sistema en el que se ejecuta.\r
:::\r
\r
Si lo que queremos es ejecutar un comando del SO, tenemos que hacerlo, al igual que si lo hacemos manualmente, a travs del shell del sistema, donde volvemos a encontrar la dicotoma entre sistemas UNIX y sistemas Windows.\r
\r
Vamos a ver el cdigo que, a travs de las propiedades del sistema, nos permite obtener un listado de los archivos existentes en la carpeta personal del usuario.\r
\r
\`\`\`java\r
// Primero obtenemos la carpeta del usuario\r
String homeDirectory = System.getProperty("user.home");\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info Modo shell no interactivo\r
Como se puede observar, tanto para Windows como UNIX se ha usado el modificador **c** del comando. Este modificador indica que se abra un shell, se ejecute el comando recibido y se cierre el proceso del shell.\r
:::\r
\r
A continuacin podemos ver un ejemplo de respuesta ante la pulsacin de un botn, en una app grfica, para abrir una pgina en el navegador. Tenemos cmo se hara en sistemas *X y comentado una de las formas de hacerlo en Windows.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Vamos a crear nuestro primer programa en Java, que no va a ser tan sencillo como pueda parecer\r
\r
Usando mtodos de las clases System y Runtime hacer un programa que muestre\r
\r
- todas las propiedades establecidas en el sistema operativo y sus valores.\r
- memoria total, memoria libre, memoria en uso y los procesadores disponibles\r
\r
Mira los mtodos que proporcionan las clases Runtime  y system. Intenta obtener una lista u otra estructura de datos que te permita recorrer las propiedades para ir mostrando sus nombres y valores.\r
:::\r
\r
::: details Solucin propuesta para la actividad anterior\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
:::\r
\r
::: info Formato numrico\r
Todos los lenguajes de programacin tienen varias formas de mostrar la informacin al usuario. Cuando se trata de mostrar informacin a a travs de la consola, tenemos un par de alternativas para formatear la informacin numrica.\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Si usamos la clase NumberFormat o cualquiera de sus descendientes podemos controlar con bastante precisin cmo se vern los nmeros, usando patrones.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Si usamos hashes en vez de ceros permitimos que .30 se vea como 0.3\r
// (los dgitos adicionales son opcionales)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Heredado de la sintaxis de la funcin printf de C, podemos utilizar la sintaxis de java.util.Formatter para configurar cmo ser visualizada la informacin.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// % rellena con hasta 10 posiciones los nmeros\r
// para justificarlos a la derecha.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
:::\r
\r
::: info Usando colores en la salida por consola\r
\r
Hay una forma sencilla de mostrar informacin por consola usando diferentes colores. Os dejo un ejemplo de cdigo con la definicin de algunos colores y la forma de usarlos.\r
\r
\`\`\`java:no-line-numbers\r
public class UsarColoresEnConsola {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hola" \r
                            + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Adis" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
`]},{title:"3.4 Mecanismos alternativos de sincronizacin",headers:[{level:2,title:"3.4.1. Semforos",slug:"_3-4-1-semaforos",link:"#_3-4-1-semaforos",children:[]},{level:2,title:"3.4.2. Mecanismos de alto nivel",slug:"_3-4-2-mecanismos-de-alto-nivel",link:"#_3-4-2-mecanismos-de-alto-nivel",children:[{level:3,title:"Colas concurrentes",slug:"colas-concurrentes",link:"#colas-concurrentes",children:[]},{level:3,title:"Colecciones concurrentes",slug:"colecciones-concurrentes",link:"#colecciones-concurrentes",children:[]},{level:3,title:"Variables atmicas",slug:"variables-atomicas",link:"#variables-atomicas",children:[]}]},{level:2,title:"3.4.3 Executors, Callables y Future",slug:"_3-4-3-executors-callables-y-future",link:"#_3-4-3-executors-callables-y-future",children:[]}],path:"/es/unit3/alternatives.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.4 Mecanismos alternativos de sincronizacin\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.4 Mecanismos alternativos de sincronizacin" />\r
\r
# 3.4 Mecanismos alternativos de sincronizacin\r
\r
[[toc]]\r
\r
## 3.4.1. Semforos\r
\r
Otro posible mecanismo para sincronizar hilos son los \`semforos\`. Un semforo es un mecanismo para permitir, o restringir, el acceso a recursos compartidos en un entorno de multiprocesamiento, con varios hilos ejecutndose de forma concurrente.\r
\r
> Especificacin de [java.util.concurrent.Semaphore](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html)\r
\r
Los semforos se emplean para permitir el acceso a diferentes partes de programas (llamados secciones crticas) donde se manipulan variables o recursos que deben ser accedidos de forma especial. Segn el valor con que son inicializados se permiten a ms o menos procesos utilizar el recurso de forma simultnea.\r
\r
El funcionamiento de los semforos se basa en el uso de dos mtodos, as como en el valor inicial \`permits\` con el que se crea el semforo:\r
\r
- release(): Ejecutado por un hilo para liberar el semforo cuando el hilo ha terminado de ejecutar la seccin crtica. Por defecto se incrementa la variable \`permits\` en 1, aunque puede recibir un valor e incrementarla en esa cantidad.\r
- acquire(): Ejecutado por un hilo para acceder al semforo. Para que un hilo pueda tomar el control del semforo y no quedarse bloqueado, la variable \`permits\`debe tener un valor mayor que cero. Tambin puede recibir un valor, por lo que \`permits\` tendr que ser mayor que dicho valor.\r
- permits: Se inicializa a la cantidad de recursos existentes o hilos que queramos que puedan acceder simultneamente. As, cada proceso, al ir solicitando un recurso, verificar que el valor del semforo sea mayor de 0; si es as es que existen recursos libres, seguidamente acaparar el recurso y restar el valor del semforo.\r
Cuando el semforo alcance el valor 0, significar que todos los recursos estn siendo utilizados, y los procesos que quieran solicitar un recurso debern esperar a que el semforo sea positivo (algn hilo haga un release).\r
\r
:::info Mutex\r
Un tipo simple de semforo es el binario, que puede tomar solamente los valores 0 y 1.\r
\r
Se inicializan en 1 y son usados cuando slo un proceso puede acceder a un recurso a la vez. Se les suele llamar mutex.\r
\r
Tienen un funcionamiento similar a synchronized, funcionando en exclusin mutua (**mut**ual **ex**clusion).\r
:::\r
\r
Veamos un ejemplo en el que varios Productores y Consumidores acceden de forma simultnea a un objeto compartido\r
\r
\`\`\`java {class="line-numbers",5-7,13,15,20,27,37,39,44,51}\r
public class Almacen {\r
\r
  private final int MAX_LIMITE = 20;\r
  private int producto = 0;\r
  private Semaphore productor = new Semaphore(MAX_LIMITE);\r
  private Semaphore consumidor = new Semaphore(0);\r
  private Semaphore mutex = new Semaphore(1);\r
\r
  public void producir(String nombreProductor) {\r
    System.out.println(nombreProductor + " intentando almacenar un producto");\r
    try {\r
        // En el ejemplo, hasta 20 productores pueden acceder a la vez      \r
        productor.acquire();\r
        // Sin embargo, slo 1 (consumidor/productor) a la vez podr actualizar \r
        mutex.acquire();\r
\r
        producto++;\r
        System.out.println(nombreProductor + " almacena un producto. "\r
            + "Almacn con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
      \r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // El productor permite que un consumidor pueda acceder\r
      consumidor.release();\r
    }\r
\r
  }\r
\r
  public void consumir(String nombreConsumidor) {\r
    System.out.println(nombreConsumidor + " intentando retirar un producto");\r
    try {\r
        // En el ejemplo siempre tiene que llegar un consumidor antes que un productor\r
        consumidor.acquire();\r
        // Sin embargo, slo 1 (consumidor/productor) a la vez podr actualizar \r
        mutex.acquire();\r
\r
        producto--;\r
        System.out.println(nombreConsumidor + " retira un producto. "\r
            + "Almacn con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // El consumidor avisa para que un productor pueda volver a dejar productos.\r
      productor.release();\r
\r
    }\r
  }\r
\r
}\r
\`\`\`\r
\r
## 3.4.2. Mecanismos de alto nivel\r
\r
Java, en su paquete \`java.util.concurrent\` proporciona varias clases \`thread-safe\` que nos permiten acceder a los elementos de colecciones y tipos de datos sin preocuparnos de la concurrencia.\r
\r
Es un paquete muy amplio que contiene multitud de clases que podemos utilizar en nuestros desarrollos multihilo para simplificar la complejidad de los mismos.\r
\r
### Colas concurrentes\r
\r
La interfaz **BlockingQueue** define una cola \`FIFO\` que bloquea hilos que intentan extraer un elemento si la cola est vaca, hasta que vuelva a haber elementos. Tambin permite establecer un nmero mximo de elementos, de marea que se bloquean los procesos cuando intentan aadir por encima de ese lmite, a la espera que se extraigan.\r
\r
Las clases LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue y DelayQueue implementan la interfaz BlockingQueue.\r
\r
### Colecciones concurrentes\r
\r
El uso de colecciones simultneas es una forma recomendada de crear estructuras de datos compatibles con procesos. Dichas colecciones incluyen ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArraylist y CopyOnWriteArraySet.\r
\r
**ConcurrentMap** es una subinterfaz de \`java.util.Map\` con operaciones atmicas para eliminar o reemplazar pares clave/valor existentes o aadir pares clave/valor no existentes. ConcurrentHashMap es la versin thread-safe anloga a HashMap.\r
\r
### Variables atmicas\r
\r
El paquete \`java.util.concurrent.atomic\` incluye clases que proporcionan acciones atmicas sobre tipos de datos bsicos. Tenemos AtomicBoolean, AtomicInteger, AtomicDouble, .... y proporcionan mtodos para recuperar su valor, incrementar, decrementar, etc.\r
\r
## 3.4.3 Executors, Callables y Future\r
\r
Existen muchas aproximaciones y libreras que permiten el uso y gestin de hilos desde un programa. Una de las que nos ofrece Java como parte del JDK es la interfaz Executors.\r
\r
\`Executors\` nos va a permitir definir un pool de threads (un conjunto de hilos) que se encargarn de ejecutar las tareas, pero con un lmite en cuanto al nmero de hilos creados y gestionando  la JVM la cola de hilos que sern ejecutados en ese pool.\r
\r
Se sale del mbito de este mdulo estudiar y analizar el funcionamiento de Executors y todas sus posibilidades. Aqu os dejo un enlace a un artculo que lo explica con un ejemplo muy ilustrativo.\r
\r
[Executors: Ejemplo supermercado](https://jarroba.com/multitarea-e-hilos-en-java-con-ejemplos-ii-runnable-executors/)\r
\r
\`Callable\` viene a poner solucin a uno de los problemas que tenemos con la interfaz Runnable, la posibilidad de devolver un valor desde este mtodo.\r
\r
Si se necesita que un proceso devuelva datos al finalizar, se debe crear una clase que implemente la interfaz Callable y defina un mtodo \`call()\` que desempee la misma funcin que run() en Runnable. En este caso se tendrn que crear los procesos de forma diferente; la clase Thread no acepta un objeto Callable como argumento. Por contra, la clase Executors ofrece diversos mtodos estticos que crean un proceso a partir de su clase Callable.\r
\r
\`Future\` es una interfaz que implementa el objeto que devuelve el resultado de la ejecucin de un Callable. Se puede seguir ejecutando una aplicacin hasta que necesite obtener el resultado del hilo *Callable*, momento en el que se invoca el mtodo get() en la instancia Future. Si el resultado ya est disponible se recoge y en caso contrario se bloquear en la llamada hasta que su mtodo call() devuelva el resultado.\r
`]},{title:"3.6 Anexo II - ArrayList hoja de referencia de los alumnos",headers:[{level:2,title:"A. Definicin y creacin",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de ArrayList",slug:"a-1-constructores-de-arraylist",link:"#a-1-constructores-de-arraylist",children:[]}]},{level:2,title:"B. Mtodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creacin de un ArrayList",slug:"b-1-creacion-de-un-arraylist",link:"#b-1-creacion-de-un-arraylist",children:[]},{level:3,title:"B.2. Aadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si un elemento ya existe",slug:"b-3-comprobar-si-un-elemento-ya-existe",link:"#b-3-comprobar-si-un-elemento-ya-existe",children:[]},{level:3,title:"B.4. Acceder a un elemento del ArrayList",slug:"b-4-acceder-a-un-elemento-del-arraylist",link:"#b-4-acceder-a-un-elemento-del-arraylist",children:[]},{level:3,title:"B.5. Otras funciones de utilidad",slug:"b-5-otras-funciones-de-utilidad",link:"#b-5-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Aadir datos a un ArrayList",slug:"c-anadir-datos-a-un-arraylist",link:"#c-anadir-datos-a-un-arraylist",children:[{level:3,title:"C.1. Aadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Aadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Aadir / eliminar elementos desde cdigo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la coleccin",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el mtodo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Bsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Bsqueda usando los mtodos de la clase",slug:"e-1-busqueda-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Bsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Bsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Bsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtencin de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenacin de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar usando mtodos de Collection",slug:"g-1-ordenar-usando-metodos-de-collection",link:"#g-1-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.2. Ordenar con expresiones lambda",slug:"g-2-ordenar-con-expresiones-lambda",link:"#g-2-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.3. Ordenar con API Stream",slug:"g-3-ordenar-con-api-stream",link:"#g-3-ordenar-con-api-stream",children:[]}]}],path:"/es/unit3/arraylist_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.6 Anexo II - ArrayList hoja de referencia de los alumnos\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Anexo II - ArrayList hoja de referencia de los alumnos" />\r
\r
# 3.6 Anexo II - ArrayList hoja de referencia de los alumnos\r
\r
::: info Autora\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del mdulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informacin a la que podris acceder durante los exmenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definicin y creacin\r
\r
Una coleccin representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacn donde poder guardarlos. En Java, se emplea la interfaz genrica \`Collection\` para este propsito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de mtodos comunes, como pueden ser: aadir, eliminar, obtener el tamao de la coleccin.\r
\r
Partiendo de la interfaz genrica Collection extienden otra serie de interfaces genricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
La clase ArrayList en Java permite almacenar datos en memoria de forma similar a los Arrays con la ventaja de que el numero de elementos que almacena lo hace de forma dinmica, es decir, que no es necesario declarar su tamao como pasa con los Arrays. Los elementos pueden aadirse o eliminarse segn necesidad.\r
\r
### A.1. Constructores de ArrayList\r
\r
ArrayList proporciona 3 constructores que definen la capacidad inicial de la coleccin o si la inicializamos a partir de los valores de otra coleccin.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de ArrayList vaca.\r
ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\r
// ArrayList(int initialCapacity). Crea una instancia de ArrayList con una capacidad inicial especificada. \r
ArrayList<Persona> listaPersonas = new ArrayList<>(10);\r
\r
// ArrayList(Collection c). Crea una instancia de ArrayList a partir de otra coleccin de datos. Los datos se aaden en el orden en el que el Iterator de la otra coleccin los recorra.\r
ArrayList<Persona> listaPersonas = new ArrayList<>(c);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Mtodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendramos con la ejecucin de estos mtodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garca", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martnez", 65, 1.84d, 82, "Hombre");\r
  Persona p3 = new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre");\r
  Persona p4 = new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer");\r
\`\`\`\r
\r
### B.1. Creacin de un ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un ArrayList de Personas\r
  ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\`\`\`\r
\r
### B.2. Aadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Aadir un objeto Persona al final del ArrayList\r
  listaPersonas.add(p1);\r
\r
  // Aade el elemento al ArrayList en la posicin 'n+1'. \r
  // Cuidado, no podemos insertar en posiciones que no existen.\r
  listaPersonas.add(1, p1);\r
  \r
  // Borra el elemento de la posicin 'n+1' del ArrayList   \r
  // Cuidado, no podemos eliminar de posiciones que no existen.\r
  listaPersonas.remove(2);\r
\r
  // Borra el primer objeto pasado encontrado en el ArrayList que se le pasa como parmetro.  \r
  listaPersonas.remove(p1);  \r
\`\`\`\r
\r
::: info Duplicados\r
Si ya existe un elemento en el ArrayList, esta coleccin no controla la existencia de duplicados, por lo que tendremos el mismo objeto en dos posiciones diferentes.\r
Podemos evitarlo comprobando previamente si ya existe ese objeto, como veremos a continuacin.\r
:::\r
\r
### B.3. Comprobar si un elemento ya existe\r
\r
\`\`\`java:no-line-numbers\r
  // Comprueba si existe del objeto que se le pasa como parmetro\r
  listaPersonas.contains(p4);\r
\r
  // Devuelve la posicin del primer objeto pasado encontrado en el ArrayList  \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.indexOf(p1);\r
\r
  // Devuelve la posicin del ltimo objeto pasado en el ArrayList   \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### B.4. Acceder a un elemento del ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el elemento que esta en la posicin 'n+1' del ArrayList\r
  listaPersonas.get(2);\r
\`\`\`\r
\r
### B.5. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el numero de elementos del ArrayList\r
  listaPersonas.size();\r
\r
  //Borra todos los elementos de ArrayList   \r
  listaPersonas.clear();\r
\r
  // Devuelve true si el ArrayList esta vaco. Sino Devuelve false   \r
  listaPersonas.isEmpty();\r
\r
  // Pasa el ArrayList a un Array \r
  Object[] array = listaPersonas.toArray();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Aadir datos a un ArrayList\r
\r
::: info Orden de los elementos en un ArrayList\r
Cuando aadimos elementos a un ArrayList, el orden de insercin se conserva.\r
\r
Una Lista, por definicin, siempre mantiene el orden de los elementos. Esto no es solo para ArrayList, sino para todo tipo de listas como LinkedList, Vector, y el resto de clases que implementan el interfaz \`java.util.List\` .\r
\r
:::\r
\r
### C.1. Aadir elementos desde el constructor\r
\r
A la hora de crear el ArrayList, podemos aadirle datos, usando la sintaxis del doble corchete o bien con la construccin List.of o Arrays.asList\r
\r
\`\`\`java:no-line-numbers\r
  // Crea una nueva lista y a la vez la inicializa con valores  \r
  ArrayList<Persona> lista1 = new ArrayList<>() {{\r
      add(p1);\r
      add(p2);\r
  }};\r
\r
  // En este caso indicamos los valores como si de parmetros se tratase\r
  // De esta forma podemos aadir hasta un mximo de 10 elementos\r
  ArrayList<Persona> lista2 = new ArrayList<>(\r
        List.of(p1, p2, p3)\r
  );\r
\r
  // De forma similar al caso anterior, con una construccin a partir de un Array\r
  ArrayList<Persona> lista3 = new ArrayList<>(\r
        Arrays.asList(p1, p2, p3)\r
  );       \r
\`\`\`\r
\r
### C.2. Aadir elementos desde otras colecciones\r
\r
Podemos inicializar un ArrayList, como hemos visto en los ejemplos anteriores, desde varios tipos de colecciones (listas) que poseen caractersticas similares.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del cdigo anterior, creamos un nuevo ArrayList a partir de lista2\r
  ArrayList<Persona> lista4 = new ArrayList<>(lista3);  \r
  \r
  // Aade todos los elementos de la lista que indiquemos como argumento al final del ArrayList\r
  lista4.addAll(lista3);\r
\r
  // Hace lo mismo, pero lo inserta en la posicin indicada (debe existir al menos la posicin anterior)  \r
  lista4.addAll(lista3,2);\r
\`\`\`\r
\r
### C.3. Aadir / eliminar elementos desde cdigo\r
\r
\`\`\`java:no-line-numbers\r
  // Aadir un elemento al final de la lista\r
  lista4.add(p4);\r
  // Aade un elemento en la posicin indicada. El elemento que ocupaba esa posicin y todos los que haba detrs, se mueven una posicin a la derecha.\r
  // En el ejemplo, inserta p1 al principio de la lista.\r
  lista4.add(0,p1);   // Inserta p1 al principio de la lista.\r
  \r
  // Eliminar un elemento. Si existe lo elimina y devuelve true, si no devuelve false\r
  boolean existe = lista4.remove(p1);  \r
  // Eliminar un elemento por ndice. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = lista4.remove(2);  \r
  // Elimina del ArrayList todos aquellos elementos que coinciden con los indicados en la lista que pasamos como argumento \r
  lista4.removeAll(lista3);\r
  // Elimina del ArrayList todos aquellos elementos que cumplen con el predicado (la condicin) descrita como argumento en el mtodo e indicada como expresin lambda\r
  lista4.removeIf(p->p.getEdad()<18);   // Elimina los menores de 18\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la coleccin\r
\r
Vamos a preparar un ArrayList para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList creation\r
  ArrayList<Persona> grupoPersonas = new ArrayList<>() {{\r
    add(new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
    add(new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
    add(new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
    add(new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
    add(new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
    add(new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\r
\`\`\`\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por ndice\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(i));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el ArrayList es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : coleccin)\r
\r
\`\`\`java:no-line-numbers\r
    // Obtenemos un objeto de tipo Persona en cada iteracin del bucle\r
    for (Persona p: grupoPersonas) {\r
        System.out.println(p);\r
    }\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una coleccin y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un mtodo iterator() que devuelve una instancia de Iterator para recorrer la coleccin.\r
\r
Iterator tiene 4 mtodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento ms en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el ltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la accin indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la lista\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el mtodo forEach con expresiones lambda\r
\r
En este caso aprovechamos el mtodo foreach de las colecciones para poder realizar una accin concreta sobre cada uno de los elementos de la misma.\r
\r
De forma similar al bucle foreach, indicamos un elemento de la lista y la accin a realizar sobre el mismo\r
\r
\`\`\`java:no-line-numbers\r
  // Para cada persona (p) -> Accin a realizar\r
  grupoPersonas.forEach(p -> System.out.println(p));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin\r
\r
Mientras se est recorriendo una coleccin, no con todos los tipos de bucles se puede modificar (aadir/eliminar elementos) de la coleccin. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendramos problemas. Al acceder por ndice, podemos aadir o eliminar elementos mientras se recorre la coleccin.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.get(i).getNombre().equals("Jordi")) {\r
      grupoPersonas.remove(i);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Persona p : grupoPersonas) {\r
    if (p.getPeso()>100) {\r
      grupoPersonas.remove(p);\r
    }\r
    System.out.println("Eliminada: " + p);\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Siempre que usemos el mtodo remove de Iterator para eliminar elementos de la coleccin mientras la recorremos, podremos hacerlo sin que se genere ninguna excepcin.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Persona> iterator = grupoPersonas.iterator();\r
  while (iterator.hasNext()) {\r
    Persona p = iterator.next();\r
    if (p.getAltura() < 100) {\r
      // Si borramos usando iterator.remove funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el mtodo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.forEach((p) -> {if (p.getNombre().equals("Jordi")) grupoPersonas.remove(p);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la coleccin, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Bsqueda de elementos\r
\r
Para buscar elementos en un ArrayList hay distintas formas de hacerlo. Desde los propios mtodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Bsqueda usando los mtodos de la clase\r
\r
La clase ArrayList nos ofrece diferentes alternativas para buscar y/o saber si un elemento est presente en la coleccin. As, podemos usar los mtodos\r
\r
\`\`\`java:no-line-numbers\r
  // Comprobar si est el objeto en la coleccin\r
  boolean existe = grupoPersonas.contains(p1);\r
  // O simplemente obtener su posicin, si lo encuentra\r
  grupoPersonas.indexOf(p1);\r
  grupoPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### E.2. Bsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la coleccin hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> it = grupoPersonas.iterator();\r
  while (it.hasNext()) {\r
    Persona p = it.next();\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado: " + p);\r
      break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Bsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado:: " + p);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Bsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestin de las colecciones.\r
Podemos emplear varios mtodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcoleccin\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
\r
  // Obtener un subarray con los elementos que cumplan el criterio\r
  grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList());\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);   \r
  }\r
\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuntos cumplen el criterio de bsqueda\r
  grupoPersonas.stream().filter(p -> p.getAltura() > 170).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Persona> first = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .findFirst();\r
\r
  // Obtener cualquiera que cumpla el criterio, o null si no hay ninguno\r
  Persona any = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)                \r
          .findAny()\r
          .orElse(null);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtencin de subcolecciones\r
\r
Lo podemos considerar un tipo especial de bsqueda en el que el objetivo es conseguir una coleccin con los elementos que cumplan un determinado criterio.\r
\r
As, la forma de buscar es idntica a la del apartado anterior, pero en este caso lo que obtendremos de esa bsqueda ser una nueva lista con un subconjunto de elementos de la original\r
\r
### F.1. Subcolecciones usando bucles\r
\r
Para obtener los elementos podemos aplicar lo aprendido en el anterior punto. Buscaremos elemento a elemento y, cuando se cumpla una condicin especificada, aadiremos los elementos encontrados a una nueva coleccin.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas = new ArrayList<>();\r
  for (Persona p : grupoPersonas) {\r
    if (p.getNombre().startsWith("M")) {\r
      personas.add(p);\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
La idea es similar al punto anterior\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas2 = new ArrayList<>();\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().startsWith("M")) {\r
      personas2.add(p);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener directamente una subcoleccin mediante el filtrado, haciendo subconjuntos y guardando el resultado.\r
\r
Con API Stream podemos guardar el resultado usando diferentes formas de .collect, que darn como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList de Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas3 = (ArrayList<Persona>) grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toList());\r
\r
  // Conjunto de Personas cuyo nombre empieza por "M"\r
  Set<Persona> personas4 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toSet());\r
  \r
  // Mapa de Personas cuyo nombre empieza por "M"\r
  // En la construccin del mapa, hay que elegir un campo que sirva de clave\r
  Map<String, Persona> personas5 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toMap(Persona::getApellidos, Function.identity()));\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenacin de elementos\r
\r
### G.1. Ordenar usando mtodos de Collection\r
\r
Si lo que queremos es tener el conjunto ordenados, la forma ms fcil es ordenarla usando el mtodo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Ordena segn el mtodo compareTo sobrescrito al implementar el interfaz Comparable\r
  // Si no se ha implementado, ordena segn el orden natural\r
  Collections.sort(grupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(grupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su mtodo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos ms adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.2. Ordenar con expresiones lambda\r
\r
De esta forma no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparacin que queremos hacer como parmetro del mtodo sort.\r
\r
As podemos tener distintas formas de ordenar, segn nos convenga.\r
\r
\`\`\`java:no-line-numbers\r
  // Indicamos la comparacin que queremos hacer. Podemos usar compareTo \r
  Collections.sort(grupoPersonas, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(grupoPersonas);      \r
\r
  // o bien podemos definir nuestro propio comparador\r
  Collections.sort(grupoPersonas, (p1, p2) -> {\r
    String nombreCompleto1 = p1.getApellidos() + ", " + p1.getNombre();\r
    String nombreCompleto2 = p2.getApellidos() + ", " + p2.getNombre();\r
    return nombreCompleto1.compareTo(nombreCompleto2);\r
});\r
\`\`\`\r
\r
### G.3. Ordenar con API Stream\r
\r
Con API Stream usamos tambin el mtodo sorted para indicar qu comparacin se debe realizar. Tenemos varias opciones en funcin del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el ms flexible es aquel en el que indicamos, mediante una expresin lambda, qu comparacin realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en una nueva lista con los elementos ordenados\r
  ArrayList<Persona> grupoPersonasOrdenado = (ArrayList<Persona>) grupoPersonas.stream()\r
          // En este caso ordenamos por apellido, ascendente.\r
          .sorted((p1, p2) -> p1.getApellidos().compareTo(p2.getApellidos()))\r
          // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
          //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
          .collect(Collectors.toList());\r
\`\`\`\r
\r
::: info Encadenar mtodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcoleccin con los resultados.\r
\r
Es lo ms parecido que vamos a encontrar a una consulta SQL para los datos de una coleccin cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantneas, sin lugar a bugs, con muy poco cdigo.\r
:::\r
`]},{title:"3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans",headers:[],path:"/es/unit3/debugger_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans" />\r
\r
# 3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans\r
\r
Los entornos de desarrollo Java proporcionan las herramientas necesarias para la depuracin (debugging) de aplicaciones multihilo.\r
\r
Al igual que en aplicaciones monohilo, podemos ubicar los breakpoints en el punto en el que nos interese detener la ejecucin del programa, para de esta forma poder inspeccionar el estado de los objetos, los valores de las propiedades, etc.\r
\r
Para poder monitorizar los hilos de un programa, debemos activar la ventana de Debugging desde el menu *Window > Debugging > Debugging (Alt+Shift +9)*\r
\r
![Activar thread debug](../../media/unit3/NetbeansDebug1.jpg)\r
\r
A partir de ese momento podremos ver la parte derecha las opciones de depuracin de hilos junto con toda la informacin de los hilos que se estn ejecutando en nuestra aplicacin.\r
\r
Veamos el significado de lo que Netbeans nos muestra en esta caja de dilogo\r
\r
![Dilogo depuracin threads](../../media/unit3/NetbeansDebug2.jpg)\r
\r
- Con una franja de color verde a la izquierda y resaltado tambin en color verde vemos lo que Netbeans denomina el *current thread*, es decir, el hilo que estamos depurando y sobre el que se aplicarn las acciones de depuracin como Step Into, StepOver, Pause, Continue, etc. Adems, podremos inspeccionar el valor de las variables para ese hilo en concreto.\r
- Con una franja de color amarillo en la parte izquierda, y relacionado con el aviso de la parte inferior, vemos los hilos que estn parados en algn breakpoint marcado por nosotros. Este color y los avisos estn para que atendamos al hilo y podamos visualizar su estado o continuar con su ejecucin.\r
- En la parte derecha de cada hilo tenemos un acceso rpido a la funcin de Reanudar o Pausar cada uno de los threads activos.\r
  \r
![Cambio de hilo](../../media/unit3/NetbeansDebug3.jpg)\r
\r
Pulsando con el botn derecho sobre cualquiera de los hilos podemos convertirlo en el *current thread*. As pasamos a controlar la ejecucin e inspeccin de ese hilo mientras los dems siguen pausados o bien continuan su ejecucin.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug4.jpg)\r
\r
Adems, la rueda dentada que est al lado del identificador de cada hilo nos d informacin del estado del hilo.\r
\r
- Cuando la rueda est de color naranja indica que el hilo est suspendido en espera de nuestra atencin.\r
- Cuando la rueda est verde, indica que el hilo est en ejecucin. Si ponemos el ratn encima podemos obtener informacin de su estado. Como se puede observar en la imagen, el hilo 2 est en ejecucin aunque se encuentra en estado de espera. Es un hilo que est bloqueado en un join.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug5.jpg)\r
\r
Por ltimo, la depuracin de hilos tambin nos ayuda a detectar cmo los hilos estn sincronizndose con el uso de monitores. Podemos ver si un hilo tiene un monitor (bloqueo) bajo su control, y qu hilos estn esperando a que se libere un bloqueo para poder continuar.\r
\r
Como herramienta adicional, Netbeans nos proporciona una utilidad (*Debug > Check for deadlocks*) que comprueba si hay hilos que estn en un interbloqueo, informndonos de los monitores que tienen bajo su control y de los monitores para los que estn realizando alguna espera.\r
`]},{title:"3.7 Anexo III - HashMap hoja de referencia de los alumnos",headers:[{level:2,title:"A. Definicin y creacin",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de HashMap",slug:"a-1-constructores-de-hashmap",link:"#a-1-constructores-de-hashmap",children:[]}]},{level:2,title:"B. Mtodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creacin de un HashMap",slug:"b-1-creacion-de-un-hashmap",link:"#b-1-creacion-de-un-hashmap",children:[]},{level:3,title:"B.2. Aadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si una clave o un valor existen",slug:"b-3-comprobar-si-una-clave-o-un-valor-existen",link:"#b-3-comprobar-si-una-clave-o-un-valor-existen",children:[]},{level:3,title:"B.4. Acceder a las partes del mapa",slug:"b-4-acceder-a-las-partes-del-mapa",link:"#b-4-acceder-a-las-partes-del-mapa",children:[]},{level:3,title:"B.5. Acceder a un elemento del mapa",slug:"b-5-acceder-a-un-elemento-del-mapa",link:"#b-5-acceder-a-un-elemento-del-mapa",children:[]},{level:3,title:"B.6. Otras funciones de utilidad",slug:"b-6-otras-funciones-de-utilidad",link:"#b-6-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Aadir datos a un HashMap",slug:"c-anadir-datos-a-un-hashmap",link:"#c-anadir-datos-a-un-hashmap",children:[{level:3,title:"C.1. Aadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Aadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Aadir / eliminar elementos desde cdigo",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la coleccin",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el mtodo forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Bsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Bsqueda por clave o usando los mtodos de la clase",slug:"e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Bsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Bsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Bsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtencin de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenacin de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar por clave",slug:"g-1-ordenar-por-clave",link:"#g-1-ordenar-por-clave",children:[]},{level:3,title:"G.2. Ordenar usando mtodos de Collection",slug:"g-2-ordenar-usando-metodos-de-collection",link:"#g-2-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/es/unit3/hashmap_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.7 Anexo III - HashMap hoja de referencia de los alumnos\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.7 Anexo III - HashMap hoja de referencia de los alumnos" />\r
\r
# 3.7 Anexo III - HashMap hoja de referencia de los alumnos\r
\r
::: info Autora\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del mdulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la informacin a la que podris acceder durante los exmenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definicin y creacin\r
\r
Una coleccin representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacn donde poder guardarlos. En Java, se emplea la interfaz genrica \`Collection\` para este propsito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de mtodos comunes, como pueden ser: aadir, eliminar, obtener el tamao de la coleccin.\r
\r
Partiendo de la interfaz genrica Collection extienden otra serie de interfaces genricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
Un HashMap bsicamente designa claves nicas para los valores correspondientes que se pueden recuperar en cualquier punto dado, es decir, nos permite almacenar elementos asociando a cada clave un valor.\r
\r
Para cada clave tenemos un valor asociado. Podemos despus buscar fcilmente un valor para una determinada clave. Las claves en el diccionario no pueden repetirse.\r
\r
### A.1. Constructores de HashMap\r
\r
HashMap proporciona 4 constructores que definen la capacidad inicial de la coleccin y en qu momento debe redimensionarse. Son parmetros para mejorar el rendimiento en el uso del HashMap.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de HashMap con una capacidad inicial de 16 y un factor de carga de 0,75.\r
HashMap<Integer, String> hm1 = new HashMap<>(); \r
\r
// HashMap(int initialCapacity). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga de 0,75. \r
HashMap<Integer, String> hm1 = new HashMap<>(10); \r
\r
// HashMap(int initialCapacity, float loadFactor). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga especificados. \r
HashMap<Integer, String> hm1 = new HashMap<>(5, 0.75f); \r
\r
//HashMap(Mapa de mapas) . Crea una instancia de HashMap con las mismas asignaciones que el mapa especificado. \r
HashMap<Integer, String> hm1 = new HashMap<>();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Mtodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendramos con la ejecucin de estos mtodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "Garca", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martnez", 65, 1.84d, 82, "Hombre");\r
\`\`\`\r
\r
### B.1. Creacin de un HashMap\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un HashMap con claves de tipo String y valores de tipo Persona\r
  HashMap<String,Persona> DNIs = new HashMap<>();\r
\`\`\`\r
\r
### B.2. Aadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Element.put(k,v) - Aade un par clave-valor al mapa.\r
  DNIs.put("390543M",p);\r
  // Element.remove(Object key) - Removes the key and his value.\r
  DNIs.remove("298423Z");// Will remove (390543M, p1) from the map.\r
\`\`\`\r
\r
::: warning Clave ya existente\r
Si ya existe un elemento con la misma clave en el mapa, el mtodo put reemplaza el valor existente por el nuevo.\r
Podemos evitarlo comprobando previamente si ya existe esa clave o con el mtodo **DNIs.putIfAbsent(k,v)**.\r
:::\r
\r
### B.3. Comprobar si una clave o un valor existen\r
\r
\`\`\`java:no-line-numbers\r
  // Element.containsKey(Key)  Comprueba si existe la clave dada\r
  DNIs.containsKey("390543M");\r
  // Element.containsValue(Value)  Comprueba si existe el valor dado asociado a alguna clave\r
  DNIs.containsValue(p2);\r
\`\`\`\r
\r
### B.4. Acceder a las partes del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.keySet() - Obtiene el conjunto de claves del mapa\r
  Set<String> claves = DNIs.keySet();\r
  // Element.values() - Obtiene el conjunto de valores almacenados en el mapa\r
  Collection<Persona> valores = DNIs.values();\r
  // Element.entrySet() - Obtiene el conjunto de pares clave-valor del mapa\r
  Set<Entry<String,Persona>> tuplas = DNIs.entrySet();\r
\`\`\`\r
\r
### B.5. Acceder a un elemento del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.get(Key) - Obtiene el valor asociado a la clave\r
  Persona p = DNIs.get("390543")\r
\`\`\`\r
\r
### B.6. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Element.size() - Devuelve el nmero de elementos en el mapa\r
  int size = DNIs.size();\r
  //Element.clear() - Elimina todas las asignaciones y vaca el mapa\r
  DNIs.clear();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Aadir datos a un HashMap\r
\r
::: info Orden de los elementos en el HashMap\r
Cuando aadimos elementos a una HashMap, el orden de insercin no se conserva. Internamente, para cada elemento, se genera un hash separado y los elementos se indexan en funcin de este hash para hacerlo ms eficiente. Antes de aadir un elemento, como se ha avisado antes, es recomendable comprobar si ya existe para no sustituirlo\r
:::\r
\r
### C.1. Aadir elementos desde el constructor\r
\r
A la hora de crear el Hashmap, podemos aadirle datos, usando la sintaxis del doble corchete o bien con la construccin Map.of\r
\r
\`\`\`java:no-line-numbers\r
  // Crea un nuevo mapa y a la vez lo inicializa con valores  \r
  HashMap<String, Persona> map1 = new HashMap<>() {{\r
    put("390543M", p1);\r
    put("298423Z", p2);\r
  }};\r
  // En este caso indicamos los pares clave valor como si de un array se tratase\r
  // De esta forma podemos aadir hasta un mximo de 10 elementos\r
  HashMap<String, Persona> map2 = new HashMap<>(\r
    Map.of("390543M", p1, "298423Z", p2)\r
  );\r
\`\`\`\r
\r
### C.2. Aadir elementos desde otras colecciones\r
\r
Al ser una coleccin compuesta por una clave y un valor, la inicializacin se limita a los tipos de colecciones que tienen una estructura similar.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del cdigo anterior, creamos un nuevo mapa a partir de map2\r
  HashMap<String, Persona> map3 = new HashMap<>(map2);\r
  // O bien copiando todos los pares clave-valor\r
  map3.putAll(map2);  \r
\`\`\`\r
\r
### C.3. Aadir / eliminar elementos desde cdigo\r
\r
\`\`\`java:no-line-numbers\r
  // Aadir y si existe la clave reemplazarlo\r
  DNIs.put("390543M", p1);\r
  // Aadir slo si la clave no existe\r
  DNIs.putIfAbsent("390543M", p1);\r
  // Eliminar un elemento. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = map3.remove("390543M");  \r
  // Eliminar un par clave-valor. Si existe la tupla, la elimina y devuelve true, si no devuelve false\r
  boolean existe = map3.remove("390543M", p1);  \r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la coleccin\r
\r
Vamos a preparar un HashMap para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap creation\r
  HashMap<String, Persona> grupoPersonas = new HashMap<>() {{\r
          put("12345678A", new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
          put("23456789B", new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
          put("34567890C", new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
          put("45678901D", new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
          put("56789012E", new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
          put("67890123F", new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\`\`\`\r
\r
::: info Tipos de valores\r
Vamos a mostrar ejemplos de cmo recorrer cada uno de los elementos que componen el HashMap, claves, valores y pares clave-valor.\r
\r
.entrySet() - devuelve el conjunto de pares clave-valor\r
\r
.keySet() - devuelve el conjunto de claves\r
\r
.values() - devuelve la coleccin de valores\r
:::\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por ndice, por lo que vamos a necesitar una forma de obtener el ndice (i) de cada elemento para recorrer el HashMap.\r
\r
En este caso, vamos a usar el ndice de la clave, a travs del mtodo toArray.\r
\r
::: warning Orden de los elementos en el HashMap\r
Es importante recordar y tener en cuenta que los elementos en un HashMap se ordenan automticamente en base a una funcin Hash (resumen) que permite realizar una bsqueda muy rpida sobre la clave. Por lo tanto, no podemos esperar que el recorrido por ndice coincida con el orden en el que los elementos se aaden al mapa.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(map.keySet().toArray()[i]));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el HashMap es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : coleccin)\r
\r
\`\`\`java:no-line-numbers\r
  // Recorremos la estructura obteniendo la tupla (k,v) en cada iteracin\r
  for (Map.Entry<String, Persona> entry : grupoPersonas.entrySet()) {\r
        System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\r
  }\r
\`\`\`\r
\r
o bien para ir mostrando las claves\r
\r
\`\`\`java:no-line-numbers\r
  for (String key : grupoPersonas.keySet()) {\r
    System.out.println("DNI = " + key);\r
  }\r
\`\`\`\r
\r
o los valores\r
\r
\`\`\`java:no-line-numbers\r
  for (Person value : grupoPersonas.values()) {\r
    System.out.println("Value = " + value);\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una coleccin y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un mtodo iterator() que devuelve una instancia de Iterator para recorrer la coleccin.\r
\r
Iterator tiene 4 mtodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento ms en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el ltimo elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la accin indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la coleccin\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.values().iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el mtodo forEach con expresiones lambda\r
\r
En este caso aprovechamos el mtodo foreach de las colecciones para poder realizar una accin concreta sobre cada uno de los elementos de la misma\r
\r
\`\`\`java:no-line-numbers\r
  // Pares (clave,valor)\r
  grupoPersonas.forEach((k,v) -> System.out.println("Clave: " + k + ", Values: " + v));\r
  // Claves\r
  grupoPersonas.keySet().forEach(k -> System.out.println("Clave: " + k));\r
  // Valores\r
  grupoPersonas.values().forEach(v -> System.out.println("Values: " + v));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la coleccin\r
\r
Mientras se est recorriendo una coleccin, no con todos los tipos de bucles se puede modificar (aadir/eliminar elementos) de la coleccin. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendramos problemas. Al acceder por ndice, podemos aadir o eliminar elementos mientras se recorre la coleccin.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.keySet().toArray()[i].equals("23456789B")) {\r
      grupoPersonas.remove(grupoPersonas.entrySet().toArray()[i]);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Map.Entry<String, Persona> p : grupoPersonas.entrySet()) {\r
    if (p.getKey().equals("34567890C")) {\r
      personas.remove(p.getKey());\r
    }\r
    System.out.println("Clave: " + p.getKey() + " Valor: " + p.getValue().toString());\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Si usamos el mtodo remove para eliminar elementos de la coleccin mientras la recorremos, podremos hacerlo sin que se genere ninguna excepcin.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Entry<String, Persona>> iterator = grupoPersonas.entrySet().iterator();\r
  while (iterator .hasNext()) {\r
    Map.Entry<String, Persona> p = (Map.Entry<String, Persona>) iterator.next();\r
    if (p.getKey().equals("12345678A")) {\r
      // Si borramos usando iterator.remove o el mtodo remove(key) de HashMap, funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el mtodo forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, slo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la coleccin.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.keySet().forEach((k) -> {if (k.equals("34567890C")) grupoPersonas.remove(k);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la coleccin, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.values().forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Bsqueda de elementos\r
\r
Para buscar elementos en un HashMap hay distintas formas de hacerlo. Desde los propios mtodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Bsqueda por clave o usando los mtodos de la clase\r
\r
La clase HashMap nos ofrece diferentes alternativas para buscar y/o saber si un elemento est presente en la coleccin. As, podemos usar los mtodos\r
\r
\`\`\`java:no-line-numbers\r
  // A partir de una clave, obtener el valor\r
  grupoPersonas.get("34567890C");\r
  // O simplemente comprobar si existe esa clave o ese valor antes de buscarlo\r
  grupoPersonas.containsKey("34567890C");\r
  grupoPersonas.containsValue(person);\r
\`\`\`\r
\r
### E.2. Bsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la coleccin hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
  Iterator<Map.Entry<String, Persona>> it = grupoPersonas.entrySet().iterator();\r
  while (it.hasNext()) {\r
    Map.Entry<String, Persona> entry = it.next();\r
    if (((Persona)entry.getValue()).getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + entry.getKey() + ", Value: " +\r
      entry.getValue());\r
    break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Bsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
  grupoPersonas.forEach((k, v) -> {\r
    if (v.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + k + ", Value: " + v);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Bsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestin de las colecciones.\r
Podemos emplear varios mtodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcoleccin\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber ms de un elemento que cumpla el criterio de bsqueda\r
\r
  // Obtener un submapa con los elementos que cumplan el criterio\r
  grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("abc"))\r
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Entry<String, Persona> p : grupoPersonas.entrySet().stream()\r
      .filter(k -> k.getKey().equals("abc"))\r
      .collect(Collectors.toList())) {\r
          System.out.println(p.getValue());   // Sacamos el valor de la tupla <clave,valor>\r
  }\r
\r
  for (Persona p : grupoPersonas.entrySet().stream()\r
      .filter((k) -> k.getKey().equals("98761234D"))\r
      .map(Map.Entry::getValue)         // Cogemos slo los valores del entryMap\r
      .collect(Collectors.toList())) {\r
          System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuntos cumplen el criterio de bsqueda\r
  grupoPersonas.entrySet().stream().filter(k -> k.getKey().equals("abc")).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Entry<String,Persona>> s = grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("6780123F"))\r
    .findFirst();\r
  \`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtencin de subcolecciones\r
\r
Lo podemos considerar un tipo especial de bsqueda en el que el objetivo es conseguir una coleccin con los elementos que cumplan un determinado criterio.\r
\r
As, la forma de buscar es idntica a la del apartado anterior, pero en este caso lo que obtendremos de esa bsqueda ser un nuevo tipo de coleccin, no necesariamente otro HashMap.\r
\r
### F.1. Subcolecciones usando bucles\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String,Persona> personas2 = new HashMap<String,Persona>();\r
  for (Entry<String, Persona> e : grupoPersonas.entrySet()) {\r
    if(e.getKey().endsWith("F")) {\r
      personas2.put(e.getKey(), e.getValue());\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
En este ejemplo obtenemos un nuevo HashMap, pero tambin podramos guardar la informacin en un ArrayList o en cualquier otro tipo de estructura.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas2 = new HashMap<String, Persona>();\r
  grupoPersonas.forEach((k, v) -> {\r
    if (k.endsWith("F")) {\r
      grupoPersonas2.put(k, v);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener diferentes tipos de subcolecciones. Con API Stream podemos filtrar, hacer subconjuntos y guardar el resultado usando diferentes formas de .collect, que darn como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap de Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas3 = (HashMap<String, Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // Lista de Personas cuyo DNI acaba en "F"\r
  List<Persona> listaPersonas3 = (List<Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toList());\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenacin de elementos\r
\r
::: danger HashMap no garantiza el orden de los elementos\r
Como ya hemos comentado anteriormente, un HashMap es una estructura de datos en la que el orden de los elementos no est garantizado. Es por eso que si queremos mantener una copia ordenada de los elementos, deberemos recurrir a otros tipos de colecciones que s garantizan el orden.\r
:::\r
\r
### G.1. Ordenar por clave\r
\r
Hay un tipo especial de map, TreeMap, en el que los elementos se ordenan siguiendo el orden natural de las claves. Por lo tanto es la opcin ideal si queremos tener los elementos ordenados por clave.\r
\r
\`\`\`java:no-line-numbers\r
  // As podemos recorrer el TreeMap y mostrar los elementos ordenados por clave\r
  TreeMap<String, Persona> grupoPersonasOrdenado = new TreeMap<>(grupoPersonas);\r
 \r
  Iterator it=grupoPersonasOrdenado.keySet().iterator();\r
  while(it.hasNext())\r
  {\r
    int key=(int)itr.next();\r
    System.out.println("Key: "+key+" Element: "+hashMap.get(key));\r
  }\r
\`\`\`\r
\r
### G.2. Ordenar usando mtodos de Collection\r
\r
Si lo que queremos es tener el conjunto de claves o valores ordenados por separado, la forma ms fcil es obtener una lista y ordenarla usando el mtodo sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Para las claves\r
  List<String> clavesGrupoPersonas = new ArrayList<>(grupoPersonas.keySet());\r
  Collections.sort(clavesGrupoPersonas);\r
\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas = new ArrayList<>(grupoPersonas.values());\r
  // Ordena segn el mtodo compareTo sobrescrito al implementar el interfaz Comparable\r
  Collections.sort(valoresGrupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(valoresGrupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su mtodo \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos ms adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
Si usamos una lista, no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparacin que queremos hacer como parmetro del mtodo sort\r
\r
\`\`\`java:no-line-numbers\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas2 = new ArrayList<>(grupoPersonas.values());\r
  // Indicamos la comparacin que queremos hacer. Podemos usar compareTo o definir\r
  // nuestro propio comparador\r
  Collections.sort(valoresGrupoPersonas2, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(valoresGrupoPersonas2);      \r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos tambin el mtodo sorted para indicar qu comparacin se debe realizar. Tenemos varias opciones en funcin del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el ms flexible es aquel en el que indicamos, mediante una expresin lambda qu comparacin realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en un LinkedHashMap que s garantiza el orden\r
  Map<String, Persona> sortedMap = grupoPersonas.entrySet().stream()\r
      // En este caso ordenamos por apellido, ascendente.\r
      .sorted((e1, e2) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
      //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\r
\`\`\`\r
\r
::: info Encadenar mtodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcoleccin con los resultados.\r
\r
Es lo ms parecido que vamos a encontrar a una consulta SQL para los datos de una coleccin cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantneas, sin lugar a bugs, con muy poco cdigo.\r
:::\r
`]},{title:"3 Introduccin",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit3/",pathLocale:"/es/",extraFields:[`---\r
title: 3 Introduccin\r
---\r
\r
# Tema 3. Programacin multihilo\r
\r
Tras aprender los conceptos bsicos de la programacin concurrente y ver cmo los procesos pueden colaborar para conseguir multitarea, en este tema vamos a poner la mirada dentro de un proceso.\r
\r
La ejecucin de un proceso comienza con un nico hilo, pero se pueden crear ms sobre la marcha. Los distintos hilos de un mismo proceso comparten:\r
\r
- El espacio de memoria asignado al proceso\r
- La informacin de acceso a ficheros (incluyendo stdin, stdout y stderr).\r
\r
Las caractersticas anteriores son las que los diferencias de los procesos. En cambio, cada hilo tiene sus propios valores para\r
\r
- Los registros del procesador\r
- El estado de su pila (stack), donde entre otras cosas se almacenan las variables locales.\r
  \r
Por lo tanto, vamos a utilizar los threads para realizar programacin concurrente y/o paralela dentro de un proceso.\r
\r
Aunque los hilos se ejecutan en el contexto de un procesos, cada uno tiene su TCB (Tread Control Block) que es sensiblemente ms pequeos que el PCB (Process Control Block) porque entre los hilos comparten gran parte de ese PCB. Por eso veremos que a los hilos tambin se le llama \`lightweight processes\` (procesos ligeros) y por tanto los cambios de contexto en el procesador son mucho menos costosos para los hilos que para los procesos.\r
\r
::: warning Hilos: comunicacin vs sincronizacin \r
Por todo lo comentado, el intercambio de informacin entre hilos es sencillo, dado que los distintos hilos de un mismo proceso comparten la memoria asignada al proceso.\r
\r
Sin embargo, los hilos deben coordinarse para el acceso a los contenidos de la memoria y a los ficheros, lo cual hace que esa coordinacin y sincronizacin sea la parte complicada de uso.\r
\r
De eso va este tema.\r
:::\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Conocer las tcnicas bsicas para desarrollar aplicaciones multihilo en Java\r
- Crear y lanzar varios hilos que compartan informacin\r
- Depurar aplicaciones multihilo\r
- Usar los mtodos de sincronizacin para procesos y subprocesos\r
- Compartir informacin entre los hilos de un proceso\r
- Aprender acerca de los problemas de acceso a memoria compartida\r
- Usar diferentes tcnicas de programacin para sincronizar la ejecucin de los threads.\r
`]},{title:"3.3 Modelo productor-consumidor",headers:[{level:2,title:"3.3.1. Esquema de sincronizacin y comunicacin de hilos",slug:"_3-3-1-esquema-de-sincronizacion-y-comunicacion-de-hilos",link:"#_3-3-1-esquema-de-sincronizacion-y-comunicacion-de-hilos",children:[]},{level:2,title:"3.3.2 Clase Principal",slug:"_3-3-2-clase-principal",link:"#_3-3-2-clase-principal",children:[]},{level:2,title:"3.3.3 Clase Productor y Consumidor",slug:"_3-3-3-clase-productor-y-consumidor",link:"#_3-3-3-clase-productor-y-consumidor",children:[]},{level:2,title:"3.3.4 Clase Compartida. Sincronizacin de hilos",slug:"_3-3-4-clase-compartida-sincronizacion-de-hilos",link:"#_3-3-4-clase-compartida-sincronizacion-de-hilos",children:[]}],path:"/es/unit3/producer-consumer.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.3 Modelo productor-consumidor\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.3 Modelo productor-consumidor" />\r
\r
# 3.3 Modelo productor-consumidor\r
\r
[[toc]]\r
\r
## 3.3.1. Esquema de sincronizacin y comunicacin de hilos\r
\r
La sincronizacin de threads implica disponer de mecanismos que permitan asegurar que no se producen situaciones de \`inanicin o starvation\` (bloqueo de hilos como consecuencia del acceso a recursos compartidos limitados), \`interbloqueos\` (espera por parte de los hilos cuando una condicin no puede ser satisfecha) y que, por lo tanto, se opera de forma correcta con los recursos compartidos por hilos concurrentes.\r
\r
En esta seccin vamos a ejemplificar la comparticin de recursos a travs de un objeto contenedor (objeto compartido) mediante el famoso algoritmo del Productor-Consumidor que podemos ver resumido en [Wikipedia](https://es.wikipedia.org/wiki/Problema_productor-consumidor).\r
\r
Si no se implementasen medidas de control, ya hemos visto que podran darse situaciones anmalas como:\r
\r
- El consumidor puede obtener los elementos producidos ms de una vez, excediendo la produccin del mismo (poder dejar la cuenta en nmeros rojos en el ejemplo del banco, o que un lector pueda leer un libro antes de estar terminado).\r
- El productor sea ms rpido que el Consumidor y genere ms informacin de la que el sistema pueda almacenar, o bien parte de la informacin que genere se pierda sin que un Consumidor la haya recuperado.\r
- El Consumidor sea ms rpido que el Productor y puede terminar consumiendo dos o ms veces el mismo valor, generando informacin inconsistente en el sistema.\r
\r
Todas estas circunstancias son las que conocemos como condiciones de carrera o \`race conditions\`.\r
\r
El esquema de clases representado por este modelo se repite fielmente entre los diferentes ejercicios que vamos a realizar, es lo que denominamos el modelo Productor-Consumidor.\r
\r
![Producer-Consumer](./../../media/unit3/ProducerConsumer.png)\r
\r
Este modelo se basa en tres clases, aunque dependiendo del problema, podemos encontrarnos que no tenemos **productor** o **consumidor**.\r
\r
::: info Modelo como patrn de diseo\r
Es importante que nos ajustemos al esquema presentado en el modelo.\r
\r
Como ya se ha dicho, a veces no habr productor, otras no estar el consumidor, en otras el cdigo de bloqueo estar slo en una de las clases, pero no debemos inventar ni aadir nada al esquema, debemos encajar el problema a solucionar dentro del cdigo proporcionado.\r
:::\r
\r
## 3.3.2 Clase Principal\r
\r
> La clase principal siempre va a tener la misma estructura. El siguiente cdigo se puede usar como plantilla\r
\r
En esta clase se declara el objeto o propiedad que van a compartir el productor y el consumidor. Este objeto es a travs del que se realiza la comunicacin, sincronizacin e intercambio de informacin entre los hilos.\r
\r
Aqu se representa como un objeto, aunque puede ser una Coleccin o cualquier estructura de datos que puedan compartir los hilos.\r
\r
\`\`\` java {4,5,6}\r
public class ClasePrincipal { \r
\r
    public static void main(String[] args) {    \r
        ClaseCompartida objetoCompartido = new ClaseCompartida();\r
        Productor productor  = new Productor(objetoCompartido);\r
        Consumidor consumidor  = new Consumidor(objetoCompartido);\r
        productor.start();\r
        consumidor.start();\r
\r
        // No es obligatorio, pero en ocasiones puede interesar que la ClasePrincipal\r
        // espere a que acaben los hilos\r
        productor.join();\r
        consumidor.join();\r
\r
        // Acciones a realizar una vez hayan acabado el productor y el consumidor\r
    }\r
    \r
}\r
\`\`\`\r
\r
::: warning Nmero de hilos por tipo\r
En el ejemplo se crea un hilo de cada tipo. Esto no tiene porqu ser as.\r
\r
Cada problema determinar el nmero de hilos *Productores* y *Consumidores* necesarios, por lo que ser en este mtodo main, o en algn otro mtodo de la *ClasePrincipal* donde se realice la gestin de los hilos.\r
\r
De igual forma, depender de cada problema si el hilo principal debe esperar a que el resto finalice o no.\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.3 Clase Productor y Consumidor\r
\r
> Por otro lado vamos a tener la clase del **productor** y del **consumidor** que se encargan de realizar las llamadas necesarias a los mtodos del objeto compartido que reciben como parmetro.\r
\r
Estas dos clases son las que van a tener, dentro del mtodo **run**, la lgica de la aplicacin, accediendo al objeto compartido, modificando las propiedades compartidas entre los diferentes hilos (productores y/o consumidores) y actualizando el estado del objeto compartido para que module su funcionalidad.\r
\r
\`\`\` java {2,5,15}\r
public class Consumidor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Consumidor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecucin del mtodo run estar normalmente gestionada por un bucle\r
        // que controlar el ciclo de vida del hilo y se adaptar al problema.\r
        // En el caso de simulaciones se harn esperas proporcionales.\r
        try {\r
            // Cdigo que hace el hilo consumidor\r
            objetoCompartido.accionDeConsumir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
}    \r
\`\`\`\r
\r
\`\`\` java {2,5,15}\r
public class Productor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Productor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecucin del mtodo run estar normalmente gestionada por un bucle\r
        // que controlar el ciclo de vida del hilo y se adaptar al problema.\r
        // En el caso de simulaciones se harn esperas proporcionales.\r
        try {\r
            // Cdigo que hace el hilo productor\r
            objetoCompartido.accionDeProducir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
} \r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.4 Clase Compartida. Sincronizacin de hilos\r
\r
 El modelo se completa con la clase compartida. Aqu vamos a crear los mtodos a los que acceden productores y consumidores y, adems, vamos a realizar la sincronizacin entre hilos para que no se produzcan \`condiciones de carrera\`.\r
\r
\`\`\` java {2,9,11,14,21,25,28,30,33,40,44}\r
public class ClaseCompartida {\r
    int valorAccedidoSimultaneamente;\r
    \r
    ClaseCompartida() {\r
        // Se inicializa el valor\r
        this.valorAccedidoSimultaneamente = 0;\r
    }\r
\r
    public synchronized void accionDeConsumir() {\r
        // Si no se cumple la condicin para poder consumir, el consumidor debe esperar\r
        while (valorAccedidoSimultaneamente == 0) {\r
            try {\r
                System.out.println("Consumidor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar la gestin de la Interrupcin\r
            }\r
        }\r
                \r
        // Cuando se ha cumplido la condicin para consumir, el consumidor consume\r
        valorAccedidoSimultaneamente--;\r
        System.out.printf("Se ha consumido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
    \r
    public synchronized void accionDeProducir () {\r
        // Si no se cumple la condicin para poder producir, el productor debe esperar\r
        while (valorAccedidoSimultaneamente > 10) {\r
            try {\r
                System.out.println("Productor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizar la gestin de la Interrupcin                \r
            }\r
        }\r
        \r
        // Cuando se ha cumplido la condicin para producir, el productor produce\r
        valorAccedidoSimultaneamente++;\r
        System.out.printf("Se ha producido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
}\r
\`\`\`\r
\r
Lo interesante del cdigo anterior, como ya hemos visto con anterioridad, es la pareja de mtodos \`wait / notifyAll\`, junto con el modificador \`synchronized\`.\r
\r
- Cuando se llama a un mtodo **synchronized** este mtodo se ejecuta s y solo s no hay otro hilo ejecutando otro mtodo **synchronized** \`del mismo objeto\`. Si se diese ese caso, el hilo se quedar en espera hasta que otro hilo libere el monitor. En ese momento todos los hilos que estn esperando se despiertan y slo uno de ellos, el que consigue el monitor, puede ejecutar el cdigo **synchronized" en exclusin mutua.\r
- Cuando se hace una llamada al mtodo **wait**, un hilo se queda en espera y, adems, libera el bloqueo del monitor. El hilo se quedar en espera hasta que otro hilo ejecute una llamada de sealizacin (**notify/notifyAll**).\r
- Cuando se hace una llamada al mtodo **notify** o **notifyAll**, uno o todos los hilos que estn en espera por haber hecho **wait** se despiertan y pasan a esperar poder tomar el control del bloqueo del **synchronized**. A partir de ese momento, de forma aleatoria, uno de ellos o de los que ya estaban en la cola del bloqueo **synchronized** toma el control y o bien empieza o bien sigue ejecutndose por donde se qued (en caso de que hubiese llamado a **wait**).\r
  \r
> Con los mtodos **wait**, **notify/notifyAll** y los bloques de cdigo **synchronized** se consigue evitar que varios hilos puedan modificar a la vez una variable *(Ver lneas 21 y 40 del ejemplo anterior)*.\r
\r
::: info Resumen del modelo Productor-Consumidor\r
El modelo Productor-Consumidor original trabaja con un buffer en el que el Productor va depositando informacin y el Consumidor la va sacando, de forma que el buffer nunca se llene ni se pueda leer si est vaco.\r
\r
En nuestro ejemplo, lo hemos simplificado al uso de una variable que nunca puede exceder el valor de 10 ni ser inferior a 0.\r
\r
Como ya hemos dicho, esa variable puede ser cualquier tipo de dato, y el cdigo de las clases variar en funcin de ello, para adaptarlo al problema y al control del tipo de dato utilizado.\r
\r
Adems, las condiciones o estados que se utilizan para las esperas y las actualizaciones ser lo que nosotros, como programadores, tengamos que adaptar al modelo para hacerlo funcionar en situaciones diferentes.\r
:::\r
`]},{title:"3.1. Clases Java para la gestin de hilos",headers:[{level:2,title:"3.1.1. El interfaz Runnable",slug:"_3-1-1-el-interfaz-runnable",link:"#_3-1-1-el-interfaz-runnable",children:[{level:3,title:"Clase Java que implementa la interfaz Runnable",slug:"clase-java-que-implementa-la-interfaz-runnable",link:"#clase-java-que-implementa-la-interfaz-runnable",children:[]},{level:3,title:"Implementacin con clase annima de la interfaz Runnable",slug:"implementacion-con-clase-anonima-de-la-interfaz-runnable",link:"#implementacion-con-clase-anonima-de-la-interfaz-runnable",children:[]},{level:3,title:"Implementacin de Runnable a travs de una expresin Lambda",slug:"implementacion-de-runnable-a-traves-de-una-expresion-lambda",link:"#implementacion-de-runnable-a-traves-de-una-expresion-lambda",children:[]},{level:3,title:"Llamar al mtodo run de una clase que implemente Runnable",slug:"llamar-al-metodo-run-de-una-clase-que-implemente-runnable",link:"#llamar-al-metodo-run-de-una-clase-que-implemente-runnable",children:[]}]},{level:2,title:"3.1.2 Thread subclass",slug:"_3-1-2-thread-subclass",link:"#_3-1-2-thread-subclass",children:[]},{level:2,title:"3.1.3 Starting a Thread With a Runnable",slug:"_3-1-3-starting-a-thread-with-a-runnable",link:"#_3-1-3-starting-a-thread-with-a-runnable",children:[{level:3,title:"Subclass or Runnable?",slug:"subclass-or-runnable",link:"#subclass-or-runnable",children:[]}]},{level:2,title:"3.1.4 Mtodos de la clase java.lang.Thread",slug:"_3-1-4-metodos-de-la-clase-java-lang-thread",link:"#_3-1-4-metodos-de-la-clase-java-lang-thread",children:[{level:3,title:"Cmo pausar un hilo",slug:"como-pausar-un-hilo",link:"#como-pausar-un-hilo",children:[]},{level:3,title:"Gestin de la prioridad de los hilos",slug:"gestion-de-la-prioridad-de-los-hilos",link:"#gestion-de-la-prioridad-de-los-hilos",children:[]}]}],path:"/es/unit3/runnable.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.1. Clases Java para la gestin de hilos\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.1. Clases Java para la gestin de hilos" />\r
\r
# 3.1. Clases Java para la gestin de hilos\r
\r
[[toc]]\r
\r
## 3.1.1. El interfaz Runnable\r
\r
Un hilo (thread en adelante) puede ejecutar cdigo Java dentro de tu aplicacin Java.\r
\r
![alt_text](../../media/unit3/Single_vs_MultiThreaded_Approaches.jpg)\r
\r
Cuando un programa Java se lanza (se convierte en un proceso) empieza a ejecutarse por su mtodo main() que lo ejecuta el thread principal (main), un hilo especial creado por la Java VM para ejecutar la aplicacin. Desde un proceso se pueden crear e iniciar tantos threads como necesites. Estos hilos ejecutarn partes del cdigo de la aplicacin en paralelo con el thread principal\r
\r
Los thread en Java son objetos como cualquier otro. Un thread es una instancia de la clase java.lang.Thread, o instancias de clases que heredan de sta. Como ya hemos icho, adems de ser objetos, los threads tienen la capacidad de ejecutar cdigo.\r
\r
La forma ms usada para indicar a un thread qu cdigo queremos que ejecute es creando una clase que implemente la interfaz  \`java.lang.Runnable\`.\r
\r
Esta interfaz es una interfaz estndar que viene con la plataforma Java. La interfaz Runnable slo tiene un nico mtodo, void run().\r
\r
> [java.lang.Runnable specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html)\r
\r
Sea lo que sea lo que el thread tenga que hacer, debe estar incluido en la implementacin del mtodo run. Tenemos tres posibilidades de implementar dicha interfaz:\r
\r
- Crear una clase Java que implemente la interfaz Runnable.\r
- Crear una clase annima que implemente la interfaz Runnable.\r
- Crear una expresin Lambda que implemente la interfaz Runnable.\r
\r
En las siguientes secciones podemos ver cmo usar cada una de ellas.\r
\r
### Clase Java que implementa la interfaz Runnable\r
\r
La primera forma que vamos a ver es creando una clase que implementa la interfaz. Podemos ver un ejemplo bsico en el siguiente cdigo:\r
\r
\`\`\`java\r
public class MyRunnable implements Runnable {\r
\r
  public void run(){\r
      System.out.println("MyRunnable running");\r
  }\r
}\r
\`\`\`\r
\r
Todo lo que hace la implementacin es imprimir el texto "MyRunnable running". Tras ejecutar esa lnea de cdigo, el mtodo run termina y el thread que estuviese ejecutndolo se parara.\r
\r
### Implementacin con clase annima de la interfaz Runnable\r
\r
Otra forma de obtener un objeto que implemente Runnable es crear una clase annima. A continuacin tenemos un ejemplo de cmo hacerlo\r
\r
\`\`\`java\r
Runnable myRunnable =\r
    new Runnable(){\r
        public void run(){\r
            System.out.println("Runnable running");\r
        }\r
    }\r
\`\`\`\r
\r
Salvo por el hecho de usar una clase annima, el ejemplo hace exactamente lo mismo que el anterior en el que se creaba una clase que implementaba la interfaz.\r
\r
### Implementacin de Runnable a travs de una expresin Lambda\r
\r
Para la tercera forma nos vamos a basar en la caracterstica de la interfaz Runnable, esto es, que slo tiene un nico mtodo a implementar, el mtodo run. Aunque Runnable no es una interfaz funcional, podemos crear una expresin Lambda que no dar lugar a confusin acerca del mtodo que se quiere ejecutar. Por este motivo podemos usar la expresin lambda como si Runnable fuese una interfaz funcional.\r
\r
Vamos a verlo con un ejemplo\r
\r
\`\`\`java\r
Runnable runnable =\r
        () -> { System.out.println("Lambda Runnable running"); };\r
\`\`\`\r
\r
### Llamar al mtodo run de una clase que implemente Runnable\r
\r
Vamos a fijarnos en este ejemplo\r
\r
\`\`\`java{1,13,23}\r
public class LiftOff implements Runnable {\r
    private int countDown = 10;\r
    private static int taskCount = 0;\r
    private final int id = taskCount;\r
    \r
    public LiftOff() {}\r
    \r
    public LiftOff(int countDown) {\r
        this.countDown = countDown;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        while (countDown > 0) {\r
            System.out.println("#" + id + " (" + countDown + ")" );\r
            countDown--;\r
        }\r
        System.out.println("Lanzamiento (" + id + ")");\r
    }\r
    \r
    public static void main(String[] args) {\r
        LiftOff launch = new LiftOff();\r
        launch.run();\r
        System.out.println("Comienza la cuenta atrs!");\r
    }    \r
}\r
\`\`\`\r
\r
Copia el cdigo anterior y ejectalo en tu IDE. Qu ves en la salida?\r
\r
::: question Qu est pasando con la ejecucin del programa anterior?\r
Tras ejecutarlo, el mensaje "Comienza la cuenta atrs!" est puesto en el sitio correcto?\r
\r
intenta crear ms instancias del la clase LiftOff y haz que se ejecuten todas (dentro del main)\r
\r
Si observas la salida de aplicacin, est haciendo algo diferente a una aplicacin monohilo?\r
Qu puedes extraer de la salida del programa?\r
:::\r
\r
::: details Respuesta a las cuestiones planteadas\r
El mensaje debera mostrarse antes que la cuenta atrs. De hecho la instruccin con el System.out est despus de la llamada al mtodo run.\r
\r
Como se puede observar, no estamos haciendo nada diferente. El cdigo de run se est ejecutando uno despus de otro.\r
\r
En realidad, **no estamos creando nuevos threads**, lo nico que hemos hecho hasta ahora es implementar una interfaz, pero llamando al mtodo run estamos haciendo que el hilo principal de la aplicacin, el nico hilo de momento, est ejecutando un mtodo run, despus otro, despus otro, ... y cuando ha acabado con todos hace el System.out.\r
:::\r
\r
## 3.1.2 Thread subclass\r
\r
Adems de implementando la interfaz Runnable, la segunda forma que tenemos de indicar a un thread el cdigo a ejecutar es creando una subclase de  \`java.lang.Thread\` y sobrescribiendo el mtodo run(). La clase Thread implementa de forma implcita la interfaz Runnable. Al igual que con Runnable, el mtodo run() contiene el cdigo que ejecutar un thread cuando se llame al mtodo \`start()\`.\r
\r
> [java.lang.Thread specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html)\r
\r
Vamos a ver un ejemplo de creacin de una clase que herede de Thread:\r
\r
\`\`\`java\r
public class MyThread extends Thread {\r
  public void run(){\r
      System.out.println("MyThread running");\r
  }\r
}\r
\`\`\`\r
\r
Para crear y lanzar un nuevo thread tenemos que usar el siguiente cdigo\r
\r
\`\`\`java\r
MyThread myThread = new MyThread();\r
myTread.start();\r
\`\`\`\r
\r
La llamada al mtodo start() devuelve el control al thread principal en cuanto el hilo asociado se inicia. A diferencia del ejemplo de la cuenta atrs, cuando llamamos al mtodo start  **el hilo principal no espera a que el mtodo run() se ejecute por completo** antes de seguir. El mtodo run() se ejecutar en un hilo de ejecucin diferente, dentro del mismo proceso y compitiendo por las unidades de procesamiento del sistema. Al igual que en los casos anteriores, cuando se ejecute el mtodo run() mostrar por pantalla el mensaje "MyThread running" y el hilo terminar su ejecucin (y su vida) porque finaliza el cdigo del mtodo run().\r
\r
El ejemplo se puede repetir con una clase annima, aunque ya no con una expresin lambda, ya que la clase Thread tiene muchos ms mtodos y no es una interfaz funcional.\r
\r
\`\`\`java\r
Thread thread = new Thread(){\r
  public void run(){\r
    System.out.println("Thread Running");\r
  }\r
}\r
\r
thread.start();\r
\`\`\`\r
\r
El ejemplo mostrar el mensaje "Thread running" cuando el mtodo run() se ejecutado por el nuevo thread.\r
\r
::: question Ejemplo Cuenta atrs\r
Copia el ejemplo original de la "Cuenta Atrs" y haz que la clase LiftOff ahora herede de Thread.\r
Ahora, en vez de llamar directamente al mtodo run, haz que los threads llamen al mtodo start().\r
\r
El mensaje "Comienza la cuenta atrs!" aparece ahora en el sitio correcto? Porqu sale antes si en el cdigo est despus?\r
\r
Crea nuevas instancias de LiftOff y has que se lancen en el main\r
En qu ha cambiado ahora la ejecucin de las aplicacin respecto a una aplicacin monohilo?\r
Qu puedes extraer de la salida del programa?\r
:::\r
\r
::: details Respuesta a las cuestiones planteadas\r
Ahora el mensaje "Comienza la cuenta atrs!" s aparece, en la salida, en la posicin correcta, es decir, antes de la cuenta atrs. Si observamos el cdigo, siguiendo una lgica secuencial, el mensaje debera aparecer despus, como pas en la primera prueba que hicimos.\r
\r
La diferencia ahora es que el cdigo del run() lo est ejecutando un hilo diferente, y desde el momento en que se hace el start() el control vuelve al hilo principal (main) que contina ejecutando las lneas de cdigo que hay en el mtodo main. La creacin de un hilo, aunque menos que la de un proceso, tambin tiene un coste de recursos y temporal, por lo que el hilo tarda unos instantes en empezar a ejecutarse. Por eso el hilo principal tiene tiempo de ejecutar la siguiente instruccin y mostrar el mensaje.\r
\r
La gran diferencia ahora, que podemos observar en la salida, es que los hilos se estn ejecutando concurrentemente, ya que vemos como sus salidas se intercalan.\r
\r
Esa es la diferencia ms obvia. Sin embargo, si ejecutamos el programa varias veces, podremos observar que no hay dos ejecuciones iguales. No depende de nosotros el orden en el que se ejecutan las instrucciones, sino que depende de la planificacin que realice el SO. En este contexto nos encontramos con una ejecucin aleatoria o **indeterminista** como la denominamos en el primer tema.\r
\r
El cmo controlar ese orden es lo que trabajaremos en la segunda parte del tema.\r
:::\r
\r
::: info Cundo termina un proceso?\r
En el ejemplo anterior, la ltima lnea del hilo principal se ejecuta antes que el cdigo de los hilos. Qu pasa entonces con el proceso?\r
\r
En un proceso monohilo, estamos acostumbrados a que el proceso sigue en ejecucin (vivo) mientras el cdigo que hayamos puesto en el main est ejecutndose. En concreto mientras el main-thread est en ejecucin.\r
\r
![Ciclo de vida de un proceso](../../media/unit3/threads_process_end.png)\r
\r
Cuando un proceso tiene mas hilos, la norma es que el proceso no finaliza su ejecucin hasta que el ltimo de los hilos haya terminado. As que podemos encontrarnos, como en ejemplo de la cuenta atrs, que el main-thread acaba y el proceso sigue en ejecucin.\r
:::\r
\r
## 3.1.3 Starting a Thread With a Runnable\r
\r
Para hacer que un thread ejecute el cdigo del mtodo run de una clase (instancia de clase, clase annima, expresin lambda) que implemente la interfaz Runnable, tenemos que pasar esa instancia como parmetro en el constructor de la clase Thread. Veamos cmo se hace:\r
\r
\`\`\`java\r
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...\r
\r
Thread thread = new Thread(runnable);\r
thread.start();\r
\`\`\`\r
\r
Cuando se inicia el thread, llamando a su mtodo start(), se crea un nuevo thread que ejecuta el cdigo del mtodo run de la instancia MyRunnable. El ejemplo anterior imprimir el texto "MyRunnable running (ver el cdigo de MyRunnable en los ejemplos anteriores).\r
\r
::: info\r
En resumen, tenemos dos formas de indicarle a un thread qu cdigo debe ejecutar.\r
\r
- Crear una subclase de Thread y sobrescribir el mtodo run().\r
- Pasar una instancia de un objeto que implemente la interfaz Runnable al constructor de Thread.\r
\r
**En ambos casos, para que se cree el thread y ejecute el cdigo del mtodo run, debemos llamar al mtodo start() del objeto Thread.**\r
:::\r
\r
<CodeGroup>\r
<CodeGroupItem title="Extends Thread" active>\r
\r
\`\`\`java{1,7}\r
public class EjemploThread extends Thread {\r
  public void run() {\r
    // Cdigo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    EjemploThread hilo = new EjemploThread();\r
    hilo.start();\r
  }\r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Runnable">\r
\r
\`\`\`java{1,7}\r
public class EjemploRunnable implements Runnable {\r
  public void run() {\r
    // Cdigo del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    Thread hilo = new Thread(new EjemploRunnable());\r
    hilo.start();\r
  }    \r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
</CodeGroup>\r
\r
### Subclass or Runnable?\r
\r
No hay nada que indique que una forma es mejor que otra. Ambos mtodos son similares y el resultado es el mismo. . **El mtodo preferido debera ser implementar Runnable**, y pasarle la instancia al constructor de Thread.\r
\r
unas cuantas razones en contra de usar Thread\r
\r
- Cuando heredamos de la clase Thread, no estamos sobrescribiendo ninguno de sus mtodos. Por contra, estamos sobrescribiendo un mtodo de la interfaz Runnable (que Thread implementa internamente . Esto supone una clara violacin del principio IS-A del Thread.\r
- Cuando pasamos la instancia de Runnable y la utilizamos como argumento en el constructor de Thread estamos usando composicin y no herencia, lo cual permite mucha ms flexibilidad.\r
- Si heredamos de Thread, ya no podemos heredar de otras clases. Esto supone un gran problema cuando usamos libreras o componentes grficos, ya que Java noi permite la herencia mltiple.\r
- Desde Java 8 en adelante, la interfaz Runnable se puede representar con expresiones lambda\r
\r
::: danger Error comn: Llamar a run () en vez de a start()\r
Cuando empezamos a trabajar con hilos, un error muy comn es llamar directamente al mtodo run en vez de llamar al mtodo start():\r
\r
> Thread newThread = new Thread(MyRunnable());\r
> newThread.run();  //should be start();\r
\r
or\r
\r
> MyRunnable runnable = new MyRunnable();\r
> runnable.run();  \r
\r
En principio no notamos ningn error ya que el cdigo de run() se ejecuta y podemos ver los resultados. Sin embargo, ese cdigo **no es ejecutado por el nuevo thread** que acabamos de crear. El mtodo run() es ejecutado por el thread que ha creado el objeto, es decir, el mismo thread que ha ejecutado las lneas anteriores a la llamada a run().\r
\r
Para hacer que el mtodo run, de una instancia que implemente Runnable o de una que herede de Thread, sea ejecutado por un el nuevo thread que acabamos de crear, newThread, debemos llamar al mtodo newThread.start().\r
:::\r
\r
## 3.1.4 Mtodos de la clase java.lang.Thread\r
\r
Si miramos a la definicin de la clase Thread veremos que tiene muchos mtodos. Debemos tener cuidado ya que algunos de estos mtodos como stop(), suspend(), resume() and destroy()  han sido marcados como \`obsoletos(deprecated)\`.\r
\r
Veamos algunos de los mtodos de la clase Thread ms utilizados:\r
\r
| Method                      | Description                                                                                                                                                                                                            |\r
| :-------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| start()                     | Hace que un nuevo thread ejecute el cdigo del mtodo run()                                                                                                                                                            |\r
| boolean isAlive()           | Comprueba si un thread est vivo o no                                                                                                                                                                                  |\r
| sleep(long ms)              | Cambia el estado del thread a bloqueado durante los ms indicados                                                                                                                                                       |\r
| run()                       | Es el cdigo que el thread ejecuta. Es llamado por el mtodo start(). Representa el ciclo de vida de un thread.                                                                                                        |\r
| String toString()           | Devuelve una representacin legible de un thread [nombre, priority, nombre_del_grupo                                                                                                                                   |\r
| long getId()                | Devuelve el identificador del thread (es un id asignado por el proceso)                                                                                                                                                |\r
| void yield()                | Hace que el hilo pare su ejecucin instantneamente volviendo a la cola y permitiendo que otros hilos y/o procesos se ejecuten.                           |\r
| void join()                 | Se llama desde otro thread y hace que el thread que lo invoca se bloquee hasta que el thread termine. Es parecido a p.waitFor() para los procesos                                                                      |\r
| String getName()            | Obtiene el nombre del thread                                                                                                                                                                                           |\r
| String setName(String name) | Cambia el nombre del thread                                                                                                                                                                                            |\r
| int getPriority()           | Obtiene la prioridad del thread                                                                                                                                                                                        |\r
| setPriority(int p)          | Modifica la prioridad del thread                                                                                                                                                                                       |\r
| void interrupt()            | Interrumpe la ejecucin del thread provocando que salte una excepcin de tipo InterruptedException                                                                                                                     |\r
| boolean interrupted()       | Comprueba si un thread ha sido interrumpido                                                                                                                                                                            |\r
| Thread.currentThread()      | Mtodo esttico de la clase Thread que devuelve una referencia al hilo que est ejecutando el cdigo                                                                                                                   |\r
| boolean isDaemon()          | Comprueba si un hilo es un servicio/demonio. Un proceso/hilo de baja prioridad que se ejecuta de forma independiente de su proceso padre. Un proceso puede finalizar aunque un hilo *daemon* est todava ejecutndose. |\r
| setDaemon(boolean on)       | Convierte un hilo en un demonio/servicio. Por defecto todos los hilos se crean como hilos de usuario.                                                                                                                  |\r
| int activeCount()           | Devuelve el nmero de hilos pertenecientes a un grupo que siguen activos.                                                                                                                                              |\r
| Thread.State getState()     | Devuelve el estado actual del hilo. Los posibles valores son NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.                                                                                             |\r
\r
La clase Thread tambin tiene unos 9 constructores, la mayora de ellos estn duplicados permitiendo recibir un objeto Runnable como parmetro\r
\r
| Constructores de la clase Thread                                                                      |\r
| :---------------------------------------------------------------------------------------------------- |\r
| Thread()                                                                                              |\r
| Thread(Runnable target)                                                                              |\r
| Thread(String name)                                                                                  |\r
| Thread(Runnable target, String name)                                                                 |\r
| Thread(ThreadGroup group, Runnable target)                                                           |\r
| Thread(ThreadGroup group, Runnable target, String name)                                              |\r
| Thread(ThreadGroup group, Runnable target, String name, long stackSize)                              |\r
| Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) |\r
\r
Veamos un ejemplo prctico de uso de todos estos mtodos\r
\r
\`\`\`java\r
public class U3S2_ThreadMethodsExample extends Thread {\r
    \r
    U3S2_ThreadMethodsExample (ThreadGroup group, String name) {\r
        // Call to parent class constructor with group and thread name\r
        super(group, name);\r
    }\r
    \r
    @Override\r
    public void run() {\r
        String threadName = Thread.currentThread().getName();\r
        System.out.println("["+threadName+"] " + "Inside the thread");\r
        System.out.println("["+threadName+"] " + "Priority: " \r
          + Thread.currentThread().getPriority());\r
        Thread.yield();\r
        System.out.println("["+threadName+"] " + "Id: " \r
          + Thread.currentThread().getId());\r
        System.out.println("["+threadName+"] " + "ThreadGroup: " \r
          + Thread.currentThread().getThreadGroup().getName());\r
        System.out.println("["+threadName+"] " + "ThreadGroup count: " \r
          + Thread.currentThread().getThreadGroup().activeCount());\r
    } \r
    \r
    public static void main(String[] args) {\r
        // main thread \r
        Thread.currentThread().setName("Main");\r
        System.out.println(Thread.currentThread().getName());\r
        System.out.println(Thread.currentThread().toString());\r
        \r
        ThreadGroup even = new ThreadGroup("Even threads");\r
        ThreadGroup odd = new ThreadGroup("Odd threads");\r
        \r
        Thread localThread = null;\r
        for (int i=0; i<10; i++) {\r
            localThread = new U3S2_ThreadMethodsExample((i%2==0)?even:odd, "Thread"+i);\r
            localThread.setPriority(i+1);\r
            localThread.start();\r
        }\r
              \r
        try {\r
            localThread.join(); // --> Will wait until last thread ends \r
                                // like a waitFor() for processes\r
        } catch (InterruptedException ex) {\r
            ex.printStackTrace();\r
            System.err.println("The main thread was interrupted while waiting for " \r
              + localThread.toString() + "to finish");\r
        }\r
        System.out.println("Main thread ending");\r
    }    \r
}\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver cmo tenemos que ayudarnos del mtodo esttico \`Thread.currentThread()\` para saber qu hilo est ejecutndose en cada momento, ya que hay muchos hilos ejecutando el mismo cdigo al mismo tiempo.\r
\r
Hemos creado una nica clase para los hilos y para el hilo principal. No debera ser una prctica comn ms all de los ejemplos. Es mejor separar el cdigo del objeto que hereda de Thread o que implementa Runnable en una clase aparte.\r
\r
Tambin es importante hacer ver que la clase Thread (o Runnable) puede tener sus propios constructores, propiedades y mtodos, ms all del mtodo run que estn obligadas a sobrescribir. Tambin puede invocar a los constructores de la superclase haciendo uso de super().\r
\r
:::question Dividir el cdigo en dos clases\r
Copia el cdigo de ThreadMethodsExample y divdelo en dos clases. Por un lado, una que contenga a la clase que extiende de Thread y otra que simplemente tenga el mtodo main y el cdigo para crear y lanzar los hilos..\r
\r
Una vez dividido el cdigo cambia U3S2_ThreadMethodsExample para que implemente la interfaz Runnable. Haz los cambios oportunos en la otra clase para que todo vuelva a funcionar como antes.\r
:::\r
\r
Si ejecutas el programa podrs ver que aunque los threads son lanzados en orden (1, 2, 3 etc.) su ejecucin ya no se realiza de forma secuencial, pudiendo ocurrir que el thread 1 no sea el primero en mostrar su nombre por la salida estndar (System.out). Esto es debido a que los threads se ejecutan en paralelo y no de forma secuencial. La JVM y/o el sistema operativo determinan el orden en el que se ejecutan. Este orden no tiene porqu ser el mismo en el que se lanzaron ni cada vez que se ejecutan.\r
\r
### Cmo pausar un hilo\r
\r
Un thread puede pausar su propia ejecucin llamando al mtodo esttico **Thread.sleep()**. El mtodo sleep() recibe como parmetro el nmero de milisegundos que quiere estar pausado antes de volver a ponerse como listo para ejecucin. No es un mtodo preciso al 100% (menos an si utilizamos la versin que recibe ms y ns), pero an as es bastante preciso. A continuacin tenemos un ejemplo de un thread que se pausa durante 3 segundos (3000ms) llamando al mtodo sleep():\r
\r
\`\`\`java:no-line-numbers\r
try {\r
    Thread.sleep(3000L);\r
} catch (InterruptedException e) {\r
    e.printStackTrace();\r
}\r
\`\`\`\r
\r
::: info Simulacin de sistema reales\r
Este es un mtodo que vamos a utilizar exhaustivamente en las actividades para simular perodos de tiempo y acelerar las simulaciones.\r
\r
Por ejemplo, podemos hacer un ajuste para que cada hora *real* se reduzca a un segundo. De esta forma podremos simular un da completo en tan solo 24 segundos.\r
\r
Tambin es interesante su uso para utilizar perodos de tiempo aleatorios en la ejecucin de cada hilo, permitiendo as una simulacin realista de los eventos en un sistema real.\r
:::\r
\r
En Java podemos generar nmeros aleatorios en el rango de los enteros, long, float y double.\r
\r
Tenemos tres mtodos bsicos para hacerlo\r
\r
#### Method 1: Usando la clase Random\r
\r
Podemos usar la clase  \`java.util.Random\` para generar datos aleatorios, siguiendo los siguientes pasos:\r
\r
- Importar la clase java.util.Random\r
- Crear una instancia de la clase Random, por ejemplo \`Random rand = new Random()\`\r
- Llamar a alguno de los mtodos del objeto:\r
  - nextInt(limitesuperior) genera nmeros aleatorios en el rango 0 a lmitesuperior-1.\r
  - nextFloat() genera un float entre 0.0 and 1.0.\r
  - nextDouble() genera un double entre 0.0 and 1.0.\r
  \r
Si llamamos al mtodo nextInt con parmetros (el lmite superior), obtendremos nmeros enteros en el rango\r
\r
> int randomWithNextIntWithinARange = random.nextInt(max)\r
\r
Esto nos dar un nmero entre  *0 (inclusive)* y *max* (no incluido) [min, max[. El valor del lmite debe ser mayor que 0 sino obtendremos una java.lang.IllegalArgumentException.\r
\r
#### Method 2: Usando Math.random\r
\r
Para generar nmeros aleatorios en un rango podemos usar Math.random() siguiendo los pasos detallados a continuacin:\r
\r
- Declarar el valor mnimo del rango\r
- Declarar el valor mximos del rango\r
- Usar la frmula \`Math.random()*(max-min)+min\` para generar valores entre  *min* y *max*, ambos inclusive [min, max].\r
\r
El valor devuelto por Math.random() est en el rango [0, 1]\r
\r
Para generar nmeros entre 0 y un lmite superior (50)\r
\r
> Math.random()*50\r
\r
Para generar nmeros entre 1 y un lmite superior (50)\r
\r
> Math.random()*49+1\r
\r
Para generar nmeros en un rango predeterminado [200, 500]\r
\r
> Math.random()*300+200\r
\r
#### Method 3: Usar ThreadLocalRandom\r
\r
La clase \`java.util.Random\` no tiene buen rendimiento en entornos multihilo. De forma simplificada, el motivo es la contencin, ya que muchos hilos comparten la misma instancia de Random y se tiene que secuenciar y sincronizar el acceso a sus mtodos.\r
\r
Para evitar esa limitacin, Java introdujo la clase \`java.util.concurrent.ThreadLocalRandom\` para generar nmeros aleatorios en entornos multihilo.\r
\r
Si llamamos al mtodo \`ThreadLocalRandom.current()\` nos devolver la instancia de ThreadLocalRandom para el hilo actual. A partir de aqu podemos generar valores aleatorios llamando a los mtodos de la clase con la instancia obtenida.\r
\r
Para generar valores enteros sin lmite:\r
\r
> int unboundedRandomValue = ThreadLocalRandom.current().nextInt());\r
\r
Para generar valores enteros en un rango dato, es decir, con un lmite superior e inferior [0, 100[:\r
\r
> int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);\r
\r
Al igual que con Random, 0 est incluido en el rango mientra que 100 no.\r
\r
Tambin podemos generar otros tipos de datos como long y Double llamando a los mtodos \`nextLong()\` y \`nextDouble()\` de forma similar a los ejemplos anteriores.\r
\r
La clase ThreadLocalRandom hereda de Random, por lo que comparten muchos mtodos y funcionalidad.\r
\r
### Gestin de la prioridad de los hilos\r
\r
Los hilos heredan la prioridad del padre en Java, pero este valor puede ser cambiado con el mtodo \`setPriority()\` y con \`getPriority()\` podemos saber la prioridad de un hilo.\r
\r
El valor de la prioridad vara entre 1 y 10. *Cuanto ms alto es el valor, mayor es la prioridad*. La clase Thread define las siguientes constantes \`MIN_PRIORITY\` (valor 1) \`MAX_PRIORITY\` (valor 10) y \`NORM_PRIORITY\` (valor 5). El planificador elige el hilo en funcin de su prioridad. Si dos hilos tienen la misma prioridad realiza un round-robin, es decir de forma cclica va alternando los hilos.\r
\r
El hilo de mayor prioridad seguir funcionando hasta que ceda el control por:\r
\r
- Cede el control llamando al mtodo yield().\r
- Deja de ser ejecutable (por muerte o por bloqueo)\r
- Aparece un hilo de mayor prioridad, por ejemplo si se encontraba en estado dormido por una operacin de E/S o bien es desbloqueado por otro con los mtodos notifyAll() / notify().\r
\r
\`\`\`java\r
class U3S3_HiloPrioridad1 extends Thread {\r
  private int c = 0;\r
  private boolean stopHilo = false;\r
  public long getContador () {\r
    return c;\r
  }\r
  public long pararHilo() {\r
    stopHilo = true;\r
  }\r
  @Override\r
  public void run() {\r
    while (!stopHilo) c++;\r
  }\r
}\r
\r
public class U3S3_EjemploHiloPrioridad1 {\r
  public static void main(String args[]) {\r
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();\r
\r
    h1.setPriority(Thread.NORM_PRIORITY);\r
    h2.setPriority(Thread.MAX_PRIORITY);\r
    h3.setPriority(Thread.MIN_PRIORITY);\r
\r
    h1.start();\r
    h2.start();\r
    h3.start();\r
\r
    try {\r
      Thread.sleep(10000);\r
        } catch (InterruptedException e) {}\r
\r
    h1.pararHilo();\r
    h2.pararHilo();\r
    h3.pararHilo();\r
\r
    System.out.println("h2 (Prio. Mx: "+h2.getContador());\r
    System.out.println("h1 (Prio. Normal: "+h1.getContador());\r
    System.out.println("h3 (Prio. Mnima: "+h3.getContador());\r
  }\r
}\r
\`\`\`\r
`]},{title:"3.2 Sincronizacin y comunicacin de hilos",headers:[{level:2,title:"3.2.1. Memoria compartida",slug:"_3-2-1-memoria-compartida",link:"#_3-2-1-memoria-compartida",children:[]},{level:2,title:"3.2.2. Sincronizacin",slug:"_3-2-2-sincronizacion",link:"#_3-2-2-sincronizacion",children:[{level:3,title:"Monitores y bloqueos",slug:"monitores-y-bloqueos",link:"#monitores-y-bloqueos",children:[]},{level:3,title:"Secciones crticas",slug:"secciones-criticas",link:"#secciones-criticas",children:[]},{level:3,title:"Sincronizacin y actualizacin de la informacin",slug:"sincronizacion-y-actualizacion-de-la-informacion",link:"#sincronizacion-y-actualizacion-de-la-informacion",children:[]}]},{level:2,title:"3.2.3 Sincronizacin entre hilos",slug:"_3-2-3-sincronizacion-entre-hilos",link:"#_3-2-3-sincronizacion-entre-hilos",children:[]}],path:"/es/unit3/synchronization.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.2 Sincronizacin y comunicacin de hilos\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.2 Sincronizacin y comunicacin de hilos" />\r
\r
# 3.2 Sincronizacin y comunicacin de hilos\r
\r
[[toc]]\r
\r
::: info Vocabulario\r
\r
- **Condicin de carrera**: Situacin en que el correcto funcionamiento de un programa depende del orden en que se intercale la ejecucin de las instrucciones de sus diferente hilos. Esto ocurre cuando uno o ms hilos acceden a informacin compartida de forma concurrente e intentan modificarla a la vez.\r
- **Deadlock**: Situacin en que dos o ms hilos estn bloqueados mutuamente, todos ellos esperando para conseguir el bloqueo sobre objetos bloqueados por otros hilos, de manera que ninguno de ellos podr continuar nunca.\r
- **Seccin crtica**: Fragmento de un programa que no puede ejecutar de manera simultnea (concurrentemente) ms de un hilo del programa, es decir, que distintos hilos deben ejecutar en exclusin mutua\r
- **Thread-safe**: Se dice de una clase cuyos mtodos implementan los mecanismos de sincronizacin necesarios para el uso concurrente de sus objetos por parte de distintos hilos, de manera que **no es necesario ningn mecanismo de sincronizacin externo** a la propia clase.\r
\r
:::\r
\r
## 3.2.1. Memoria compartida\r
\r
A menudo los hilos necesitan comunicarse unos con otros. La forma que tienen de hacerlo consiste en compartir un objeto.\r
\r
Vamos a desarrollar un ejemplo en el que dos hilos comparten un objeto de la clase Contador.\r
\r
![alt_text](../../media/unit3/SumadorRestador_uml.jpg)\r
\r
<!--\r
\`\`\`puml\r
class Contador {\r
  - int c = 0\r
  + Contador(int c)\r
  +void incrementa()\r
  +void decrementa()\r
  + int valor()\r
}\r
class Sumador extends Thread {\r
  - Contador c\r
  + Sumador(String name, Contador c)\r
  + void run()\r
\r
}\r
class Restador implements Runnable{\r
  - Contador c\r
  + Restador(String name, Contador c)\r
  + void run()\r
\r
}\r
Restador o-- Contador\r
Sumador o-- Contador\r
\`\`\`\r
-->\r
\r
Para probar el objeto compartido, en una cuarta clase que contiene el main se crea un objeto Contador que se inicializa a 100 y se crean y lanzan dos threads, uno de tipo Sumador y otro de tipo Restador. En la clase Sumador se usa el mtodo del objeto Contador que incrementa en uno su valor mientras que en la clase Restador se usa el mtodo que decrementa en uno su valor. Cada una va a realizar la accin 300 veces, esperando entre cada accin un tiempo aleatorio entre 50ms y 150ms.\r
Es muy importante asegurarse que pasamos el mismo objeto Contador como parmetro al constructor de Sumador y de Restador, para que ambos trabajen con la misma instancia.\r
\r
::: question Comportamiento esperado\r
Crea las cuatro clases en funcin del diagrama de clases proporcionado. Asegrate que Sumador hereda de Thread y Restador implementa la interfaz Runnable para comprobar las diferencias de uso y creacin de threads a partir de cada tipo de clase.\r
\r
Qu debera ocurrir tras ejecutar el cdigo?\r
\r
Comprueba lo que pasa realmente. Intenta ejecutar el programa varias veces para ver si puedes obtener resultados diferentes.\r
:::\r
\r
:::details Cdigo del ejemplo\r
\r
\`\`\`java{4,7,9}\r
public class U3S3_SharedMemory {\r
  public static void main(String[] args) throws InterruptedException {\r
    // Inicializar el objeto Contador\r
    Contador c = new Contador(100);\r
    \r
    // Crear y lanzar 2 hilos (Sumador + Restador)\r
    Sumador s1 = new Sumador("Sumador1", c);\r
    Restador r1 = new Restador("Restador1", c);\r
    Thread h1 = new Thread(r1);\r
    \r
    s1.start();\r
    h1.start();\r
    \r
    // El hilo principal espera a que los hilos s1 y r1 terminen\r
    s1.join();\r
    h1.join();\r
    \r
    System.out.println("El valor final de c es " + c.valor());\r
    \r
  }\r
\`\`\`\r
\r
\`\`\`java\r
public class Contador {\r
  private int c = 0;\r
  \r
  public Contador(int c) {\r
    this.c = c;\r
  }\r
  \r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
  \r
  public int valor() {\r
    return c;\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,5,14}\r
public class Sumador extends Thread {\r
  private Contador c;\r
  public Sumador(String name, Contador c) {\r
    // To set the thread name we can access the Thread class constructor\r
    super(name);\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.incrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());\r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }\r
    }\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,3,13,17}\r
public class Restador implements Runnable {\r
  private Contador c;\r
  private String name;\r
  public Restador(String name, Contador c) {\r
    // Restador doesn't extend Thread, so it cannot call the Thread constructor\r
    // super(name);\r
    this.name = name;\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    Thread.currentThread().setName(this.name);\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.decrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());              \r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }      \r
    }    \r
  }\r
}\r
\`\`\`\r
\r
Si ejecutamos el programa, la mayora de veces obtendremos el resultado esperado, 100. Sin embargo, hay ocasiones en que podemos encontrar otros valores tales como 99, 101 o cualquier otro.\r
\r
Para evitar problemas de sincronizacin (son problemas como hemos visto aleatorios y muy difciles de detectar), necesitamos que los hilos estn sincronizados entre s.\r
:::\r
\r
Si analizamos el problema anterior, veremos que se est intentando ejecutar el siguiente cdigo en paralelo desde diferentes hilos, en **la misma instancia (memoria compartida)**:\r
\r
\`\`\`java\r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
\`\`\`\r
\r
Si aplicsemos las condiciones de Bernstein a esos dos mtodos, veramos que no se cumple ninguna de las tres, por lo que ese cdigo no puede ser ejecutado concurrentemente, al menos no sin tener problemas de concurrencia.\r
\r
As, para evitar que varios hilos ejecuten esos mtodos de forma concurrente, necesitamos estructuras de programacin que nos ayuden a conseguirlo.\r
\r
## 3.2.2. Sincronizacin\r
\r
El cdigo anterior no funciona porque las operaciones que se realizan en los mtodos incrementa y decrementa no son atmicas, sino que se descomponen en operaciones ms simples que se ejecutan una tras otra.\r
\r
Cuando estas operaciones se ejecutan en un hilo, la ejecucin del hilo se puede interrumpir y se pueden intercalar entre ellas operaciones de otros hilos. Segn cmo se intercalen las operaciones y los datos a los que accedan, se pueden obtener resultados no esperados. Esto es lo que se conoce como una \`condicin de carrera\`.\r
\r
Como vimos en la primera parte del tema, la comunicacin entre threads se produce principalmente mediante el acceso compartido a objetos y sus propiedades. Este mecanismo de comunicacin es muy eficiente pero presenta dos tipos de errores:\r
\r
- Interferencia entre threads\r
- Errores de consistencia de la informacin en memoria.\r
\r
La herramienta de programacin que utilizamos para prevenir este tipo de errores es la *sincronizacin*.\r
\r
La mayor parte del tiempo, los threads no tienen en cuenta al resto de hilos que se ejecutan en el programa ni les importa lo que stos hagan. Pero si necesitan algo de otro thead, entonces necesitan la sincronizacin.\r
\r
### Monitores y bloqueos\r
\r
La sincronizacin en Java se realiza usando \`monitores\`. Es una propiedad que proporciona la clase Object, por lo tanto todas nuestras clases Java, directa o indirectamente, heredan esta propiedad de Object. Este mecanismo permite a un nico thread a la vez ejecutar la seccin de cdigo protegida por el monitor.\r
\r
Un monitor no es ms que un bloqueo sobre un objeto. **Cada objeto tiene un y slo un bloqueo (candado) interno asociado**. El bloqueo de un objeto solamente puede ser adquirido por un thread en cada momento.\r
\r
La sincronizacin implica muchos conceptos. El ms utilizado es la \`exclusin mutua\` (**slo un hilo puede disponer de un monitor a la vez)**. Por lo tanto, la sincronizacin utilizando monitores significa que cuando un hilo accede a una seccin protegida por un monitor, ningn otro hilo puede acceder a esa o a cualquier otra seccin protegida por ese mismo monitor, hasta que el hilo salga de la seccin protegida\r
\r
Pero la sincronizacin tambin asegura que las escrituras en memoria realizadas por un thread dentro de un bloque protegido por un monitor son accesibles al resto de threads que accedan a los bloques protegidos por ese mismo monitor.\r
\r
::: danger Un objeto, un monitor\r
He recalcado en varias ocasiones que los bloques de cdigo a los que se accede en exclusin mutua son aquellos que estn protegidos por el mismo monitor. Esto es lo mismo que decir a aquellos que se realizan sobre el mismo objeto.\r
Cada objeto tiene asociado un monitor y la exclusin mutua y la sincronizacin de memoria tiene sentido si varios threads usan el mismo monitor para su sincronizacin.\r
:::\r
\r
Cada objeto gestiona una cola de hilos que quieren conseguir el bloqueo **(monitor)** del mismo. Como suele ser habitual, la eleccin del proceso de la cola que conseguir el bloqueo es totalmente indeterminista, depende de mltiples factores y no sigue ningn orden preestablecido.\r
\r
### Secciones crticas\r
\r
En Java la palabra reservada \`synchronized\` sirve para hacer que un bloque de cdigo o un mtodo sea protegido por el cerrojo del objeto. Para ejecutar un bloque o un mtodo sincronizado, los hilos deben conseguir previamente el bloqueo (candado) del objeto, debiendo esperar a que quede libre (el hilo que lo tiene lo libere) si el monitor ya ha sido adquirido por otro hilo.\r
\r
Esto ocurre slo si se est intentando **acceder al monitor del mismo objeto que otro hilo** ya tenga en propiedad.\r
\r
La palabra reservada synchronized puede aplicarse en distintos tipos de bloques de cdigo y, en cada caso, se utilizar un objeto de bloqueo distinto.\r
\r
- Mtodos no estticos\r
- Static methods\r
- Code blocks inside methods\r
\r
Para mtodos no estticos se aade la palabra reservada synchronized a la definicin del mtodo.\r
\r
\`\`\`java{3}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
}\r
\`\`\`\r
\r
El bloqueo se aplica sobre el objeto sobre el que se ejecuta el mtodo, es decir, **el objeto \`this\`**. En este caso dos hilos no podran ejecutar a la vez dos mtodos del mismo objeto marcados como synchronized.\r
\r
Cada objeto que instanciemos de la clase tendr su propio monitor asociado que no interferir con los bloqueos que se hayan hecho sobre otros objetos de la misma clase.\r
\r
Como ya hemos dicho, este comportamiento slo es vlido si todos los mtodos sincronizados a los que se quiere acceder pertenecen a la misma instancia. De este modo el monitor es el mismo y se aplica la exclusin mutua en la ejecucin de los bloques de cdigo protegidos por el monitor.\r
\r
\`\`\`java{3,6}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
 public synchronized void sub(int value){\r
   this.count -= value;\r
 }\r
}\r
\`\`\`\r
\r
::: info Sincronizacin con mtodos estticos\r
En este caso el bloqueo se realiza sobre la clase a la que pertenece el mtodo. Como **slo hay una instancia de cada objeto clase en la JVM**, slo un hilo a la vez podr adquirir el monitor y ejecutar el cdigo protegido de una clase esttica..\r
:::\r
\r
La sincronizacin no tiene porqu realizarse sobre todo un mtodo, *aunque es lo ms recomendable*. A veces es preferible sincronizar slo una parte de un mtodo. Otras no es posible sincronizar el mtodo completo. Para sincronizar un bloque de cdigo usamos la palabra reservada synchronized seguida, entre parntesis, del objeto del que usaremos el monitor. El cdigo protegido se ubicar entre un par de llaves.\r
\r
\`\`\`java{2}\r
public void add(int value){\r
  synchronized(this){\r
    this.count += value;  \r
  }\r
 }\r
\`\`\`\r
\r
En el ejemplo se ha utilizado \`this\` como objeto para el monitor. Decimos que el codigo est sincronizado con el monitor del objeto que pongamos entre parntesis. **Un mtodo sincronizado usa el objeto al que pertenece como monitor, es decir, tambin usa this**.\r
\r
Slo puede haber un thread ejecutando un bloque sincronizado para el mismo monitor. Los dems se quedan esperando.\r
\r
El siguiente cdigo define dos bloques protegidos por la instancia a la que pertenecen. **En trminos de sincronizacin, ambos bloque son totalmente equivalentes.**:\r
\r
\`\`\`java{2,8}\r
public class MyClass { \r
  public synchronized void log1(String msg1, String msg2){\r
    log.writeln(msg1);\r
    log.writeln(msg2);\r
  }\r
 \r
  public void log2(String msg1, String msg2){\r
    synchronized(this){\r
     log.writeln(msg1);\r
     log.writeln(msg2);\r
    }\r
  }\r
 }\r
\`\`\`\r
\r
Por lo tanto, slo un thread podra ejecutar uno de los dos bloques anteriores al mismo tiempo. Si otro hilo intentase ejecutar el mismo bloque, o el otro, se quedara bloqueado en la cola de espera del monitor hasta que el monitor quede libre.\r
\r
::: warning Qu objetos se pueden usar como monitores\r
Oracle dice que se puede usar cualquier objeto como monitor de sincronizacin, sin embargo **recomiendan que no se sincronice sobre String, o cualquier objeto envoltorio (wrapper) de los tipos de datos primitivos** (Integer, Double, Boolean, ...).\r
\r
Para estar seguros, lo mejor es sincronizar sobre \`this\`, sobre una instancia de un objet o, en su defecto sobre un nuevo objeto de tipo object, aunque sea un objeto vaco sin propiedades ni funcionalidad.\r
:::\r
\r
### Sincronizacin y actualizacin de la informacin\r
\r
Sin el uso de la palabra reservada synchronized (o el modificador \`volatile\` ) no tenemos ninguna garanta de que cuando un hilo cambie el valor de una variable compartida con otros threads (por ejemplo a travs de un objeto compartido entre todos los threads), los otros hilos puedan ver el valor modificado. No hay ninguna garanta de que cuando una variable se guarda en un registro de la CPU, el valor de sta se vuelque a la memoria principal.\r
\r
Esto, en programacin secuencial no supone ningn problema ya que el nico hilo existente no necesita de estas actualizaciones "instantneas". Si fuese necesario se usara la palabra \`volatile\` para las variables a las que se quiera forzar ese comportamiento.\r
\r
En la programacin multihilo, y dentro de la sincronizacin, un bloque protegido por un monitor nos garantiza que:\r
\r
- Cuando un hilo entra en un bloque \`synchronized\` se actualizar el valor de todas las variables visibles para el hilo.\r
- Cuando un hilo salga de un bloque \`synchronized\` todos los cambios realizados por el hilo se actualizarn en la memoria principal.\r
\r
El comportamiento descrito es similar al que provoca el uso de la palabra reservada \`volatile\`, evitando el uso de caches y la desincronizacin de la informacin entre la CPU y la memoria principal.\r
\r
El siguiente ejemplo muestra un monitor que implementa un contador:\r
\r
\`\`\`java \r
class Contador { \r
  // monitor contador\r
  private int actual; \r
  public Contador(int inicial) \r
  { \r
    actual = inicial;    \r
  } \r
  public synchronized void inc() { actual++; } \r
  public synchronized void dec() { actual--; } \r
  public synchronized int valor() { return actual;} \r
} \r
 \r
class Usuario extends Thread { \r
  // clase hilo usuario\r
  private Contador cnt; \r
  public Usuario(String nombre, Contador cnt) { \r
    super(nombre); this.cnt = cnt;    \r
  } \r
  public void run() { \r
    for (int i = 0; i < 1000; i++) { \r
      cnt.inc();          \r
      System.out.println("Hola, soy " + this.getName() + ", mi contador vale " + cnt.valor()); \r
    }    \r
  }  \r
}\r
\r
class EjemploContador { \r
  // principal\r
  final static int nHebras = 20; \r
  public static void main(String[] args) {\r
    // metodo principal      \r
    final Contador cont1 = new Contador(10);       \r
    Usuario hebra[] = new Usuario[nHebras]; \r
    for (int i = 0; i < nHebras; i++) {          \r
      //crea hebras\r
      hebra[i] = new Usuario("la hebra-" + i, cont1); \r
      // lanza hebras      \r
      hebra[i].start(); }    \r
    } \r
  }\r
}\r
\`\`\`\r
\r
Es importante hacer notar, aunque suene a pesado, que todos los hilos acceden al cdigo protegido del objeto cont1 que se crea en el mtodo main. As, no puede haber dos hilos ejecutando a la vez ninguna de los tres mtodos de la instancia cont1 de la clase Contador.\r
\r
::: danger Usar final con objetos de tipo monitor\r
Un objeto usado como monitor, o como memoria compartida entre hilos, debera ser de tipo **final**, porque si se le asigna un nuevo valor quedan si efecto todos los bloqueos que existan sobre dicho objeto. Un objeto de tipo final una vez que se ha creado y se le ha asignado un valor no se le puede asignar un nuevo valor.\r
:::\r
\r
## 3.2.3 Sincronizacin entre hilos\r
\r
Ya hemos visto un tipo de problema en el que varios hilos comparten recursos y se sincroniza el acceso a estos recursos mediante el uso de monitores. Hasta ahora, una vez que un hilo obtiene el bloqueo de un monitor, puede hacer uso del mismo de forma indiscriminada, sin tener en cuenta ninguna otra condicin.\r
\r
Ahora vamos a ver cmo, en funcin del estado de los recursos, cada uno de los hilos podr realizar determinadas acciones o no, permitiendo que los hilos se queden a la espera de un cambio de estado que podr ser notificado por otros hilos.\r
\r
Para ello, adems de un mecanismo de bloque sobre los recursos compartidos, ser necesario un mecanismo de espera para que, en el caso de que el estado de los recursos compartidos no permita a un hilo realizar una accin, la ejecucin del hilo quede en suspenso a la espera de que esa condicin se cumpla.\r
\r
El mecanismo es de **espera no activa**, es decir, no se debe consumir tiempo del procesador ni recursos del sistema para comprobar si es posible continuar con la ejecucin, mientras no se reciba una notificacin de que el estado ha cambiado y podra permitir que el hilo contine su ejecucin.\r
\r
Esto tambin nos permitir, colateralmente, controlar el orden de ejecucin de los hilos en funcin de la relacin que se establezca entre ellos.\r
\r
Para resolver este tipo de situaciones volvemos a utilizar mtodos de la clase Object, accesibles para cualquier objeto.\r
\r
- **wait()**: interrumpe la ejecucin del hilo actual. La ejecucin del hilo queda bloqueada mientras otro hilo no ejecute el mtodo notify (o notifyAll) sobre el objeto. Este mtodo, por tanto, proporciona un mecanismo de espera no activa.\r
- **notify()**: desbloquea uno de los hilos que estn esperando sobre un objeto tras haber ejecutado el mtodo wait()., de manera que pueda continuar su ejecucin. Este mtodo proporciona un mecanismo de notificacin para terminar con la espera no activa de los hilos que estn a la espera de un objeto de bloqueo. **El orden en que se desbloquean los hilos en un objeto de bloqueo vuelve a ser indeterminista** y no tiene porqu coincidir con el orden en que se bloquearon.\r
- **notifyAll()**: desbloquea todos los hilos que estn esperando sobre un objeto de bloqueo tras haber ejecutado el mtodo wait(), de manera que puedan continuar su ejecucin.\r
\r
wait , notify and notifyAll se utilizan para permitir a los hilos comunicarse entre ellos mediante un mecanismo de *signal&continue*.\r
\r
::: danger Contexto de ejecucin de los mtodos de sincronizacin\r
El hilo que llama a wait(), notify() o notifyAll() debe tener el bloqueo del monitor del objeto sobre el que se llama. Si no lo tiene, se lanzar una excepcin de tipo \`java.lang.IllegalMonitorStateException\`. \r
Por lo tanto, **estos mtodos deben ser llamados desde un bloque sincronizado**.\r
:::\r
\r
Cuando se llama al mtodo **wait()**, el hilo estar dentro de un bloque sincronizado, por lo tanto tendr el bloqueo del monitor. En ese momento el hilo libera el bloqueo de *ese monitor* y se queda en una **cola (perteneciente al objeto) de hilos en espera de ser notificados**, diferente a la de los hilos que estn esperando por el bloqueo.\r
\r
Cuando se desbloquea un hilo porque otro ha llamado a **notify()/notifyAll()**, el hilo vuelve al punto donde hizo el wait(), por lo tanto sigue dentro de un bloque sincronizado. Para poder continuar con la ejecucin tendr que pasar a la **cola de hilos esperando por el bloqueo** y esperar a ser seleccionado para seguir ejecutndose.\r
\r
![Colas de un monitor](../../media/unit3/Monitor_queues.png)\r
\r
\`\`\`java\r
synchronized(objBloqueo)\r
{\r
  while(!condicinParaPoderSeguir) {\r
    try {\r
      // Espera que la condicin cambie y otro hilo avise\r
      objBloqueo.wait()\r
    } catch (InterruptedException e) {}\r
  }\r
\r
  // Si el hilo ha llegado hasta aqu, significa que o bien al principio\r
  // o bien tras haber realizado una o ms esperas y haber sido notificado\r
  // de cambios por parte de otros hilos, la condicin se ha cumplido\r
\r
  // Adems ha conseguido el bloqueo del monitor para poder continuar \r
  // dentro del bloque synchronized\r
  realizar_operacin;\r
\r
  // Esta parte es opcional. La puede realizar este mismo hilo, en este \r
  // mismo mtodo, o bien la puede realizar otro hilo en otro mtodo\r
  if(condicinParaQueOtrosSigan) {\r
    objetoBloqueo.notify(); // o objetoBloqueo.notifyAll()\r
  }  \r
}\r
\`\`\`\r
\r
En el ejemplo anterior, las condiciones suelen estar basadas en propiedades del propio objBloqueo, ya que de esta forma se mantiene un estado compartido por todos los hilos.\r
\r
Veamos ahora otro ejemplo\r
\r
\`\`\`java\r
// It is the common java class on which thread will act and call wait and notify method.\r
public class Book {\r
  String title;\r
  boolean isCompleted;\r
\r
  public Book(String title) {\r
    super();\r
    this.title = title;\r
  }\r
  public String getTitle() {\r
    return title;\r
  }\r
  public void setTitle(String title) {\r
    this.title = title;\r
  }\r
  public boolean isCompleted() {\r
    return isCompleted;\r
  }\r
  public void setCompleted(boolean isCompleted) {\r
    this.isCompleted = isCompleted;\r
  } \r
}\r
\`\`\`\r
\r
\`\`\`java{14,17}\r
// It will first take a lock on book object \r
// Then, the thread will wait until other thread call notify method, then after it will complete its processing. \r
// So in this example, it will wait for BookWriter to complete the book.\r
public class BookReader implements Runnable{\r
  Book book;\r
\r
  public BookReader(Book book) {\r
    super();\r
    this.book = book;\r
  }\r
\r
  @Override\r
  public void run() {\r
    synchronized (book) {\r
      System.out.println(Thread.currentThread().getName()+" is waiting for the book to be completed: "+book.getTitle());\r
      try {\r
        book.wait();\r
      } catch (InterruptedException e) {  \r
        e.printStackTrace();\r
      }\r
      System.out.println(Thread.currentThread().getName()+": Book has been completed now!! you can read it");\r
    }\r
  } \r
}\r
\`\`\`\r
\r
\`\`\`java{15,22,25}\r
// This class will notify thread(in case of notify) which is waiting on book object. \r
// It will not give away lock as soon as notify is called, it first complete its synchronized block. \r
// So in this example, BookWriter will complete the book and notify it to BookReaders. \r
public class BookWriter implements Runnable{\r
  Book book;\r
 \r
  public BookWriter(Book book) {\r
    super();\r
    this.book = book;\r
  }\r
 \r
  @Override\r
  public void run() {\r
    synchronized (book) {\r
      System.out.println("Author is Starting book : " +book.getTitle() );\r
      try {\r
        Thread.sleep(1000);\r
      } catch (InterruptedException e) {\r
        e.printStackTrace();\r
      }\r
      book.setCompleted(true);\r
      System.out.println("Book has been completed now");\r
 \r
      book.notify();\r
      System.out.println("notify one reader");\r
    } \r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{8,9,26}\r
// This is our main class which will create object of above classes and run it.\r
public class U3S5_Books {\r
\r
  public static void main(String args[])\r
  {\r
    // Book object on which wait and notify method will be called\r
    Book book=new Book("The Alchemist");\r
    BookReader johnReader=new BookReader(book);\r
    BookReader arpitReader=new BookReader(book);\r
\r
    // BookReader threads which will wait for completion of book\r
    Thread johnThread=new Thread(johnReader,"John");\r
    Thread arpitThread=new Thread(arpitReader,"Arpit");\r
\r
    arpitThread.start();\r
    johnThread.start();\r
\r
    // To ensure both readers started waiting for the book\r
    try {\r
      Thread.sleep(3000);\r
    } catch (InterruptedException e) {\r
      e.printStackTrace();\r
    }\r
\r
    // BookWriter thread which will notify once book get completed\r
    BookWriter bookWriter=new BookWriter(book);\r
    Thread bookWriterThread=new Thread(bookWriter);\r
    bookWriterThread.start();\r
  }\r
}\r
\`\`\`\r
\r
::: details Comentarios y preguntas sobre el cdigo anterior\r
Si ejecutamos el cdigo anterior, tenemos que hacernos varias preguntas:\r
\r
- a) Cuntos wait() se hacen? Y cuntos notify()?\r
\r
**Solucin**: Se estn haciendo 2 wait(), 1 por cada hilo BookReader y slo un notify(), as que algo no cuadra.\r
\r
Uno de los lectores se queda sin notificar, por lo tanto un hilo se queda esperando en un wait(). Como ese hilo no termina, el proceso tampoco. Hay que recordar que un proceso no termina hasta que lo hace el ltimo de sus hilos. Esto en Netbeans implica que el programa no acaba y lo tenemos que parar.\r
\r
**Solucin**: En este caso tenemos dos alternativas. La primera pasa por usar notifyAll() en vez de notify(). De esta forma los dos BookReader se activan y se quedan a la espera de poder tomar el bloqueo del monitor. Uno lo har primero y el otro despus, pero los dos acabarn leyendo el libro.\r
La otra opcin es, siguiendo con notify(), que cada lector cuando acabe de leer el libro notifique a otros posibles lectores que haya en espera para que uno se despierte y lea el libro.\r
\r
- b) En el main hemos hecho que primero empiecen los BookReaders y una vez que estn esperando el BookWriter escriba el libro y avise. Qu pasa si lo hacemos al revs o si los lanzamos todos juntos y no sabemos en qu orden se van a ejecutar?\r
\r
Si lanzamos primero el BookWriter, este acaba el libro y notifica a... nadie, porque los BookReaders todava no estarn esperando. Despus llegarn los BookReaders y se quedarn los dos colgados, ya que ningn otro hilo les notificar.\r
\r
**Solucin**: Los hilos ahora mismo se estn bloqueando de manera indiscriminada, pero realmente deben bloquearse slo si el libro que quieren leer no est acabado. Por lo tanto tenemos que controlar con una condicin el bloqueo de los BookReader. Tal y como hemos comentado las condiciones las debe tener el objeto compartido, en este caso book, que lo comparten el BookWriter y los dos BookReader. La condicin que nos sirve para discriminar si un BookReader puede continuar o no es la propiedad isCompleted que consultamos a travs del mtodo book.isCompleted(),\r
\r
\`\`\`java\r
try {\r
  if (!book.isCompleted())\r
    book.wait();\r
} catch (InterruptedException e) { \r
\`\`\`\r
\r
Con esos dos cambios la aplicacin debera funcionar con cualquier nmero de BookReaders y de BookWriters, sin importar el orden ni la cantidad.\r
:::\r
\r
::: info notify() o notifyAll()?\r
Todo depender del sistema que estemos programando, pero por norma general, si queremos que tras modificar el estado del sistema slo contine un hilo, llamaremos a notify().\r
\r
Sino, debera utilizarse notifyAll(). Si todo est bien programado el hilo comprobar si puede seguir y, en caso contrario, volver a hacer un wait() y seguir esperando, por eso no supone un problema que que ms de un hilo se active.\r
\r
El uso de notify() supone un mayor riesgo de que se produzcan bloqueos indefinidos de hilos a la espera de notificaciones que nunca van a llegar, siendo este bloqueo diferente de un interbloqueo o deadlock. Debemos ser muy cuidadosos con la programacin de los mecanismos de sincronizacin.\r
\r
Hay que tener en cuenta tambin que debera haber al menos una llamada notify() por cada wait() que se haya realizado, aunque eso tampoco asegura que algn hilo no se quede bloqueado.\r
:::\r
\r
::: question Modifica el ejemplo Sumador-Restador\r
Haz las modificaciones necesarias en las clases del proyecto U3S3_SharedMemory (gurdalo como U3S3_SharedMemory_v2) para que:\r
\r
- El primer hilo que haga una operacin sobre el contador sea un Sumador\r
- Despus de un Sumador siempre se ejecute un Restador y despus de un Restador siempre se ejecute un Sumador, haciendo una secuencia Sumador-Restador-Sumador-Restador-...\r
:::\r
\r
::: details U3S3_SharedMemory_v2\r
\r
\`\`\`java\r
public class Contador {\r
\r
    private int c = 0;\r
    boolean ahoraSumador = true;\r
\r
    public Contador(int c) {\r
        this.c = c;\r
        ahoraSumador = true;\r
    }\r
\r
    public synchronized void incrementa() {\r
        while (!ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) {\r
            }\r
        }\r
\r
        // El hilo hace su tarea\r
        c++;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = false;\r
        notifyAll();\r
\r
    }\r
\r
    public synchronized void decrementa() {\r
        while (ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) { }\r
        }\r
\r
        // El hilo hace su tarea\r
        c--;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = true;\r
        notifyAll();\r
    }\r
\r
    public int valor() {\r
        return c;\r
    }\r
}\r
\`\`\`\r
\r
En la clase Contador hemos incorporado un estado, que controla qu hilo es el que puede ejecutar y cul el que tiene que esperar.\r
\r
Adems, como se comenta ms adelante, se ha movido la salida de los hilos a los mtodos de esta clase.\r
\r
\`\`\`java\r
public class Restador  implements Runnable {\r
    private Contador c;\r
    private String name;\r
    public Restador(String name, Contador c) {\r
        // super(name);\r
        this.name = name;\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        Thread.currentThread().setName(this.name);\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.decrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }        \r
    }\r
}\r
\`\`\`\r
\r
Tanto Restador como Sumador siguen siendo prcticamente idnticos.\r
\r
\`\`\`java\r
public class Sumador  extends Thread {\r
    private Contador c;\r
    public Sumador(String name, Contador c) {\r
        super(name);\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.incrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }\r
    }\r
}\r
\`\`\`\r
\r
La clase principal se mantiene igual.\r
:::\r
\r
::: danger Salida sincronizada\r
Como se puede observar, la salida que en el ejemplo original se realizaba en el mtodo run de Sumador y Restador, ahora se ha movido a la clase Contador, en concreto a los mtodos \`synchronized\`.\r
\r
Hay que tener cuidado con la salida por pantalla. Todos los threads estn usando System.out a la vez y los resultados que se muestran por pantalla, concretamente el orden en el que se muestran, no siempre es el mismo orden en el que se han producido. Por eso es importante que las salidas de los hilos se muevan dentro de los bloques sincronizados.\r
\r
Si no controlamos la forma de mostrar la salida podemos encontrarnos con problemas que estn bien resueltos pero que la salida nos dice lo contrario.\r
:::\r
\r
`]},{title:"4 Introduccin",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit4/",pathLocale:"/es/",extraFields:[`---\r
title: 4 Introduccin\r
---\r
\r
# Tema 4. Programacin en red\r
\r
Hasta ahora hemos visto como varias aplicaciones pueden colaborar entre s para realizar una tarea de forma conjunta (\`multiproceso\`) o bien cmo un mismo programa puede dividir una tarea en partes que se ejecuten de forma concurrente y simultnea (\`multihilo\`). Todo esto ocurre dentro de una mquina, bien sea en **monoprocesador** o **multiprocesador**, controlados por un mismo SO y compartiendo habitualmente parte de la memoria y de la E/S.\r
\r
En este tema vamos a ir un paso ms all, vamos a crear aplicaciones que funcionen en entornos distribuidos. Volvemos a tener mltiples procesos en ejecucin, pero a diferencia de lo que vimos en el tema 2, en el que los procesos tenan una relacin padre-hijo (lanzador-lanzado), ahora los procesos se van a ejecutar en sistemas independientes y se comunicarn a travs de la red usando \`protocolos de comunicacin\`.\r
\r
Podemos encontrar bsicamente dos modelos de sistemas distribuidos:\r
\r
- **Cliente / Servidor**: un proceso, denominado \`servidor\`, ofrece servicios a uno o ms procesos, denominados \`clientes\`.\r
- **Entre iguales (P2P)**: todos los procesos colaboran de forma similar y con un mismo fin, no existiendo una especializacin ni diferenciacin entre ellos..\r
\r
::: warning Procesos e Hilos\r
Para realizar un programa distribuido en el que se pueda realizar una conexin y una comunicacin a travs de una red de ordenadores no partimos de cero. \r
\r
La programacin en red est fuertemente ligada a la programacin multiproceso. Principalmente en la forma de comunicacin que ya vimos entre procesos.\r
\r
Por otro lado, la especializacin y el servicio que ofrece un servidor, de forma simultnea a varios clientes, est basada en la divisin del trabajo en hilos.\r
\r
Por todo lo comentado, todos los conceptos y conocimientos adquiridos hasta ahora nos sirven de base para avanzar en los contenidos de este tema.\r
:::\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Conocer el protocolo TCP/IP, las direcciones usadas en cada capa y y los protocolos asociados.\r
- Conocer las clases que permiten trabajar con direcciones y nombres de servidores.\r
- Aprender las caractersticas bsicas de los protocolos TCP y UDP.\r
- Desarrollar aplicaciones bsicas que se comuniquen usando el protocolo TCP.\r
- Desarrollar aplicaciones bsicas que se comuniquen usando el protocolo UDP.\r
- Disear y programar protocolos para la comunicacin entre aplicaciones distribuidas.\r
- Coordinar la ejecucin de mltiples clientes en servidores multihilo.\r
`]},{title:"4.2 Sockets TCP",headers:[{level:2,title:"4.2.1. Comunicacin cliente/servidor con sockets TCP",slug:"_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",link:"#_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",children:[{level:3,title:"Programacin de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.2.2. Cliente TCP",slug:"_4-2-2-cliente-tcp",link:"#_4-2-2-cliente-tcp",children:[{level:3,title:"Streams para E/S en los sockets",slug:"streams-para-e-s-en-los-sockets",link:"#streams-para-e-s-en-los-sockets",children:[]}]},{level:2,title:"4.2.3 Servidor TCP",slug:"_4-2-3-servidor-tcp",link:"#_4-2-3-servidor-tcp",children:[]},{level:2,title:"4.2.4 Servidor multihilo",slug:"_4-2-4-servidor-multihilo",link:"#_4-2-4-servidor-multihilo",children:[]}],path:"/es/unit4/sockets-tcp.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.2 Sockets TCP\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 Sockets TCP" />\r
\r
# 4.2 Sockets TCP\r
\r
[[toc]]\r
\r
## 4.2.1. Comunicacin cliente/servidor con sockets TCP\r
\r
Oracle ha resumido el uso de los sockets en un breve tutorial. Todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)\r
\r
La interfaz Java que da soporte a sockets TCP est constituida por las clases **ServerSocket** y **Socket**.\r
\r
- ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexin de los clientes. Su mtodo \`accept\` toma una peticin de conexin de la cola, o si la cola est vaca, se bloquea hasta que llega una peticin.\r
  \r
  El resultado de ejecutar accept es una instancia de Socket, a travs del cual el servidor tiene acceso a los datos enviados por el cliente.\r
\r
- Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, as se crea el socket local y adems se conecta con el servicio.\r
  \r
  Esta clase proporciona los mtodos \`getInputStream\` y \`getOutputStream\` para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir \`BufferedReader\` y \`PrintWriter\`, respectivamente, para poder procesar los datos de forma ms sencilla.\r
\r
### Programacin de aplicaciones Cliente y/o Servidor\r
\r
Al crear aplicaciones cliente y servidor puede que nos encontremos con varios escenarios, a saber:\r
\r
- Si tenemos que programar solo el servidor **deberemos definir un protocolo** de comunicacin para usar ese servidor.\r
- Si tenemos que programar solo el cliente **necesitaremos conocer el protocolo** de comunicacin para conectar con ese servidor.\r
- Si tenemos que programar el cliente y el servidor, tendremos que empezar por **definir el protocolo** de comunicacin entre ambos.\r
\r
::: info Herramientas para definir los protocolos\r
Dentro de todos los diagramas que ofrece UML, el diagrama de secuencia es el que mejor se adapta para definir los protocolos de comunicacin entre clases y las interacciones que se producen.\r
\r
Para crear estos diagramas existen multitud de herramientas, tanto de escritorio como online. De todas ellas cabe destacar:\r
\r
- [Mermaid Live editor](https://mermaid.live/) que usa una [sintaxis en modo texto](https://mermaid-js.github.io/mermaid/#/sequenceDiagram) para definir los diagramas.\r
- [WebSequenceDiagrams](https://www.websequencediagrams.com/): Ms visual y tambin con una definicin textual de los diagramas.\r
- [Visual Paradigm Online](https://online.visual-paradigm.com/drive/#diagramlist:proj=0&dashboard): Herramienta totalmente visual y con unos resultados ms espectaculares.\r
\r
Estas herramientas son las que tenis que usar en las actividades en las que se os pida definir un protocolo de comunicacin cliente / servidor.\r
:::\r
\r
## 4.2.2. Cliente TCP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser:\r
\r
1. Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.\r
2. Obtener las referencias al stream de entrada y al de salida al socket.\r
3. Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar el socket.\r
\r
\`\`\`java{12,14,17,36,38,51,52,54}\r
public class BasicClient {\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est en la misma mquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket("localhost", 4444);\r
            // Obtenemos el canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexin");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenva al servidor hasta que este\r
        // se despide con "Adios"\r
        try {\r
            while (true) {\r
                // Leo la entrada del usuario\r
                linea = stdIn.nextLine();\r
                // La envia al servidor por el OutputStream\r
                salida.println(linea);\r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Enva a la salida estndar la respuesta del servidor\r
                System.out.println("Respuesta servidor: " + linea);\r
                // Si es "Adios" es que finaliza la comunicacin\r
                if (linea.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
\r
        // Libera recursos\r
        salida.close();\r
        entrada.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\r
\`\`\`\r
::: info Herramientas para simular clientes genricos\r
Si slo tenemos que desarrollar un servidor y no tenemos o no queremos hacer un cliente para las pruebas, tenemos varias herramientas que nos ayudan a hacer de clientes genricos, tiles para una gran variedad de servidores, incluso para servidores estndar como FTP, HTTP, etc.\r
\r
La primera herramienta es una aplicacin y un protocolo de nivel de aplicacin de TCP/IP, es la herramienta \`Telnet\`.\r
\r
Esta herramienta suele venir instalada en los sistemas GNU/Linux y OS X. Sin embargo en los sistemas Windows viene deshabilitada por defecto.\r
\r
Os dejo un enlace al artculo de Xataka [Telnet: qu es y cmo activarlo en Windows 10](https://www.xataka.com/basics/telnet-que-como-activarlo-windows-10).\r
\r
Es importante que lo activis tanto en clase como en el aula.\r
\r
La segunda herramienta es NetCat. Es una herramienta muy verstil y potente, ya que no slo puede hacernos de cliente, sino que tambin puede servir como servidor.\r
\r
Como muchas otras herramientas, esta tambin viene instalada de serie en GNU/Linux y OS X, pero no en Windows. Su uso en los sistemas de Microsoft es algo ms controvertido ya que el sistema la detecta como un virus y tenemos que habilitar su uso en el *Guardian* del SO.\r
\r
Os dejo tambin un enlace a este artculo de IONOS [Qu es Netcat y cmo funciona?](https://www.ionos.es/digitalguide/servidores/herramientas/netcat/)\r
:::\r
\r
### Streams para E/S en los sockets\r
\r
Si vemos ejemplos en Internet o en tutoriales, podemos observar que hay dos formas mayoritarias de enviar y recibir la informacin a travs de los streams que proporciona un socket.\r
\r
![Basic Stream IO](../../media/unit4/basicIOStreams.png)\r
\r
En cualquier caso, a travs de los streams enviamos bytes, que es la forma ms bsica de generar informacin, bien sea a travs de la red o entre procesos.\r
\r
Como es complicado gestionar a nivel de bytes toda la informacin que queremos enviar o recibir, usamos \`Decorators\` o \`Wrappers\` para enviar tipos de datos de un nivel de abstraccin mayor.\r
\r
En los temas anteriores, cuando hemos tenido que intercambiar informacin entre procesos, hemos estado usando BufferedReader y PrintWriter. Estas clases trabajan a nivel de Strings, y son muy tiles cuando lo que queremos intercambiar a travs de los streams son cadenas de texto.\r
\r
> En los protocolos de comunicaciones, ms del 90% de la informacin que se intercambia, a nivel de protocolo, es en formato texto.\r
\r
Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos.\r
\r
\`DataInputStream\` y \`DataOutputStream\` proporcionan mtodos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo nmeros y valores booleanos. \r
\r
![Basic Stream IO](../../media/unit4/streamWrappers.png)\r
\r
DataOutputStream codifica esos valores de forma independiente de la mquina y los enva al stream de ms bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.\r
\r
As, podemos trabajar con DataInputStream y DataOutputStream a partir de los streams que nos proporcionan los sockets\r
\r
\`\`\`java\r
// Cdigo en el cliente\r
DataInputStream dis = new DataInputStream(socket.getInputStream());\r
dis.readDouble();\r
\r
// Cdigo en el servidor\r
DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\r
dis.writeDouble(number);\r
\`\`\`\r
\r
Los mtodos \`readUTF()\` and \`writeUTF()\` de DataInputStream y DataOutputStream leen y escriben un String de caracteres Unicode usando la codificacin UTF-8.\r
\r
::: warning Elige un mtodo y usa siempre el mismo\r
Es muy importante no mezclar diferentes wrappers en el mismo sistema. Aunque todos acaban utilizando el InputStream y el OutputStream, las codificaciones y la forma de enviar la informacin no es la misma.\r
\r
Por lo que, si usas DataInputStream en el cliente para leer, debes usar DataOutputStream en el servidor para enviar. Adems de usar los mtodos complementarios para la lectura y escritura, por ejemplo readInt / writeInt.\r
:::\r
\r
Informacin extrada de [Learning Java, 4th Edition - O'Reilly](https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch12s01.html)\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.3 Servidor TCP\r
\r
La forma de implementar un servidor ser:\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_states.png)\r
\r
1. Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.\r
2. Esperar solicitudes de clientes\r
3. Cuando se produce una solicitud:\r
    - Aceptar la conexin obteniendo un objeto de la clase Socket\r
    - Obtener las referencias al stream de entrada y al de salida al socket anterior.\r
    - Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket.Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar los sockets.\r
\r
\`\`\`java{9,23,26,29,36,40,50,51,52,53}\r
public class BasicServer {\r
\r
    public static final int PORT = 4444;\r
\r
    public static void main(String[] args) throws IOException {\r
        // Establece el puerto en el que escucha peticiones\r
        ServerSocket socketServidor = null;\r
        try {\r
            socketServidor = new ServerSocket(PORT);\r
        } catch (IOException e) {\r
            System.out.println("No puede escuchar en el puerto: " + PORT);\r
            System.exit(-1);\r
        }\r
\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        System.out.println("Escuchando: " + socketServidor);\r
        try {\r
            // Se bloquea hasta que recibe alguna peticin de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexin aceptada: " + socketCliente);\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Hace eco de lo que le proporciona el cliente, hasta que recibe "Adios"\r
            while (true) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
                // Enva a la salida estndar el mensaje del cliente\r
                System.out.println("Cliente: " + str);\r
                // Le enva la respuesta al cliente por el OutputStream                \r
                salida.println(str);\r
                // Si es "Adios" es que finaliza la comunicacin\r
                if (str.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
        salida.close();\r
        entrada.close();\r
        socketCliente.close();\r
        socketServidor.close();\r
    }\r
\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_sequence.png)\r
\r
El servidor monohilo se encarga de realizar las operaciones de E/S con el cliente. Hasta que no acaba no puede hacer otro \`accept\` y atender a otro cliente.\r
\r
::: warning Local Name Resolver (hosts file)\r
Deberas saber que DNS traduce nombre de dominio en direcciones IP. Pero, sabes que hay un archivo en tu sistema que puede sobrescribir esas traducciones?\r
\r
Es el archivo \`hosts\` y nos permite mapear nombre de dominio a direcciones IP. Tu archivo HOSTS slo afecta al comportamiento de tu equipo, por lo que podemos usarlo para crear direcciones personalizadas para IP de nuestra red, o bien para redireccionar / bloquear el acceso a determinados sitios web.\r
\r
Como puedes imaginar, cambiar de forma incorrecta o **maliciosa** el contenido del archivo hOSTS puede romper fcilmente el comportamiento de tu conexin a Internet, As que la modificacin del archivo no es trivial para los usuarios, algo que es de agradecer.\r
\r
- Windows\r
\r
El archivo HOSTS est almacenado como un fichero de texto plano en la carpeta del sistema de Windows.\r
\r
Abre el men inicio y escribe "notepad".\r
\r
Pulsa con el botn derecho y selecciona la opcin de "Ejecutar como administrador"\r
\r
En Notepad, ve a Archivo > Abrir y pega la siguiente ruta:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Ahora ya puedes editar y guardar los cambios en tu archivo HOSTS.\r
\r
Para mapear un dominio, aade una nueva lnea siguiendo los ejemplos que hay en el archivo.\r
\r
- OS X & GNU/Linux\r
\r
El archivo est en /etc/hosts y debes editarlo con privilegios de administrador.\r
\r
\`\`\`bash\r
# Aadimos las siguientes entradas al archivo hosts\r
## En clase \r
##  - como cliente y servidor ponemos la IP de nuestro equipo.\r
##  - como profesor ponemos la IP del ordenador del profesor\r
## En casa (la direccin probablemente tenga el formato 192.168.X.X)\r
##  - como cliente, servidor y profesor ponemos la IP de nuestro equipo.\r
\r
# En nuestras actividades, para no tener que ir cambiando las direcciones IP, usaremos \r
# siempre estos nombres de dominio, as los programas funcionarn tanto en clase como\r
# en casa.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.4 Servidor multihilo\r
\r
Si queremos que un servidor pueda atender varias peticiones de forma simultanea, debemos usar hilos para dotarle de esa capacidad.\r
\r
El flujo bsico ahora cambiara para adaptarse a este formato\r
\r
\`\`\`\r
while (true) {\r
\r
    Aceptar la conexin obteniendo un objeto de la clase Socket;\r
\r
    Crear un thread para que se encargue de la comunicacin con ese cliente, es decir, \r
    para que gestione el socket obtenido en el accept.;\r
}\r
\`\`\`\r
![Estados de un servidor multihilo](../../media/unit4/multithread_server_states.png)\r
\r
El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexin de nuevos clientes con los que volver a hacer lo mismo.\r
\r
El servidor multihilo se ayuda de una clase \`Worker\` que hereda de Thread, pudiendo as ejecutarse concurrentemente con el hilo principal.\r
\r
Esta clase \`Worker\` es la encargada de realizar toda la comunicacin con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe  la conexin de un cliente \`ServerSocket.accept()\`.\r
\r
\`\`\`java {6,20,24}\r
public static final int PORT = 4444;\r
public static void main(String[] args)  {\r
    // Establece el puerto en el que escucha peticiones\r
    ServerSocket socketServidor = null;\r
    try {\r
        socketServidor = new ServerSocket(PORT);\r
    } catch (IOException e) {\r
        System.out.println("No puede escuchar en el puerto: " + PORT);\r
        System.exit(-1);\r
    }\r
\r
    Socket socketCliente = null;\r
\r
    System.out.println("Escuchando: " + socketServidor);\r
    try {\r
        \r
        while (true) {\r
            // Se bloquea hasta que recibe alguna peticin de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexin aceptada: " + socketCliente);\r
            // Para seguir aceptando peticiones de otros clientes\r
            // se crea un nuevo hilo que se encargar de la comunicacin con el cliente\r
            new Worker(socketCliente).start();\r
        }\r
                        \r
    ...\r
}    \r
\`\`\`\r
\r
Y esta sera una implementacin estndar de un worker\r
\r
\`\`\`java{13,15,22,26}\r
public class Worker extends Thread {\r
\r
    private Socket socketCliente;\r
    private BufferedReader entrada = null;\r
    private PrintWriter salida = null;\r
\r
    ....\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Realizamos la comunicacin entre servidor y cliente\r
            // **** ES LO QUE CAMBIA EN CADA EJERCICIO ****\r
\r
            // Hacemos una recepcin de informacin desde el cliente\r
            String mensajeRecibido = entrada.readLine();\r
            System.out.println("<-- Cliente: " + mensajeRecibido);\r
            \r
            // Hacemos un envo al cliente\r
            String mensajeEnviado = "Mensaje enviado desde el servidor al cliente";\r
            salida.println(mensajeEnviado);\r
            System.out.println("--> Cliente: " + mensajeEnviado);\r
        }\r
        ....\r
}        \r
\`\`\`\r
\r
Quedando ahora la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/multithread_server_sequence.png)\r
\r
<div class="pagebreak"> </div>\r
\r
::: info Ejecucin de mltiples clientes desde lnea de comandos\r
Para poder lanzar varias aplicaciones java a la vez, la forma ms correcta de hacerlo es desde una terminal de comandos. Esto nos permite poder pasarle argumentos a todas las clases, no slo a la que est marcada como *principal* en el proyecto.\r
\r
Aqu tenemos dos posibilidades, **ejecutar las clases individualmente**, tal y como hacemos desde el IDE o bien **lanzar las clases desde un archivo JAR**.\r
\r
En ambos casos, necesitamos haber compilado y construido el proyecto (*F11  Shift+F11 en Netbeans*).\r
\r
Ejecucin de clases individuales\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener las clases compiladas.\r
- A continuacin, al igual que hacamos con los procesos, debemos ubicarnos en la carpeta \`build/classes\` del proyecto.\r
- Desde ah, ejecutaremos\r
    > build/classes$ java psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuacin del nombre de la clase son los parmetros que la clase recibir en el args[] de su mtodo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > build/classes$ java psp.actividades.U4AX_ClaseSCliente localhost 5566\r
\r
    Si queremos lanzar ms de un cliente, repetiremos el comando desde otra ventana de comandos.\r
\r
Lanzar las clases desde un archivo JAR\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener el proyecto construido\r
- A continuacin, y a diferencia del caso anterior, debemos ubicarnos en el directorio donde est el archivo JAR. Si no lo hemos movido, estar en la carpeta \`dist\` del proyecto.\r
- Desde ah, ejecutaremos, **para la clase principal del proyecto**\r
    > dist$ java -jar U4AX_ProyectoClienteServidor.jar 5566\r
\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuacin del nombre de la clase son los parmetros que la clase recibir en el args[] de su mtodo main.\r
\r
    y para la clase o clases que no sean las principales\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseCliente localhost 5566\r
\r
    Si queremos lanzar ms de un cliente, repetiremos el comando desde otra ventana de comandos.\r
:::`]},{title:"4.3 Sockets UDP",headers:[{level:2,title:"4.3.1. Comunicacin cliente/servidor con sockets UDP",slug:"_4-3-1-comunicacion-cliente-servidor-con-sockets-udp",link:"#_4-3-1-comunicacion-cliente-servidor-con-sockets-udp",children:[{level:3,title:"DatagramSocket",slug:"datagramsocket",link:"#datagramsocket",children:[]},{level:3,title:"DatagramPacket",slug:"datagrampacket",link:"#datagrampacket",children:[]},{level:3,title:"Programacin de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.3.2. Cliente UDP",slug:"_4-3-2-cliente-udp",link:"#_4-3-2-cliente-udp",children:[]},{level:2,title:"4.3.3 Servidor UDP",slug:"_4-3-3-servidor-udp",link:"#_4-3-3-servidor-udp",children:[]},{level:2,title:"4.3.4 Multicast socket",slug:"_4-3-4-multicast-socket",link:"#_4-3-4-multicast-socket",children:[]}],path:"/es/unit4/sockets-udp.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.3 Sockets UDP\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.3 Sockets UDP" />\r
\r
# 4.3 Sockets UDP\r
\r
[[toc]]\r
\r
## 4.3.1. Comunicacin cliente/servidor con sockets UDP\r
\r
Igual que en el apartado anterior, Oracle proporciona una gua son informacin bsica sobre el uso de los Sockets UDP. De nuevo, todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about datagrams](https://docs.oracle.com/javase/tutorial/networking/datagrams/index.html)\r
\r
::: info UDP - Protocolo sin conexin\r
El protocolo de comunicaciones con \`datagramas\` UDP, es un protocolo sin conexin, es decir, cada vez que se enven datagramas es necesario enviar el descriptor del socket local y la direccin del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicacin.\r
\r
Se trata de un servicio de transporte sin conexin. Son ms eficientes que TCP, pero no est garantizada la fiabilidad: los datos se envan y reciben en paquetes, cuya entrega no est garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envi.\r
:::\r
\r
La interfaz Java que da soporte a sockets TCP est constituida por las clases **DatagramPacket** y **DatagramSocket**.\r
\r
- DatagramSocket: es la clase utilizada para realizar el envo y la recepcin de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexin, slo se encarga de transportar los datos del origen al destino.\r
\r
    Lo nico que se hace es enviar los datos, mediante la creacin de un socket y utilizando los mtodos de envo y recepcin apropiados.\r
\r
    Esta clase proporciona los mtodos \`send\` y \`receive\`.\r
\r
- DatagramPackets: esta clase es la encargada de incluir la informacin que se quiere enviar/recibir y la informacin de direccionamiento, es decir, la direccin a la que se quiere enviar l informacin que contiene.\r
  \r
   DatagramPacket contiene la informacin relevante. Cuando se desea recibir un datagrama, ste deber almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no slo debe tener la informacin, sino que adems debe tener la direccin IP y el puerto de destino.\r
\r
::: warning Puertos duplicados UDP / TCP\r
Dado que la gestin de los puertos y el protocolo que se utiliza es diferente, podemos usar el mismo nmero de puerto para un servicio que use el protocolo TCP y otro servicio, en el mismo puerto, que use UDP.\r
\r
En realidad, un socket adems de IP_origen, Puerto_origen, IP_destino, Puerto_destino, tambin incluye el protocolo usado, por eso un socket con el mismo origen y destino, es diferente y puede ser usado a al vez por UDP y TCP\r
\r
**Socket = [Protocolo (TCP/UDP) + IP_origen + Puerto_origen + IP_destino + Puerto_destino]**\r
:::\r
\r
### DatagramSocket\r
\r
Esta clase proporciona los siguiente mtodos\r
\r
| Mtodo | Descripcin |\r
| --- | ----------- |\r
| public DatagramSocket () throws SocketException | Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible. |\r
| public DatagramSocket (int port) throws SocketException | dem, pero con la salvedad de que permite especificar el nmero de puerto asociado. |\r
| public DatagramSocket (int port, InetAddress ip) throws SocketException | Permite especificar, adems del puerto, la direccin local a la que se va a asociar el socket. |\r
| public int getLocalPort() | Retorna el nmero de puerto en el host local al que est conectado el socket. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Enva un DatagramPacket a travs del socket. |\r
| **public setSoTimeout(int timeout)** | Permite establecer un tiempo de espera lmite para que el mtodo receive se quede bloqueado esperando a recibir una respuesta por parte del otro extremo. Si no reciben datos en el tiempo fijado se lanza la excepcin \`InterruptedIOException\` |\r
\r
El DatagramSocket, cuando se utiliza en la parte receptora (la que vamos a llamar servidora) que ofrece el servicio para que los clientes se conecten, slo va a indicar el puerto al que esos clientes deben enviar sus solicitudes. En el caso de los procesos que acten como clientes, se usar el constructor sin parmetros para que sea el SO el que asigne un puerto libre.\r
\r
Por lo tanto, un mismo DatagramSocket al no incluir ninguna informacin de direccionamiento puede ser reutilizado para enviar y/o recibir datagramas a/desde diferentes destinos.\r
\r
### DatagramPacket\r
\r
La clase \`DatagramPacket\` como se ha indicado anteriormente, es un contenedor del mensaje y del destino de ese mensaje.\r
\r
![Datagram Packet](../../media/unit4/datagrampacket.svg)\r
\r
Esta clase proporciona los siguiente mtodos\r
\r
| Mtodo | Descripcin |\r
| --- | ----------- |\r
| public DatagramPacket(byte ibuf[], int  ilength)  | Implementa un DatagramPacket para la **recepcin** de paquetes de longitud ilength, siendo el valor de este parmetro menor o igual que ibuf.length. |\r
| public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)  | Implementa un DatagramPacket para el **envo** de paquetes de longitud ilength al nmero de puerto especificado en el parmetro iport, del host especificado en la direccin de destino que se le pasa por medio del parmetro iaddr. |\r
| public InetAddress getAddress () | Retorna la direccin IP del host al cual se le enva el datagrama o del que el datagrama se recibi. |\r
| public byte[] getData() | Retorna los **datos a recibir** o a enviar. |\r
| public int getLength() | Retorna la longitud de los datos a enviar o a recibir. |\r
| public int getPort() | Retorna el nmero de puerto de la mquina remota a la que se le va a enviar el datagrama o del que se recibi. |\r
\r
Como se intuye de la descripcin de los mtodos, la forma de crear el datagrama va a depender de si queremos enviar o recibir la informacin, ya que en cada uno de estas acciones tendremos que indicar dnde van dirigidos esos datos (envo) o bien esa informacin ya vendr incluida en el datagrama (recepcin) y podremos acceder a ella a travs de los mtodos getter de la clase.\r
\r
Es importante hacer ver que la informacin debe enviarse como un array de bytes y que se recibe de la misma forma, por lo que tendremos que usar los mtodos de String o de cualquiera de los otros tipos primitivos de Java para convertirlos a bytes.\r
\r
### Programacin de aplicaciones Cliente y/o Servidor\r
\r
En el caso de aplicaciones UDP, el protocolo de comunicacin no tiene sentido a nivel de capa de transporte, ya que slo se envan y reciben mensajes y hablamos de un \`protocolo no orientado a conexin\`, por lo tanto no sirve para realizar confirmaciones o dilogos entre la parte servidora y cliente.\r
\r
La parte del protocolo se delega en una capa superior, que ser la encargada de gestionar la comunicacin a un nivel de abstraccin mayor.\r
\r
De todas formas, la comunicacin entre ambas partes debe seguir estando sincronizada en los que a envos / respuestas se refiere para no dejar a la otra parte bloqueada en las lecturas.\r
\r
::: info Bloqueo de lecturas con timeout\r
Esta caracterstica, tambin disponible para los sockets TCP, permite evitar un bloqueo infinito de un hilo a la espera de recibir datos del otro extremo del socket.\r
\r
Es de especial importancia en la gestin de las comunicaciones UDP ya que, como hemos dicho, no tienen porqu seguir un protocolo preestablecido a nivel de transporte.\r
\r
Con el mtodo \`setSoTimeout\` de DatagramSocket podemos fijar un tiempo de espera mximo para la recepcin de datos a travs del socket.\r
:::\r
\r
## 4.3.2. Cliente UDP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente ser:\r
\r
1. El cliente crear un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.\r
2. Utilizar el mtodo send() del socket para enviar la peticin en forma de datagrama.\r
    - La informacin se envia en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
3. Permanece a la espera de recibir respuesta\r
4. El cliente recibe la respuesta del servidor mediante el mtodo receive() del socket.\r
    - La informacin se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
5. Cerrar y liberar los recursos.\r
\r
\`\`\`java{10,14,17,20,28,31}\r
public class BasicUDP_Client {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // IP y puerto al que se enva el Datagrama\r
        InetAddress destino = InetAddress.getLocalHost();\r
        int port = 12345; \r
        \r
        // Buffer para recibir el datagrama\r
        byte[] buffer = new byte[1024];\r
        \r
        // El mensaje a enviar en el Datagrama se convierte a bytes\r
        String mensajeEnviado = "Enviando Saludos !!";\r
        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\r
\r
        // Se preparara el DatagramPacket que se va a enviar\r
        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\r
        // En este caso, especificamos un puerto, aunque podramos dejarlo para\r
        // que el SO asigne uno libre\r
        DatagramSocket socket = new DatagramSocket(34567);\r
        \r
        System.out.println("Host destino : " + destino.getHostName());\r
        System.out.println("IP Destino : " + destino.getHostAddress());\r
        System.out.println("Puerto local del socket: " + socket.getLocalPort());\r
        System.out.println("Puerto al que envio: " + datagramaEnviado.getPort());\r
\r
        // Envo del Datagrama\r
        socket.send(datagramaEnviado);\r
        \r
        // Cierre y liberacin de recursos       \r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.3 Servidor UDP\r
\r
En los sockets UDP no se establece conexin. A pesar de que cuando los programamos s existen diferencias entre el servidor y el cliente, estas no son tan claras como con los sockets TCP. La funcionalidad y el cdigo que diferencia a un servidor de un cliente est ms diluido.\r
\r
> Podemos considerar servidor al que espera un mensaje y responde; y cliente al que inicia la comunicacin.\r
\r
Tanto uno como otro si desean ponerse en contacto necesitan saber en qu ordenador y en qu puerto est escuchando el otro.\r
\r
1. El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.\r
2. Permanece a la espera de recibir peticiones.\r
3. El servidor recibe las peticiones mediante el mtodo receive() del socket.\r
    - La informacin se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
4. En el datagrama recibido va incluido adems del mensaje, el puerto y la IP del cliente emisor de la peticin; lo que le permite al servidor conocer la direccin del emisor del datagrama. Utilizando el mtodo send() del socket puede enviar la respuesta al cliente emisor.\r
5. El servidor permanece a la espera de recibir ms peticiones.\r
6. Cerrar y liberar los recursos.\r
\r
\`\`\`java{6,10,18,20,21,33}\r
public class BasicUDP_Server {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // Buffer para recibir el datagrama\r
        byte[] bufer = new byte[1024];\r
\r
        // El Socket del servidor se asocia a un puerto para que los clientes\r
        // puedan enviar peticiones.\r
        DatagramSocket socket = new DatagramSocket(12345);\r
\r
        // Se espera la llegada de un DATAGRAMA\r
        // Al igual que con TCP, esta llamada a receive es bloqueante\r
        // y es la que tiene que marcar la sincronizacin entre lecturas y \r
        // escrituras de las app cliente / servidor\r
        System.out.println("Esperando Datagrama ................");\r
        // Se crea el objeto que almacenar el mensaje enviado por el cliente\r
        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\r
        // Se espera el mensaje y se le pasa el datagrama para que lo almacene ah\r
        socket.receive(datagramaRecibido);\r
        String mensajeRecibido = new String(datagramaRecibido.getData());\r
\r
        //Informacin recibida\r
        System.out.println("Nmero de Bytes recibidos: " + datagramaRecibido.getLength());\r
        System.out.println("Contenido del Paquete    : " + mensajeRecibido.trim());\r
\r
        System.out.println("Puerto origen del mensaje: " + datagramaRecibido.getPort());\r
\r
        System.out.println("IP de origen             : " + datagramaRecibido.getAddress().getHostAddress());\r
        System.out.println("Puerto destino del mensaje:" + socket.getLocalPort());\r
\r
        // Liberamos los recursos\r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor UDP](../../media/unit4/udp_process.png)\r
\r
Veamos ahora un ejemplo completo de C/S UDP\r
\r
\`\`\`java\r
public class BasicUDP_Client2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // FLUJO PARA ENTRADA ESTANDAR\r
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r
\r
        DatagramSocket clientSocket = new DatagramSocket();\r
        byte[] enviados = new byte[1024];\r
        byte[] recibidos = new byte[1024];\r
\r
        // DATOS DEL SERVIDOR al que enviar mensaje\r
        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\r
        int puerto = 9876; // puerto por el que escucha\r
\r
        // INTRODUCIR DATOS POR TECLADO\r
        System.out.print("Introduce mensaje: ");\r
        String cadena = in.readLine();\r
        enviados = cadena.getBytes();\r
\r
        // ENVIANDO DATAGRAMA AL SERVIDOR\r
        System.out.println("Enviando " + enviados.length + " bytes al servidor.");\r
        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\r
        clientSocket.send(envio);\r
\r
        // RECIBIENDO DATAGRAMA DEL SERVIDOR\r
        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\r
        System.out.println("Esperando datagrama....");\r
        clientSocket.receive(recibo);\r
        String mayuscula = new String(recibo.getData());\r
\r
        // OBTENIENDO INFORMACIN DEL DATAGRAMA\r
        InetAddress IPOrigen = recibo.getAddress();\r
        int puertoOrigen = recibo.getPort();\r
        System.out.println("\\tProcedente de: " + IPOrigen + ":" + puertoOrigen);\r
        System.out.println("\\tDatos: " + mayuscula.trim());\r
\r
        //cerrar socket\r
        clientSocket.close();\r
\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class BasicUDP_Server2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Puerto por el que escucha el servidor: 9876\r
        DatagramSocket serverSocket = new DatagramSocket(9876);\r
        byte[] recibidos = new byte[1024];\r
        byte[] enviados = new byte[1024];\r
        String cadena;\r
\r
        while (true) {\r
            System.out.println("Esperando datagrama.....");\r
\r
            //RECIBO DATAGRAMA\r
            recibidos = new byte[1024];\r
            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\r
            serverSocket.receive(paqRecibido);\r
            cadena = new String(paqRecibido.getData());\r
\r
            //DIRECCION ORIGEN\r
            InetAddress IPOrigen = paqRecibido.getAddress();\r
            int puerto = paqRecibido.getPort();\r
            System.out.println("\\tOrigen: " + IPOrigen + ":" + puerto);\r
            System.out.println("\\tMensaje recibido: " + cadena.trim());\r
\r
            //CONVERTIR CADENA A MAYSCULA\r
            String mayuscula = cadena.trim().toUpperCase();\r
            enviados = mayuscula.getBytes();\r
\r
            //ENVIO DATAGRAMA AL CLIENTE\r
            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\r
            serverSocket.send(paqEnviado);\r
\r
            // Condicin de finalizacin\r
            if (cadena.trim().equals("*")) {\r
                break;\r
            }\r
\r
        }//Fin de while\r
\r
        serverSocket.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.4 Multicast socket\r
\r
La clase MulticastSocket es til para enviar paquetes a mltiples destinos simultneamente.\r
\r
Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo nmero de puerto.\r
\r
Cuando se enva un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibirn el mensaje.\r
\r
La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el nmero de miembros del grupo ni sus direcciones IP.\r
\r
::: info Grupo multicast\r
\r
Un grupo multicast se especifica mediante una direccin IP de clase D y un nmero de puerto UDP estndar.\r
\r
Las direcciones desde la 224.0.0.0 a la 239.255.255.255 estn destinadas para ser direcciones de multicast.\r
\r
La direccin 224.0.0.0 est reservada y no debe ser utilizada.\r
:::\r
\r
Los mtodos que proporciona la clase MulticastSocket son\r
\r
| Mtodo | Descripcin |\r
| --- | ----------- |\r
|  MulticastSocket() throws IOException  | Construye un socket multicast dejando al SO que asigne un puerto libre. |\r
|  MulticastSocket(int port) throws IOException  | Construye un socket multicast y lo conecta al puerto local especificado. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Enva un DatagramPacket a travs del socket. |\r
| joinGroup( InetAddress multicastAddress) | Permite al socket unirse al grupo de multicast. A partir de ese momento podr recibir los mensajes que se envan a esa direccin. Un MulticastSocket puede estar unido a ms de un grupo multicast. |\r
| leaveGroup( InetAddress multicastAddress) | Permite al socket abandonar el grupo de multicast |\r
\r
Y a continuacin presentamos el esquema de llamadas seguido por un **servidor multicast**\r
\r
1. Se crea el socket multicast. No hace falta especificar puerto\r
    > MulticastSocket ms = new MulticastSocket();\r
\r
2. Se define el puerto multicast\r
    > int Puerto = 12345;\r
\r
3. Se crea el grupo multicast\r
    > InetAddress grupo = InetAddress.getByName(225.0.0.1);\r
\r
4. Se crea el datagrama\r
    > DatagramPacket paquete = new DatagramPacket(msg.getBytes(), msg.length(), grupo, Puerto);\r
\r
5. Se enva el paquete al grupo\r
    > ms.send(paquete);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
y el esquema de llamadas seguido por un **cliente multicast**\r
\r
1. Se crea un socket multicast en el puerto establecido\r
    > MulticastSocket ms = new MulticastSocket(12345);\r
\r
2. Se configura la IP del grupo al que nos conectaremos\r
    > InetAddress grupo = InetAddress.getByName(225.0.0.1);\r
\r
3. Se une al grupo\r
    > ms.joinGroup(grupo);\r
\r
4. Recibe el paquete del servidor multicast\r
\r
    > byte[] buf = new byte[1000];\r
DatagramPacket recibido = new DatagramPacket(buf, buf.length);\r
ms.receive(recibido);\r
\r
5. Salimos del grupo multicast:\r
    > ms.leaveGroup(grupo);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
Y ahora lo vemos todo junto con un ejemplo\r
\r
\`\`\`java\r
public class U4_BasicMulticastServer {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // Enviamos la informacin introducida por teclado hasta que se enve un *        \r
        Scanner in = new Scanner(System.in);\r
\r
        //Se crea el socket multicast.\r
        MulticastSocket ms = new MulticastSocket();\r
        // Se escoge un puerto para el server\r
        int puerto = 12345;\r
        // Se escoge una direccin para el grupo\r
        InetAddress grupoMulticast = InetAddress.getByName("225.0.0.1");\r
\r
        String cadena = "";\r
        while (!cadena.trim().equals("*")) {\r
\r
            System.out.print("Datos a enviar al grupo: ");\r
            cadena = in.nextLine();\r
\r
            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\r
            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\r
            ms.send(paquete);\r
        }\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class U4_BasicMulticastClient {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Se crea el socket multicast\r
        // El puerto debe ser el mismo en todos los clientes, ya que el \r
        // servidor multicast enva la informacin a la IP multicast y a un puerto\r
        int puerto = 12345;//Puerto multicast\r
        MulticastSocket ms = new MulticastSocket(puerto);\r
\r
        //Nos unimos al grupo multicast\r
        InetAddress grupo = InetAddress.getByName("225.0.0.1");\r
        ms.joinGroup(grupo);\r
        String msg = "";\r
\r
        while (!msg.trim().equals("*")) {\r
            // El buffer se crea dentro del bucle para que se sobrescriba \r
            // con cada nuevo mensaje\r
            byte[] buf = new byte[1000];\r
            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\r
            //Recibe el paquete del servidor multicast\r
            ms.receive(paquete);\r
            msg = new String(paquete.getData());\r
            System.out.println("Recibo: " + msg.trim());\r
        }\r
\r
        // Abandonamos grupo\r
        ms.leaveGroup(grupo);\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
::: info mezcla de sockets en una app\r
Ya hemos visto todo el abanico de posibilidades que tenemos para comunicar dos procesos en red.\r
\r
A partir de este momento, en nuestras aplicaciones no slo tenemos que elegir uno de ellos, sino que podemos tener varios sockets, de diferente tipo, para comunicar los clientes y los servidores.\r
\r
Se trata ahora de analizar en qu situacin es ms conveniente un tipo que otro y usarlo. Podemos ayudarnos de la creacin de hilos que estn "especializados" en el envo y/o recepcin de informacin de un socket, permitiendo que se intercambien varios mensajes a la vez.\r
:::\r
`]},{title:"4.4 Protocolos con estado",headers:[{level:2,title:"4.4.1. Protocolos con y sin estado",slug:"_4-4-1-protocolos-con-y-sin-estado",link:"#_4-4-1-protocolos-con-y-sin-estado",children:[{level:3,title:"Protocolos sin estado",slug:"protocolos-sin-estado",link:"#protocolos-sin-estado",children:[]},{level:3,title:"Protocolos con estado",slug:"protocolos-con-estado",link:"#protocolos-con-estado",children:[]}]},{level:2,title:"4.4.2 Programacin de servidores basados en estados",slug:"_4-4-2-programacion-de-servidores-basados-en-estados",link:"#_4-4-2-programacion-de-servidores-basados-en-estados",children:[{level:3,title:"Programacin de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.4.3. Ejemplo de servidor con estados",slug:"_4-4-3-ejemplo-de-servidor-con-estados",link:"#_4-4-3-ejemplo-de-servidor-con-estados",children:[{level:3,title:"Ejemplo del Worker que implementa el protocolo",slug:"ejemplo-del-worker-que-implementa-el-protocolo",link:"#ejemplo-del-worker-que-implementa-el-protocolo",children:[]}]},{level:2,title:"4.4.4. Ejemplo de cliente con estados",slug:"_4-4-4-ejemplo-de-cliente-con-estados",link:"#_4-4-4-ejemplo-de-cliente-con-estados",children:[{level:3,title:'Ejemplo de cliente "genrico" que implementa el protocolo',slug:"ejemplo-de-cliente-generico-que-implementa-el-protocolo",link:"#ejemplo-de-cliente-generico-que-implementa-el-protocolo",children:[]}]}],path:"/es/unit4/stateful-protocols.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.4 Protocolos con estado\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.4 Protocolos con estado" />\r
\r
# 4.4 Protocolos con estado\r
\r
[[toc]]\r
\r
## 4.4.1. Protocolos con y sin estado\r
\r
Como ya hemos comentado anteriormente, un protocolo, aplicado al mundo de las comunicaciones informticas, es un conjunto de reglas que especifican la manera en la que se realiza la comunicacin entre dos interlocutores.\r
\r
Este conjunto de reglas establece el formato de los mensajes que se intercambian \`(texto, binario, JSON, XML, CSV, ...)\`, las acciones que cada uno de los extremos de la comunicacin deben realizar en cada momento \`(envo o recepcin)\` y, lo que nos ocupa en este apartado del tema, si las acciones dependen de acciones anteriores o no.\r
\r
### Protocolos sin estado\r
\r
En informtica, un protocolo sin estado es un protocolo de comunicaciones que trata cada peticin como una transaccin independiente que no tiene relacin con cualquier solicitud anterior, de modo que la comunicacin se compone de pares independientes de solicitud y respuesta.\r
[Wikipedia: Protocolo sin estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)\r
\r
El ejemplo ms conocido de protocolo sin estado es HTTP.1 El protocolo no proporciona medio alguno de almacenamiento de datos de un usuario entre las peticiones, dejando esta tarea a niveles superiores y haciendo necesario el reenvo de informacin de manera continua para simular un funcionamiento con estado (cookies, cabeceras, etc.).\r
\r
### Protocolos con estado\r
\r
Un protocolo sin estado no requiere que el servidor retenga informacin de la sesin o de estado acerca de los intercambios de informacin durante la realizacin de mltiples peticiones. En contraste, un protocolo que requiere el mantenimiento del **estado interno en el servidor** se conoce como un **protocolo con estado**.\r
\r
Por lo tanto, un estado es una configuracin en un programa o mquina que depende de los estados anteriores y que determina el funcionamiento del sistema, en funcin de la entrada recibida y del estado actual en el que se encuentre el sistema.\r
\r
Poniendo una analoga, podemos tomar una solicitud a la administracin, donde debemos realizar varios pasos hasta resolver la solicitud.\r
\r
1. En primer lugar se rellena una instancia con los datos y se enva al departamento correspondiente.\r
2. Ese departamento comprobar la instancia recibida y contestar solicitando informacin adicional o confirmando que la solicitud se ha recibido correctamente.\r
3. En un proceso posterior, se solicita un pago de tasas al usuario.\r
4. El usuario tiene que realizar el pago de tasas y enviar el justificante.\r
5. Tras cotejar toda la informacin, se le solicita al usuario que aporte los documentos originales.\r
6. El usuario se persona para mostrar la documentacin original\r
7. Finalmente se resuelve la solicitud informando al usuario el resultado de la misma.\r
\r
Esto, que puede ser un procedimiento normal, refleja claramente un proceso en el que se siguen una serie de pasos y cuyo orden no se puede cambiar.\r
\r
Por ejemplo, no tendra sentido hacer el pago de las tasas (paso 4) sin antes haber presentado la solicitud (paso 1) o sin haber recibido la confirmacin de que la solicitud est completa.\r
\r
Esto mismo pasa con algunos protocolos de comunicacin.\r
\r
## 4.4.2 Programacin de servidores basados en estados\r
\r
Hay toda una teora matemtica, \`la teora de grafos\`, desarrollada en torno a esto, junto con un modelo computacional, \`los autmatas finitos\`, que estudian y optimizan el desarrollo de aplicaciones basadas en estados.\r
\r
La teora de grafos es una rama de las matemticas y las ciencias de la computacin que estudia las propiedades de los grafos\r
\r
La teora de grafos tiene sus fundamentos en las \`matemticas discretas\` y de las \`matemticas aplicadas\`. Esta teora requiere de diferentes conceptos de diversas reas como **combinatoria, lgebra, probabilidad, geometra de polgonos, aritmtica y topologa**. Actualmente ha tenido mayor influencia en el campo de la informtica, las ciencias de la computacin y telecomunicaciones. Debido a la gran cantidad de aplicaciones en la optimizacin de recorridos, procesos, flujos y algoritmos de bsquedas, entre otros\r
\r
Un autmata finito o mquina de estado finito es un modelo computacional que toma decisiones de computacin de forma automtica sobre una entrada para producir una salida.\r
\r
Este modelo est conformado por un alfabeto, un conjunto de estados finito, una funcin de transicin, un estado inicial y un conjunto de estados finales.\r
\r
La finalidad de los autmatas finitos, entre otras, es la de reconocer lenguajes regulares, que corresponden a los lenguajes formales ms simples segn la Jerarqua de Chomsky.\r
\r
### Programacin de aplicaciones Cliente y/o Servidor\r
\r
Como en todos los casos que hemos estudiado con anterioridad, el protocolo es la pieza comn entre los clientes y los servidores.\r
\r
Nuestros clientes podrn estar bien o mal programados, de hecho muchos de nuestros clientes son interactivos, por lo que podemos alterar el orden de los comandos a nuestro antojo, no siendo esto ningn problema.\r
\r
Debe ser el servidor el que tenga el control del proceso, el que asegure la integridad del sistema y de los datos, por lo tanto va a ser en la parte del servidor donde tengamos que realizar las modificaciones para adaptarlo al control y gestin de los estados.\r
\r
Esto no quita que los clientes deban seguir \`sincronizados\` con el servidor para evitar situaciones de interbloqueo, ya que de una forma u otra el cliente siempre debe seguir el protocolo, aunque no los estados tal y como hemos dicho.\r
\r
## 4.4.3. Ejemplo de servidor con estados\r
\r
Vamos a ver qu pasos debemos seguir para controlar los estados en el servidor y cmo adaptar un cliente.\r
\r
El ejemplo que vamos a utilizar es el de la actividad  \`U4A03_ProtocoloSaludo\`. Primero vamos a aclarar cmo debe funcionar este protocolo.\r
\r
Si el cliente est bien programado, el intercambio de informacin entre Cliente y Servidor se realiza en tres pasos\r
\r
1. Cliente enva "Hi Server!"\r
2. Servidor responde "Hi Client!"\r
3. Cliente responde "By Server!"\r
\r
Ante un funcionamiento normal, este protocolo es bastante fcil de implementar. Sin embargo,\r
\r
- Qu pasa si el cliente enva "By Server!" como primer mensaje?\r
- Qu debe responder el servidor si no recibe el mensaje que est esperando?\r
- Qu debe hacer el cliente si no recibe el mensaje que est esperando?\r
\r
Estas son las circunstancias a las que debemos responder con los estados del protocolo, indicando en cada caso qu debe hacer cada una de las partes. Todo depender de la funcionalidad que est implementando el protocolo.\r
\r
Cada caso es diferente, por ejemplo, si es importante hacer los tres pasos en orden, ante cualquier fallo se debe volver a empezar (un borrado en una BD, una autenticacin de tres vas). Si por el contrario, los dos primeros pasos se tienen que realizar de forma conjunta, pero el tercero es independiente, si el incumplimiento del protocolo se produce en ese momento, no es necesario que se repitan los dos primeros pasos, sino que slo ser necesario repetir el ltimo.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Estado Hi\\nEsperando al saludo\r
    Bye: Estado Bye\\nEsperando la despedida\r
    [*] -> Hi\r
    Hi -> Hi : Mensaje incorrecto\\nSe enva error al cliente\r
    Hi -> Bye : Se ha recibido el mensaje correcto\\nSe enva respuesta al cliente\r
    note left of Hi : Permanecemos en este estado\\nhasta que se reciba el mensaje correcto\r
    Bye -> Hi : Mensaje incorrecto\\nSe enva error al cliente\r
    Bye -> [*] : Se ha recibido el mensaje correcto\\nSe cierra la conexin con el cliente\r
-->\r
\r
### Ejemplo del Worker que implementa el protocolo\r
\r
\`\`\`java{12,17,34,50,61,71}\r
public class U4A03_SaludoWorker extends Thread {\r
\r
    Socket socketCliente;\r
    BufferedReader entrada;\r
    PrintWriter salida;\r
\r
    private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\r
    U4A03_SaludoWorker(Socket socketCliente) {\r
        this.socketCliente = socketCliente;\r
        // Inicializamos el valor del estado al estado inicial\r
        estado = Estados.HI;\r
    }\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Recibe lo que enva el cliente hasta que el mensaje sea\r
            // END OF TRANSMISSION\r
            while (estado != Estados.END) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
\r
                // Comprobamos si se ha cerrado el extremo cliente del socket\r
                // Y damos por concluida la comunicacin.\r
                if (str == null) {\r
                    estado = Estados.END;\r
                } else {\r
                    // Mostramos la informacin recibida por consola\r
                    System.out.println("CLIENTE > " + str);\r
                }\r
\r
                // Controlamos la respuesta en funcin del mensaje recibido y \r
                // el estado actual\r
                switch (estado) {\r
                    case HI:\r
                        if (messages[0].equals(str)) {\r
                            // Enviamos respuesta al cliente\r
                            salida.println(messages[1]);\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.BYE;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                        }\r
                        break;\r
                    case BYE:\r
                        if (messages[2].equals(str)) {\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.END;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                            estado = Estados.HI;\r
                        }\r
                        break;\r
                    case END:\r
                        // No sera necesario contemplarlo en este caso\r
                        // Pero s en otros en los que se tenga que enviar \r
                        // algn mensaje antes de salir.\r
                        break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("Error de comunicacin con el cliente");\r
        } catch (Exception e) {\r
            System.out.println(e.getLocalizedMessage());\r
            e.printStackTrace();\r
        } finally {\r
            try {\r
                entrada.close();\r
                System.out.println("Conexin cerrada: " + socketCliente);\r
                socketCliente.close();\r
            } catch (IOException e) {\r
                System.out.println("Error inesperado cerrando los recursos");\r
            }\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El cdigo corresponde al worker de un servidor multihilo. Analicemos ahora el cdigo por partes\r
\r
Es recomendable usar propiedades para guardar los mensajes que queramos comparar y tener un ENuM para definir los estados. Los \`enum\` en Java permiten ser usados en los bloques switch-case.\r
\r
La propiedad **estado** va a ser el punto central que controle el flujo de ejecucin del servidor.\r
\r
\`\`\`java:no-line-numbers {6}\r
private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\`\`\`\r
\r
En el constructor, adems de todas las propiedades, inicializamos el estado, asignndole el valor del estado inicial.\r
\r
\`\`\`java:no-line-numbers{4}\r
U4A03_SaludoWorker(Socket socketCliente) {\r
    this.socketCliente = socketCliente;\r
    // Inicializamos el valor del estado al estado inicial\r
    estado = Estados.HI;\r
}\r
\`\`\`\r
\r
El servidor estar ejecutndose hasta que se alcance el estado final\r
\r
\`\`\`java:no-line-numbers\r
// Recibe lo que enva el cliente hasta que el mensaje sea\r
// END OF TRANSMISSION\r
while (estado != Estados.END) {\r
\`\`\`\r
\r
En este ejemplo, el intercambio de informacin con el cliente se hace uno a uno, es decir se recibe un mensaje y se enva una respuesta, pero no tiene porqu ser as, se pueden recibir varios mensajes y no enviar respuesta, o cualquier combinacin de envo respuesta que nos imaginemos.\r
\r
El cdigo que sigue e un control para saber si el cliente ha cerrado el socket, as evitamos tener excepciones de tipo NullPointerException o dejar al servidor en un bucle infinito. Forzamos la salida cambiando el estado del protocolo.\r
\r
\`\`\`java:no-line-numbers{4}\r
// Comprobamos si se ha cerrado el extremo cliente del socket\r
// Y damos por concluida la comunicacin.\r
if (str == null) {\r
    estado = Estados.END;\r
} else {\r
    // Mostramos la informacin recibida por consola\r
    System.out.println("CLIENTE > " + str);\r
}\r
\`\`\`\r
\r
Este es el cdigo que implementa el diagrama de estados que he diseado para esta actividad.\r
Fijaos que el servidor tiene que realizar una comprobacin para cada lnea que sale de un estado. En este caso al ser slo dos lneas, sirve con un if-else, pero puede ser un nmero mayor de opciones.\r
\r
Adems, una de las opciones tiene un comportamiento totalmente diferente al resto, ya que **cuando se recibe el mensaje final, el protocolo no dice que enviemos una respuesta al cliente**.\r
\r
Esto \`debemos controlarlo en el cliente\`, porque si lo programamos de forma que enve un mensaje y espere una respuesta, puede quedarse bloqueado en la lectura. Aprovechando que este es el ltimo mensaje, ms adelante veremos cmo se ha solventado en el cliente.y las opciones que tenemos para evitar posibles bloqueos como este.\r
\r
\`\`\`java:no-line-numbers{16}\r
// Controlamos la respuesta en funcin del mensaje recibido y \r
// el estado actual\r
switch (estado) {\r
    case HI:\r
        if (messages[0].equals(str)) {\r
            // Enviamos respuesta al cliente\r
            salida.println(messages[1]);\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.BYE;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
        }\r
        break;\r
    case BYE:\r
        if (messages[2].equals(str)) {\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.END;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
            estado = Estados.HI;\r
        }\r
        break;\r
    case END:\r
        // No sera necesario contemplarlo en este caso\r
        // Pero s en otros en los que se tenga que enviar \r
        // algn mensaje antes de salir.\r
        break;\r
}\r
\`\`\`\r
\r
## 4.4.4. Ejemplo de cliente con estados\r
\r
Aunque un cliente interactivo como los que usamos para las pruebas no deberan cambiar su funcionalidad, s hay que hacer pequeos ajustes para adaptar su funcionamiento a las posibles respuestas y errores que enva el servidor.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/client_sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Envo mensaje\r
    Bye: Recibo mensaje\r
    [*] -> Hi\r
    Hi -> Bye : Se enva un mensaje\\nSe espera la respuesta del servidor\r
    Bye -> Hi : Se muestra la respuesta del servidor\r
    note left of Hi : Se envan mensajes\\nmientras el servidor mantenga\\nla conexin abierta   \r
    Hi -> [*] : Se ha detectado el cierre\\nde la conexin con el servidor\r
-->\r
\r
Como ya hemos dicho en el cdigo del servidor, si implementamos el protocolo como un cliente de envo-respuesta, hay un caso en el que no debemos esperar una respuesta. Este es el caso de la salida, en la que se enva un mensaje pero no esperamos respuesta por parte del servidor.\r
\r
Se puede pensar en poner una condicin de salida para cuando el cliente enva el ltimo mensaje, pero no podemos asegurar que ese mensaje cerrar la comunicacin, porque depender del estado en el que se encuentre el servidor.\r
\r
### Ejemplo de cliente "genrico" que implementa el protocolo\r
\r
\`\`\`java{39,41}\r
public class U4A03_SaludoClient {\r
\r
    private static final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que est en la misma mquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket(args[0], Integer.parseInt(args[1]));\r
\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexin");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenva al servidor hasta que se enva \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
            // Recibe la respuesta del servidor por el InputStream\r
            linea = entrada.readLine();\r
            if (linea == null) {\r
                // Comprobamos si se ha cerrado el extremo servidor del socket\r
                // Y damos por concluida la comunicacin.\r
                break;\r
            } else {\r
                // Enva a la salida estndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            }\r
        } while (true);\r
\r
        // Libera recursos\r
        salida.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\`\`\`\r
\r
El cdigo corresponde a un cliente interactivo genrico, que va enviando mensajes y esperando la respuesta de los mismos sin hacer ningn tipo de control sobre lo que se enva o lo que recibe.\r
\r
Analicemos algunos aspectos del cdigo del cliente\r
\r
La parte que sigue es equivalente a la que hemos usado en el servidor. No modificamos el flujo envo-recepcin, pero s que comprobamos si el lado del servidor ha cerrado el socket (ha realizado todo el protocolo correctamente) para decidir que el cliente finalice su ejecucin.\r
\r
\`\`\`java:no-line-numbers{3}\r
// Recibe la respuesta del servidor por el InputStream\r
linea = entrada.readLine();\r
if (linea == null) {\r
    // Comprobamos si se ha cerrado el extremo servidor del socket\r
    // Y damos por concluida la comunicacin.\r
    break;\r
} else {\r
    // Enva a la salida estndar la respuesta del servidor\r
    System.out.println("SERVIDOR > " + linea);\r
}\r
} while (true);\r
\`\`\`\r
\r
::: warning Lectura con timeout\r
Otra manera distinta de hacer lo mismo es usando lecturas con timeout.\r
\r
En este ejemplo podramos haber comprobado si el mensaje enviado es el mensaje de finalizacin. Es ese caso, si todo ha ido bien, no deberamos esperar una respuesta por parte del server, pero si ha habido algn error, s debemos realizar una lectura del socket.\r
\r
Usando este cdigo\r
\r
\`\`\`java\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenva al servidor hasta que se enva \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
\r
            // Si enviamos el mensaje de salida, no hacemos una lectura indefinida\r
            if (linea.equals(messages[2])) {\r
                socketCliente.setSoTimeout(100);\r
            } else {\r
                socketCliente.setSoTimeout(0);\r
            }\r
\r
            try { \r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Enva a la salida estndar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            } catch (SocketTimeoutException ste) {\r
                // Pasado el timeout no se ha recibido una respuesta\r
                // Podemos suponer que el server no enva respuesta\r
                // Eso indica que el protocolo se ha completado\r
                // Damos por concluida la comunicacin.\r
                break;\r
            }            \r
        } while (true);\r
\`\`\`\r
\r
fijamos un tiempo de espera pasado el cual se producir una \`SocketTimeoutException\` indicando que no se ha ledo nada del socket. Si por el contrario se lee informacin del socket, esta se muestra por la consola.\r
\r
En este caso en concreto, esta solucin no funciona porque el servidor ya ha cerrado el socket. Esto sera til cuando tengamos que hacer una \`lectura opcional\` en mitad de un protocolo, y servira tanto para un cliente como para un servidor.\r
:::\r
`]},{title:"4.1 Pila de protocolos TCP IP",headers:[{level:2,title:"4.1.1. Las capas del modelo TCP/IP",slug:"_4-1-1-las-capas-del-modelo-tcp-ip",link:"#_4-1-1-las-capas-del-modelo-tcp-ip",children:[]},{level:2,title:"4.1.2. Direcciones y puertos - Sockets",slug:"_4-1-2-direcciones-y-puertos-sockets",link:"#_4-1-2-direcciones-y-puertos-sockets",children:[{level:3,title:"Direcciones IP",slug:"direcciones-ip",link:"#direcciones-ip",children:[]},{level:3,title:"Puertos",slug:"puertos",link:"#puertos",children:[]},{level:3,title:"Sockets",slug:"sockets",link:"#sockets",children:[]}]},{level:2,title:"4.1.3 TCP vs UDP",slug:"_4-1-3-tcp-vs-udp",link:"#_4-1-3-tcp-vs-udp",children:[]}],path:"/es/unit4/tcp-ip.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.1 Pila de protocolos TCP IP\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.1 Pila de protocolos TCP IP" />\r
\r
# 4.1 Pila de protocolos TCP IP\r
\r
[[toc]]\r
\r
## 4.1.1. Las capas del modelo TCP/IP\r
\r
La pila de protocolos TCP/IP, o los protocolos de internet, son un conjunto de \`protocolos de comunicacin\` usados en la red Internet o en redes similares.\r
\r
TCP/IP son los protocolos ms usados a nivel mundial. Son protocolos abiertos y por ese motivo permiten la comunicacin entre mquinas usando diferentes plataformas de hardware y software. Estos protocolos funcionan tanto en redes de rea extensa (WAN) como en redes de rea local (LAN).\r
\r
La pila de protocolos TCP/IP es, como hemos dicho, un conjunto de protocolos que reciben su nombre de los dos protocolos ms importantes \`Protocolo de Control de la Transmission(TCP)\` and the \`Protocolo de Internet(IP)\`. Adems de estos protocolos, la pila TCP/IP incluye muchos otros protocolos de ms alto nivel que facilitan la comunicacin con aplicaciones como el email, transferencia de archivos, servidores web, etc.\r
\r
::: info Documentos RFC\r
Cada protocolo de Internet, junto con sus correcciones y modificaciones posteriores, est descrito en un documento conocido como \`Request For Comments (RFC)\`.\r
\r
Aqu se puede consultar la lista de los RFCs disponibles: [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).\r
:::\r
\r
Recibe el nombre de **pila** o **stack** porque est diseado como una jerarqua de capas en las que cada capa da soporte a la capa que tiene por encima y utiliza los servicios de la capa que tiene por debajo. Cada capa est encargada de resolver un subconjunto de los problemas especficos que encontramos cuando queremos realizar una comunicacin de datos entre equipos en una red. \r
\r
El modelo TCP/IP est dividido en cuatro capas. De ms bajo nivel a ms alto tenemos la capa de enlace de datos (Link), la capa de red (internet), la capa de transporte y la capa de aplicacin, tal y como podemos ver en la siguiente imagen.\r
\r
![TCP/IP real communication flow](../../media/unit4/1-ip-real-communication-flow.gif)\r
\r
- La **capa de enlace** proporciona la comunicacin entre dos interfaces o tarjetas de red dentro de una misma red local, con conexin directa o a travs de uno o varios switches.\r
- La **capa de red** proporciona comunicacin entre dos interfaces de red o hosts. Estos hosts pueden estar en la misma red o en redes diferentes, siempre que estn interconectadas por uno o ms routers. A cada interfaz de red se le asigna una direccin IP que identifica al equipo de forma unvoca. El protocolo IP es el ms importante de esta capa y probablemente sea el ms importante de toda la pila de protocolos.\r
- La **capa de transporte** se encarga de proporcionar una comunicacin punto a punto, permitiendo manejar mltiples transferencias de informacin de forma simultanea. El protocolo principal de esta capa es el protocolo \`TCP\`, que se encarga de proporcionar un servicio confiable y orientado a conexin. \`UDP\` por su parte proporciona un servicio ms eficaz y rpido, pero lo hace de forma no fiable y no orientado a conexin.\r
- La **capa de aplicacin** proporciona servicios especficos de transmisin fiable para un tipo determinado de aplicacin (transferencia de archivos, correo electrnico, gestin de red, configuracin de red, etc.). Esta capa se encuentra unas veces dentro de las aplicaciones cliente que usamos para acceder a estos servicios y en otras ocasiones como servicios del propio SO. El interfaz entre los protocolos de la capa de aplicacin y los protocolos de la capa de transporte se definen como \`puertos \` y \`sockets\`.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.1-ip-protocols.png)\r
\r
## 4.1.2. Direcciones y puertos - Sockets\r
\r
### Direcciones IP\r
\r
Cada host o equipo que est en una red TCP/IP tiene asignada na direccin IP nica consistente en un nmero de red y un nmero de host. El nmero de red sirve para identificar la red en la que se encuentran los hosts. El nmero de host sirve para identificar a un host dentro de una red.\r
\r
Las direcciones Ipv4 son direcciones de 32-bits. La direccin IP se agrupa en cuatro octetos o bytes (grupos de 8 bits) y se representan usando el valor en notacin decimal de cada uno de los bytes, separados por puntos. El valor mnimo para cada octeto es 0 y el valor mximo es 255.\r
\r
> 192.168.0.100\r
>\r
> 127.0.0.1\r
>\r
> 10.1.100.1\r
\r
Las direcciones IPv6 est formadas por 64-bits para la direccin de red o prefijo de red, y otros 64 bits para el nmero de host. Las direcciones IPv6 se escriben como 8 grupos de 4 dgitos hexadecimales separados por el caracter ':'. Un grupo que slo tiene ceros puede ser omitido. Los ceros iniciales tambin se pueden omitir\r
\r
Todas estas direcciones seran equivalentes. Se les han aplicado diferentes reglas de reduccin\r
\r
> 2001:0db8:0000:0000:0000:0000:1428:57ab\r
>\r
> 2001:0db8:0000:0000:0000::1428:57ab\r
>\r
> 2001:0db8:0:0:0:0:1428:57ab\r
>\r
> 2001:0db8:0:0::1428:57ab\r
>\r
> 2001:0db8::1428:57ab\r
>\r
> 2001:db8::1428:57ab\r
\r
![Routing](../../media/unit4/data_transfer.gif)\r
\r
### Puertos\r
\r
Cuando una aplicacin que se estejecutando en un equipo quiere comunicarse con otra aplicacin de otro equipo, se identifica a s misma con un nmero de 16 bits, que denominamos \`puerto\`. Ese identificador es usado por los protocolos de la capa de transporte (TCP or UDP) para entregar los mensajes a la aplicacin correcta dentro del equipo.\r
\r
Los puertos van de 0 a 65535, y se agrupan en tres rangos\r
\r
| Grupo de puertos                      | Rango de puertos    | Descripcin                                                    |\r
| ------------------------------- | ------------- | -------------------------------------------------------------- |\r
| Puertos bien conocidos o puertos del sistema | 0 - 1023      | Los usan los protocolos estndar y los servicios del SO |\r
| Puertos registrados | 1024- 49151   | Reservados por empresas y organizaciones para sus propios servicios |\r
| Puertos efmeros | 49152 - 65535 | De libre disposicin y uso para aplicaciones cliente y servidor |\r
\r
Los servidores de protocolos estndar como Telnet y FTP usan uno o ms de estos puertos bien conocidos. La mayora de los servidores slo utilizan un puerto aunque hay otros, como FTP, que usan dos. El uso de un puerto especfico permite a las aplicaciones cliente el poder comunicarse con el servidor sin tener que enviar una peticin previa para determinar qu puerto se est usando.\r
\r
> Por ejemplo, las peticiones HTTP se envan por defecto al puerto 80 del servidor..\r
\r
Las aplicaciones cliente (navegadores, clientes de correo, etc) no necesitan usar uno de los puertos bien conocidos ya que son los que inician la comunicacin. A los procesos cliente se les asigna un nmero de puerto de forma dinmica por parte del SO. Ese nmero est incluido en todos los datagramas que intercambia con el servidor, por lo tanto el servidor tiene acceso a esa informacin.\r
\r
### Sockets\r
\r
Un \`socket\` es bsicamente un punto final de conexin en una comunicacin entre proceso y est formado por una combinacin unica de  **direccin IP, puerto y protocolo de transporte (normalmente TCP)**.\r
\r
Cuando una aplicacin cliente quiere comunicarse con un servidor, el SO crea el socket que usar el cliente para recibir la informacin del servidor. lA combinacin nica de Protocolo + puerto + IP permite que este extremo de la comunicacin sea accesible desde el servidor, de manera inequvoca y asegura que los datos los recibe el proceso que los solicit.\r
\r
El servidor tiene su propio socket par comunicarse con el cliente, y una conexin establecida entre el cliente y el servidor usando los dos extremos (los dos sockets cliente <--> servidor. Las aplicaciones intercambian informacin escribiendo o leyendo en los sockets que han creado..\r
\r
La conexin usada por un cliente est formada por dos sockets, uno en el lado del cliente y otro en el lado des servidor. Por lo tanto, la conexin puede identificarse con una tupla formada por cuatro nmero: la direccin IP de origen, la direccin IP de destino, el puerto de origen y el puerto de destino.\r
\r
Esto permite que mltiples aplicaciones cliente ejecutndose en mquinas diferentes puedan conectarse al mismo socket de destino en el servidor. Tampoco hay confusin de a qu equipo se debe enviar un datagram de respuesta, incluso si el puerto de origen y destino es el mismo.\r
\r
Usando sockets tambin es posible tener varias aplicaciones cliente corriendo en el mismo equipo y conectndose al mismo servidor (varias pestaas de un navegador). Los datagramas de respuesta enviados por el servidor al cliente contienen la informacin del socket en el lado del client, la cual incluye el puerto asignado individualmente a cada uno de los clientes, no pudiendo haber confusin sobre a qu proceso entregar la respuesta.\r
\r
![TCP/IP logical communication flow](../../media/unit4/2-ip-logical-communication-flow.gif)\r
\r
En una red, la comunicacin real se realiza de una capa a la siguiente o a la anterior. Sin embargo, las aplicaciones de cada capa realizan una abstraccin de las capas inferiores y ven su flujo de comunicacin como una comunicacin directa con la capa equivalente en el otro extremo de la conexin.\r
\r
En la pila de protocolos TCP/IP se manejan diferentes elementos de informacin en cada nivel (frames, packets, datagramas, streams, messages, ...).\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.0-The-TCP-IP-UDP-IP-Stack_Q640.jpg)\r
\r
Como ya se ha citando anteriormente, los sockets son el puente entre la capa de transporte y la capa de aplicacin. Este es el punto donde vamos a trabajar y desarrollar nuestras aplicaciones en este tema, ofreciendo servicios a los protocolos de la capa superior, la capa de aplicacin.\r
\r
## 4.1.3 TCP vs UDP\r
\r
El protocolo TCP que es el ms utilizado en la navegacin cotidiana. Es el ms habitual por tratarse de un protocolo de transporte orientado a conexin. Esto quiere decir que el protocolo TCP est diseado no solo para transmitir una determinada informacin entre un dispositivo y otro, sino tambin para verificar la correcta recepcin de la informacin transmitida entre un dispositivo y otro, o, dicho de otro modo, es un protocolo para manejar conexiones de extremo a extremo.\r
\r
El protocolo TCP establece una conexin entre el dispositivo emisor y el dispositivo receptor y verifica de forma continua la emisin y recepcin de la informacin entre ambos. El protocolo TCP consigue esta verificacin dividiendo los flujos de bytes en segmentos ordenados con un nmero de secuencia antes de transmitirlos a travs del protocolo IP. Este nmero de secuencia es verificado por el dispositivo receptor y, en caso de que falte alguno de los segmentos, el protocolo TCP vuelve a solicitar su envo a travs del protocolo IP, hasta que el mensaje llega en su totalidad al dispositivo receptor. Gracias a su fiabilidad, el protocolo TCP da soporte a los protocolos HTTP, SMTP, SSH y FTP.\r
\r
El protocolo TCP ofrece los siguientes servicios :\r
\r
- Comunicacin Full duplex: los dos extremos pueden transmitir simultaneamente\r
- Timing: Utiliza temporizadores para asegurar que los datos se transmiten de forma sncrona\r
- Secuenciacin: Los bloques se transmiten con un nmero de secuencia para que puedan ser reensamblados en el destino, en orden correcto, antes de pasarlos al protocolo de la capa de aplicacin.\r
- Control de flujo: Se encarga de gestionar el congestin y adaptar la velocidad de envo / recepcin de bloques.\r
- Gestin de errores: Usa comprobaciones checksum para detectar posibles errores en la transmisin de los datos y gestionar dichos errores.\r
\r
![TCP/IP logical communication flow](../../media/unit4/5-Graphic-UDP-Vs-TCP.png)\r
\r
El protocolo UDP funciona de manera similar al protocolo TCP, pero no es un protocolo de transporte orientado a conexin. Esto quiere decir que el protocolo UDP no verifica la recepcin de los datos transmitidos entre un dispositivo y otro. Por esto, se articula en un nivel de capa inferior al protocolo TCP, con lo que el sistema de verificacin de la recepcin de los datos debe implementarse en las capas superiores.\r
\r
La principal ventaja del protocolo UDP consiste en su velocidad. Al prescindir de un sistema de verificacin de ida y vuelta entre el dispositivo emisor y el dispositivo receptor, el protocolo UDP permite una velocidad de transferencia superior a la del protocolo TCP. Por esto, el protocolo UDP es el ms utilizado por los servicios de transmisin de voz o vdeo en streaming, donde la velocidad de la transmisin es ms importante que una posible prdida de datos puntual.\r
\r
Cabe destacar su uso especializado para transmisiones de tipo multicast y broadcast.\r
\r
![TCP/IP logical communication flow](../../media/unit4/tcp_vs_udp.png)\r
`]},{title:"5.2 Cliente FTP",headers:[{level:2,title:"5.2.1 Apache Common Net FTP",slug:"_5-2-1-apache-common-net-ftp",link:"#_5-2-1-apache-common-net-ftp",children:[]},{level:2,title:"5.2.2 Servidor FTP",slug:"_5-2-2-servidor-ftp",link:"#_5-2-2-servidor-ftp",children:[]},{level:2,title:"5.2.3 Cliente FTP",slug:"_5-2-3-cliente-ftp",link:"#_5-2-3-cliente-ftp",children:[{level:3,title:"5.2.3.1 Conectar y autenticar",slug:"_5-2-3-1-conectar-y-autenticar",link:"#_5-2-3-1-conectar-y-autenticar",children:[]},{level:3,title:"5.2.3.2 Cambio de directorios",slug:"_5-2-3-2-cambio-de-directorios",link:"#_5-2-3-2-cambio-de-directorios",children:[]},{level:3,title:"5.2.3.3 Enviar archivos al servidor",slug:"_5-2-3-3-enviar-archivos-al-servidor",link:"#_5-2-3-3-enviar-archivos-al-servidor",children:[]},{level:3,title:"5.2.3.4 Descargar archivos del servidor",slug:"_5-2-3-4-descargar-archivos-del-servidor",link:"#_5-2-3-4-descargar-archivos-del-servidor",children:[]},{level:3,title:"5.2.3.5 Otras acciones",slug:"_5-2-3-5-otras-acciones",link:"#_5-2-3-5-otras-acciones",children:[]}]}],path:"/es/unit5/ftp.html",pathLocale:"/es/",extraFields:[`---\r
title: 5.2 Cliente FTP\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.2 Cliente FTP" />\r
\r
# 5.2 Cliente FTP\r
\r
[[toc]]\r
\r
## 5.2.1 Apache Common Net FTP\r
\r
La librera Apache Commons Net implementa el lado de muchos protocolos bsicos de Internet.\r
\r
El propsito de la biblioteca es proporcionar acceso a protocolos fundamentales, no abstracciones de alto nivel. Por lo tanto, algunos de los diseos violan los principios de diseo orientado a objetos.\r
\r
Nuestra filosofa es hacer que la funcionalidad global de un protocolo sea accesible (por ejemplo, TFTP enva archivo y recibe archivo) cuando sea posible, pero tambin proporcionar acceso a los protocolos fundamentales cuando corresponda para que el programador pueda construir sus propias implementaciones personalizadas (por ejemplo, las clases de paquetes TFTP y los mtodos de envo y recepcin de paquetes TFTP estn expuestos).\r
\r
::: tip Librera Apache Commons NET\r
\r
Los protocolos soportados incluyen:\r
\r
- FTP/FTPS\r
- FTP over HTTP (experimental)\r
- NNTP\r
- SMTP(S)\r
- POP3(S)\r
- IMAP(S)\r
- Telnet\r
- TFTP\r
- Finger\r
- Whois\r
- rexec/rcmd/rlogin\r
- Time (rdate) and Daytime\r
- Echo\r
- Discard\r
- NTP/SNTP\r
:::\r
\r
En Java, de forma nativa, es posible realizar transferencias de archivos utilizando este protocolo, pero es extremadamente difcil hacerlo. La librera Apache Commons Net proporciona clases y utilidades para realizar cualquier operacin sobre un servidor FTP o FTPS desde un cliente Java.\r
\r
Esta librera se puede descargar desde la pgina web de apache.org a travs del siguiente enlace: https://commons.apache.org/proper/commons-net/\r
\r
## 5.2.2 Servidor FTP\r
\r
El servidor FTP es un programa que se ejecuta en un ordenador y permite que otros ordenadores se conecten a l y transfieran archivos utilizando el protocolo FTP.\r
\r
Para realizar las pruebas vamos a utilizar el servidor FTP FileZilla, que se puede descargar desde la [pgina web de Filezilla](https://filezilla-project.org/download.php?type=server).\r
\r
La instalacin es muy sencilla, simplemente hay que seguir los pasos del asistente de instalacin. Una vez instalado, tendremos que configurar el servidor, para ello tendremos que abrir el programa FileZilla Server Interface, que estar en el men de inicio de Windows.\r
\r
![FileZilla Server Interface](../../media/unit5/FileZilla-Server-Interface.png)\r
\r
Una vez instalado el servidor, tendremos que configurarlo. Para ello, tendremos que abrir el programa FileZilla Server Interface, que estar en el men de inicio de Windows y abrir el men Server y seleccionar la opcin "Configure".\r
\r
A continuacin, en la seccin Users, tendremos que crear un usuario, para ello tendremos que hacer clic en el botn "Add" y rellenar los campos con los datos del usuario que queremos crear. A continuacin, cambiaremos el tipo de autenticacin a "Require a password to login" e introduciremos la contrasea que queremos asignar al usuario.\r
\r
A continuacin, en la seccin Mounting Points, tendremos que aadir un nuevo punto de montaje, para ello tendremos que hacer clic en el botn "Add" y rellenar los campos con los datos del punto de montaje que queremos crear. En el campo "Native path" tendremos que seleccionar el directorio que queremos compartir.\r
\r
::: tip Rutas Virtuales vs Rutas Nativas\r
Las rutas virtuales se utilizan para asignar un directorio en el servidor a un directorio virtual. Esto le permite crear una estructura de directorios virtuales que es diferente de la estructura de directorios real en el servidor. Por ejemplo, puede asignar el directorio "C:\\Mis Documentos" al directorio virtual "/Documentos". Cuando un cliente se conecta al servidor y cambia al directorio "/Documentos", el cliente estar realmente en el directorio "C:\\Mis Documentos" del servidor.\r
:::\r
\r
Una vez que hayamos creado el usuario y el punto de montaje, tendremos que hacer clic en el botn "OK" para guardar los cambios.\r
\r
## 5.2.3 Cliente FTP\r
\r
Las clases y mtodos principales del paquete org.apache.commons.net.ftp se muestran a continuacin.\r
\r
### 5.2.3.1 Conectar y autenticar\r
\r
\`\`\`java\r
public class ApacheFTPClient {\r
\r
    private String server;\r
    private int port;\r
    private String user;\r
    private String password;\r
    private FTPClient ftp;\r
\r
    public ApacheFTPClient(String server, int port, String user, String password) {\r
        this.server = server;\r
        this.port = port;\r
        this.user = user;\r
        this.password = password;\r
    }\r
\r
    void open() throws IOException {\r
        ftp = new FTPClient();\r
\r
        ftp.connect(server, port);\r
        int reply = ftp.getReplyCode();\r
        if (!FTPReply.isPositiveCompletion(reply)) {\r
            ftp.disconnect();\r
            throw new IOException("Exception in connecting to FTP Server");\r
        }\r
\r
        ftp.login(user, password);\r
    }\r
\r
    void close() throws IOException {\r
        ftp.disconnect();\r
    }\r
\r
    public static void main(String[] args) throws IOException {\r
        ApacheFTPClient client = new ApacheFTPClient("localhost", 21, "alumnodam", "psp");\r
        client.open();\r
        client.close();\r
    }\r
}\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver cmo conectarnos a un servidor FTP utilizando la librera Apache Commons Net.\r
\r
1. Para ello, tendremos que crear una instancia de la clase **FTPClient** y llamar al mtodo connect, pasando como parmetros el servidor y el puerto al que queremos conectarnos.\r
1. A continuacin, tendremos que comprobar que la conexin se ha establecido correctamente, para ello tendremos que llamar al mtodo *getReplyCode* y comprobar que el valor devuelto por este mtodo es positivo.\r
1. Por ltimo, tendremos que llamar al mtodo login, pasando como parmetros el usuario y la contrasea con la que queremos iniciar sesin.\r
\r
### 5.2.3.2 Cambio de directorios\r
\r
En el protocolo FTP, el directorio local es el directorio en el ordenador del cliente y el directorio remoto es el directorio en el servidor. Tanto el directorio local como el remoto se llaman directorios de trabajo y ambos se pueden cambiar con el mtodo **changeWorkingDirectory** para los archivos remotos y los mtodos **File** para establecer el origen de los archivos locales.\r
\r
Para mostrar el directorio de trabajo actual, podemos utilizar el mtodo **printWorkingDirectory** y para mostrar el contenido del directorio de trabajo actual, podemos utilizar el mtodo **listFiles** o el mtodo **listNames**.\r
\r
\`\`\`java\r
    // Obtener el directorio de trabajo remoto actual\r
    String workingDirectory = ftp.printWorkingDirectory();\r
    \r
    // Mostrar el contenido del directorio de trabajo remoto actual\r
    for (String name : ftp.listNames()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Cambiar el directorio de trabajo remoto actual\r
    ftp.changeWorkingDirectory(fileName)\r
\`\`\`\r
\r
Para mostrar el directorio de trabajo local actual, tenemos que gestionarlo con la clase File y sus mtodos. Tambin podemos confiar en la clase System y sus mtodos como estudiamos en la unidad de gestin de procesos.\r
\r
\`\`\`java\r
    // Obtener el directorio de trabajo local actual\r
    String workingDirectory = System.getProperty("user.dir");\r
    \r
    // Mostrar el contenido del directorio de trabajo local actual\r
    File file = new File(workingDirectory);\r
    for (String name : file.list()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Cambiar el directorio de trabajo local actual\r
    System.setProperty("user.dir", fileName);\r
\`\`\`\r
\r
### 5.2.3.3 Enviar archivos al servidor\r
\r
En FTP los archivos se pueden cargar de dos formas diferentes:\r
\r
Modo ASCII: el archivo se carga como texto, con las terminaciones de lnea convertidas al estndar de red.\r
\r
\`\`\`java\r
    public boolean sendTextFile(String fileName) throws FileNotFoundException, IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        InputStream input = new FileInputStream(file);\r
        boolean upload = ftp.storeFile(fileRemote, input);\r
        input.close();\r
        return upload;\r
    }\r
\`\`\`\r
\r
Modo binario: el archivo se carga tal cual, sin ninguna conversin.\r
\r
\`\`\`java\r
    public boolean sendBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        InputStream input = new FileInputStream(file);\r
        OutputStream output = ftp.storeFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        input.close();\r
        output.close();\r
        boolean upload = ftp.completePendingCommand();\r
        \r
        return upload;\r
    }\r
\`\`\`\r
\r
### 5.2.3.4 Descargar archivos del servidor\r
\r
Como con la carga, los archivos se pueden descargar de dos formas diferentes:\r
\r
Modo ASCII: el archivo se descarga como texto, con las terminaciones de lnea convertidas al estndar local.\r
\r
\`\`\`java\r
    public boolean getTextFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        OutputStream output = new FileOutputStream(file);\r
        boolean download = ftp.retrieveFile(fileRemote, output);\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
Modo binario: el archivo se descarga tal cual, sin ninguna conversin.\r
\r
\`\`\`java\r
    public boolean getBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        OutputStream output = new FileOutputStream(file);\r
        InputStream input = ftp.retrieveFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        boolean download = ftp.completePendingCommand();\r
        input.close();\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
### 5.2.3.5 Otras acciones\r
\r
Otras acciones que se pueden realizar sobre el servidor FTP son:\r
\r
Mostrar informacin de los archivos y propiedades de los archivos\r
\r
\`\`\`java\r
    public void showFileInfo(String fileName) throws IOException {\r
        FTPFile[] files = ftp.listFiles(fileName);\r
        for (FTPFile file : files) {\r
            System.out.println(file.getName());\r
            System.out.println(file.getTimestamp().getTime());\r
            System.out.println(file.getSize());\r
            if (f.getType() == FTPFile.FILE_TYPE) {\r
                tipo = "File";\r
            }\r
            if (f.getType() == FTPFile.DIRECTORY_TYPE) {\r
                tipo = "Folder";\r
            }\r
        }\r
    }    \r
\`\`\`\r
\r
Aadir y eliminar directorios FTP remotos\r
\r
\`\`\`java\r
    public void addRemoteDirectory(String directory) throws IOException {\r
        ftp.makeDirectory(directory);\r
    }\r
\r
    public void removeRemoteDirectory(String directory) throws IOException {\r
        ftp.removeDirectory(directory);\r
    }\r
\`\`\`\r
\r
Crear y eliminar archivos FTP remotos\r
\r
\`\`\`java\r
    public void addRemoteFile(String fileName) throws IOException {\r
        ftp.storeFile(fileName, new ByteArrayInputStream(new byte[0]));\r
    }\r
\r
    public void removeRemoteFile(String fileName) throws IOException {\r
        ftp.deleteFile(fileName);\r
    }\r
\`\`\`\r
\r
Renombrar archivos y directorios FTP remotos\r
\r
\`\`\`java\r
    public void renameRemoteFile(String oldName, String newName) throws IOException {\r
        ftp.rename(oldName, newName);\r
    }\r
\`\`\`\r
`]},{title:"5.4 Anexo I - Configuraciones GMail",headers:[{level:2,title:"5.4.1 Excepciones comunes al usar el correo de Gmail",slug:"_5-4-1-excepciones-comunes-al-usar-el-correo-de-gmail",link:"#_5-4-1-excepciones-comunes-al-usar-el-correo-de-gmail",children:[{level:3,title:"5.4.1.1 Verificacin en dos pasos",slug:"_5-4-1-1-verificacion-en-dos-pasos",link:"#_5-4-1-1-verificacion-en-dos-pasos",children:[]},{level:3,title:"5.4.1.2 Aplicaciones menos seguras",slug:"_5-4-1-2-aplicaciones-menos-seguras",link:"#_5-4-1-2-aplicaciones-menos-seguras",children:[]}]}],path:"/es/unit5/gmail_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 5.4 Anexo I - Configuraciones GMail\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.4 Anexo I - Configuraciones GMail" />\r
\r
# 5.4 Anexo I - Configuraciones GMail\r
\r
[[toc]]\r
\r
## 5.4.1 Excepciones comunes al usar el correo de Gmail\r
\r
Al enviar un correo electrnico con cualquiera de los mtodos anteriores, es posible que aparezcan las siguientes excepciones, incluso si las credenciales de Gmail son correctas.\r
\r
:::danger Seguridad de Google\r
Es importante comprobar la seguridad de tu cuenta. Cambia la siguiente configuracin solo si ests absolutamente seguro de lo que ests haciendo.\r
\r
No compartas ninguna de las contraseas porque tu cuenta se puede usar sin tu permiso.\r
:::\r
\r
### 5.4.1.1 Verificacin en dos pasos\r
\r
\`\`\`java\r
Error while trying to send mail: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
La excepcin (jakarta.mail.AuthenticationFailedException) habla de la contrasea especfica de la aplicacin requerida. Esto se debe a que su cuenta de Gmail est configurada para la verificacin de 2 pasos, por lo que su contrasea directa de Gmail no funcionar aqu debido a razones de seguridad. Para rectificar esto, debe seguir los pasos a continuacin.\r
\r
1. Inicia sesin con tu cuenta de Google\r
2. Vaya a su cuenta de Google o simplemente haga clic en el enlace [Configuracin de seguridad de la cuenta de Google](https://myaccount.google.com/?pli=1)\r
![Configuracin de Google](../../media/unit5/Google-Settings-1.1.png)\r
3. Haga clic en Seguridad en el men de la izquierda.\r
4. Desplcese un poco hacia abajo para llegar a la seccin "Iniciar sesin en Google", probablemente la 3 seccin desde la parte superior.\r
5. Aqu puede ver que la verificacin en 2 pasos est activada.\r
![Configuracin de Google](../../media/unit5/Google-Settings-1.2.png)\r
6. Haga clic en Contraseas de aplicaciones justo debajo de ella. Google le pedir que vuelva a introducir la contrasea.\r
7. En la siguiente pantalla, debe seleccionar la Aplicacin y el Dispositivo.\r
8. En el men desplegable "Seleccionar aplicacin", simplemente seleccione Otro (Nombre personalizado).\r
9. D un nombre apropiado como "Web" y presione el botn Generar.\r
![Configuracin de Google](../../media/unit5/Google-Settings-1.3.png)\r
10. Aparecer una contrasea generada en la pantalla con una ventana emergente.\r
11. Guarde y use esta contrasea para todo su cdigo de correo Java.\r
\r
### 5.4.1.2 Aplicaciones menos seguras\r
\r
\`\`\`java\r
Error while trying to send mail: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
1. Inicia sesin con tu cuenta de Google\r
1. Vaya a su cuenta de Google o simplemente haga clic en el enlace [Configuracin de aplicaciones menos seguras de Google](https://www.google.com/settings/security/) para avanzar hasta el paso 5.\r
![Configuracin de Google](../../media/unit5/Google-Settings-1.1.png)\r
1. Haga clic en Seguridad en el men de la izquierda.\r
1. Desplcese un poco hacia abajo para llegar a las "Aplicaciones menos seguras".\r
1. Lo encontrar desactivado. Ingrese a la seccin para activarlo.\r
![Configuracin de Google](../../media/unit5/Google-Settings-2.3.png)\r
1. Guarde y use la contrasea de su cuenta para todo su cdigo de correo Java.\r
`]},{title:"5 Introduccin",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit5/",pathLocale:"/es/",extraFields:[`---\r
title: 5 Introduccin\r
---\r
\r
# Tema 5. Servicios en red\r
\r
Los servicios son programas auxiliares utilizados en un sistema para gestionar una coleccin de recursos y prestar su funcionalidad a los usuario y aplicaciones.\r
\r
El acceso a los servicios est formado por el conjunto de operaciones que ofrece, por ejemplo, un servicio de archivos ofrece operaciones de lectura, escritura y borrado de ficheros.\r
\r
Todos los servicios de Internet implementan una relacin cliente-servidor. Existen multitud de libreras para trabajar con los servicios ms comunes. En esta unidad nos vamos a centrar en el servicio FTP (transferencia de archivos), SMTP (envo de emails) y POP3/IMAP (lectura de emails).\r
\r
Adems, hay otras aproximaciones, tambin basadas en la arquitectura cliente-servidor que permiten ofrecer acceso a los sistemas. Entre los ms utilizados, est lo que se denomina API Rest, que no deja de ser un servicio sobre HTTP que permite interactuar con el backend de los sistemas, de forma independiente a la arquitectura y lenguajes utilizados en el frontend.\r
\r
Nosotros vamos a analizar en esta unidad otras aproximaciones como los sistemas de colas, basados en el protocolo MQ, o los sistemas serverless que ofrecen las principales plataformas de computacin en la nube (Azure Functions, AWS Lambda y Google Cloud Functions).\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Utilizar libreras Java para usar los protocolos de aplicacin ms importantes de TCP/IP.\r
- Probar servicios de comunicacin en red.\r
- Permitir operaciones en la nube de forma sencilla.\r
- Crear aplicaciones que permitan una comunicacin asncrona entre clientes y entre clientes y servidores.\r
`]},{title:"5.1 Correo",headers:[{level:2,title:"5.1.1 Jakarta Mail",slug:"_5-1-1-jakarta-mail",link:"#_5-1-1-jakarta-mail",children:[{level:3,title:"Uso de la librera",slug:"uso-de-la-libreria",link:"#uso-de-la-libreria",children:[]}]},{level:2,title:"5.1.2 Clases principales de la API Jakarta Mail",slug:"_5-1-2-clases-principales-de-la-api-jakarta-mail",link:"#_5-1-2-clases-principales-de-la-api-jakarta-mail",children:[{level:3,title:"jakarta.mail.Session",slug:"jakarta-mail-session",link:"#jakarta-mail-session",children:[]},{level:3,title:"jakarta.mail.Message",slug:"jakarta-mail-message",link:"#jakarta-mail-message",children:[]},{level:3,title:"jakarta.mail.Address",slug:"jakarta-mail-address",link:"#jakarta-mail-address",children:[]},{level:3,title:"jakarta.mail.Authenticator",slug:"jakarta-mail-authenticator",link:"#jakarta-mail-authenticator",children:[]},{level:3,title:"jakarta.mail.Transport",slug:"jakarta-mail-transport",link:"#jakarta-mail-transport",children:[]}]},{level:2,title:"5.1.3 Enviar correos electrnicos bsicos en Jakarta Mail",slug:"_5-1-3-enviar-correos-electronicos-basicos-en-jakarta-mail",link:"#_5-1-3-enviar-correos-electronicos-basicos-en-jakarta-mail",children:[{level:3,title:"Preparacin de la sesin",slug:"preparacion-de-la-sesion",link:"#preparacion-de-la-sesion",children:[]},{level:3,title:"Composicin del mensaje (texto sin formato)",slug:"composicion-del-mensaje-texto-sin-formato",link:"#composicion-del-mensaje-texto-sin-formato",children:[]},{level:3,title:"Enviar mensaje",slug:"enviar-mensaje",link:"#enviar-mensaje",children:[]}]},{level:2,title:"5.1.4 Enviar mensajes HTML",slug:"_5-1-4-enviar-mensajes-html",link:"#_5-1-4-enviar-mensajes-html",children:[]},{level:2,title:"5.1.5 Enviar correo electrnico con archivos adjuntos",slug:"_5-1-5-enviar-correo-electronico-con-archivos-adjuntos",link:"#_5-1-5-enviar-correo-electronico-con-archivos-adjuntos",children:[]},{level:2,title:"5.1.6 Enviar correos electrnicos HTML con imgenes",slug:"_5-1-6-enviar-correos-electronicos-html-con-imagenes",link:"#_5-1-6-enviar-correos-electronicos-html-con-imagenes",children:[{level:3,title:"Insertando imgenes CID (Content-ID)",slug:"insertando-imagenes-cid-content-id",link:"#insertando-imagenes-cid-content-id",children:[]},{level:3,title:"Insertando imgenes en lnea (Base64)",slug:"insertando-imagenes-en-linea-base64",link:"#insertando-imagenes-en-linea-base64",children:[]},{level:3,title:"Linked images",slug:"linked-images",link:"#linked-images",children:[]}]},{level:2,title:"5.1.7 Lectura de emails con Jakarta Mail",slug:"_5-1-7-lectura-de-emails-con-jakarta-mail",link:"#_5-1-7-lectura-de-emails-con-jakarta-mail",children:[]}],path:"/es/unit5/mail.html",pathLocale:"/es/",extraFields:[`---\r
title: 5.1 Correo\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.1 Correo" />\r
\r
# 5.1 Correo\r
\r
[[toc]]\r
\r
## 5.1.1 Jakarta Mail\r
\r
Al buscar en Internet tutoriales sobre el envo de correos electrnicos usando Java, existe una alta probabilidad de que cada uno mencione algo llamado \`Jakarta Mail\` o \`Java Mail\`.\r
\r
Durante mucho tiempo, Java Enterprise Edition (comnmente conocido como Java EE), ha sido la plataforma de facto para desarrollar aplicaciones de misin crtica.\r
\r
Recientemente, con el fin de impulsar la creacin de aplicaciones nativas de la nube, varios proveedores de software prominentes se unieron para transferir tecnologas Java EE a la Fundacin Eclipse, que es una organizacin sin fines de lucro encargada de administrar las actividades de la comunidad de software de cdigo abierto Eclipse.\r
\r
> **En consecuencia, Java EE ha sido renombrado a Jakarta EE.**\r
\r
A pesar del cambio de nombre, todas las clases principales y definiciones de propiedades siguen siendo las mismas tanto para Jakarta Mail como para JavaMail.\r
\r
::: tip Jakarta vs Java Mail\r
Para evitar confusiones, es importante tener en cuenta que JavaMail es solo el nombre anterior de Jakarta Mail y los dos representan el mismo software.\r
:::\r
\r
Entonces, Jakarta Mail, o JavaMail como a algunos todava les gusta llamarlo, es una API para enviar y recibir correos electrnicos a travs de **SMTP**, **POP3**, as como **IMAP** y es la opcin ms popular que tambin admite la autenticacin TLS y SSL. Es independiente de la plataforma, independiente del protocolo e integrado en la plataforma Jakarta EE.\r
\r
Tambin puede encontrar Jakarta Mail como un paquete opcional para su uso con la plataforma Java SE.\r
\r
\r
\r
### Uso de la librera\r
\r
>[JakartaMail API](https://jakarta.ee/specifications/mail/2.1/jakarta-mail-spec-2.1) es la especificacin de la API de correo de Jakarta. La implementacin de referencia de esta especificacin se puede encontrar en el repositorio de GitHub [Jakarta Mail Specification](https://jakartaee.github.io/mail-api/).\r
\r
::: danger JavaMail API\r
Como su nombre indica, JavaMail API es una API, no una implementacin. Por lo tanto, no puede usarlo directamente en su proyecto. En cambio, debe usar una implementacin de la API de correo de Jakarta, como la implementacin de referencia de la especificacin de la API de correo de Jakarta.\r
:::\r
\r
Tambin puede encontrar el archivo jakarta.mail-api-X.Y.Z.jar en el repositorio de Maven y agregarlo con dependencias \`Maven\`:\r
\r
\`\`\`xml:no-line-numbers\r
    <dependencies>\r
        <dependency>\r
            <groupId>org.eclipse.angus</groupId>\r
            <artifactId>angus-mail</artifactId>\r
            <version>2.0.2</version>\r
            <type>jar</type>\r
        </dependency>\r
        <dependency>\r
            <groupId>jakarta.mail</groupId>\r
            <artifactId>jakarta.mail-api</artifactId>\r
            <version>2.1.2</version>\r
            <type>jar</type>\r
        </dependency>\r
    </dependencies>\r
\`\`\`\r
\r
::: info Implementaciones de Jakarta Mail\r
En el ejemplo anterior hemos usado la implementacin de Jakarta AngusMail, pero se pueden usar otras como la propia de Oracle, simplemente cambiando la dependencia.\r
\r
\`\`\`xml:no-line-numbers\r
        <dependency>\r
            <groupId>com.sun.mail</groupId>\r
            <artifactId>jakarta.mail</artifactId>\r
            <version>2.0.1</version>\r
        </dependency>        \r
\`\`\`\r
\r
Al ser una implementacin del API propuesta por Jakarta, el cdigo debera funcionar sin cambios.\r
:::\r
\r
## 5.1.2 Clases principales de la API Jakarta Mail\r
\r
La API de correo de Jakarta tiene una amplia gama de clases e interfaces que se pueden usar para enviar, leer y realizar otras acciones con mensajes de correo electrnico, al igual que en un sistema de correo tpico.\r
\r
Aunque hay varios paquetes en el Proyecto de Correo de Jakarta, dos de los ms utilizados son \`jakarta.mail\` y \`jakarta.mail.internet\`.\r
\r
El paquete **jakarta.mail** proporciona clases que modelan un sistema de correo y el paquete **jakarta.mail.internet** proporciona clases que se centran en los sistemas de correo de Internet.\r
\r
A continuacin tenemos una descripcin de las clases principales de cada uno de los paquetes:\r
\r
### jakarta.mail.Session\r
\r
La clase Session, que no tiene subclases, es la *clase de nivel superior de la API de correo de Jakarta*. Es un objeto multiproceso que acta como fbrica de conexiones para la API de correo de Jakarta. adems de recopilar las propiedades y los valores predeterminados de la API de correo, **es responsable de los ajustes de configuracin y la autenticacin**.\r
\r
Para obtener el objeto Session, puede llamar a cualquiera de los dos mtodos siguientes:\r
\r
- getDefaultInstance(), que devuelve la sesin predeterminada\r
- getInstance(), que devuelve una nueva sesin\r
  \r
### jakarta.mail.Message\r
\r
La clase Message es una *clase abstracta* que modela un mensaje de correo electrnico; Sus subclases soportan las implementaciones reales. Por lo general, su \`subclase MimeMessage\` *(jakarta.mail.internet.MimeMessage)* se utiliza para preparar los detalles del mensaje de correo electrnico que se enviar. **Un MimeMessage es un mensaje de correo electrnico que utiliza el estilo de formato MIME (Multipurpose Internet Mail Extension)** definido en el RFC822.\r
\r
Estos son algunos de los mtodos ms utilizados de la clase MimeMessage:\r
|Mtodo |Descripcin |\r
|:---|:---|\r
|setFrom(Address addresses) | Se utiliza para establecer el campo de encabezado "De".|\r
|setRecipients(Message.RecipientType type, String addresses) | Se utiliza para establecer el tipo de destinatario indicado en las direcciones proporcionadas. Los posibles tipos de direcciones definidos son "Para" (Message.RecipientType.TO), "CC" (Message.RecipientType.CC) y "CCO" (Message.RecipientType.BCC).|\r
|setSubject(String subject) | Se utiliza para establecer el campo de encabezado del asunto del correo electrnico.|\r
|setText(String text) | Se utiliza para establecer la cadena proporcionada como contenido del correo electrnico, utilizando el tipo MIME de "texto / sin formato". |\r
|setContent(Object message, String contentType) |Se utiliza para establecer el contenido del correo electrnico y se puede utilizar con un tipo MIME que no sea "text/html".|\r
\r
### jakarta.mail.Address\r
\r
La clase Address es una *clase abstracta* que modela las direcciones (direcciones To y From) en un mensaje de correo electrnico; Sus subclases soportan las implementaciones reales. Por lo general, su \`subclase InternetAddress\`, que denota una direccin de correo electrnico de Internet, es la que mas se usa.\r
\r
### jakarta.mail.Authenticator\r
\r
La clase Authenticator es una *clase abstracta* que se utiliza para obtener autenticacin para acceder a los recursos del servidor de correo, a menudo requiriendo la informacin del usuario. Por lo general, su \`subclase PasswordAuthentication\` es la que mas se usa.\r
\r
### jakarta.mail.Transport\r
\r
La clase Transport es una *clase abstracta* que utiliza el \`protocolo SMTP\` para enviar y transportar mensajes de correo electrnico.\r
\r
## 5.1.3 Enviar correos electrnicos bsicos en Jakarta Mail\r
\r
Bsicamente, estos son los pasos para enviar un email utilizando la API de correo de Jakarta:\r
\r
1. Configurar detalles del servidor SMTP utilizando un **objeto Java Properties**. Puede obtener detalles del servidor SMTP de su proveedor de servicios de correo electrnico.\r
1. Crear un objeto Session llamando al mtodo getInstance(). Luego, pasar el \`nombre de usuario y contrasea de la cuenta\` a PasswordAuthentication. Al crear el objeto de sesin, siempre debe registrar el *Authenticator* con la sesin.\r
1. Una vez creado el objeto Session, el siguiente paso es crear el email que se enviar. Para ello, empezaremos pasando el objeto de sesin creado al constructor de clase MimeMessage.\r
1. A continuacin, despus de crear el objeto de mensaje, establecer los campos De, Para y Asunto del email.\r
1. Utilizar el mtodo \`setText()\` para establecer el contenido del mensaje de correo electrnico.\r
1. Utilizar el objeto Transport para enviar el correo.\r
1. Agregue excepciones para recuperar los detalles de cualquier posible error al enviar el mensaje.\r
\r
### Preparacin de la sesin\r
\r
El primer paso es obtener el objeto de sesin de correo. La clase *Session* es una clase singleton. Por lo tanto, no se puede crear directamente una instancia de la misma. Debemos llamar a uno de los mtodos estticos sobrecargados, generalmente \`getInstance()\`.\r
\r
::: info Archivos/Objetos Properties\r
Un archivo de propiedades es un archivo de texto que contiene pares clave-valor para los valores de configuracin de un proyecto.\r
\r
Se pueden crear sobre la marcha como en los siguientes ejemplos, pero tambin se puede leer desde un archivo en el proyecto (esta es la forma preferida).\r
\r
Aqu puedes encontrar algunos enlaces para echar un vistazo a cmo usar y acceder a estos archivos\r
\r
- [Java Properties Files y como usarlos - Arquitectura Java](https://www.arquitecturajava.com/java-properties-files-y-como-usarlos/)\r
- [Getting started with Java properties  - Baeldung](https://www.baeldung.com/java-properties)\r
- [Properties class in Java - javaTpoint](https://www.javatpoint.com/properties-class-in-java)\r
\r
![http://www.instanceofjava.com/2018/01/how-to-read-values-from-properties-file.html](../../media/unit5/propertiesfile.png)\r
\r
En la imagen anterior puedes ver dnde colocar el archivo de propiedades en un proyecto 'Maven'.\r
:::\r
\r
\`\`\` java\r
// Prepare SMTP configuration into a Property object\r
final Properties prop = new Properties();\r
prop.put("mail.smtp.username", "usuario@gmail.com");\r
prop.put("mail.smtp.password", "passwordEmail");\r
prop.put("mail.smtp.host", "smtp.gmail.com");\r
prop.put("mail.smtp.port", "587");\r
prop.put("mail.smtp.auth", "true");\r
prop.put("mail.smtp.starttls.enable", "true"); // TLS\r
\r
// Create the Session with the user credentials\r
Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
    @Override\r
    protected PasswordAuthentication getPasswordAuthentication() {\r
        return new PasswordAuthentication(prop.getProperty("mail.smtp.username"), \r
                    prop.getProperty("mail.smtp.password"));\r
    }\r
});\r
\`\`\`\r
\r
En el cdigo anterior, acabamos de crear el objeto Session con propiedades y el objeto Authenticator.\r
\r
Las propiedades son las siguientes.\r
\r
- mail.smtp.username  Nombre de usuario para acceder al servidor SMTP\r
- mail.smtp.password  Contrasea de acceso al servidor SMTP\r
- mail.smtp.host  Host del servidor SMTP\r
- mail.smtp.port  Puerto\r
- mail.smtp.auth  Se requiere autenticacin.\r
- mail.smtp.starttls.enable  TLS habilitado o no.\r
\r
El Authenticator es una clase abstracta. Su objeto se crea proporcionando una implementacin annima del mtodo \`getPasswordAuthentication()\`. La clase *PasswordAuthentication* se utiliza como marcador para almacenar credenciales de usuario.\r
\r
Este es un cdigo de ejemplo para leer las propiedades de un archivo en el proyecto.\r
\r
\`\`\`java\r
    private void loadSMTPConfiguration() {\r
        try ( InputStream input = this.getClass().getResourceAsStream("/" + propertiesFile)) {\r
\r
            smtpConfiguration = new Properties();\r
            // load a properties file\r
            smtpConfiguration.load(input);\r
\r
            // get the property value and print it out\r
            smtpConfiguration.forEach((key, value) -> System.out.println("Key : " + key + ", Value : " + value));\r
\r
        } catch (IOException ex) {\r
            System.err.println("Cant open properties file: " + ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }\r
    }    \r
\`\`\`\r
\r
El contenido del archivo de propiedades podra ser as\r
\r
\`\`\`txt\r
# Data to send emails from a GMAIL account\r
mail.from=cuenta@iesdoctorbalmis.com  cuenta@gmail.com\r
mail.smtp.username=cuenta@iesdoctorbalmis.com\r
mail.smtp.password=***contrasea de la cuenta habilitando apps poco seguras o contrasea de app con 2FA***\r
\r
mail.smtp.host=smtp.gmail.com\r
mail.smtp.port=587\r
mail.smtp.auth=true\r
mail.smtp.starttls.enable=true\r
\`\`\`\r
\r
### Composicin del mensaje (texto sin formato)\r
\r
A continuacin, redactaremos el mensaje de correo electrnico. La clase jakarta.mail.Message representa un mensaje en Java mail API. Dado que es una clase abstracta, usaremos su clase de implementacin concreta \`jakarta.mail.internet.MimeMessage\`. Java Mail API permite enviar correo en texto plano o en contenido HTML. Comencemos enviando un mensaje de texto sin formato.\r
\r
\`\`\`java{8}\r
// Prepare the MimeMessage\r
Message message = new MimeMessage(mailSession);\r
// Set From and subject email properties\r
message.setFrom(new InternetAddress("no-reply@gmail.com"));\r
message.setSubject("Sending Mail with pure Java Mail API ");\r
\r
// Set to, cc & bcc recipients        \r
InternetAddress[] toEmailAddresses = \r
        InternetAddress.parse("user1@gmail.com, user2@gmail.com");\r
InternetAddress[] ccEmailAddresses = \r
        InternetAddress.parse("user21@gmail.com, user22@gmail.com");\r
InternetAddress[] bccEmailAddresses = \r
        InternetAddress.parse("user31@gmail.com");\r
            \r
message.setRecipients(Message.RecipientType.TO,toEmailAddresses);\r
message.setRecipients(Message.RecipientType.CC,ccEmailAddresses);\r
message.setRecipients(Message.RecipientType.BCC,bccEmailAddresses);\r
\r
/* Mail body with plain Text */\r
message.setText("Hello User," \r
        + "\\n\\n If you read this, means mail sent with Java Mail API is successful");\r
\r
\`\`\`\r
\r
> **Para enviar un correo electrnico en texto sin formato, simplemente pasamos el texto en el mtodo message.setText().**\r
\r
### Enviar mensaje\r
\r
Hasta ahora, hemos creado una sesin y redactado el mensaje. Ahora es el momento de enviar el mensaje a los destinatarios. Usaremos la clase jakarta.mail.Transport para hacerlo. La clase proporciona mtodos \`send()\` sobrecargados.\r
\r
\`\`\`java\r
    // Send the configured message in the session\r
    Transport.send(message);\r
\`\`\`\r
\r
::: info Emails temporales\r
[YopMail](http://www.yopmail.com/en/) es un servicio de correo electrnico temporal que se puede utilizar para recibir correos electrnicos de forma annima. No se requiere registro para usar el servicio. Puede usar cualquier direccin de correo electrnico de su eleccin para recibir correos electrnicos. El servicio es gratuito y se puede utilizar para recibir correos electrnicos de forma annima. El servicio es gratuito y se puede utilizar para recibir correos electrnicos de forma annima.\r
:::\r
\r
## 5.1.4 Enviar mensajes HTML\r
\r
En trminos de usabilidad, el contenido HTML es muy superior al texto sin formato. Por lo tanto, la mayora de las veces enviamos emails en formato HTML. Java Mail API admite el envo de correos electrnicos en formato HTML. Para enviar un correo electrnico con contenido HTML, debemos  reemplazar el mtodo message.setText() con el siguiente cdigo.\r
\r
\`\`\`java\r
...\r
message.setContent("Just discovered that Jakarta Mail is fun and easy to use", \r
"text/html");\r
...\r
\`\`\`\r
\r
> usaremos el mtodo **setContent()** para establecer el contenido y especificar \`"text/html"\` en el segundo argumento, lo que indica que el mensaje tiene formato HTML.\r
\r
## 5.1.5 Enviar correo electrnico con archivos adjuntos\r
\r
Adems de los pasos mencionados anteriormente, estos son los diferentes pasos involucrados en el uso de la API de correo de Jakarta para enviar archivos adjuntos de correo electrnico:\r
\r
1. Creamos una instancia del objeto \`MimeMultipart\` que se utilizar como envoltorio o *wrapper* para las distintas partes *MimeBodyPart*. **Un *MultiPart* acta como un contenedor que guarda varias partes individuales**, y viene con mtodos para obtener y configurar sus diversas subpartes.\r
1. Luego, establecemos la primera parte del objeto *Multipart* pasndole el mensaje real.\r
1. A continuacin, establecemos la segunda y las siguientes parte del objeto *Multipart* agregando los datos adjuntos.\r
1. Incluimos el objeto *Multipart* en el mensaje a enviar.\r
1. Enviamos el mensaje\r
\r
![Estructura del mensaje MIME Multipart](../../media/unit5/e-mail_multipart_structure.png)\r
\r
\`\`\`java{2,5,9,12,16,19}\r
 // create an instance of multipart object\r
Multipart multipart = new MimeMultipart();\r
\r
// create the 1st message body part\r
MimeBodyPart messageBodyPart = new MimeBodyPart();\r
// Add a plain message (HTML can also be added with setContent)\r
messageBodyPart.setText("Please find the attachment sent using Jakarta Mail");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// 2nd. bodyPart with an attached file\r
messageBodyPart = new MimeBodyPart();\r
String filename = "C:/temp/file1.pdf";\r
messageBodyPart.attachFile(filename);\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
## 5.1.6 Enviar correos electrnicos HTML con imgenes\r
\r
Para agregar una imagen a su correo electrnico HTML en Jakarta Mail, puede elegir cualquiera de las tres opciones comunes:\r
\r
- Insertando imgenes CID.\r
- Insertando imgenes en lnea o codificacin Base64.\r
- Enlazando imgenes.\r
  \r
### Insertando imgenes CID (Content-ID)\r
\r
Para insertar imgenes CID, debemos crear un mensaje \`MIME multipart/related\` usando el siguiente cdigo:\r
\r
\`\`\`java{2,5,17}\r
// 1st part of the message. An HTML code with a CID referenced image\r
Multipart multipart = new MimeMultipart("related");\r
MimeBodyPart htmlPart = new MimeBodyPart();\r
//add reference to your image to the HTML body <img src="cid:some-image-cid" alt="img" />\r
String messageBody = "<p></p><img src=\\"cid:my-test-image-cid\\" alt=\\"embedded img\\" /></p>";\r
htmlPart.setText(messageBody, "utf-8", "html");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(htmlPart);\r
\r
// 2nd part of the message. The image with special CID header markers\r
MimeBodyPart imgPart = new MimeBodyPart();\r
// imageFile is the file containing the image\r
imgPart.attachFile(imageFile);\r
// or, if the image is in a byte array in memory, use\r
// imgPart.setDataHandler(new DataHandler(\r
//      new ByteArrayDataSource(bytes, "image/whatever")));\r
imgPart.setContentID("<my-test-image-cid>");\r
// Add the multipart object to the message\r
multipart.addBodyPart(imgPart);\r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
### Insertando imgenes en lnea (Base64)\r
\r
Para la insercin en lnea o la codificacin Base64, debe incluir los datos de imagen codificados en el cuerpo HTML de forma similar a esta:\r
\r
\`\`\`html\r
<img src="data:image/jpeg;base64,base64-encoded-data-here" />\r
\`\`\`\r
\r
::: warning tamao del HTML\r
Cada dgito Base64 representa 6 bits de datos, por lo que el cdigo generado para una imagen real ser bastante grande.\r
\r
Como esto afecta el tamao total del mensaje HTML, es mejor no usar imgenes grandes en lnea.\r
:::\r
\r
Para codificar/decodificar una secuencia en Base 64 podemos usar la clase \`java.util.Base64\`\r
\r
 \`\`\`java\r
byte[] fileContent = new FileInputStream(imageFile).readAllBytes();\r
String base64EncodedData = Base64.getEncoder().encodeToString(fileContent);\r
 \`\`\`\r
\r
:::tip Codificacin base64\r
Base64 es una buena opcin para enviar datos binarios a travs de protocolos de texto como HTTP, sin prdida de informacin.\r
\r
Esta operacin se puede aplicar a cualquier archivo binario. Es til cuando necesitamos transferir contenido binario en formato JSON, por ejemplo desde la aplicacin mvil al endpoint de conexin REST.\r
\r
[Image to Base64 String Conversion - Baeldung](https://www.baeldung.com/java-base64-image-string)\r
:::\r
\r
### Linked images\r
\r
Por ltimo, tenemos imgenes vinculadas que son esencialmente imgenes alojadas en algn servidor externo al que luego crea un enlace.\r
Podemos hacerlo usando la etiqueta img en el cuerpo HTML de la siguiente manera.\r
\r
\`\`\`html\r
<img src="/wp-content/uploads/2018/11/blog/-illustration-email-embedding-images.png" alt="img" />\r
\`\`\`\r
\r
::: warning Debug Jakarta Mail\r
La depuracin juega un papel fundamental en las pruebas de envo de correo electrnico.\r
\r
En Jakarta Mail, es bastante sencillo. Tan solo hay que establecer debug a true en las propiedades de configuracin de la sesin:\r
\r
> props.put("mail.debug", "true");\r
\r
Como resultado, obtendremos una descripcin paso a paso de cmo se ejecuta el cdigo. Si aparece algn problema con el envo del mensaje, comprenderemos instantneamente lo que ha sucedido y en qu paso.\r
:::\r
\r
## 5.1.7 Lectura de emails con Jakarta Mail\r
\r
El API de correo de Jakarta tambin proporciona soporte para leer correos electrnicos. Para leer correos electrnicos, debe usar la clase \`javax.mail.Store\`. La clase Store es una clase abstracta que modela un almacn de mensajes y su protocolo de acceso, y es una subclase de las clases \`POP3Store\` e \`IMAPStore\`.\r
\r
Leer correos electrnicos almacenados en un servidor IMAP consta de los siguientes pasos:\r
\r
- Creacin de la sesin IMAP (Session), indicando el protocolo, el nombre del host, el puerto, si usa SSL y el servidor de autenticacin asociado.\r
- Configuracin y obtencin del almacn (Store).\r
- Obtencin de la conexin a travs del almacn, indicando el identificador de la cuenta y la contrasea.\r
- Obtencin de la carpeta a leer.\r
- Apertura de la carpeta.\r
- Obtencin de los mensajes\r
- Procesamiento de mensajes\r
- Cierre de la carpeta y del almacn.\r
- Cierre de la sesin y de la conexin\r
\r
\`\`\`java\r
    // Prepare IMAP configuration into a Property object\r
    final Properties prop = new Properties();\r
    prop.put("mail.imap.host", "imap.gmail.com");\r
    prop.put("mail.imap.port", "993");\r
    prop.put("mail.imap.ssl.enable", "true");\r
    prop.put("mail.imap.auth", "true");\r
\r
    // Create the Session with the user credentials\r
    Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
        @Override\r
        protected PasswordAuthentication getPasswordAuthentication() {\r
            return new PasswordAuthentication(prop.getProperty("mail.imap.username"), \r
                        prop.getProperty("mail.imap.password"));\r
        }\r
    });\r
\r
    // Get the Store object and connect to the current host using the specified username and password.\r
    Store store = mailSession.getStore("imap");\r
    store.connect(prop.getProperty("mail.imap.host"), \r
            prop.getProperty("mail.imap.username"), \r
            prop.getProperty("mail.imap.password"));\r
\r
    // Get the folder and open it\r
    Folder folder = store.getFolder("INBOX");\r
    folder.open(Folder.READ_ONLY);\r
\r
    // Get the messages\r
    Message[] messages = folder.getMessages();\r
\r
    // Process the messages\r
    for (int i = 0; i < messages.length; i++) {\r
        Message message = messages[i];\r
        System.out.println("Message " + (i + 1));\r
        System.out.println("From: " + message.getFrom()[0]);\r
        System.out.println("Subject: " + message.getSubject());\r
        System.out.println("Sent Date: " + message.getSentDate());\r
        System.out.println("Text: " + message.getContent().toString());\r
    }\r
\r
    // Close the folder and store objects\r
    folder.close(false);\r
    store.close();\r
\`\`\`\r
`]},{title:"4.2 Clases auxiliares para direccionamiento",headers:[{level:2,title:"4.2.1. java.net.NetworkInterface",slug:"_4-2-1-java-net-networkinterface",link:"#_4-2-1-java-net-networkinterface",children:[]},{level:2,title:"4.2.2 java.net.InterfaceAddress",slug:"_4-2-2-java-net-interfaceaddress",link:"#_4-2-2-java-net-interfaceaddress",children:[]},{level:2,title:"4.2.3. java.net.InetAddress",slug:"_4-2-3-java-net-inetaddress",link:"#_4-2-3-java-net-inetaddress",children:[]},{level:2,title:"4.2.4 java.net.URL",slug:"_4-2-4-java-net-url",link:"#_4-2-4-java-net-url",children:[]},{level:2,title:"4.2.5 java.net.URLConnection",slug:"_4-2-5-java-net-urlconnection",link:"#_4-2-5-java-net-urlconnection",children:[]}],path:"/es/unit5/urls.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.2 Clases auxiliares para direccionamiento\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 Clases auxiliares para direccionamiento" />\r
\r
# 4.2 Clases auxiliares para direccionamiento\r
\r
[[toc]]\r
\r
## 4.2.1. java.net.NetworkInterface\r
\r
Esta clase representa la interfaz de red, tanto software como hardware, su nombre, la lista de direcciones IP asignadas y toda la informacin relacionada. Se puede usar en los casos en que queramos usar especficamente una interfaz particular para transmitir nuestro paquete en un sistema con mltiples NIC.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html)\r
\r
::: info Qu es una interfaz de red?  \r
Se puede pensar en una interfaz de red como un punto en el que su computadora se conecta a la red. No es necesariamente una pieza de hardware, pero tambin se puede implementar en un software. Por ejemplo, una interfaz de bucle invertido que se utiliza con fines de prueba.\r
:::\r
\r
| Method                                                            | Description                                                                                                                                                                                                                        |\r
| ----------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public static Enumeration getNetworkInterfaces()                  | Devuelve todas las interfaces de red del sistema.                                                                                                                                                                                  |\r
| public List getInterfaceAddresses()                               | Devuelve una lista de todas las direcciones de interfaz en esta interfaz.                                                                                                                                                          |\r
| public Enumeration getInetAddresses()                             | Devuelve una enumeracin de todas las Inetaddresses vinculadas a esta interfaz de red, si el administrador de seguridad lo permite.                                                                                                |\r
| public String getName()                                           | Devuelve el nombre de esta interfaz de red                                                                                                                                                                                         |\r
| public int getIndex()                                             | Devuelve el ndice asignado a esta interfaz de red por el sistema. Los ndices se pueden utilizar en lugar de nombres largos para hacer referencia a cualquier interfaz del dispositivo.                                           |\r
| public String getDisplayName()                                    | Este mtodo devuelve el nombre de la interfaz de red en un formato de string legible.                                                                                                                                              |\r
| public static NetworkInterface getByName(String name)             | Busca y devuelve la interfaz de red con el nombre especificado, o nulo si no existe.                                                                                                                                               |\r
| public static NetworkInterface getByIndex(int index)              | Realiza una funcin similar a la funcin anterior con el ndice utilizado como parmetro de bsqueda en lugar del nombre.                                                                                                          |\r
| public static NetworkInterface getByInetAddress(InetAddress addr) | Este mtodo se usa ampliamente ya que devuelve la interfaz de red a la que est vinculada la direccin de red especificada. Si una InetAddress est vinculada a varias interfaces, se puede devolver cualquiera de las interfaces. |\r
| public boolean isUp()                                             | Devuelve un valor booleano que indica si esta interfaz de red est en funcionamiento.                                                                                                                                              |\r
\r
\`\`\`java\r
// Java program to illustrate various java.net.NetworkInterface class methods.\r
\r
public class NetworkInterfaceExample\r
{\r
    public static void main(String[] args) throws SocketException,\r
                                                UnknownHostException\r
    {\r
\r
        // getNetworkInterfaces() returns a list of all interfaces\r
        // present in the system.\r
        ArrayList<NetworkInterface> interfaces = Collections.list(\r
                                            NetworkInterface.getNetworkInterfaces());\r
\r
        System.out.println("Information about present Network Interfaces...\\n");\r
        for (NetworkInterface iface : interfaces)\r
        {\r
            // isUp() method used for checking whether the interface in process\r
            // is up and running or not.\r
            if (iface.isUp())\r
            {\r
                // getName() method\r
                System.out.println("Interface Name: " + iface.getName());\r
\r
                // getDisplayName() method\r
                System.out.println("Interface display name: " + iface.getDisplayName());\r
\r
                // getHardwareAddress() method\r
                System.out.println("Hardware Address: " +\r
                                Arrays.toString(iface.getHardwareAddress()));\r
\r
                // getParent() method\r
                System.out.println("Parent: " + iface.getParent());\r
\r
                // getIndex() method\r
                System.out.println("Index: " + iface.getIndex());\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInterface addresses: ");\r
\r
                // getInterfaceAddresses() method\r
                for (InterfaceAddress addr : iface.getInterfaceAddresses())\r
                {\r
                    System.out.println("\\t\\t" + addr.getAddress().toString());\r
                }\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInetAddresses associated with this interface: ");\r
\r
                // getInetAddresses() method returns list of all\r
                // addresses currently bound to this interface\r
                Enumeration<InetAddress> en = iface.getInetAddresses();\r
                while (en.hasMoreElements())\r
                {\r
                    System.out.println("\\t\\t" + en.nextElement().toString());\r
                }\r
\r
                // getMTU() method\r
                System.out.println("\\tMTU: " + iface.getMTU());\r
\r
                // getSubInterfaces() method\r
                System.out.println("\\tSubinterfaces: " +\r
                                Collections.list(iface.getSubInterfaces()));\r
\r
                // isLoopback() method\r
                System.out.println("\\tis loopback: " + iface.isLoopback());\r
\r
                // isVirtual() method\r
                System.out.println("\\tis virtual: " + iface.isVirtual());\r
\r
                // isPointToPoint() method\r
                System.out.println("\\tis point to point: " + iface.isPointToPoint());\r
\r
                // supportsMulticast() method\r
                System.out.println("Supports Multicast: " + iface.supportsMulticast());\r
\r
            }\r
        }\r
\r
        // getByIndex() method returns network interface\r
        // with the specified index\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
\r
        // toString() method is used to display textual\r
        // information about this network interface\r
        System.out.println("Network interface 1: " + nif.toString());\r
\r
        // getByName() method returns network interface\r
        // with the specified name\r
        NetworkInterface nif2 = NetworkInterface.getByName("eth0");\r
        InetAddress ip = InetAddress.getByName("localhost");\r
\r
        // getbyInetAddress() method\r
        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\r
        System.out.println("\\nlocalhost associated with: " + nif3);\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.2 java.net.InterfaceAddress\r
\r
Esta clase representa una direccin de interfaz de red. Cada dispositivo que tiene una direccin IP tiene una direccin IP en la interfaz de red. De hecho, el comando ping no hace ping a un dispositivo, sino a la direccin de interfaz de los dispositivos.\r
\r
Java proporciona ciertos mtodos para tratar con direcciones de interfaz que se pueden usar en lugares donde existe la necesidad de conocer la topologa de la red, para la deteccin de fallas en una red, etc.\r
\r
Resumiendo, esta clase representa a una direccin IP, una mscara de red y una direccin broadcast (cuando la direccin es IPv4). Slo representa una direccin IP address y una longitud de prefijo de red en el caso de direcciones IPv6.\r
\r
> [java.net.InterfaceAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html)\r
\r
| Method                                | Description                                                                                                                                                                                                      |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public InetAddress getAddress()       | Devuelve una InetAddress para esta direccin                                                                                                                                                                     |\r
| public InetAddress getBroadcast()     | Devuelve InetAddress para la direccin de transmisin para esta direccin de interfaz. Como solo las direcciones IPv4 tienen direcciones de transmisin, se devolvera un valor nulo al usar una direccin IPv6. |\r
| public short getNetworkPrefixLength() | Devuelve la longitud del prefijo para esta direccin de interfaz, es decir, la mscara de subred para esta direccin.                                                                                            |\r
\r
\`\`\`java\r
// Java program to illustrate methods of java.net.InterfaceAddress class\r
\r
public class InterfaceaddressExample\r
{\r
    public static void main(String[] args) throws SocketException\r
    {\r
        // Modify according to your system\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
        List<InterfaceAddress> list = nif.getInterfaceAddresses();\r
\r
        for (InterfaceAddress iaddr : list)\r
        {\r
            // getAddress() method\r
            System.out.println("getAddress() : " + iaddr.getAddress());\r
\r
            // getBroadcast() method\r
            System.out.println("getBroadcast() : " + iaddr.getBroadcast());\r
\r
            // getNetworkPrefixLength() method\r
            System.out.println("PrefixLength : " + iaddr.getNetworkPrefixLength());\r
\r
            // hashCode() method\r
            System.out.println("Hashcode : " + iaddr.hashCode());\r
\r
            // toString() method\r
            System.out.println("toString() : " + iaddr.toString());\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.3. java.net.InetAddress\r
\r
La clase java.net.InetAddress proporciona mtodos para obtener la direccin IP de cualquier nombre de host, por ejemplo example www.google.com, www.facebook.com, etc.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)\r
\r
La clase InetAddress se usa para encapsular tanto la direccin IP numrica como el nombre de dominio para esa direccin.\r
\r
Hay 2 tipos de direcciones:\r
\r
- Unicast: un identificador para una nica interfaz.\r
- Multicast: un identificador para un conjunto de interfaces.\r
\r
::: warning Local Name Resolver (hosts file)\r
Deberas saber que DNS traduce nombre de dominio en direcciones IP. Pero, ?sabes que hay un archivo en tu sistema que puede sobrescribir esas traducciones?\r
\r
Es el archivo \`hosts\` y nos permite mapear nombre de dominio a direcciones IP. Tu archivo HOSTS slo afecta al comportamiento de tu equipo, por lo que podemos usarlo para crear direcciones personalizadas para IP de nuestra red, o bien para redireccionar / bloquear el acceso a determinados sitios web.\r
\r
Como puedes imaginar, cambiar de forma incorrecta o **maliciosa** el contenido del archivo hOSTS puede romper fcilmente el comportamiento de tu conexin a Internet, As que la modificacin del archivo no es trivial para los usuarios, algo que es de agradecer.\r
\r
- Windows\r
\r
El archivo HOSTS est almacenado como un fichero de texto plano en la carpeta del sistema de Windows.\r
\r
Abre el men inicio y escribe "notepad".\r
\r
Pulsa con el botn derecho y selecciona la opcin de "Ejecutar como administrador"\r
\r
En Notepad, ve a Archivo > Abrir y pega la siguiente ruta:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Ahora ya puedes editar y guardar los cambios en tu archivo HOSTS.\r
\r
Para mapear un dominio, aade una nueva lnea siguiendo los ejemplos que hay en el archivo.\r
\r
- OS X & GNU/Linux\r
\r
El archivo est en /etc/hosts y debes editarlo con privilegios de administrador.\r
\r
\`\`\`bash\r
# Aadimos las siguientes entradas al archivo hosts\r
## En clase \r
##  - como cliente y servidor ponemos la IP de nuestro equipo.\r
##  - como profesor ponemos la IP del ordenador del profesor\r
## En casa \r
##  - como cliente, servidor y profesor ponemos la IP de nuestro equipo.\r
\r
# En nuestras actividades, para no tener que ir cambiando las direcciones IP, usaremos \r
# siempre estos nombres de dominio, as los programas funcionarn tanto en clase como\r
# en casa.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
| Method                                                                       | Description                                                                                                       |\r
| ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r
| public static InetAddress getByName(String host) throws UnknownHostException | Este mtodo devuelve la instancia de InetAddress que contiene el nombre y la IP del host recibido como parmetro. |\r
| public static InetAddress getLocalHost() throws UnknownHostException         | Este mtodo devuelve la instancia de InetAddress que contiene el nombre y la IP de LocalHost.                     |\r
| public String getHostName()                                                  | Este mtodo devuelve el nombre de host para esta direccin IP.                                                    |\r
| public String getHostAddress()                                               | Este mtodo obtiene la direccin IP en forma de string.                                                           |\r
| public boolean isReachable(int timeout)                                      | Este mtodo prueba si esa direccin es accesible.                                                                 |\r
\r
\`\`\`java\r
\r
class InetAddressExample {\r
    public static void main(String[] args)\r
        throws UnknownHostException\r
    {\r
        // To get and print InetAddress of Local Host\r
        InetAddress address1 = InetAddress.getLocalHost();\r
        System.out.println("InetAddress of Local Host : "\r
                        + address1);\r
\r
        // To get and print InetAddress of Named Host\r
        InetAddress address2\r
            = InetAddress.getByName("45.22.30.39");\r
        System.out.println("InetAddress of Named Host : "\r
                        + address2);\r
\r
        // To get and print ALL InetAddresses of Named Host\r
        InetAddress address3[]\r
            = InetAddress.getAllByName("172.19.25.29");\r
        for (int i = 0; i < address3.length; i++) {\r
            System.out.println(\r
                "ALL InetAddresses of Named Host : "\r
                + address3[i]);\r
        }\r
\r
        // To get and print InetAddresses of\r
        // Host with specified IP Address\r
        byte IPAddress[] = { 125, 0, 0, 1 };\r
        InetAddress address4\r
            = InetAddress.getByAddress(IPAddress);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address : "\r
            + address4);\r
\r
        // To get and print InetAddresses of Host\r
        // with specified IP Address and hostname\r
        byte[] IPAddress2\r
            = { 105, 22, (byte)223, (byte)186 };\r
        InetAddress address5 = InetAddress.getByAddress(\r
            "gfg.com", IPAddress2);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address and hostname : "\r
            + address5);\r
    }\r
}\r
\r
\`\`\`\r
\r
::: question Buscador de equipos (U4S4_HostSeeker)\r
Tu equipo est conectado a una LAN (Red de rea Local) y probablemente est usando una direccin IP privada.\r
\r
Las direcciones pueden ser de clase C (192.168.X.Y), clase B (172.17.X.Y) o clase A (10.X.Y.Z). Eso depende principalmente de la mscara de red y del prefijo de red usado para la configuracin del interfaz.\r
\r
Puedes comprobar esta configuracin con los comandos **ifconfig** de OSX GNU/Linux o **ipconfig** de Windows..\r
\r
Escribe un programa que averige, dentro de nuestra red, qu hosts estn activos en la red, es decir, qu hosts son "alcanzables" desde tu equipo usando uno de los interfaces disponibles.\r
\r
Primero vamos a hacerlo de forma sencilla. Escribe un programa que sabiendo la direccin de tu equipo y la longitud del prefijo, pruebe todas las posibles combinaciones.\r
\r
> Si nuestra IP es 192.168.0.50 y el prefijo es /24, esto indica que los primeros 24 bits de la direccin IP son el identificador de la red, y que los 8 ltimos son para identificadores de hosts. Por lo que slo tenemos que ir probando con los ltimos 8 bits (el ltimo dgito de la direccin) para detectar a otros equipos en la red. Esto nos da 254 posibilidades, ya que la 0 y la 255 no se usan para hosts.\r
>\r
> Si por el contrario, el prefijo fuese 16, tendramos que ir cambiando los dos ltimos nmeros.\r
>\r
> 192.168.0.1 a 192.168.0.254, despus 192.168.1.1 a 192.168.1.254, as hasta 192.168.255.1 a 192.168.255.254, es decir, tendra que usar un bucle anidado.\r
\r
La aplicacin slo debe mostrar la direccin IP de los equipos que sean alcanzables.\r
\r
**Optativo**: Una vez que tengas tu aplicacin funcionando, intenta hacerla genrica y reutilizable para que funcione en cualquier red, obteniendo el prefijo de red y comprobando todas las posibles direcciones en la red en funcin del prefijo obtenido.\r
\r
En ambos casos la aplicacin recibir el nombre de una NIC como argumento y comprobar slo las direcciones IP asignadas a esa interfaz.\r
\r
Podemos saber si una direccin es IPv4 o IPv6 usando el operador \`nstanceof\` con las subclases Inet4Address y Inet6Address.\r
:::\r
\r
::: details Cdigo del ejemplo\r
\r
\`\`\`java\r
public class U4S4_HostSeeker {\r
\r
    private final int timeout = 10;\r
    private String interfaceName;\r
    private String ipAddress;\r
    private String networkMask;\r
\r
    private ArrayList<String> reachableIps = new ArrayList<>();\r
\r
    public static void main(String[] args)\r
            throws UnknownHostException, IOException {\r
\r
        U4S4_HostSeeker seeker = new U4S4_HostSeeker(args);\r
        System.out.println("Scanning...");\r
        seeker.processNetwork();\r
        seeker.listResults();\r
    }\r
\r
    public U4S4_HostSeeker(String[] args) throws SocketException, UnknownHostException {\r
        NetworkInterface networkCard = null;\r
\r
        switch (args.length) {\r
            case 1 -> {\r
                // Get the interface from the name\r
                interfaceName = args[0];\r
                                \r
                networkCard = NetworkInterface.getByName(interfaceName);\r
\r
                // Get the IP and the mask from the NetworkInterface\r
                List<InterfaceAddress> cardAddresses = networkCard.getInterfaceAddresses();\r
                for (InterfaceAddress ifAddr : cardAddresses) {\r
                    if (ifAddr.getAddress() instanceof Inet4Address) {\r
                        ipAddress = ifAddr.getAddress().getHostAddress();\r
                        networkMask = Integer.toString(ifAddr.getNetworkPrefixLength());\r
                    }\r
                }\r
\r
            }\r
            case 2 -> {\r
                // Get the IP and mask\r
                ipAddress = args[0];\r
                networkMask = args[1];\r
\r
                // Get the interface name from the assigned IP\r
                networkCard = NetworkInterface.getByInetAddress(InetAddress.getByName(ipAddress));\r
                interfaceName = networkCard.getName();\r
            }\r
            default -> {\r
                // In order to find the right interface name... run the app with no args\r
                NetworkInterface.networkInterfaces().forEach((t) -> {\r
                    try {\r
                        if (t.isUp())\r
                            System.out.println(t.getName() + " --> " + t.getDisplayName() + " : " + t.inetAddresses().findFirst().toString());\r
                    } catch (SocketException ex) {\r
                        Logger.getLogger(U4S4_HostSeeker.class.getName()).log(Level.SEVERE, null, ex);\r
                    }\r
                });\r
                \r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker IP maskLength");\r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker interfaceName");\r
                throw new AssertionError();\r
            }\r
        }\r
\r
    }\r
\r
    private void processNetwork() throws IOException {\r
        String baseAddress;\r
        String[] addressParts = ipAddress.split("\\\\.");\r
        switch (networkMask) {\r
            case "24" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + "." + addressParts[2] + ".";\r
                checkClassCNetwork(baseAddress);\r
\r
            }\r
            case "16" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + ".";\r
                checkClassBNetwork(baseAddress);\r
            }\r
            case "8" -> {\r
                baseAddress = addressParts[0] + ".";\r
                checkClassANetwork(baseAddress);\r
\r
            }\r
            default ->\r
                throw new AssertionError();\r
        }\r
    }\r
\r
    // Check for /24 networks \r
    private void checkClassCNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        System.out.println("Checking network " + baseAddress + "0...");\r
        for (int i = 1; i < 255; i++) {\r
            InetAddress tempIP = InetAddress.getByName(baseAddress + i);\r
            if (tempIP.isReachable(timeout)) {\r
                addReachableIp(tempIP.getHostAddress());\r
            }\r
        }\r
    }\r
\r
    // Check for /16 networks \r
    private void checkClassBNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class C adresses: " + baseAddress + i + ".xxx");\r
            checkClassCNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    // Check for /8 networks \r
    private void checkClassANetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class B adresses: " + baseAddress + i + ".xxx");\r
            checkClassBNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    private /*synchronized*/ void addReachableIp(String ip) {\r
        reachableIps.add(ip);\r
    }\r
\r
    private void listResults() {\r
        System.out.println("Reachable IPs:");\r
        for (String ip : reachableIps) {\r
            System.out.println("--> " + ip);\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
:::\r
\r
## 4.2.4 java.net.URL\r
\r
URL es un acrnimo de Localizador de recursos uniforme. Un recurso puede ser cualquier cosa, desde un simple archivo de texto hasta cualquier otro como imgenes, directorio de archivos, etc.\r
\r
> [java.net.URL specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html)\r
\r
Es un puntero para localizar recursos en www (World Wide Web), por ejemplo:\r
\r
> http://psp2dam.github.io/psp_pages/\r
\r
La URL tiene las siguientes partes:\r
\r
- **Protocolo**: en este caso el protocolo es HTTP, puede ser HTTPS en algunos casos\r
- **Nombre de host o IP**: el nombre de host representa la direccin de la mquina en la que se encuentra el recurso, en este caso, www.example.com\r
- **Nmero de puerto**: es un atributo opcional. Si no se especifica, devuelve -1. En el caso anterior, el nmero de puerto es 80. Si no se indica se usa el puerto usado por defecto por el protocolo indicado en el primer campo.\r
- **Nombre del recurso**: es el nombre de un recurso ubicado en el servidor dado que queremos ver (la carpeta /psp_pages). Dependiendo de la configuracin del servidor, el nombre del archivo puede tener un valor por defecto. En el ejemplo slo se ha indicado una ruta, por lo que se intentar devolver el archivo \`ndex.html\` si se encuentra en esa carpeta.\r
\r
| Constructor                                              | Descripcin                                                                                                                                                                       |\r
| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| URL(String spec)                                         | Este constructor crea un objeto de clase URL a partir de una representacin de string dada                                                                                        |\r
| URL(String protocol, String host, int port, String file) | Este constructor crea un objeto de URL a partir del protocolo, host, nmero de puerto y archivo especificados.                                                                    |\r
| URL(String protocol, String host, String file)           | Este constructor crea un objeto de URL a partir del protocolo, el servidor y la ruta/archivo especificados.                                                                       |\r
| URL(URL context, String spec)                            | Este constructor crea una instancia de una URL analizando el src dado con el controlador especificado dentro de un contexto dado. Se usa cuando tenemos rutas relativas a una URL |\r
\r
Estos son los mtodos mas importantes y utilizados de la clase de URL:\r
\r
| Mtodo                                | Descripcin                                                                                                                     |\r
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\r
| public String getProtocol()           | Este mtodo obtiene el nombre de protocolo de esta URL.                                                                         |\r
| public String getHost()               | Este mtodo obtiene el nombre de host de esta URL, si corresponde.                                                              |\r
| public String getPort()               | Este mtodo obtiene el nmero de puerto de esta URL.                                                                            |\r
| public String getFile()               | Este mtodo obtiene la parte de la ruta de esta URL.                                                                            |\r
| public String getAuthority()          | Este mtodo obtiene la parte de autoridad de esta URL.                                                                          |\r
| public String toString()              | Este mtodo construye una representacin de string de esta URL.                                                                 |\r
| public String getQuery()              | Este mtodo obtiene la parte de consulta de esta URL.                                                                           |\r
| public String getDefaultPort()        | Este mtodo obtiene el nmero de puerto predeterminado del protocolo asociado con esta URL.                                     |\r
| public URLConnection openConnection() | Este mtodo devuelve una instancia de URLConnection que representa una conexin al objeto remoto al que hace referencia la URL. |\r
| public InputStream openStream()       | Este mtodo abre una conexin a esta URL y devuelve un InputStream para leer desde esa conexin.                                |\r
| public boolean equals(Object obj)     | Este mtodo compara la igualdad de esta URL con otro objeto.                                                                    |\r
| public Object getContent()            | Este mtodo obtiene el contenido de esta URL.                                                                                   |\r
| public String getRef()                | Este mtodo obtiene el ancla (tambin conocido como la referencia) de esta URL.                                               |\r
| public URI toURI()                    | Este mtodo devuelve un URI equivalente a esta URL.                                                                             |\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args) throws MalformedURLException{  \r
\r
    URL url=new URL("http://psp2dam.github.io/psp_pages");  \r
  \r
    System.out.println("Protocol: "+url.getProtocol());  \r
    System.out.println("Host Name: "+url.getHost());  \r
    System.out.println("Port Number: "+url.getPort());  \r
    System.out.println("File Name: "+url.getFile());  \r
}   \r
\`\`\`\r
\r
Vamos con otro ejemplo ms completo de uso de los mtodos de URL.\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args){    \r
    URL url=new URL("https://www.google.com/search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8");    \r
        \r
    System.out.println("Protocol: "+url.getProtocol());    \r
    System.out.println("Host Name: "+url.getHost());    \r
    System.out.println("Port Number: "+url.getPort());    \r
    System.out.println("Default Port Number: "+url.getDefaultPort());    \r
    System.out.println("Query String: "+url.getQuery());    \r
    System.out.println("Path: "+url.getPath());    \r
    System.out.println("File: "+url.getFile());      \r
}    \r
\`\`\`\r
\r
\`\`\`bash:no-line-numbers{3}\r
Protocol: https\r
Host Name: www.google.com\r
Port Number: -1\r
Default Port Number: 443\r
Query String: q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
Path: /search\r
File: /search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
\`\`\`\r
\r
## 4.2.5 java.net.URLConnection\r
\r
La clase URLConnection se utiliza para dos propsitos diferentes pero relacionados.\r
\r
- En primer lugar, proporciona ms control sobre la interaccin con un servidor (especialmente un servidor HTTP) que la clase URL.\r
- En segundo lugar, con una URLConnection podemos verificar el encabezado enviado por el servidor y responder en consecuencia, podemos configurar los campos de encabezado utilizados en las requests de los clientes. Tambin podemos descargar archivos binarios usando URLConnection.\r
\r
La clase URLConnection representa un enlace entre la URL y la aplicacin. Puede usarse para leer y escribir datos en el recurso sealado por la URL.\r
\r
> [java.net.URLConnection specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html)\r
\r
La clase URLConnection en Java es una clase abstracta que representa una conexin de un recurso segn lo especificado por la URL correspondiente. Tiene dos subclases \`HttpURLConnection\` y \`JarURLConnection\` que se encargan de hacer la conexin entre el programa cliente y el recurso indicado en URL.\r
\r
La clase URLConnection proporciona una gran cantidad de mtodos. Podemos mostrar el contenido de una pgina web usando el mtodo \`getInputStream()\` , de un modo similar a como lo hacamos con los procesos.\r
\r
| Mtodo                                            | Descripcin                                                                                                                             |\r
| ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r
| void connect()                                    | Este mtodo se utiliza para establecer una conexin con el recurso especificado por la URL, si dicha conexin an no se ha establecido. |\r
| Object getContent()                               | Recupera el contenido de esta conexin URL.                                                                                             |\r
| String getContentEncoding()                       | Devuelve el valor del campo de encabezado de codificacin de contenido.                                                                 |\r
| int getContentLength()                            | Devuelve el valor del campo de encabezado de longitud del contenido.                                                                    |\r
| long getContentLengthLong()                       | Devuelve el valor del campo de encabezado de longitud del contenido como long.                                                          |\r
| String getContentType()                           | Devuelve el valor del campo de encabezado de tipo de contenido.                                                                         |\r
| long getDate()                                    | Devuelve el valor del campo de encabezado de fecha.                                                                                     |\r
| boolean getDoInput()                              | Devuelve el valor del indicador doInput de esta URLConnection.                                                                          |\r
| boolean getDoInput()                              | Devuelve el valor del indicador doInput de esta URLConnection.                                                                          |\r
| String getHeaderField(int n)                      | obtiene el valor del ensimo campo de encabezado.                                                                                       |\r
| String getHeaderField(String name)                | Devuelve el valor del campo de encabezado con nombre.                                                                                   |\r
| String getHeaderFieldKey(int n)                   | obtiene el valor del ensimo campo de encabezado.                                                                                       |\r
| Map<String, List&lt;String&gt;> getHeaderFields() | Devuelve un mapa no modificable de los campos de encabezado.                                                                            |\r
| long getIfModifiedSince()                         | Devuelve el valor del campo ifModifiedSince de este objeto.                                                                             |\r
| InputStream getInputStream()                      | Devuelve un flujo de entrada que lee de esta conexin abierta                                                                           |\r
| long getLastModified()                            | Devuelve el valor del campo de encabezado modificado por ltima vez.                                                                    |\r
| OutputStream getOutputStream()                    | Devuelve un flujo de salida que escribe en esta conexin.                                                                               |\r
| URL getURL()                                      | Devuelve el valor del campo URL de este URLConnection.                                                                                  |\r
| void setDoInput(boolean doinput)                  | Establece el valor del campo doInput para esta URLConnection en el valor especificado.                                                  |\r
| void setDoOutput(boolean dooutput)                | Establece el valor del campo doOutput para esta URLConnection en el valor especificado.                                                 |\r
\r
::: info Cmo obtener un objeto de tipo URLConnection\r
El mtodo openConnection() de la clase URL devuelve un objeto de tipo URLConnection.\r
:::\r
\r
\`\`\`java{11}\r
// URLConnectionExample\r
public static void main(String[] args) throws MalformedURLException, IOException{\r
\r
    // Creating an object of URL class\r
\r
    // Custom input URL is passed as an argument\r
    URL u = new URL("www.google.com");\r
\r
    // Creating an object of URLConnection class to\r
    // communicate between application and URL\r
    URLConnection urlconnect = u.openConnection();\r
\r
    // Creating an object of InputStream class\r
    // for our application streams to be read\r
    InputStream stream\r
        = urlconnect.getInputStream();\r
\r
    BufferedReader in =  \r
        new BufferedReader(\r
            new InputStreamReader(stream));\r
    // Till the time URL is being read\r
    String line;\r
    while ((line = in.readLine()) != null) {\r
\r
        // Continue printing the stream\r
        System.out.println(line);\r
    }\r
}\r
\`\`\`\r
\r
::: warning MalformedURLException\r
Si pruebas el cdigo anterior, obtendrs una excepcin de tipo \`MalformedURLException\`. \r
Qu deberas cambiar para que funcione correctamente?\r
:::\r
\r
::: question Descargar imgenes (U4S7_ImagesDownloader)\r
Crea una nueva aplicacin que descargue imgenes de una URL.\r
\r
La URL de la imagen se debe pasar como argumento a la aplicacin. La imagen descargada debe guardarse en una carpeta images, en la raz del proyecto, con el mismo nombre que tuviese el recurso online.\r
:::\r
\r
::: details Cdigo del ejemplo\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
`]},{title:"6.4 Encriptacin asimtrica",headers:[{level:2,title:"6.4.1. Clave pblica y clave privada",slug:"_6-4-1-clave-publica-y-clave-privada",link:"#_6-4-1-clave-publica-y-clave-privada",children:[]},{level:2,title:"6.4.2. Firma digital",slug:"_6-4-2-firma-digital",link:"#_6-4-2-firma-digital",children:[{level:3,title:"Integridad",slug:"integridad",link:"#integridad",children:[]},{level:3,title:"Autenticacin y no repudio",slug:"autenticacion-y-no-repudio",link:"#autenticacion-y-no-repudio",children:[]}]},{level:2,title:"6.4.3 Certificados digitales",slug:"_6-4-3-certificados-digitales",link:"#_6-4-3-certificados-digitales",children:[{level:3,title:"Claves digitales",slug:"claves-digitales",link:"#claves-digitales",children:[]},{level:3,title:"Infraestructura de clave pblica (PKI)",slug:"infraestructura-de-clave-publica-pki",link:"#infraestructura-de-clave-publica-pki",children:[]}]},{level:2,title:"6.4.4. Generacin de pares de claves",slug:"_6-4-4-generacion-de-pares-de-claves",link:"#_6-4-4-generacion-de-pares-de-claves",children:[{level:3,title:"Tipos de ficheros para certificados digitales",slug:"tipos-de-ficheros-para-certificados-digitales",link:"#tipos-de-ficheros-para-certificados-digitales",children:[]},{level:3,title:"Generacin de claves desde Java",slug:"generacion-de-claves-desde-java",link:"#generacion-de-claves-desde-java",children:[]}]},{level:2,title:"6.4.5. Cifrado y descifrado usando un par de claves",slug:"_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",link:"#_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",children:[]},{level:2,title:"6.2.3. Cifrado asimtrico con GnuPG",slug:"_6-2-3-cifrado-asimetrico-con-gnupg",link:"#_6-2-3-cifrado-asimetrico-con-gnupg",children:[]}],path:"/es/unit6/asymmetric-keys.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.4 Encriptacin asimtrica\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.4 Encriptacin asimtrica" />\r
\r
# 6.4 Encriptacin asimtrica\r
\r
[[toc]]\r
\r
## 6.4.1. Clave pblica y clave privada\r
\r
La criptografa asimtrica o **criptografa de clave pblica** supuso una autntica revolucin en su momento. Permita el intercambio seguro de informacin (confidencialidad, autenticacin y no repudio) entre interlocutores que no compartan ningn secreto.\r
\r
Se cre en los aos 70 a partir del trabajo de *Diffie y Hellman* por una parte y de *Rivest, Shamir y Adleman* por otra.\r
\r
Se basa en la existencia de un par de claves, una pblica y otra privada, entre las cuales existe una relacin matemtica, de manera que es muy difcil obtener la clave privada a partir de la pblica. Sin embargo, es muy sencillo obtener la clave pblica a partir de la privada.\r
\r
::: info Algoritmo RSA\r
En la familia de algoritmos RSA (Rivest, Shamir y Adleman) la clave pblica consiste en un nmero que es el producto de dos factores primos muy grandes (mayores que 10^100) y la clave privada se deriva de la factorizacin de dicho nmero, es decir, los dos factores primos.\r
\r
Requiere poco procesamiento multiplicar dos nmeros primos tan grandes, pero requiere una cantidad enorme de clculos encontrar la factorizacin del nmero.\r
:::\r
\r
A diferencia del cifrado simtrico, el el cifrado asimtrico se usan funciones diferentes para cifrar y descifrar los mensajes.\r
\r
- Para **encriptacin** se usa la **clave pblica**. Cualquiera puede tener acceso a la clave pblica, mediante la cual, usando la funcin de cifrado, se encripta la informacin dirigida a un destinatario concreto (el propietario de la clave privada asociada).\r
- Para **desencriptacin** se usa la **clave privada**, que debe mantenerse a buen recaudo ya que slo con esa clave y la funcin de descifrado se puede desencriptar un mensaje cifrado con la clave pblica correspondiente.\r
\r
Entre los algoritmos de cifrado asimtrico ms utilizados se encuentran\r
\r
- Rivest Shamir Adleman (RSA). Basado en la factorizacin de nmeros primos grandes.\r
- Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).\r
- Elliptical Curve Cryptography (ECC). Est basado en las matemticas de las curvas elpticas\r
- the Diffie-Hellman exchange method.\r
- TLS/SSL protocol.\r
\r
![cifrado asimtrico](../../media/unit6/asymmetric-encryption-primitive.png)\r
\r
## 6.4.2. Firma digital\r
\r
Con la firma digital Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
![cifrado asimtrico](../../media/unit6/proceso-firma-digital.png)\r
\r
El proceso bsico que se sigue para la firma electrnica es el siguiente:\r
\r
1. El usuario dispone de un documento electrnico (una hoja de clculo, un pdf, una imagen, incluso un formulario en una pgina web) y de un **certificado** (clave pblica y clave privada) que le pertenece y le identifica.\r
2. La aplicacin o dispositivo digital utilizados para la firma realiza un **resumen del documento**. El resumen de un documento de gran tamao puede llegar a ser tan solo de unas lneas. Este resumen es nico y cualquier modificacin del documento implica tambin una modificacin del resumen.\r
3. La aplicacin utiliza la clave privada para codificar el resumen.\r
4. La aplicacin crea otro documento electrnico que contiene ese resumen codificado. Este nuevo documento es la firma electrnica.\r
\r
El resultado de todo este proceso es un documento electrnico obtenido a partir del documento original y de las claves del firmante. La firma electrnica, por tanto, es el mismo documento electrnico resultante.\r
\r
![verificacin de firma digital](../../media/unit6/digital-signature-sign-verify.png)\r
\r
### Integridad\r
\r
Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificacin respecto al momento en el que se firm, garantizando de esta forma la integridad de la informacin firmada.\r
\r
### Autenticacin y no repudio\r
\r
Por las caractersticas de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave pblica, que el mensaje recibido lo gener el propietario de la clave privada.\r
\r
Con esta caracterstica se puede probar y demostrar que el mensaje lo firm el emisor y no cualquier otra persona, garantizando por un lado la autora y por otro evitando que el emisor niegue haber generado esa informacin.\r
\r
## 6.4.3 Certificados digitales\r
\r
Un certificado digital es un documento electrnico expedido por una **Autoridad de Certificacin** e identifica a una persona (fsica o jurdica) con un par de claves.Tiene como misin validar y certificar que una firma electrnica se corresponde con una persona o entidad concreta.\r
\r
Contiene la informacin necesaria para firmar electrnicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiracin y organismo que lo expide.\r
\r
La Autoridad de Certificacin da fe de que la firma electrnica se corresponde con un usuario concreto. Esa es la razn por la que los certificados estn firmados, a su vez, por la Autoridad de Certificacin.\r
\r
### Claves digitales\r
\r
En un certificado, las claves digitales son los elementos esenciales para la firma e identificacin del firmante. Existen dos claves, la **clave privada** y **clave pblica**, y trabajan de forma complementaria. *Lo que cifra o codifica una clave slo lo puede descifrar o decodificar la otra*.\r
\r
La diferencia entre ellas es que la clave privada est pensada para que nunca salga del certificado y est siempre bajo el control del firmante. En cambio, la clave pblica se puede repartir o enviar a otros usuarios.\r
\r
En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la pblica y del Certificado Pblico para referirse al certificado que slo contiene la clave pblica.\r
\r
::: info Creacin de Certificados digitales\r
Obtener el Certificado Digital depende de si el certificado est contenido en una tarjeta, como el DNIe, o de si el certificado se guarda en un fichero software.\r
\r
En ambos procesos hay un paso que es la identificacin del responsable o usuario del certificado, lo cual requiere que ste **se persone en las oficinas de una Autoridad de Registro**. Estas oficinas corroboran la identidad.\r
:::\r
\r
### Infraestructura de clave pblica (PKI)\r
\r
Una infraestructura de clave pblica (PKI) es una combinacin de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecucin con garantas de operaciones criptogrficas, cumpliendo los requisitos de integridad, confidencialidad, autenticacin y no repudio.\r
\r
Una PKI permite establecer y gestionar asociaciones entre claves pblicas e identidades de personas y organizaciones.\r
\r
La cuestin entonces es determinar si un certificado es vlido o de confianza, ol o que es lo mismo, si representa a la persona u organizacin que aparece como titular y propietario  del certificado.\r
\r
Para dar por vlido un certificado digital su firma digital debe ser vlida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qu emisores son de confianza.\r
\r
::: warning Autenticidad de los certificados\r
Los certificados deben estar firmados por una AC por dos motivos\r
\r
1. Garantizar su integridad, de forma que cualquier intento de modificacin del certificado lo invalide.\r
2. Identificar al creador del certificado digital. Todo el sistema est basado en una relacin de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones pblicas o privadas de reconocido prestigio\r
:::\r
\r
En nuestro sistema podemos ver y modificar qu entidades de certificacin consideramos como seguras, es decir, que los certificados que stas hayan firmado los tomaremos como vlidos.\r
\r
[Autoridades de confianza para apps de Azure](https://docs.microsoft.com/es-es/exchange/trusted-root-certification-authorities-for-federation-trusts-exchange-2013-help)\r
\r
En Windows, si ejecutamos \`certmgr.msc\` podemos acceder a la configuracin de certificados del sistema. En OSX lo podemos hacer con la aplicacin \`Llavero\`.\r
\r
Para nuestra navegacin, la informacin de qu certificados considera el navegador como seguros, depende de en qu AC confiemos (por defecto en la instalacin vienen configurados los ms comunes)\r
\r
[Ver certificados y AC en Chrome](https://www.adminfacil.es/como-ver-los-certificados-instalados-en-google-chrome/)\r
\r
::: danger Certificados autofirmados\r
**Hemos de tener en cuenta que, con herramientas como las que proporciona Java, SSH o GnuPG cualquiera puede generar un certificado digital con la informacin que quiera**\r
\r
Para las pruebas vamos a firmar nuestros propios certificados. Incluso dentro de una compaa podemos ejercer nosotros mismos como Autoridad de Certificacin de Confianza, firmando nuestros certificados.\r
\r
Debemos preparar la configuracin de nuestros sistemas para que **confen** en esos certificados autofirmados, asumiendo el riesgo que esto conlleva.\r
:::\r
\r
## 6.4.4. Generacin de pares de claves\r
\r
La generacin y gestin de pares de claves implica dos aspectos fundamentales.\r
\r
Por un lado, tenemos la creacin de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuacin, se pueden generar desde una aplicacin, igual que hacemos con las claves simtricas.\r
\r
Por otro lado, tenemos la gestin del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados \`keyrings\` a los que puede acceder una aplicacin y desde los que gestionamos las relaciones de confianza.\r
\r
El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generacin de nmeros aleatorios para satisfacer unos requisitos mnimos de seguridad.\r
\r
::: info SecureRandom\r
La generacin de nmeros aleatorios juega un papel fundamental en la criptografa, siendo uno de los **Engine** que proporciona el JCA junto con un amplio grupo de algoritmos.\r
\r
La clase **SecureRandom** genera nmero aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto simtricas como asimtricas\r
:::\r
\r
### Tipos de ficheros para certificados digitales\r
\r
Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el estndar X.509. Generalmente uncertificado no contiene slo la clave, sino que tiene informacin adicional.\r
\r
Esxiten dos posibles codificaciones para almacenar certificados X.509\r
\r
- der: Es una codificacin binaria\r
- dem: Es una codificacin en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado\r
\r
Veamos un ejemplo de certificado con codificacin dem\r
\r
\`\`\`sh\r
-----BEGIN CERTIFICATE----- \r
MIIDijCCAvOgAwIBAgIJAKRvtQxONVZoMA0GCSqGSIb3DQEBBAUAMIGLMQswCQYD \r
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxl \r
MSAwHgYDVQQKExdBcnViYSBXaXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFD \r
MSMwIQYDVQQDExpteXNlcnZlci5hcnViYW5ldHdvcmtzLmNvbTAeFw0wODA0MzAy \r
MzM3MDJaFw0xMDA0MzAyMzM3MDJaMIGLMQswCQYDVQQGEwJVUzETMBEGA1UECBMK \r
Q2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxlMSAwHgYDVQQKExdBcnViYSBX \r
aXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFDMSMwIQYDVQQDExpteXNlcnZl \r
ci5hcnViYW5ldHdvcmtzLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA \r
zRwqc9prVXycGhHcsAjGPzC2MKU4DhXSr86Z89Jk8/cXEJBJ0C/NgdAqqDgxneUh \r
nVyxGxODa7BNGAWSagdCsKLrbkchr479E3xLfgdc3UzAJITLGCXGiQ66NwQDyM5I \r
G/xKYm4oqgyOE/lFTTkK0M8V0NmmJynyOCYC/AwQKjMCAwEAAaOB8zCB8DAdBgNV \r
HQ4EFgQUM5btT6IlPGkLTTPvFccTVURO1p0wgcAGA1UdIwSBuDCBtYAUM5btT6Il \r
PGkLTTPvFccTVURO1p2hgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD \r
YWxpZm9ybmlhMRIwEAYDVQQHEwlTdW5ueXZhbGUxIDAeBgNVBAoTF0FydWJhIFdp \r
cmVsZXNzIE5ldHdvcmtzMQwwCgYDVQQLEwNUQUMxIzAhBgNVBAMTGm15c2VydmVy \r
LmFydWJhbmV0d29ya3MuY29tggkApG+1DE41VmgwDAYDVR0TBAUwAwEB/zANBgkq \r
hkiG9w0BAQQFAAOBgQBp71WeF6dKvqUSO1JFsVhBeUesbEgx9+tx6eP328uL0oSC \r
fQ6EaiXZVbrQt+PMqG0F80+4wxVXug9EW5Ob9M/opaCGI+cgtpLCwSf6CjsmAcUc \r
b6EjG/l4HW2BztYJfx15pk51M49TYS7okDKWYRT10y65xcyQdfUKvfDC1k5P9Q== \r
-----END CERTIFICATE-----\r
\`\`\`\r
\r
Adems de la codificacin, tenemos formatos de fichero estndar para guardar los certificados usando una de las codificaciones anteriores\r
\r
- cer, crt, der: Contienen certificados X.509 estndares codificados como \`der\`\r
- p12: Realmente hace referencia a toda una familia de estndares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, adems de los datos del certificado, una clave privada. Si contiene la clave privada, sta estar protegida por una contrasea que ser necesaria para acceder a la clave privada. [PKCS en Wikipedia](https://es.wikipedia.org/wiki/PKCS)\r
\r
### Generacin de claves desde Java\r
\r
Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde cdigo\r
\r
1. El primer paso para obtener un par de claves es obtener un objeto *keyPairGenerator* para el algoritmo que queramos utilizar.\r
2. A continuacin se inicializa el generador del par de claves llamando a alguna de las versiones del mtodo *initialize*. En nuestro caso indicaremos el tamao de clave para el algoritmo seleccionado y un generador de nmeros aleatorios.\r
3. El ltimo paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.\r
4. A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer ser guardarlas en sendos archivos.\r
\r
A continuacin podemos ver un ejemplo de generacin de claves, almacenamiento de las claves en un fichero y visualizacin de la clave obtenida.\r
\r
\`\`\`java{14,15,18-20,39,52}\r
public class U6S4_1_GenerateRsaKeyPair {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            // Elijo un algoritmo de generacin de nmeros aleatorios de los denominados\r
            // altamente seguros para generar el par de claves\r
            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\r
            // Preparo el generados de claves para usar el algortimo RSA\r
            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\r
            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\r
\r
            // Creo el par de claves y lo guardo en objetos\r
            KeyPair parClaves = genParClaves.generateKeyPair();\r
            PublicKey clavePublica = parClaves.getPublic();\r
            PrivateKey clavePrivada = parClaves.getPrivate();\r
\r
            // Guardamos la clave pblica en un archivo y la visualizamos\r
            // La clave se guarda con codificacin DER y en formato X.509\r
            guardaClavePublicaX509(clavePublica);\r
            \r
            // Guardamos la clave privada en un archivo y la visualizamos\r
            // La clave se guarda con codificacin DER y en formato PKCS#8\r
            guardaClavePrivadaPKCS8(clavePrivada);\r
            \r
\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algortimo en ningn Provider");\r
        }\r
\r
    }\r
\r
    private static void guardaClavePublicaX509(PublicKey clavePublica) {\r
        try (FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\r
            publicKeyFile.write(clavePublica.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\r
                    codificacionClavePublica.getFormat(), ficheroClavePublica);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave pblica en " + ficheroClavePublica);\r
        }                \r
    }\r
\r
    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\r
        try (FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\r
            privateKeyFile.write(clavePrivada.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\r
                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave privada en " + ficheroClavePrivada);\r
        }        \r
    }\r
\r
    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\r
        System.out.println("Clave guardada en formato " + formatoClave \r
                + " en fichero " + ficheroClave);\r
        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll("(.{76})", "$1\\n"));\r
    }\r
}\r
\`\`\`\r
\r
Esta sera la salida proporcionada\r
\r
\`\`\`sh\r
Clave guardada en formato X.509 en fichero claves/clavepublica.der\r
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4UFRgEIm3lFKO75QmqTPvkDs0fM6NUm2FHQcA\r
cQHawLx9/WKXh9xkx/xYZZcc4L2YQYcwTu4jfk889iGKGLn2Kh4ywBY+g8uZ6ljM5PT6f95dU6Zd\r
xATWOn1qsizBubf7kKhBL7xDnKU5do3XYzrSjme+9uIsgS7HQ7K0MbKrpQIDAQAB\r
\r
Clave guardada en formato PKCS#8 en fichero claves/claveprivada.pkcs8\r
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALhQVGAQibeUUo7vlCapM++QOzR8\r
zo1SbYUdBwBxAdrAvH39YpeH3GTH/FhllxzgvZhBhzBO7iN+Tzz2IYoYufYqHjLAFj6Dy5nqWMzk\r
9Pp/3l1Tpl3EBNY6fWqyLMG5t/uQqEEvvEOcpTl2jddjOtKOZ7724iyBLsdDsrQxsqulAgMBAAEC\r
gYA97xBLL4N3YqnTSgIYc6b2Cxs56e5mYppWrohZx5996GHuXCSzEn4mh2TuN0Tt+T78WJiazQsM\r
djceHv7qLqDd2kWn3IR0gX207KxwjG0I/sAP2z/i9NZ7DPL+FUv8lmeYUfDj8h3wkyhmBqn+tan1\r
0xIOcZUrr/yRhrjZLI1SCQJBAPEc4uWSbyBLHVC6SNga7XWNmwi8Mq4PZJdhW9RJWDxg9zOlC/HV\r
rV60ddbfW/ldIqCH33DUge5U5YhD6Mla/XMCQQDDsahcwTksp2bJowMTRgFHT094sihtSlQ7sgdI\r
uAemuMvBmVTHleFBWMqz1rAN6A/76yef3WK4I+nsmeCGa+yHAkEA7BR1kYT8q+kATi/n7TkIcoZx\r
W28yTD2kJ5jbWhNqgswKn5WmCWdH9qfJjddrbdEke3wuaoKYqeyURgUAJE+kQwJADhEsQBanrH0Q\r
F3h/VRhYKS8bUFrGKy0Hpw7iFSkda6+m/fCutnYgrhja4ViSaT2AQKSjwYsheIkkXJynFiKV6wJA\r
PUHXqlvfgPr4w2U+Ddq7h/gp59kO0uojGrEBO0B2wt3PuuSQlZlMN97Ly9QmB6LYRtw6woCZZZOD\r
ePqA7rf8IA==\r
\`\`\`\r
\r
En el ejemplo anterior en lugar de utilizar clases estndar para volcar el contenido binario de las claves a un archivo en formato raw, se utilizan clases codificadoras para generar ficheros binarios en formatos estndares, tanto para la clave pblica como para la privada.\r
\r
Esto tiene la enorme ventaja de que se pueden utilizar las claves generadas con herramientas estndar como openssl. Adems, facilita la tarea ya que las claves pblica y privada para criptografa asimtrica son objetos compuestos.\r
\r
::: info Codificacin Base64\r
Base64 es un grupo de esquemas de codificacin de binario a texto que representa los datos binarios mediante una cadena.\r
\r
Los esquemas de codificacin Base64 son comnmente usados cuando se necesita codificar datos binarios para que sean almacenados y transferidos sobre un medio diseado para tratar con datos textuales. Esto es para asegurar que los datos se mantienen intactos y sin modificaciones durante la transmisin.\r
\r
Los valores codificados en Base64 como texto se muestran en filas de 76 caracteres como mximo, para mejor legibilidad, y siguiendo convenciones habituales.\r
\r
Para verlos en pantalla se aade un salto de lnea despus de cada grupo de 76 caracteres usando  \`replaceAll("(.{76})", "$1\\n")\`.\r
:::\r
\r
Las claves que se han guardado con el programa tienen las siguientes caractersticas:\r
\r
- La clave pblica se guarda en un fichero \`clavepublica.der\`, con el formato de la estructura *SubjectPublicKeyInfo* en formato *ASN.1* definido en el estndar *X.509*, y con codificacin *DER (binaria)*. Para eso se ha utilizado la clase codificadora **X509EncodedKeySpec**.\r
- La clave privada se guarda en un fichero \`claveprivada.pkcs8\`, en formato *PKCS#8*, y con codificacin *DER (binaria)*. Para eso se ha utilizado la clase codificadora **PKCS8EncodedKeySpec**.\r
\r
::: info Codificaciones por defecto\r
Las codificaciones usadas en el programa coinciden con las codificacione por defecto que usan las clases PrivateKey y PublicKey, como se puede ver en los valores proporcionados por los mtodos getFormat() y getEncoded().\r
:::\r
\r
## 6.4.5. Cifrado y descifrado usando un par de claves\r
\r
Aunque ya hemos visto que las claves se pueden generar desde cdigo, lo normal es que una vez hayamos generado un par de claves, estas se puedan reutilizar desde las aplicaciones para cifrar y descifrar informacin.\r
\r
Si hemos guardado las claves en archivos, el primer paso que tendremos que realizar es recuperar esas claves para poder realizar las operaciones criptogrficas con ellas.\r
\r
::: question Prueba de claves online\r
Podemos probar las claves generadas con una herramienta online.\r
\r
[Online RSA tool](https://www.devglan.com/online-tools/rsa-encryption-decryption)\r
\r
Prueba a copiar el contenido (en Base64) de las claves pblica y privada para hacer un cifrado y un descifrado de la informacin.\r
\r
Tambin puedes probar a simular una firma digital, realizando el cifrado con la clave privada y el descifrado con la clave pblica.\r
:::\r
\r
Veamos un ejemplo de cmo se hace todo este proceso en Java\r
\r
\`\`\`java{23-25,38-40,76-78,108-110}\r
public class U6S4_2_RsaKeyPairEncrypt {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            //////////////////////////////////////////////////\r
            // CIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave pblica de un archivo\r
            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\r
\r
            // Preparamos la informacin que queremos cifrar\r
            String textoEnClaro = "Quiero cifrar este mensaje de prueba";\r
            byte[] mensajeEnClaro = textoEnClaro.getBytes("UTF-8");\r
            \r
            // Realizamos el proceso de cifrado con clave pblica\r
            // Los pasos son exactamente los mismos que con el cifrado simtrico\r
            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\r
            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\r
            // Visualizamos el mensaje cifrado en modo texto\r
            MostrarMensajeBase64(mensajeCifrado);\r
            \r
            //////////////////////////////////////////////////\r
            // DESCIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave privada de un archivo\r
            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\r
\r
            // Realizamos el proceso de descifrado con clave privada\r
            // Los pasos son exactamente los mismos que con el cifrado simtrico\r
            // Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\r
            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\r
            // Visualizamos el mensaje descifrado\r
            System.out.println("Texto descifrado:\\n" + new String(mensajeDescifrado, "UTF-8"));\r
                        \r
        } catch (UnsupportedEncodingException ex) {\r
            System.out.println("Codificacin de caracteres UTF-8 no soportada");\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo " + algoritmoClaveAsimetrica + " en ningn Provider");\r
        } catch (NoSuchPaddingException ex) {\r
            System.err.println("El relleno especificado para el algoritmo no est permitido");\r
        } catch (InvalidKeyException ex) {\r
            System.err.println("Especificacin de clave no vlida");\r
        } catch (IllegalBlockSizeException ex) {\r
            System.err.println("Tamao de bloque no vlido");\r
        } catch (BadPaddingException ex) {\r
            System.err.println("Excepcin con el relleno usado por el algoritmo");\r
        }\r
    }\r
\r
    private static PublicKey leerClavePublica(String ficheroClave) {\r
        byte[] clavePublicaEncoded;\r
\r
        // Leemos la informacin del archivo\r
        try (FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePublicaEncoded = publicKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave pblica.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave pblica.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes ledos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\r
            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\r
\r
            // Devolvemos la clave pblica generada\r
            return clavePublica;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo " + algoritmoClaveAsimetrica + " en ningn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
\r
    private static PrivateKey leerClavePrivada(String ficheroClave) {\r
        byte[] clavePrivadaEncoded;\r
\r
        // Leemos la informacin del archivo\r
        try (FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePrivadaEncoded = privateKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave privada.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave privada.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes ledos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\r
            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\r
\r
            // Devolvemos la clave pblica generada\r
            return clavePrivada;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo " + algoritmoClaveAsimetrica + " en ningn Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
    \r
    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\r
        System.out.println("Mensaje cifrado visualizado como texto en Base64:");                \r
        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll("(.{76})", "$1\\n"));\r
    }    \r
}\r
\`\`\`\r
\r
Y esta es la salida proporcionada\r
\r
\`\`\`sh\r
Mensaje cifrado visualizado como texto en Base64:\r
EV+7WrEf+4CYwckys9blk6DXnLHUm4i0k+4BIp3oNmPdo2skYY8bQsAhXToBx2gi/rMIK9wiJTH0\r
yg99jpyaLeUgtga8PxWx1plgvxohzO/lALkf5AFRUczZh8F5QvOXCi93v2ycZCZXq7QmZTopkEQh\r
ARSezD/1Al2UYPc2X68=\r
\r
Texto descifrado:\r
Quiero cifrar este mensaje de prueba\r
\`\`\`\r
\r
::: warning Cifrado siempre diferente, descifrado siempre igual\r
El resultado de cifrar un mensaje con la misma clave pblica no siempre es igual, aunque al descifrar los mensajes con la clave privada siempre se obtiene el mensaje original.\r
\r
Esto es debido a que, para aumentar la variabilidad (**entropa**) del mensaje cifrado al mensaje que se cifra se le aade una parte aleatoria (**salt**) que se descarta cuando se descifra.\r
:::\r
\r
En el cdigo podemos observar cmo los procesos para cargar la clave desde un archivo usan las mismas clases que cuando se generaron, siendo el cdigo muy parecido.\r
\r
En cuanto al cifrado y descifrado se realiza con el *Engine Cipher* usando la misma secuencia de llamadas que con el cifrado simtrico.\r
\r
## 6.2.3. Cifrado asimtrico con GnuPG\r
\r
Con la suite GnuPG tambin podemos generar pares de claves y cifrar y descifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informacin de los algoritmos disponibles para cada tipo de servicio. En concreto, de resmenes, en mi versin instalada:\r
\r
Clave pblica: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\r
:::\r
\r
Para generar las claves, ejecutamos los siguientes comandos\r
Debemos tener en cuenta que las claves generadas se aaden a nuestro anillo de claves (almacn de seguridad de claves en las que confiamos).\r
\r
\`\`\`bash\r
gpg --gen-key\r
gpg --list-keys \r
# El formato corto equivalente es gpg -k\r
gpg --list-secret-keys \r
# El formato corto equivalente es gpg -K\r
\r
#Extraer las claves pblicas y privadas\r
# En un archivo binario\r
gpg --output tunombre.pub --export IDdeLaClavePblica\r
# En un archivo ASCII\r
gpg --armor --output tunombre.asc --export IDdeLaClavePblica\r
\r
gpg --export-secret-keys -a IDdeLaClavePblica > tunombre.priv\r
\r
# Importar una clave pblica\r
gpg --import clavepublica.asc\r
# Importar una clave privada\r
gpg --allow-secret-key-import --import claveprivada.priv\r
\`\`\`\r
\r
Para cifrar y descifrar un archivo con las claves generadas, ejecutamos los siguientes comandos\r
\r
\`\`\`bash\r
# Cifrar\r
gpg --output archivo.cifrado --encrypt --recipient IDdeLaClavePblica archivo\r
# Descifrar\r
gpg --output archivo --decrypt archivo.cifrado\r
\`\`\`\r
`]},{title:"6.2 Funciones resumen",headers:[{level:2,title:"6.2.1. Funciones hash",slug:"_6-2-1-funciones-hash",link:"#_6-2-1-funciones-hash",children:[]},{level:2,title:"6.2.2. MessageDigest",slug:"_6-2-2-messagedigest",link:"#_6-2-2-messagedigest",children:[]},{level:2,title:"6.2.3. MessageDigest con GnuPG",slug:"_6-2-3-messagedigest-con-gnupg",link:"#_6-2-3-messagedigest-con-gnupg",children:[]}],path:"/es/unit6/hash-functions.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.2 Funciones resumen\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.2 Funciones resumen" />\r
\r
# 6.2 Funciones resumen\r
\r
[[toc]]\r
\r
## 6.2.1. Funciones hash\r
\r
Un *Message digest* o resumen de mensaje, ms conocidos como **funciones hash**, es una marca digital de un bloque de datos. Existe un gran nmero de algoritmos diseados para procesar esto resmenes, los dos ms conocidos son SHA-1 y MD5.\r
\r
De un resumen cabe destacar las siguientes caractersticas:\r
\r
- Para el mismo algoritmo, el resumen siempre tiene el mismo tamao, independientemente del tamao de los datos que se haya usado para generarlo.\r
- Es imposible recuperar la informacin original a partir de un resumen.\r
- El resumen no debe desvelar nada sobre los datos que se utilizaron para generarlo.\r
- Es computacionalmente inviable encontrar dos mensajes que tengan el mismo valor de resumen.  Matemticamente es altamente improbable, pero no imposible.\r
- Un pequeo cambio en los datos resumidos genera un resumen completamente diferente.\r
\r
Los resmenes se usan para generar identificadores nicos y confiables. A veces se les llama *checksum*, ya que sirven para comprobar si una descarga se ha realizado correctamente, generando su resumen y comparndolo con el que gener el archivo original.\r
\r
::: warning Un hash no sirve para cifrar\r
Es importante destacar que, debido a que es imposible obtener los datos que generaron un resumen a partir del propio resumen, el resumen no se puede usar para cifrar informacin.\r
\r
Por el contrario, es un mecanismo que se usa para comparar. Su uso ms extendido es con las contraseas, ya que en las bases de datos se guarda un resumen en vez de la contrasea en claro. De esta forma, cuando se recibe una contrasea se genera su resumen y se compara con el valor almacenado.\r
:::\r
\r
## 6.2.2. MessageDigest\r
\r
La clase *MessageDigest* permite a las aplicaciones implementar algoritmos de resumen criptogrficamente seguros como SHA-256 o SHA-512\r
\r
Para generar un hash con JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *MesageDigest* con el mtodo esttico *getInstance()* de la misma clase, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. Se aaden datos con el mtodo *update()*. Se puede aadir un byte o un array de bytes. Este mtodo se puede invocar varias veces para ir aadiendo nuevos datos.\r
3. Se obtiene el valor de hash con el mtodo *digest()*.\r
4. Si se quisiera calcular un nuevo hash, se invocara el mtodo *reset()* para volver a empezar el proceso.\r
\r
A continuacin podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S2_MessageDigest {\r
\r
    public static void main(String[] args) {\r
        String plaintext = "Esto es un texto plano.";\r
        try {\r
            // Obtenemos un ENGINE que implementa el algoritmo especificado\r
            // Se puede indicar cualquier algoritmo disponible en el sistema\r
            // SHA-224, SHA-512, SHA-256, SHA3-224, ...\r
            MessageDigest m = MessageDigest.getInstance("SHA-256");\r
\r
            // Opcional - Reinicia el objeto para un nuevo uso \r
            // Por si queremos poner este cdigo en un bucle y procesar ms\r
            // de un mensaje\r
            m.reset();\r
\r
            // Realiza el resumen de los datos pasados por parmetro\r
            // Si queremos procesar la informacin poco a poco, \r
            // debemos ir llamando al mtodo update para cada bloque de datos\r
            m.update(plaintext.getBytes());\r
\r
            // Completa el clculo del valor del hash y devuelve el resumen\r
            byte[] digest = m.digest();\r
\r
            // Mensaje de resumen\r
            System.out.println("Resumen (raw data): " + new String(digest));\r
\r
            // Mensaje en formato hexadecimal\r
            System.out.println("Resumen (hex data): " + toHexadecimal(digest));\r
            \r
            \r
            // Informacin del proceso\r
            System.out.println("=> Algoritmo: " + m.getAlgorithm() + ", Provider: " + m.getProvider().getName() + " " + m.getProvider().getVersionStr());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.err.println("No se ha encontrado la implementacin del algoritmo MD5 en ningn Provider");\r
        }\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
}\r
\`\`\`\r
\r
y esta sera la salida proporcionada\r
\r
\`\`\`sh\r
Resumen (raw data): Y"3\x1B\`bbs?;~E\r
Resumen (hex data): FB59D31122913314111B92CD60628ED7E7DE62733F3B10DEDAF303AAABE57E45\r
=> Algoritmo: SHA-256, Provider: SUN 11\r
\`\`\`\r
\r
## 6.2.3. MessageDigest con GnuPG\r
\r
Con la suite GnuPG podemos generar resmenes de archivos utilizando los algoritmos que nos proporciona la suite.\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informacin de los algoritmos disponibles para cada tipo de servicio. En concreto, de resmenes, en mi versin instalada:\r
\r
Resumen: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\r
:::\r
\r
Para generar un resumen de un archivo, ejecutamos el comando de la siguiente forma\r
\r
\`\`\`sh\r
gpg --print-md SHA256 filename.ext\r
\`\`\``]},{title:"6 Introduccin",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit6/",pathLocale:"/es/",extraFields:[`---\r
title: 6 Introduccin\r
---\r
\r
# Tema 6. Tcnicas de programacin segura\r
\r
El trmino criptografa es un derivado de la palabra griega *kryptos* que significa oculto y *grafos* que significa escritura. El objetivo de la criptografa es ocultar el significado de un mensaje mediante el cifrado o codificacin del mensaje.\r
\r
De todas las tcnicas de programacin segura, nosotros vamos a estudiar en este tema\r
\r
- Las funciones de resumen (Hash)\r
- El **cifrado simtrico** o de clave oculta\r
- El **cifrado asimtrico** o de clave privada\r
\r
Tambin estudiaremos cmo usar canales seguros de comunicacin para nuestras aplicaciones, mediante el uso de sockets seguros empleando SSL/TLS.\r
\r
Adems, veremos una herramienta de seguridad que incorpora Java, las polticas de seguridad.\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Identificar principios y prcticas de programacin segura.\r
- Analizar tcnicas y prcticas criptogrficas.\r
- Definir polticas de seguridad.\r
- Emplear algoritmos criptogrficos.\r
- Utilizar sockets seguros para la transmisin de informacin.\r
- Estudiar el funcionamiento de TLS/SSL sobre el protocolo TCP\r
- Conocer herramientas de uso genrico en la criptografa\r
`]},{title:"6.5 Comunicaciones seguras en Java",headers:[{level:2,title:"6.5.1. Protocolo SSL (Secure Sockets Layer)",slug:"_6-5-1-protocolo-ssl-secure-sockets-layer",link:"#_6-5-1-protocolo-ssl-secure-sockets-layer",children:[]},{level:2,title:"6.5.2. JSSE",slug:"_6-5-2-jsse",link:"#_6-5-2-jsse",children:[{level:3,title:"SSLSocket y SSLServerSocket",slug:"sslsocket-y-sslserversocket",link:"#sslsocket-y-sslserversocket",children:[]},{level:3,title:"keytool: certificados, confianza y almacenes de claves",slug:"keytool-certificados-confianza-y-almacenes-de-claves",link:"#keytool-certificados-confianza-y-almacenes-de-claves",children:[]}]},{level:2,title:"6.5.3. Servidor y Cliente SSL",slug:"_6-5-3-servidor-y-cliente-ssl",link:"#_6-5-3-servidor-y-cliente-ssl",children:[]}],path:"/es/unit6/jsse.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.5 Comunicaciones seguras en Java\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.5 Comunicaciones seguras en Java" />\r
\r
# 6.5 Comunicaciones seguras en Java\r
\r
[[toc]]\r
\r
## 6.5.1. Protocolo SSL (Secure Sockets Layer)\r
\r
SSL es el protocolo habitualmente usado para encriptar la comunicacin cliente-servidor. Casi todo el trfico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.\r
\r
La implementacin de SSL es una extensin de los sockets que permite establecer un canal (stream) de comunicacin. Dicha comunicacin se inicia con un **handshake** durante el cual, el cliente y el servidor construyen una session-key (clave simtrica encriptada con par de claves asimtricas) compartida para verificar su identidad mutua.\r
\r
## 6.5.2. JSSE\r
\r
JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementacin para Java de los protocolos SSL y TSL e incluye funcionalidad de\r
\r
- encriptacin de datos\r
- autenticacin de servidores\r
- integridad de mensajes\r
- autenticacin de clientes\r
\r
Con JSSE, los programadores  pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicacin, tales como HTTP, Telnet o FTP, a travs de TCP/IP.\r
\r
Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.\r
\r
### SSLSocket y SSLServerSocket\r
\r
Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente.\r
\r
JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creacin de sockets seguros. No tienen constructor, se obtienen a travs del mtodo esttico getDefault().\r
\r
Para obtener un socket servidor seguro o *SSLServerSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
SSLServerSocket servidorSSL = (SSLServerSocket) = sfact.createServerSocket(puerto);\r
\`\`\`\r
\r
El mtodo **createServerSocket(int puerto)** devuelve un socket de servidor enlazado al puerto especificado.\r
\r
Para crear un *SSLSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
SSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\r
\`\`\`\r
\r
El mtodo createSocket (String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.\r
\r
### keytool: certificados, confianza y almacenes de claves\r
\r
Cuando dos socket SSL, uno cliente y otro servidor, intentan establecer conexin, tienen que "presentarse" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno confa en el otro, la conexin se establece, en caso contrario, no se establece.\r
\r
Para establecer esa confianza se debe crear un certificado en el servidor y aadirlo a los certificados de confianza del cliente.\r
\r
- El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta **keytool**, que viene incluida en el JDK de Java. La herramienta guardar la pareja de claves en un almacn (el cual tiene su propia clave).\r
- Despus generaremos un certificado a partir de esa pareja.\r
- El cdigo del servidor necesitar indicar el fichero donde se almacenan las claves y la clave para acceder a ese almacn.\r
- El cliente necesitar indicar que confa en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almacn de claves del cliente.\r
\r
::: info Seguridad mutua\r
Aunque no suele hacerse tambin podra hacerse a la inversa y obligar al cliente a tener un certificado que el servidor pudiera importar, lo que aumentara la seguridad.\r
:::\r
\r
Vamos a ver cmo realizar estas operaciones previas con la herramienta **keytool**\r
\r
Primero las acciones a realizar en el servidor\r
\r
\`\`\`sh:no-line-numbers\r
# El servidor genera una pareja de claves que se almacena en un\r
# fichero llamado "clavesservidor". Dentro del fichero se indica\r
# un alias para poder referirnos a esa clave fcilmente\r
# keytool -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
What is your first and last name?\r
  [Unknown]:  Vicente Martinez\r
What is the name of your organizational unit?\r
  [Unknown]:  Dpto. Informatica\r
What is the name of your organization?\r
  [Unknown]:  IES Doctor Balmis\r
What is the name of your City or Locality?\r
  [Unknown]:  Alicante\r
What is the name of your State or Province?\r
  [Unknown]:  Alicante\r
What is the two-letter country code for this unit?\r
  [Unknown]:  ES\r
Is CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES correct?\r
  [no]: yes\r
\r
# El servidor genera su "certificado", es decir un fichero que\r
# de alguna forma indica quien es l. El certificado se almacena\r
# en un fichero llamado clavesservidor y a partir de l queremos\r
# generar el certificado de un alias creado previamente con nombre servidor\r
# keytool -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
Enter keystore password:\r
Certificate stored in file <servidor.cer>\r
\`\`\`\r
\r
En la carpeta donde hemos ejecutado el comando keytool, se ha creado el almacn de claves en un fichero llamado **ClavesServidor** y el certificado exportado en el archivo **servidor.cer**\r
\r
y a continuacin las que habra que realizar en el cliente para generar el almacn de confianza que, en nuestro caso contenga el mismo certificado que hemos exportado del servidor.\r
\r
\`\`\`sh:no-line-numbers\r
# Se importa el certificado del servidor indicando que pertenece a\r
# la lista de certificados confiables.\r
# keytool -importcert -trustcacerts -alias servidor -file servidor.cer -keystore clavescliente  -storepass 87654321\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -importcert -trustcacerts -alias servidor -file servidor.cer -keystore CertificadosConfianzaCliente -storepass 87654321\r
Owner: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Issuer: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Serial number: 4eb6f2a5\r
Valid from: Mon Jan 24 00:20:24 CET 2022 until: Sun Apr 24 01:20:24 CEST 2022\r
Certificate fingerprints:\r
         SHA1: DD:A2:75:4C:1C:BC:39:60:BE:B1:20:67:E1:5C:45:8C:48:B5:1F:54\r
         SHA256: 82:C8:56:C2:DB:DE:8C:73:A9:21:C6:7D:DE:1F:39:4F:79:CC:5F:D5:10:BC:61:DA:E3:EE:E1:1D:21:EA:D2:33\r
Signature algorithm name: SHA256withRSA\r
Subject Public Key Algorithm: 2048-bit RSA key\r
Version: 3\r
\r
Extensions:\r
\r
#1: ObjectId: 2.5.29.14 Criticality=false\r
SubjectKeyIdentifier [\r
KeyIdentifier [\r
0000: 16 AE 35 7C 58 97 B1 95   91 9B FA 6C 2A 80 D2 90  ..5.X......l*...\r
0010: 1C 50 7F C0                                        .P..\r
]\r
]\r
\r
Trust this certificate? [no]:  yes\r
Certificate was added to keystore\r
\`\`\`\r
\r
En esta ocasin tambin se crea, en la carpeta donde se ha ejecutado el comando keytool, un fichero **CertificadosConfianzaCliente** con el/los certificados de confianza para el cliente.\r
\r
## 6.5.3. Servidor y Cliente SSL\r
\r
En le siguiente ejemplo podemos observar como la inicializacin del ServerSocket es diferente, pero a partir de que se llama al mtodo accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del cdigo es igual que con la clase Socket.\r
\r
\`\`\`java{5,16,17,24}\r
public class U6S5_SSLServer {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteConectado = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante cdigo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicacin\r
        // System.setProperty("javax.net.ssl.keyStore", System.getProperty("user.dir") + "\\\\ClavesServidor");\r
        // System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
        \r
        // Inicializacin del ServerSocket SSL\r
        int puerto = 6000;\r
        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\r
\r
        for (int i = 1; i < 5; i++) {\r
\r
            System.out.println("Esperando al cliente " + i);\r
\r
            // Se espera la conexin de un cliente con accept\r
            clienteConectado = (SSLSocket) servidorSSL.accept();\r
            // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
            // el cdigo del ejemplo\r
            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\r
            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\r
\r
            // El cliente enva un mensaje\r
            System.out.println("Recibiendo del CLIENTE: " + i + " \\n\\t" + flujoEntrada.readUTF());\r
\r
            // El Servidor responde con un saludo\r
            flujoSalida.writeUTF("Saludos al cliente del servidor");\r
        }\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteConectado.close();\r
        servidorSSL.close();\r
    }\r
}\r
\`\`\`\r
\r
En el cliente el proceso es el mismo, tras la llamada al mtodo createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.\r
\r
\`\`\`java{5,12,13,19,20}\r
public class U6S5_SSLClient {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteSSL = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante cdigo, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicacin\r
        // System.setProperty("javax.net.ssl.trustStore", System.getProperty("user.dir") + "/CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
        // Inicializacin del ServerSocket SSL\r
        int puerto = 6000;\r
        String host = "localhost";\r
\r
        System.out.println("Programa Cliente iniciado....");\r
        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\r
\r
        // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
        // el cdigo del ejemplo\r
        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\r
        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\r
\r
        // Envo un saludo al servidor\r
        flujoSalida.writeUTF("Saludos al SERVIDOR DESDE EL CLIENTE");\r
\r
        // El Servidor responde con un mensaje\r
        System.out.println("Recibiendo del SERVIDOR: \\n\\t" + flujoEntrada.readUTF());\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteSSL.close();\r
    }\r
\r
    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException {\r
\r
        //------------------------------------------------------------------------------\r
        //Ejemplo de la mltiple informacin sobre la sesin SSL\r
        // que se puede obtener a partir \r
        SSLSession session = ((SSLSocket) cliente).getSession();\r
        System.out.println("Host: " + session.getPeerHost());\r
        System.out.println("Cifrado: " + session.getCipherSuite());\r
        System.out.println("Protocolo: " + session.getProtocol());\r
\r
        System.out.println("IDentificador:" + new BigInteger(session.getId()));\r
\r
        System.out.println("Creacin de la sesin: " + session.getCreationTime());\r
\r
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\r
        System.out.println("Propietario: " + certificate.getSubjectDN());\r
        System.out.println("Algoritmo: " + certificate.getSigAlgName());\r
        System.out.println("Tipo: " + certificate.getType());\r
        System.out.println("Emisor: " + certificate.getIssuerDN());\r
        System.out.println("Nmero Serie: " + certificate.getSerialNumber());\r
        //-----------------------------------------------------------------------------\r
    }\r
}\r
\`\`\`\r
\r
Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Exception in thread "main" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\r
\`\`\`\r
\r
Para ejecutar el programa servidor es necesario indicar el certificado que se utilizar. \r
\r
Lo podemos indicar a la hora de ejecutar el programa, aadiendo a la lnea de comandos\r
\r
\`\`\` sh\r
 java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\r
\`\`\`\r
\r
y en el programa cliente es necesario indicar la ubicacin de los certificados de confianza\r
\r
\`\`\` sh\r
java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\r
\`\`\`\r
\r
o bien, en las opciones de ejecucin del IDE\r
\r
![Netbeans: Opciones de la JVM](../../media/unit6/VM_Options.png)\r
\r
::: info Parmetros de JVM o cdigo\r
En el cdigo anterior hay unas lneas comentadas que especifican cmo podemos configurar el valor de las propiedades desde cdigo mediante el uso del mtodo System.setProperty(String propiedad, String valor).\r
\r
En el programa servidor incluiramos las siguientes lneas:\r
\r
System.setProperty("javax.net.ssl.keyStore", "ClavesServidor");\r
System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
\r
Y en el programa cliente seran estas:\r
\r
System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
\r
Adems del nombre, podemos indicar la ruta donde se encuentran los almacenes, recordando que NO ES RECOMENDABLE el uso de barras invertidas para indicar rutas.\r
:::\r
\r
Una vez hechos los cambios, bien en las opciones de la JVM o bien en el cdigo de las aplicaciones, la salida que obtendremos ser esta\r
\r
<CodeGroup>\r
<CodeGroupItem title="Servidor" active>\r
\r
\`\`\`sh:no-line-numbers\r
Esperando al cliente 1\r
Recibiendo del CLIENTE: 1 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 2\r
Recibiendo del CLIENTE: 2 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 3\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Cliente">\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Recibiendo del SERVIDOR: \r
	Saludos al cliente del servidor\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
</CodeGroup>\r
\r
::: warning Default trusted certificates\r
Whenever Java attempts to connect to another application over SSL (e.g.: HTTPS, IMAPS, LDAPS), it will only be able to connect to that application if it can trust it. The way trust is handled in the Java world is that you have a keystore (typically $JAVA_HOME/lib/security/cacerts), also known as the truststore. This contains a list of all known Certificate Authority (CA) certificates, and Java will only trust certificates that are signed by one of those CAs or public certificates that exist within that keystore.\r
\r
If -Djavax.net.ssl.trustStore has been configured, it will override the location of the default truststore, which will need to be checked.\r
:::`]},{title:"6.6 Anexo I - Librera de registro Log4Java2",headers:[{level:2,title:"6.6.1 Registros o logs",slug:"_6-6-1-registros-o-logs",link:"#_6-6-1-registros-o-logs",children:[]},{level:2,title:"6.6.2. Configuracin automtica de Log4j2",slug:"_6-6-2-configuracion-automatica-de-log4j2",link:"#_6-6-2-configuracion-automatica-de-log4j2",children:[]},{level:2,title:"6.6.3. Niveles de registro",slug:"_6-6-3-niveles-de-registro",link:"#_6-6-3-niveles-de-registro",children:[]},{level:2,title:"6.6.4. Ejemplo de uso de Log4j2",slug:"_6-6-4-ejemplo-de-uso-de-log4j2",link:"#_6-6-4-ejemplo-de-uso-de-log4j2",children:[]},{level:2,title:"6.6.5. Configuracin de Log4j2",slug:"_6-6-5-configuracion-de-log4j2",link:"#_6-6-5-configuracion-de-log4j2",children:[]},{level:2,title:"6.6.6 Appenders",slug:"_6-6-6-appenders",link:"#_6-6-6-appenders",children:[]},{level:2,title:"6.6.7. Loggers",slug:"_6-6-7-loggers",link:"#_6-6-7-loggers",children:[]},{level:2,title:"6.6.8. Layouts",slug:"_6-6-8-layouts",link:"#_6-6-8-layouts",children:[]},{level:2,title:"6.6.9. Actividades",slug:"_6-6-9-actividades",link:"#_6-6-9-actividades",children:[]},{level:2,title:"6.6.10. Bibliografa",slug:"_6-6-10-bibliografia",link:"#_6-6-10-bibliografia",children:[]}],path:"/es/unit6/log4j_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.6 Anexo I - Librera de registro Log4Java2\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.6 Anexo I - Librera de registro Log4Java2" />\r
\r
# 6.6 Anexo I - Log4Java2 - Gestor de logs\r
\r
[[toc]]\r
\r
## 6.6.1 Registros o logs\r
\r
El registro es el proceso de escribir mensajes de registro en cualquier archivo, base de datos, consola, etc. para mantener un registro de eventos que ocurren en un sistema. El registro es una parte esencial de cualquier aplicacin para depurar y monitorear el sistema.\r
\r
El software con suficiente registro y monitorizacin le permitir detectar posibles incidentes cuando su cdigo se despliegue en un entorno de produccin. \`Log4j\` se utiliza para gestionar el registro de informacin en una aplicacin.\r
\r
Adems, en trminos de seguridad, el registro es una parte esencial de cualquier aplicacin. Si su aplicacin se ve comprometida, el registro le ayudar a rastrear el origen de un ataque, accesos indebidos, accesos no autorizados y a tomar medidas para evitar que vuelva a ocurrir.\r
\r
Hasta ahora hemos usado la instruccin SOP \`System.out.println()\` para imprimir mensaje de registro. Este sistema tiene algunas desventajas:\r
\r
- Podemos imprimir mensajes de registro solo en la consola. Por lo tanto, cuando se cierre la consola, perderemos -dos los registros.\r
- No podemos almacenar mensajes de registro en ningn lugar permanente. Estos mensajes se imprimirn uno por uno en la consola porque es un entorno de un solo hilo.\r
- No podemos configurar diferentes niveles de registro como INFO, DEBUG, ERROR, etc.\r
- No podemos configurar el formato de registro, como la fecha, la hora, el nombre de la clase, el nombre del mtodo y que se aplique a todos los mensajes de registro.\r
- No podemos configurar el destino de registro, como la consola, el archivo, la base de datos, etc.\r
\r
Para solventar estos problemas, se utiliza el framework Log4j. Log4j es un framework de cdigo abierto proporcionado por Apache solo para proyectos de Java.\r
\r
!!! note Versiones Log4j2\r
    Log4j es un sistema de registro donde la API (llamada Log4j API) y su implementacin (llamada Log4j Core) estn separadas claramente la una de la otra.\r
\r
    Esto permite que la API de Log4j proporcione una interfaz que sea fcil de usar de una manera correcta y a prueba de futuro. Consulta las pginas de [API de Java](https://logging.apache.org/log4j/2.x/manual/api.html), [API de Kotlin](https://logging.apache.org/log4j/kotlin/index.html) y [API de Scala](https://logging.apache.org/log4j/scala/latest/) para obtener ms informacin.\r
\r
    \r
Para usar Log4j2 en nuestro cdigo solo necesitamos agregar las siguientes [libreras / dependencias](https://logging.apache.org/log4j/2.x/download.html) en nuestro proyecto:\r
\r
\`\`\`bash\r
log4j-api-<version>.jar\r
log4j-core-<version>.jar\r
\`\`\`\r
\r
## 6.6.2. Configuracin automtica de Log4j2\r
\r
Podemos configurar Log4j2 con nuestra aplicacin utilizando un archivo de configuracin escrito en formato XML, JSON, YAML o propiedades. Tambin podemos hacerlo mediante cdigo pero, por ahora, nos vamos a centrar en la configuracin utilizando archivos de configuracin.\r
\r
Log4j tiene la capacidad de configurarse automticamente durante la inicializacin. Tiene un orden para buscar el archivo de configuracin en la aplicacin. Log4j proporcionar una configuracin predeterminada si no puede localizar un archivo de configuracin.\r
\r
## 6.6.3. Niveles de registro\r
\r
Los niveles de registro son un mecanismo para categorizar los registros. Los niveles se utilizan para identificar la gravedad de un evento. Podemos configurar fcilmente los niveles para especificar qu detalles de registro queremos ver. Log4j proporciona los siguientes niveles:\r
\r
1. ALL: Para registrar todos los eventos.\r
2. TRACE: Un mensaje de depuracin detallado, que captura tpicamente el flujo a travs de la aplicacin.\r
3. DEBUG: Un evento de depuracin general.\r
4. INFO: Un evento con fines informativos.\r
5. WARN: Un evento que podra posiblemente llevar a un error.\r
6. ERROR: Un error en la aplicacin, posiblemente recuperable.\r
7. FATAL: Un error grave que impedir que la aplicacin contine.\r
8. OFF: No se registrarn eventos.\r
\r
Log4j sigue el siguiente orden:\r
\r
> ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL\r
\r
Si especificamos el nivel de registro como INFO, se registrarn todos los eventos INFO, WARN, ERROR y FATAL. Si especificamos el nivel de registro como WARN, se registrarn todos los eventos WARN, ERROR y FATAL. En trminos simples, se considerarn todos los niveles por debajo del nivel especificado, incluido el nivel especificado.\r
\r
## 6.6.4. Ejemplo de uso de Log4j2\r
\r
\`\`\`java\r
package psp.examples.u06.log4j2;\r
\r
import org.apache.logging.log4j.LogManager;\r
import org.apache.logging.log4j.Logger;\r
\r
public class ModuleA {\r
\r
    private static final Logger logger = LogManager.getLogger();\r
    \r
    // Log messages\r
    public static void main(String[] args) {\r
        logger.debug("It is a debug logger.");\r
        logger.error("It is an error logger.");\r
        logger.fatal("It is a fatal logger.");\r
        logger.info("It is a info logger.");\r
        logger.trace("It is a trace logger.");\r
        logger.warn("It is a warn logger.");\r
    }\r
}\r
\`\`\`\r
\r
La salida obtenida ser la siguiente:\r
\r
\`\`\`bash\r
11:14:47.469 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\r
11:14:47.471 [main] FATAL psp.examples.u06.log4j2.ModuleA - It is a fatal logger.\r
\`\`\`\r
\r
Aunque hemos usado todos los niveles, en la consola solo vemos dos niveles. En realidad, cuando no proporcionamos ningn archivo de configuracin, por defecto Log4j utiliza una configuracin predeterminada. La configuracin predeterminada, proporcionada en la clase DefaultConfiguration, configurar:\r
\r
- Un **\`ConsoleAppender\`** para el logger por defecto, es decir, los registros se imprimirn en la consola.\r
- Un **\`PatternLayout\`** configurado con el patrn:\r
  " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n " asociado al ConsoleAppender\r
\r
!!! tip Nivel de registro por defecto\r
    Por defecto, Log4j asigna el logger raz al nivel Level.ERROR y esos logs se imprimirn en la consola estndar.\r
\r
!!! info Patrn por defecto\r
    Vamos a entender el formato de patrn en el que se imprimen los logs. Dado que no hemos pasado ningn archivo de configuracin, utiliza el formato por defecto que se muestra a continuacin.\r
\r
    > " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n "\r
\r
    - \`%d{HH:mm:ss.SSS}\` is execution timestamp i.e. 18:07:15.984\r
    - \`[%t]\` is thread name i.e. [main] \r
    - \`%-5level\` is level name i.e. ERROR\r
    - \`%logger{36}\` is logger name which we are creating as first step i.e. psp.examples.u06.log4j2\r
    - \`%msg%n\` is message i.e.  It is an error logger  followed by a new line character.\r
\r
## 6.6.5. Configuracin de Log4j2\r
\r
Para configurar Log4j2, necesitamos un archivo de configuracin. Log4j2 admite la configuracin en formato XML, JSON, YAML y propiedades.\r
\r
Log4j2 tiene una arquitectura de registro bastante compleja, sin embargo la mayora de los usuarios solo requieren estos elementos:\r
\r
- **Loggers**: Son el punto de entrada del pipeline de registro, que se utiliza directamente en el cdigo. Su configuracin debe especificar qu nivel de mensajes registran y a qu \`*appenders*\` envan los mensajes. Los cubriremos mientras configuramos los \`*loggers*\`.\r
- **Appenders**: Son el punto de salida del pipeline de registro. Deciden a qu recurso (consola, archivo, base de datos o similar) se enva el evento de registro. Los ms comunes son el \`*console appender*\` y el \`*file appender*\`.\r
- **Layouts**: Indican a los \`*appenders*\` cmo formatear el evento de registro: texto, JSON, XML o similar. Los ms comunes son \`*Pattern Layout*\` y \`*JSON Template Layout*\`.\r
\r
A continuacin se muestra un ejemplo de configuracin en formato XML.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuracin, hemos configurado un \`ConsoleAppender\` que imprimir los mensajes de registro en la consola. Hemos configurado el nivel de registro raz como \`error\`, por lo que solo se imprimirn los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscar los archivos de configuracin en el siguiente orden:\r
\r
1. Primero comprobar si se ha especificado un archivo de configuracin en la propiedad del sistema \`log4j.configurationFile\`. Si no se ha especificado, buscar los archivos de configuracin en el siguiente orden:\r
2. Si no encuentra la propiedad del sistema buscar los archivos de configuracin en el \`classpath\` en el siguiente orden:\r
\r
   - \`log4j2-test.xml\`\r
   - \`log4j2-test.json\`\r
   - \`log4j2-test.yaml\`\r
   - \`log4j2-test.yml\`\r
   - \`log4j2-test.properties\`\r
   - \`log4j2.xml\`\r
   - \`log4j2.json\`\r
   - \`log4j2.yaml\`\r
   - \`log4j2.yml\`\r
   - \`log4j2.properties\`\r
\r
Se puede ampliar la informacin en la [documentacin oficial de Log4j2](https://logging.apache.org/log4j/2.x/manual/configuration.html).\r
\r
## 6.6.6 Appenders\r
\r
> [Documentacin Appenders](https://logging.apache.org/log4j/2.x/manual/appenders.html)\r
\r
Podemos especificar destinos para mantener los registros de eventos. Podemos querer imprimir esos registros en la consola o en cualquier archivo externo. Los \`appenders\` suelen ser responsables de escribir los datos de eventos en el destino objetivo. Podemos usar varios *appenders* en una misma configuracin.\r
\r
Los \`appenders\` ms comunes son:\r
\r
- **ConsoleAppender**: Imprime los mensajes de registro en la consola.\r
- **FileAppender**: Imprime los mensajes de registro en un archivo.\r
- **RollingFileAppender**: Imprime los mensajes de registro en un archivo y crea un nuevo archivo cuando el tamao del -chivo alcanza un lmite.\r
- **DBAppender**: Imprime los mensajes de registro en una base de datos.\r
- **SMTPAppender**: Enva los mensajes de registro por correo electrnico.\r
- **SocketAppender**: Enva los mensajes de registro a un servidor remoto.\r
- **SyslogAppender**: Enva los mensajes de registro a un servidor Syslog.\r
- **JMSAppender**: Enva los mensajes de registro a un servidor JMS.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration xmlns="https://logging.apache.org/xml/ns"\r
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r
               xsi:schemaLocation="\r
                   https://logging.apache.org/xml/ns\r
                   https://logging.apache.org/xml/ns/log4j-config-2.xsd">\r
  <Appenders>\r
    <Console name="CONSOLE">\r
      <PatternLayout pattern="%p - %m%n"/>\r
    </Console>\r
    <File name="MAIN" fileName="logs/main.log">\r
      <JsonTemplateLayout/>\r
    </File>\r
    <File name="DEBUG_LOG" fileName="logs/debug.log">\r
      <PatternLayout pattern="%d [%t] %p %c - %m%n"/>\r
    </File>\r
  </Appenders>\r
  <Loggers>\r
    <Root level="INFO">\r
      <AppenderRef ref="CONSOLE" level="WARN"/>\r
      <AppenderRef ref="MAIN"/>\r
    </Root>\r
    <Logger name="org.example" level="DEBUG">\r
      <AppenderRef ref="DEBUG_LOG"/>\r
    </Logger>\r
  </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En el ejemplo anterior se han configurado tres \`appenders\`:\r
\r
- Un \`ConsoleAppender\` llamado CONSOLE con un \`PatternLayout\`.\r
  En este caso la salida se mostrar en la consola y se imprimir el nivel de log y el mensaje. Por ejemplo, \`INFO - It is an info logger\`.\r
- Un \`FileAppender\` llamado MAIN con un \`JsonTemplateLayout\`.\r
  En este caso la salida se escribir en el archivo \`logs/main.log\` en formato JSON. Por ejemplo, \`{"level":"INFO","message":"It is an info logger"}\`.\r
- Un \`FileAppender\` llamado DEBUG_LOG con un \`PatternLayout\`.\r
    En este caso la salida se escribir en el archivo \`logs/debug.log\` con el formato de fecha, hilo, nivel de log, clase y mensaje. Por ejemplo, \`2021-09-15 11:14:47,471 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\`\r
\r
## 6.6.7. Loggers\r
\r
> [Documentacin Loggers](https://logging.apache.org/log4j/2.x/manual/configuration.html#configuring-loggers)\r
\r
Los \`loggers\` se utilizan directamente en el cdigo para registrar mensajes.\r
\r
Los \`loggers\` se configuran en el archivo de configuracin de Log4j2. y se pueden configurar para enviar mensajes de registro a uno o varios \`appenders\`.\r
\r
En el ejemplo anterior, se han configurado dos \`loggers\`:\r
\r
- Un \`logger\` raz con nivel de log INFO y dos \`appenders\` asociados: CONSOLE y MAIN.\r
  En este caso, los mensajes de log con nivel INFO o superior se enviarn al \`appender\` MAIN, es decir, al archivo \`logs/main.log\`.\r
  Los mensajes de log con nivel WARN o superior se enviarn tambin al \`appender\` CONSOLE, es decir, a la consola.\r
- Un \`logger\` con nombre \`org.example\` con nivel de log DEBUG y un \`appender\` asociado: DEBUG_LOG.\r
  En este caso, los mensajes de log con nivel DEBUG o superior se enviarn al \`appender\` DEBUG_LOG.\r
\r
!!! question Un mismo mensaje, diferentes salidas\r
    Fjate en la siguiente tabla con los mensajes que se enviaran a cada \`appender\` en funcin del nivel de log, del \`logger\` que lo genere y de los \`appenders\`.\r
\r
    | Logger name | Log event level | Appenders |\r
    |-------------|-----------------|-----------|\r
    | org.example.foo | WARN | CONSOLE, MAIN, DEBUG_LOG |\r
    | org.example.foo | DEBUG | MAIN, DEBUG_LOG |\r
    | org.example.foo | TRACE | none |\r
    | com.example | WARN | CONSOLE, MAIN |\r
    | com.example | INFO | MAIN |\r
    | com.example | DEBUG | none |\r
\r
    Si un logger no tiene un nivel de log configurado se heredar el nivel de log del logger padre. Si no se ha configurado ningn nivel de log, se heredar el nivel de log del logger raz.\r
\r
## 6.6.8. Layouts\r
\r
> [Documentacin Layouts](https://logging.apache.org/log4j/2.x/manual/layouts.html)\r
\r
Los \`layouts\` se utilizan para dar formato a los mensajes de log. Log4j2 proporciona varios \`layouts\` predefinidos que se pueden utilizar para dar formato a los mensajes de log.\r
\r
Los \`layouts\` ms comunes son:\r
\r
- **PatternLayout**: Es el \`layout\` ms comnmente utilizado. Permite configurar el formato de los mensajes de log utilizando un patrn.\r
- **JsonTemplateLayout**: Es un \`layout\` que genera mensajes de log en formato JSON.\r
- **YamlLayout**: Es un \`layout\` que genera mensajes de log en formato YAML.\r
- **HtmlLayout**: Es un \`layout\` que genera mensajes de log en formato HTML.\r
- **CsvLogLayout**: Es un \`layout\` que genera mensajes de log en formato CSV.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36}  %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuracin, hemos configurado un \`ConsoleAppender\` que imprimir los mensajes de registro en la consola. Hemos configurado el nivel de registro raz como \`error\`, por lo que solo se imprimirn los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscar los archivos de configuracin en el siguiente orden:\r
\r
Un ejemplo de configuracin de Log4j2 con un \`JsonTemplateLayout\` sera el siguiente:\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <JsonTemplateLayout eventTemplateUri="classpath:log4j2/templates/JsonEventLayout.json"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
Donde un posible contenido para el archivo \`JsonEventLayout.json\` podra ser el siguiente:\r
\r
\`\`\`json\r
{\r
  "timeMillis": "\${timeMillis}",\r
  "thread": "\${thread}",\r
  "level": "\${level}",\r
  "loggerName": "\${loggerName}",\r
  "message": "\${message}",\r
  "thrown": "\${thrown}"\r
}\r
\`\`\`\r
\r
## 6.6.9. Actividades\r
\r
Puedes probar a realizar las siguientes actividades para practicar con Log4j2:\r
\r
1. Escribe un programa simple utilizando Log4j2 que imprima TODOS los niveles de error en la consola.\r
2. Utilizando el programa del ejercicio 1, genera un archivo de configuracin manual para imprimir los errores FATALES en SYSTEM_ERR y el resto de los niveles de error en SYSTEM_OUT. (Aade comentarios en el XML con \`<!--Tu comentario-->\`)\r
3. Utilizando el programa del ejercicio 1, genera un archivo de configuracin manual en el que los errores FATALES vayan a un archivo de texto, los errores de nivel ERROR aparezcan en rojo en la consola (SYSTEM_ERR) y el resto aparezcan en la consola normal (SYSTEM_OUT).\r
4. Utilizando el archivo anterior (ejercicio 3) cambia el Patrn de Salida para que lo primero que aparezca en la lnea de LOG sean tus iniciales.\r
\r
!!! tip Guardar los registros en una base de datos\r
    Log4j2 tambin permite guardar los registros en una base de datos.\r
    Investiga cmo se puede hacer y realiza un ejemplo de cmo guardar los registros en una base de datos MySQL.\r
\r
## 6.6.10. Bibliografa\r
\r
- [Log4j2 - Documentacin oficial](https://logging.apache.org/log4j/2.x/)\r
- [Tutorial de 7 partes de MakeSeleniumEasy sobre Log4j2](http://makeseleniumeasy.com/2021/03/11/log4j2-tutorial-1-introduction-to-apache-log4j2/)\r
- [Log4j2 - Tutorialspoint](https://www.tutorialspoint.com/log4j/log4j_logging_files.htm)\r
`]},{title:"6.1 Seguridad",headers:[{level:2,title:"6.1.1. Seguridad digital",slug:"_6-1-1-seguridad-digital",link:"#_6-1-1-seguridad-digital",children:[]},{level:2,title:"6.1.2. Seguridad en Java",slug:"_6-1-2-seguridad-en-java",link:"#_6-1-2-seguridad-en-java",children:[{level:3,title:"JCA: Engines, algoritmos y proveedores",slug:"jca-engines-algoritmos-y-proveedores",link:"#jca-engines-algoritmos-y-proveedores",children:[]}]},{level:2,title:"6.1.3. Proveedores",slug:"_6-1-3-proveedores",link:"#_6-1-3-proveedores",children:[]},{level:2,title:"6.1.4. Engines",slug:"_6-1-4-engines",link:"#_6-1-4-engines",children:[{level:3,title:"6.1.5. Algoritmos",slug:"_6-1-5-algoritmos",link:"#_6-1-5-algoritmos",children:[]}]}],path:"/es/unit6/security.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.1 Seguridad \r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.1 Seguridad" />\r
\r
# 6.1 Seguridad\r
\r
[[toc]]\r
\r
## 6.1.1. Seguridad digital\r
\r
Los aspectos fundamentales de la seguridad en las comunicaciones digitales son los siguientes\r
\r
- **Integridad**: Permite asegurar que los datos que recibe un receptor son idnticos a los que ha enviado el emisor. Es decir, no se ha modificado en ningn punto intermedio en **el canal, que como sabemos, es un canal compartido y por tanto, inseguro**. Las modificaciones pueden ser causadas por fallos en la transmisin a travs del canal o bien por una accin intencionada de un tercero.\r
- **Confidencialidad**: Nos asegura que los datos transmitidos son inteligibles slo para el receptor del mensaje. Por las caractersticas del medio no podemos evitar que el mensaje llegue a otros destinatarios, pero lo que s podemos evitar es que estos puedan ver el contenido original del mensaje. Esto se consigue cifrando el mensaje.\r
- **Autenticacin**: Permite asegurar al receptor de un mensaje que el emisor del mensaje es quien dice ser y no cualquier otro. Esto se consigue con los certificados y la firma digital.\r
- **No repudio**: Es una consecuencia de la caracterstica anterior, ya que un receptor puede demostrar que el mensaje fue enviado por un emisor de forma inequvoca.\r
\r
## 6.1.2. Seguridad en Java\r
\r
[oracle Security Developers Guide](https://docs.oracle.com/en/java/javase/11/security/java-cryptography-architecture-jca-reference-guide.html)\r
\r
Desde el punto de vista de la seguridad, el conjunto de clases de seguridad distribuidas con el SDK de Java 2 pueden dividirse en dos subconjuntos:\r
\r
- Clases relacionadas con el control de acceso y la gestin de permisos.\r
- Clases relacionadas con la Criptografa.\r
\r
Java incluye APIs de acceso a funciones criptogrficas de propsito general, conocidas como la **Arquitectura Criptogrfica de Java o Java Cryptography Architecture (JCA)** y la **Extension Criptogrfica de Java o Java Cryptography Extension (JCE)**.\r
\r
El JCA est formado por las clases bsicas relacionadas con criptografa distribuidas con el JDK y el soporte para la encriptacin lo proporciona el paquete de extensin JCE.\r
\r
Java tambin incluye un conjunto de paquetes para la comunicacin segura en Internet, conocidos como la **Extensin de Sockets Seguros de Java o Java Secure Socket Extension (JSSE)**. Implementa una versin Java de los protocolos SSL y TLS, adems incluye funcionalidades como cifrado de datos, autenticacin del servidor, integridad de mensajes y autenticacin del cliente.\r
\r
Por ltimo Java incluye una interfaz que permite a las aplicaciones Java acceder a servicios de control de autenticacin y acceso, el **Servicio de Autentificacin y Autorizacin de Java o Java Authentication and Authorization Service (JAAS)**. Puede usarse con dos fines: la autenticacin de usuarios para conocer quin est ejecutando cdigo Java; y la autorizacin de usuarios para garantizar que quin lo ejecuta tiene los permisos necesarios para hacerlo.\r
\r
### JCA: Engines, algoritmos y proveedores\r
\r
Java tiene una Arquitectura de Proveedores, que permite que coexistan multiples implementaciones de algoritmos criptogrficos (es decir multiples implementaciones del JCE). La plataforma Java 2 extiende substancialmente la JCA, entre otras cosas se ha mejorado la infraestructura de gestin de certificados para soportar los certificados X.509 V3.\r
\r
Para comprender el funcionamiento del JCA tenemos que definir algunos trminos bsicos:\r
\r
#### Engine\r
\r
En el contexto del JCA utilizamos el trmino motor (engine) para referirnos a una representacin abstracta de un servicio criptogrfico que no tiene una implementacin concreta. Un servicio criptogrfico siempre est asociado con un algoritmo o tipo de algoritmo y puede tener alguna de las siguientes funciones:\r
\r
- Proporcionar operaciones criptogrficas (como las empleadas en el firmado y el resumen de mensajes)- Generar o proporcionar el material criptogrfico (claves o parmetros) necesario para realizar las operaciones.\r
- Generar objetos (almacenes de claves o certificados) que agrupen claves criptogrficas de modo seguro.\r
\r
#### Algoritmo\r
\r
Un algoritmo es una implementacin de un motor. Por ejemplo, el algoritmo MD5 es una implementacin del motor de algoritmos de resumen de mensajes. La implementacin interna puede variar dependiendo del cdigo que proporcione la clase MD5.\r
\r
#### Proveedor\r
\r
Un proveedor es el encargado de proporcionar la implementacin de uno o varios algoritmos al programador (es decir, darle acceso a una implementacin interna concreta de los algoritmos).\r
\r
## 6.1.3. Proveedores\r
\r
La JCA define el concepto de proveedor mediante la clase Provider del paquete java.security. Se trata de una clase abstracta que debe ser redefinida por clases proveedor especficas.\r
\r
El constructor de una clase proveedor ajusta los valores de varias propiedades que necesita el API de seguridad de Java para localizar los algoritmos u otras facilidades implementadas por el proveedor.\r
\r
La clase Provider tiene mtodos para acceder al nombre del proveedor, el nmero de versin y otras informaciones sobre las implementaciones de los algoritmos para la generacin, conversin y gestin de claves y la generacin de firmas y resmenes.\r
\r
Si un programador desea saber los proveedores disponibles puede emplear los mtodos\r
\r
- getProvider("nombre") para saber si un proveedor concreto est instalado\r
- getProviders() que retorna un vector de cadenas con los nombres de los proveedores\r
\r
::: info Archivo java.security\r
%JAVA_HOME%/conf/security/java.security es el archivo que contiene la informacin de la configuracin de seguridad que utilizan las clases de la JCA.\r
\r
Ah estn declarados todos los proveedores y algoritmos que estn disponibles, as como el orden en el que las clases los buscarn.\r
:::\r
\r
Para entender como funcionan los proveedores daremos un ejemplo. Supongamos que un programa necesita una implementacin del algoritmo MD5. Para obtenerla el programador necesita crear una instancia del mismo y lo har escribiendo la siguiente lnea de cdigo:\r
\r
\`\`\`java\r
MessageDigest m = MessageDigest.getInstance("MD5");\r
\`\`\`\r
\r
Internamente, el mtodo getInstance() solicita a la clase java.security.Security que le proporcione el objeto solicitado. Como no se ha especificado proveedor la clase Security consulta a todos los proveedores disponibles, solicitando una implementacin del algoritmo "MD5", hasta que encuentra una o se queda sin proveedores. La consulta se realiza segn la lista de proveedores del archivo java.security, que por defecto slo contiene la entrada:\r
\r
Security.provider.1=sun.security.provider.Sun\r
\r
## 6.1.4. Engines\r
\r
En el JDK el JCA define las siguientes clases Engine\r
\r
| Clase JCA | Funcin |\r
|---|---|\r
|java.security.MessageDigest | Calculo de resumen de mensajes (hash).|\r
|java.security.Signature| Firma de datos y verificacin firmas.|\r
|java.security.KeyPairGenerator | Generar pares de claves (pblica y privada) para un algoritmo.|\r
|java.security.KeyFactory| Convertir claves de formato criptogrfico, especificaciones de claves y viceversa|\r
|java.security.certificate.CertificateFactory| Crear certificados de clave pblica y listas de revocacin(CRLs).|\r
|java.security.KeyStore | Crear y gestionar un almacn de claves (keystore).|\r
|java.security.AlgorithmParameters | Gestionar los parmetros de un algoritmo, incluyendo codificacin y descodificacin.|\r
|java.security.AlgorithmParameterGenerator | Generar un conjunto de parmetros para un algoritmo.|\r
|java.security.SecureRandom | Generar nmeros aleatorios o pseudo aleatorios.|\r
\r
Para instanciar una clase motor se debe invocar el mtodo esttico *getInstance()*, si se le pasa un nombre de algoritmo se intentar obtener una implementacin de algn proveedor.\r
\r
### 6.1.5. Algoritmos\r
\r
Al igual que pasa con las herramientas de lnea de comandos, debemos saber qu algoritmos estn disponibles para su uso por las aplicaciones en nuestra mquina virtual.\r
\r
El siguiente programa nos permite saber que proveedores y algoritmos tenemos instalados en nuestro sistema.\r
\r
Adems, si lo invocamos con la opcin -l nos dir que algoritmos implementan (leyendo las propiedades del proveedor)\r
\r
Toda la informacin mostrada se extrae del archivo *java.security*\r
\r
\`\`\`java\r
class U6S1_1_InfoProveedoresJCA {\r
\r
    public static void main(String[] args) {\r
        boolean listarProps = false;\r
        if (args.length > 0 && args[0].equals("-l")) {\r
            listarProps = true;\r
        }\r
        System.out.println("------------------------------------");\r
        System.out.println("Proveedores instalados en su sistema");\r
        System.out.println("------------------------------------");\r
        int i = 0;\r
        for (Provider proveedor: Security.getProviders()) {\r
            System.out.println("Nm. proveedor : " + (i + 1));\r
            System.out.println("Nombre         : " + proveedor.getName());\r
            System.out.println("Versin        : " + proveedor.getVersion());\r
            System.out.println("Informacin    :\\n  " + proveedor.getInfo());\r
            System.out.println("Propiedades    :");\r
            if (listarProps) {\r
                Enumeration propiedades = proveedor.propertyNames();\r
                while (propiedades.hasMoreElements()) {\r
                    String clave = (String) propiedades.nextElement();\r
                    String valor = proveedor.getProperty(clave);\r
                    System.out.println("  " + clave + " = " + valor);\r
                }\r
            }\r
            System.out.println("------------------------------------");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El siguiente programa nos permite comprobar las propiedades de los algoritmos disponibles en nuestro sistema.\r
\r
\`\`\`java\r
class U6_S1_2_ProbarAlgoritmosJCA {\r
\r
    public static void main(String[] args) {\r
        if (args.length != 1) {\r
            System.out.println("Uso: java ProbarAlgoritmosJCA <algoritmo>");\r
            System.exit(1);\r
        }\r
        try {\r
            MessageDigest md = MessageDigest.getInstance(args[0]);\r
            System.out.println("Algoritmo: " + md.getAlgorithm());\r
            System.out.println("Proveedor: " + md.getProvider().getName());\r
            System.out.println("Info     : " + md.toString());\r
            System.out.println("Tamao   : " + md.getDigestLength());\r
            System.out.println("Bloque   : " + md.getBlockSize());\r
            System.out.println("Entrada  : " + md.getInputSize());\r
            System.out.println("Salida   : " + md.getOutputSize());\r
            System.out.println("Implement: " + md.getClass().getName());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.out.println("Algoritmo no disponible");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
\r
`]},{title:"6.3 Encriptacin simtrica",headers:[{level:2,title:"6.3.1. Clave secreta",slug:"_6-3-1-clave-secreta",link:"#_6-3-1-clave-secreta",children:[]},{level:2,title:"6.3.2. Cipher",slug:"_6-3-2-cipher",link:"#_6-3-2-cipher",children:[{level:3,title:"Transformaciones bsicas en Java",slug:"transformaciones-basicas-en-java",link:"#transformaciones-basicas-en-java",children:[]}]},{level:2,title:"6.3.3. Clases stream para cifrado y descifrado simtrico",slug:"_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",link:"#_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",children:[]},{level:2,title:"6.3.4. Cifrado simtrico con GnuPG",slug:"_6-3-4-cifrado-simetrico-con-gnupg",link:"#_6-3-4-cifrado-simetrico-con-gnupg",children:[]}],path:"/es/unit6/symmetric-key.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.3 Encriptacin simtrica\r
# Frontmatter para guardar imgenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.3 Encriptacin simtrica" />\r
\r
# 6.3 Encriptacin simtrica\r
\r
[[toc]]\r
\r
## 6.3.1. Clave secreta\r
\r
Ahora nos interesa no slo verificar la integridad de la informacin intercambiada, sino tambin mantener su privacidad, es decir, que no sea "comprensible" durante la transmisin, intercambio o almacenamiento. \r
\r
Tenemos un conjunto de algoritmos denominados de **clave simtrica** (tambin conocidos como de clave secreta) en los que, mediante la aplicacin de una clave conocida tanto por el emisos como por el receptor, la informacin se **encripta o cifra** de forma que slo pueda ser **desencriptada o descifrada** utilizando el mismo algoritmo y la misma clave.\r
\r
::: info El cdigo Enigma\r
Como ejemplo de sistema simtrico est Enigma. Este fue un sistema empleado por Alemania durante la Segunda Guerra Mundial, en el que las claves se distribuan a diario en forma de libros de cdigos. \r
\r
Cada da, un operador de radio, receptor o transmisor, consultaba su copia del libro de cdigos para encontrar la clave del da. Todo el trfico enviado por ondas de radio durante aquel da era cifrado y descifrado usando las claves del da.\r
\r
Inglaterra us mquinas para descifrar las claves durante aquella guerra y aunque el citado sistema alemn, Enigma, estaba provisto de un amplio abanico de claves, los ingleses disearon mquinas de cmputo especializado, los Bombes, para comprobar las claves de modo mecnico hasta que la clave del da era encontrada. \r
\r
Esto significaba que algunas veces encontraban la clave del da pocas horas despus de que sta fuera puesta en uso, pero tambin que otros das no podan encontrar la clave correcta. \r
\r
Los Bombes no fueron mquinas de cmputo general, sino las precursoras de los ordenadores (computadoras) actuales.\r
:::\r
\r
Entre los algoritmos de cifrado simtrico ms utilizados se encuentran\r
\r
- DES\r
- 3DES o Tiple DES\r
- RC5\r
- AES\r
- Blowfish\r
- IDEA\r
\r
![cifrado simtrico](../../media/unit6/symmetric-encryption-primitive.png)\r
\r
## 6.3.2. Cipher\r
\r
Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *SecretKey* a partir de un KeyGenerator obtenido con el mtodo esttico *getInstance()*, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. As podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave ser diferente.\r
3. Se crea un objeto de tipo Cipher indicando qu algoritmo vamos a usar. Y despus, con el mtodo *init()* se indica qu vamos a hacer (cifrar/descifrar) y con qu clave.\r
4. Se aaden datos con el mtodo *update()*. Se puede aadir un byte o un array de bytes. Este mtodo se puede invocar varias veces para ir aadiendo nuevos datos.\r
5. Se obtiene el valor cifrado con el mtodo *doFinal()*.\r
6. Si se quisiera descifrar, slo hay que volver a invocar al mtodo *init()* indicando en este caso que queremos descifrar.\r
\r
A continuacin podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S3_1_SecretKeyEncrypt {\r
\r
    public static void main(String[] args) {\r
        SecretKey claveSecreta = null;\r
        \r
        try {\r
\r
            //Generamos clave secreta\r
            // Podemos crear una nueva clave\r
            claveSecreta = getNewKey();\r
            // O bien usar una clave guardada en algn almacn, fichero, etc.\r
            claveSecreta = getKeyFromData();\r
\r
            System.out.println("Clave usada: " + claveSecreta.getFormat());\r
            //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
            Cipher c = Cipher.getInstance("DESede"); // AES/ECB/PKCS5Padding\r
            // Configuramos el modo de CIFRADO\r
            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\r
\r
            // Aqu leemos la informacin que queremos cifrar\r
            // Puede ser una cadena o leerla de un archivo\r
            byte[] textoPlano = "Texto que queremos cifrar para la prueba".getBytes();\r
            \r
            // Si queremos ir cifrando poco a poco, vamos haciendo llamadas\r
            // al mtodo update\r
            // c.update(textoPlano);\r
            // Se realiza el proceso final de cifrado de la informacin\r
            byte[] textoCifrado = c.doFinal(textoPlano);\r
            System.out.println("Texto cifrado con clave secreta (raw):\\n" + new String(textoCifrado));\r
            System.out.println("Texto cifrado con clave secreta (hex):\\n" + toHexadecimal(textoCifrado));\r
                        \r
            \r
            // El proceso de descifrado es equivalente\r
            // Cambiamos el modo de ENCRYPT a DECRYPT\r
            // Usamos la misma clave\r
            // Pasamos el texto cifrado para obtener el original\r
            c.init(Cipher.DECRYPT_MODE, claveSecreta);\r
            byte[] textoOriginal = c.doFinal(textoCifrado);\r
            //Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\r
            System.out.println("Texto descifrado:\\n" + new String(textoOriginal));\r
            \r
        } catch (Exception e) {\r
            e.printStackTrace();\r
        }\r
    }\r
\r
    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
    \r
            KeyGenerator kg = KeyGenerator.getInstance("DESede");\r
            kg.init(112);\r
            SecretKey clave = kg.generateKey();\r
            \r
            return clave;\r
    }\r
\r
    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // Clave obtenida usando un generador de nmero aleatorios seguro\r
        KeyGenerator genClaves = KeyGenerator.getInstance("DESede");\r
        // Utilizamos un algoritmo de generacin de aleatorios        \r
        SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");\r
        genClaves.init(srand);\r
        \r
        SecretKey clave = genClaves.generateKey();\r
        System.out.println("Formato de clave: " + clave.getFormat());\r
        \r
        /*\r
        SecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance("DESede");\r
        DESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\r
        byte[] valorClave = keySpec.getKey();\r
        */\r
        \r
        return clave;\r
    }\r
    \r
    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        SecretKeySpec keySpec = new SecretKeySpec (valorClave, "DESede");\r
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");\r
        SecretKey clave = keyFactory.generateSecret(keySpec);\r
        \r
        return clave;\r
    }\r
\r
    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        Key clave = new SecretKeySpec(valorClave, "AES");\r
\r
        return clave;\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
    \r
}\r
\`\`\`\r
\r
y esta sera la salida proporcionada\r
\r
\`\`\`sh\r
Texto cifrado con clave secreta:\r
D0A61CD14B5844AD98B2C7BA795B327ACA0795B658C6F93EC6E1586A246BE71AC180B574207E8C4FFEB959B7D4642FCB\r
Texto descifrado:\r
Texto que queremos cifrar para la prueba\r
\`\`\`\r
\r
Hay que tener en cuenta que en el ejemplo la clave se est usando primero para cifrar y luego para descifrar. Si esto lo hacemos en programas separados, los programas que quieran comunicarse debern tener acceso a la clave.\r
\r
Lo que se suele hacer es almacenar la clave en un archivo y, cuando se necesita para cifrar o descifrar, se lee con un mtodo similar al mtodo *getKeyFromData()* del ejemplo anterior.\r
\r
### Transformaciones bsicas en Java\r
\r
En la siguiente tabla tenemos los algoritmos, modos y tipos de relleno, junto con la longitud de clave empleada, de los algoritmos de cifrado simtrico m'as comunes.\r
\r
|Transformacin (algoritmo/modo/relleno)|Key Size|\r
|---|---|\r
|AES/CBC/NoPadding|128|\r
|AES/CBC/PKCS5Padding|128|\r
|AES/ECB/NoPadding|128|\r
|AES/ECB/PKCS5Padding|128|\r
|DES/CBC/NoPadding|56|\r
|DES/CBC/PKCS5Padding|56|\r
|DES/ECB/NoPadding|56|\r
|DES/ECB/PKCS5Padding|56|\r
|DESede/CBC/NoPadding|168|\r
|DESede/CBC/PKCS5Padding|168|\r
|DESede/ECB/NoPadding|168|\r
|DESede/ECB/PKCS5Padding|168|\r
|RSA/ECB/PKCS1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-1AndMGF1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-256AndMGF1Padding|1024, 2048|\r
\r
\r
## 6.3.3. Clases stream para cifrado y descifrado simtrico\r
\r
Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete *java.crypto* pero por lo dems funcionan exactamente igual que las clases Stream del paquete *java.io*, de las que adems son clases descendientes y y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.\r
\r
| Clase |Ejemplo |\r
| --- | --- |\r
| CipherInputStream | CipherInputStream (InputStream is, Cipher c) |\r
| CipherOutputStream | CipherOutputStream (OutputStream os, Cipher c) |\r
\r
Por lo tanto, cuando tenemos que leer o escribir informacin, podemos aadir un envoltorio ms al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher.\r
\r
El uso ms comn es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la informacin de forma cifrada/descifrada.\r
\r
::: warning Tamao de bloque\r
Muchos de los algoritmos de cifrado simtrico trabajan con bloques de datos, por lo que no debemos intentar cifrar o descifrar ms informacin de la que permite el tamao de bloque.\r
\r
La clase Cipher tiene un mtodo **getBlockSize()** que nos devuelve el tamao de bloque que permite el algoritmo configurado en su mtodo **init()**.\r
:::\r
\r
Veamos un ejemplo de cmo quedara el wrapper\r
\r
\`\`\`java\r
public class U6S3_2_StreamCrypto {\r
\r
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\r
        File file;\r
        String filePath = "a.txt";\r
\r
        file = new File(filePath);\r
\r
        //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding"); //DESede\r
        // Configuramos el modo de CIFRADO\r
        byte[] valorClave = "12345678123456781234567812345678".getBytes();\r
\r
        // CIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.ENCRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (OutputStream outputStream = new BufferedOutputStream(\r
                new CipherOutputStream(new FileOutputStream(file), c))) {\r
            for (int i = 0; i < 10; i++) {\r
                outputStream.write(new String("Hello World\\n").getBytes());\r
            }\r
\r
        }\r
\r
        // DESCIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.DECRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (InputStream inputStream = new BufferedInputStream(\r
                new CipherInputStream(new FileInputStream(file), c))) {\r
\r
            System.out.println("Contenido del fichero (descifrado):\\n" + new String(inputStream.readAllBytes()));\r
        }\r
\r
    }\r
}\r
\`\`\`\r
\r
## 6.3.4. Cifrado simtrico con GnuPG\r
\r
Con la suite GnuPG tambin podemos cifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la informacin de los algoritmos disponibles para cada tipo de servicio. En concreto, de resmenes, en mi versin instalada:\r
\r
Cifrado: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\r
         CAMELLIA128, CAMELLIA192, CAMELLIA256\r
:::\r
\r
Para cifrar y descifrar un archivo, ejecutamos los siguientes comandos\r
\r
\`\`\`sh\r
gpg --symmetric --cipher-algo 3DES filename.ext\r
gpg --decrypt filename.ext.gpg\r
\`\`\`\r
\r
Vemos que para el cifrado nos solicita una clave y que con el parmetro *--cipher-algo* indicamos qu algoritmo de encriptacin queremos utilizar.\r
\r
El cifrado genera un archivo filename.ext.gpg.\r
\r
Para el descifrado, no hace falta indicar el algoritmo, aunque se puede volver a usar el parmetro *--cipher-algo* y la clave se queda en una cache de GnuPG durante un tiempo, por lo que no siempre la solicita.\r
`]},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:[""]}],mg=fe(ug),pg=()=>mg,hg=({searchIndex:e,routeLocale:r,query:n,maxSuggestions:a})=>{const o=N(()=>e.value.filter(t=>t.pathLocale===r.value));return N(()=>{const t=n.value.trim().toLowerCase();if(!t)return[];const s=[],l=(i,c)=>{ds(t,[c.title])&&s.push({link:`${i.path}#${c.slug}`,title:i.title,header:c.title});for(const d of c.children){if(s.length>=a.value)return;l(i,d)}};for(const i of o.value){if(s.length>=a.value)break;if(ds(t,[i.title,...i.extraFields])){s.push({link:i.path,title:i.title});continue}for(const c of i.headers){if(s.length>=a.value)break;l(i,c)}}return s})},gg=e=>{const r=fe(0);return{focusIndex:r,focusNext:()=>{r.value<e.value.length-1?r.value+=1:r.value=0},focusPrev:()=>{r.value>0?r.value-=1:r.value=e.value.length-1}}},fg=ue({name:"SearchBox",props:{locales:{type:Object,required:!1,default:()=>({})},hotKeys:{type:Array,required:!1,default:()=>[]},maxSuggestions:{type:Number,required:!1,default:5}},setup(e){const{locales:r,hotKeys:n,maxSuggestions:a}=qa(e),o=$r(),t=bn(),s=pg(),l=fe(null),i=fe(!1),c=fe(""),d=N(()=>r.value[t.value]??{}),u=hg({searchIndex:s,routeLocale:t,query:c,maxSuggestions:a}),{focusIndex:m,focusNext:f,focusPrev:w}=gg(u);dg({input:l,hotKeys:n});const P=N(()=>i.value&&!!u.value.length),k=()=>{P.value&&w()},v=()=>{P.value&&f()},S=x=>{if(!P.value)return;const A=u.value[x];A&&o.push(A.link).then(()=>{c.value="",m.value=0})};return()=>ce("form",{class:"search-box",role:"search"},[ce("input",{ref:l,type:"search",placeholder:d.value.placeholder,autocomplete:"off",spellcheck:!1,value:c.value,onFocus:()=>i.value=!0,onBlur:()=>i.value=!1,onInput:x=>c.value=x.target.value,onKeydown:x=>{switch(x.key){case"ArrowUp":{k();break}case"ArrowDown":{v();break}case"Enter":{x.preventDefault(),S(m.value);break}}}}),P.value&&ce("ul",{class:"suggestions",onMouseleave:()=>m.value=-1},u.value.map(({link:x,title:A,header:G},Z)=>ce("li",{class:["suggestion",{focus:m.value===Z}],onMouseenter:()=>m.value=Z,onMousedown:()=>S(Z)},ce("a",{href:x,onClick:M=>M.preventDefault()},[ce("span",{class:"page-title"},A),G&&ce("span",{class:"page-header"},`> ${G}`)]))))])}});const vg={"/en/":{placeholder:"Search"},"/es/":{placeholder:"Buscar"}},bg=["s","/"],yg=5,Sg=wr({enhance({app:e}){e.component("SearchBox",r=>ce(fg,{locales:vg,hotKeys:bg,maxSuggestions:yg,...r}))}});const wg={};function Pg(){const e=fe(!1);return Do()&&He(()=>{e.value=!0}),e}function Eg(e){return Pg(),N(()=>!!e())}const kg=()=>Eg(()=>typeof window<"u"&&window.navigator&&"userAgent"in window.navigator),Cg=()=>{const e=kg();return N(()=>e.value&&/\b(?:Android|iPhone)/i.test(navigator.userAgent))},jg=e=>{const r=bn();return N(()=>e[r.value])},qg=250,Ig=3e3,Ag={"/en/":{copy:"Copy code",copied:"Copied",hint:"Copied successfully"},"/es/":{copy:"Copiar cdigo",copied:"Copiado",hint:"Copiado con xito"},"/":{copy:"Copy code",copied:"Copied",hint:"Copied successfully"}},xg=!1,Tg=['.theme-default-content div[class*="language-"] pre'],us=!1,Xa=new Map,_g=()=>{const{copy:e}=Mm({legacy:!0}),r=jg(Ag),n=_r(),a=Cg(),o=l=>{if(!l.hasAttribute("copy-code-registered")){const i=document.createElement("button");i.type="button",i.classList.add("copy-code-button"),i.innerHTML='<div class="copy-icon" />',i.setAttribute("aria-label",r.value.copy),i.setAttribute("data-copied",r.value.copied),l.parentElement&&l.parentElement.insertBefore(i,l),l.setAttribute("copy-code-registered","")}},t=()=>Hn().then(()=>new Promise(l=>{setTimeout(()=>{Tg.forEach(i=>{document.querySelectorAll(i).forEach(o)}),l()},qg)})),s=(l,i,c)=>{let{innerText:d=""}=i;/language-(shellscript|shell|bash|sh|zsh)/.test(l.classList.toString())&&(d=d.replace(/^ *(\$|>) /gm,"")),e(d).then(()=>{c.classList.add("copied"),clearTimeout(Xa.get(c));const u=setTimeout(()=>{c.classList.remove("copied"),c.blur(),Xa.delete(c)},Ig);Xa.set(c,u)})};He(()=>{(!a.value||us)&&t(),Pa("click",l=>{const i=l.target;if(i.matches('div[class*="language-"] > button.copy')){const c=i.parentElement,d=i.nextElementSibling;d&&s(c,d,i)}else if(i.matches('div[class*="language-"] div.copy-icon')){const c=i.parentElement,d=c.parentElement,u=c.nextElementSibling;u&&s(d,u,c)}}),er(()=>n.value.path,()=>{(!a.value||us)&&t()})})};var Lg=wr({setup:()=>{_g()}});const sa=[Qu,rm,tm,cm,hm,Gh,Vh,tg,Sg,wg,Lg],Rg=[["v-8daa1a0e","/",{title:""},["/README.md"]],["v-705d1b76","/test_page.html",{title:"PSP"},[":md"]],["v-2d0a870d","/en/",{title:"PSP - Documentation Site"},["/en/README.md"]],["v-2d0a87a8","/es/",{title:"PSP - Pgina  de documentacin"},["/es/README.md"]],["v-5aa74f15","/en/unit1/concurrency.html",{title:"1.2 Concurrency"},[":md"]],["v-b73e5022","/en/unit1/",{title:"1 Introduction"},["/en/unit1/index.md"]],["v-4b0532d0","/en/unit1/operatingsystem.html",{title:"1.3 Processes in the OS"},[":md"]],["v-3f423939","/en/unit1/process.html",{title:"1.1 Processes, programs, threads"},[":md"]],["v-0532b77b","/en/unit2/console_annex.html",{title:"2.4 Annex I - System properties and console programming"},[":md"]],["v-8100edac","/en/unit2/curl_annex.html",{title:"2.5 Annex II - Curl"},[":md"]],["v-b73e4fe4","/en/unit2/",{title:"2 Introduction"},["/en/unit2/index.md"]],["v-74406b7a","/en/unit2/iostreams.html",{title:"2.3 Handling Process Streams"},[":md"]],["v-ecf5776a","/en/unit2/ipc.html",{title:"2.1 Interprocess communication"},[":md"]],["v-348bab3f","/en/unit2/processbuilder.html",{title:"2.2 Process management in Java - ProcessBuilder and Process"},[":md"]],["v-1daecb0f","/en/unit2/runtime.html",{title:"2.1 Running processes in Java with Runtime"},[":md"]],["v-5bb12cb4","/en/unit3/alternatives.html",{title:"3.4 Alternative synchronization techniques"},[":md"]],["v-10f2297a","/en/unit3/arraylist_annex.html",{title:"3.6 Annex II - ArrayList cheat sheet by students"},[":md"]],["v-737de6d4","/en/unit3/debugger_annex.html",{title:"3.5 Annex I - Debugging multithread apps in Netbeans"},[":md"]],["v-3714d943","/en/unit3/hashmap_annex.html",{title:"3.7 Annex III - HashMap cheat sheet by students"},[":md"]],["v-b73e4fa6","/en/unit3/",{title:"3 Introduction"},["/en/unit3/index.md"]],["v-30e3afd6","/en/unit3/producer-consumer.html",{title:"3.3 Producer-Consumer model"},[":md"]],["v-27271e62","/en/unit3/runnable.html",{title:"3.1 Java classes for threads"},[":md"]],["v-1dbfca26","/en/unit3/synchronization.html",{title:"3.2 Threads synchronization and communication"},[":md"]],["v-b73e4f68","/en/unit4/",{title:"4 Introduction"},["/en/unit4/index.md"]],["v-14f705b1","/en/unit4/sockets-tcp.html",{title:"4.2 TCP Sockets"},[":md"]],["v-9c83245e","/en/unit4/sockets-udp.html",{title:"4.3 UDP Sockets"},[":md"]],["v-17f557b3","/en/unit4/stateful-protocols.html",{title:"4.4 Stateful protocols"},[":md"]],["v-de8e734c","/en/unit4/tcp-ip.html",{title:"4.1 TCP IP protocol stack"},[":md"]],["v-1885fe22","/en/unit5/ftp.html",{title:"5.2 FTP Client"},[":md"]],["v-71b551b1","/en/unit5/gmail_annex.html",{title:"5.4 Annex I - GMail configurations"},[":md"]],["v-b73e4f2a","/en/unit5/",{title:"5 Introduction"},["/en/unit5/index.md"]],["v-44aca577","/en/unit5/mail.html",{title:"5.1 Mail"},[":md"]],["v-7768b66a","/en/unit5/urls.html",{title:"5.3 Auxiliary classes for networking"},[":md"]],["v-6e11e1d8","/en/unit6/asymmetric-keys.html",{title:"6.4 Encriptacin asimtrica"},[":md"]],["v-4e4467f3","/en/unit6/hash-functions.html",{title:"6.2 Hash functions"},[":md"]],["v-b73e4eec","/en/unit6/",{title:"6 Introduction"},["/en/unit6/index.md"]],["v-6fa59714","/en/unit6/jsse.html",{title:"6.5 Comunicaciones seguras en Java"},[":md"]],["v-2c8673f4","/en/unit6/log4j_annex.html",{title:"6.6 Anexo I - Logs library Log4Java2"},[":md"]],["v-2e9c294f","/en/unit6/security.html",{title:"6.1 Security"},[":md"]],["v-0b29848c","/en/unit6/symmetric-key.html",{title:"6.3 Encriptacin simtrica"},[":md"]],["v-46af1970","/es/unit1/concurrency.html",{title:"1.2 Concurrencia"},[":md"]],["v-a8728f6c","/es/unit1/",{title:"1 Introduccin"},["/es/unit1/index.md"]],["v-e2dae91a","/es/unit1/operatingsystem.html",{title:"1.3 Procesos en el SO"},[":md"]],["v-75292dd8","/es/unit1/process.html",{title:"1.1 Procesos, programas, hilos"},[":md"]],["v-0e715716","/es/unit2/console_annex.html",{title:"2.4 Anexo I - Propiedades del sistema y programacin en consola"},[":md"]],["v-3277876f","/es/unit2/curl_annex.html",{title:"2.5 Anexo II - Curl"},[":md"]],["v-a8728f2e","/es/unit2/",{title:"2 Introduccin"},["/es/unit2/index.md"]],["v-14dd1095","/es/unit2/iostreams.html",{title:"2.3 Gestin de la E-S de un proceso"},[":md"]],["v-1d42ccb4","/es/unit2/ipc.html",{title:"2.1 Comunicacin entre procesos"},[":md"]],["v-5320ff04","/es/unit2/processbuilder.html",{title:"2.2 Gestin de procesos en Java - ProcessBuilder y Process"},[":md"]],["v-b8500a2c","/es/unit2/runtime.html",{title:"2.1 Creacin de procesos en Java con Runtime"},[":md"]],["v-6718eaab","/es/unit3/alternatives.html",{title:"3.4 Mecanismos alternativos de sincronizacin"},[":md"]],["v-75f16356","/es/unit3/arraylist_annex.html",{title:"3.6 Anexo II - ArrayList hoja de referencia de los alumnos"},[":md"]],["v-36533f4a","/es/unit3/debugger_annex.html",{title:"3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans"},[":md"]],["v-405378de","/es/unit3/hashmap_annex.html",{title:"3.7 Anexo III - HashMap hoja de referencia de los alumnos"},[":md"]],["v-a8728ef0","/es/unit3/",{title:"3 Introduccin"},["/es/unit3/index.md"]],["v-2a24fba0","/es/unit3/producer-consumer.html",{title:"3.3 Modelo productor-consumidor"},[":md"]],["v-2b693c54","/es/unit3/runnable.html",{title:"3.1. Clases Java para la gestin de hilos"},[":md"]],["v-5c5621fe","/es/unit3/synchronization.html",{title:"3.2 Sincronizacin y comunicacin de hilos"},[":md"]],["v-a8728eb2","/es/unit4/",{title:"4 Introduccin"},["/es/unit4/index.md"]],["v-00fed00c","/es/unit4/sockets-tcp.html",{title:"4.2 Sockets TCP"},[":md"]],["v-c4738fa8","/es/unit4/sockets-udp.html",{title:"4.3 Sockets UDP"},[":md"]],["v-fefd7e10","/es/unit4/stateful-protocols.html",{title:"4.4 Protocolos con estado"},[":md"]],["v-d5e6a1c2","/es/unit4/tcp-ip.html",{title:"4.1 Pila de protocolos TCP IP"},[":md"]],["v-ff415906","/es/unit5/ftp.html",{title:"5.2 Cliente FTP"},[":md"]],["v-5dbd1c0c","/es/unit5/gmail_annex.html",{title:"5.4 Anexo I - Configuraciones GMail"},[":md"]],["v-a8728e74","/es/unit5/",{title:"5 Introduccin"},["/es/unit5/index.md"]],["v-50040908","/es/unit5/mail.html",{title:"5.1 Correo"},[":md"]],["v-0aba0c6f","/es/unit5/urls.html",{title:"4.2 Clases auxiliares para direccionamiento"},[":md"]],["v-222706b3","/es/unit6/asymmetric-keys.html",{title:"6.4 Encriptacin asimtrica"},[":md"]],["v-6cd9bbb8","/es/unit6/hash-functions.html",{title:"6.2 Funciones resumen"},[":md"]],["v-a8728e36","/es/unit6/",{title:"6 Introduccin"},["/es/unit6/index.md"]],["v-02f6ed19","/es/unit6/jsse.html",{title:"6.5 Comunicaciones seguras en Java"},[":md"]],["v-188e3e4f","/es/unit6/log4j_annex.html",{title:"6.6 Anexo I - Librera de registro Log4Java2"},[":md"]],["v-6d98f4d4","/es/unit6/security.html",{title:"6.1 Seguridad"},[":md"]],["v-03a9dd55","/es/unit6/symmetric-key.html",{title:"6.3 Encriptacin simtrica"},[":md"]],["v-3706649a","/404.html",{title:""},[]]];var ms=ue({name:"Vuepress",setup(){const e=Nd();return()=>ce(e.value)}}),Dg=()=>Rg.reduce((e,[r,n,a,o])=>(e.push({name:r,path:n,component:ms,meta:a},{path:n.endsWith("/")?n+"index.html":n.substring(0,n.length-5),redirect:n},...o.map(t=>({path:t===":md"?n.substring(0,n.length-5)+".md":t,redirect:n}))),e),[{name:"404",path:"/:catchAll(.*)",component:ms}]),Mg=lu,Og=()=>{const e=Wu({history:Mg(ci("/psp_pages/")),routes:Dg(),scrollBehavior:(r,n,a)=>a||(r.hash?{el:r.hash}:{top:0})});return e.beforeResolve(async(r,n)=>{var a;(r.path!==n.path||n===hr)&&([r.meta._data]=await Promise.all([pr.resolvePageData(r.name),(a=mi[r.name])==null?void 0:a.__asyncLoader()]))}),e},zg=e=>{e.component("ClientOnly",Fo),e.component("Content",Jd)},Ng=(e,r,n)=>{const a=os(()=>r.currentRoute.value.path),o=os(()=>pr.resolveRouteLocale(nn.value.locales,a.value)),t=Pm(a,()=>r.currentRoute.value.meta._data),s=N(()=>pr.resolveLayouts(n)),l=N(()=>pr.resolveSiteLocaleData(nn.value,o.value)),i=N(()=>pr.resolvePageFrontmatter(t.value)),c=N(()=>pr.resolvePageHeadTitle(t.value,l.value)),d=N(()=>pr.resolvePageHead(c.value,i.value,l.value)),u=N(()=>pr.resolvePageLang(t.value,l.value)),m=N(()=>pr.resolvePageLayout(t.value,s.value));return e.provide(Rd,s),e.provide(pi,t),e.provide(hi,i),e.provide(Od,c),e.provide(gi,d),e.provide(fi,u),e.provide(vi,m),e.provide(zo,o),e.provide(yi,l),Object.defineProperties(e.config.globalProperties,{$frontmatter:{get:()=>i.value},$head:{get:()=>d.value},$headTitle:{get:()=>c.value},$lang:{get:()=>u.value},$page:{get:()=>t.value},$routeLocale:{get:()=>o.value},$site:{get:()=>nn.value},$siteLocale:{get:()=>l.value},$withBase:{get:()=>Bo}}),{layouts:s,pageData:t,pageFrontmatter:i,pageHead:d,pageHeadTitle:c,pageLang:u,pageLayout:m,routeLocale:o,siteData:nn,siteLocaleData:l}},Fg=()=>{const e=Md(),r=zd(),n=fe([]),a=()=>{e.value.forEach(t=>{const s=Bg(t);s&&n.value.push(s)})},o=()=>{document.documentElement.lang=r.value,n.value.forEach(t=>{t.parentNode===document.head&&document.head.removeChild(t)}),n.value.splice(0,n.value.length),e.value.forEach(t=>{const s=Ug(t);s!==null&&(document.head.appendChild(s),n.value.push(s))})};Vr(Bd,o),He(()=>{a(),o(),er(()=>e.value,o)})},Bg=([e,r,n=""])=>{const a=Object.entries(r).map(([l,i])=>ve(i)?`[${l}=${JSON.stringify(i)}]`:i===!0?`[${l}]`:"").join(""),o=`head > ${e}${a}`;return Array.from(document.querySelectorAll(o)).find(l=>l.innerText===n)||null},Ug=([e,r,n])=>{if(!ve(e))return null;const a=document.createElement(e);return Oo(r)&&Object.entries(r).forEach(([o,t])=>{ve(t)?a.setAttribute(o,t):t===!0&&a.setAttribute(o,"")}),ve(n)&&a.appendChild(document.createTextNode(n)),a},Hg=jd,Jg=async()=>{var n;const e=Hg({name:"VuepressApp",setup(){var a;Fg();for(const o of sa)(a=o.setup)==null||a.call(o);return()=>[ce(Ti),...sa.flatMap(({rootComponents:o=[]})=>o.map(t=>ce(t)))]}}),r=Og();zg(e),Ng(e,r,sa);for(const a of sa)await((n=a.enhance)==null?void 0:n.call(a,{app:e,router:r,siteData:nn}));return e.use(r),{app:e,router:r}};Jg().then(({app:e,router:r})=>{r.isReady().then(()=>{e.mount("#app")})});export{Ce as _,he as a,Mr as b,ee as c,Jg as createVueApp,ne as d,je as e,Bc as f,U as o,yr as r,_e as t,Me as w};
