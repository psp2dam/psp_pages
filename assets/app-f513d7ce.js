const Vi="modulepreload",Ki=function(e){return"/psp_pages/"+e},et={},y=function(r,n,a){if(!n||n.length===0)return r();const o=document.getElementsByTagName("link");return Promise.all(n.map(t=>{if(t=Ki(t),t in et)return;et[t]=!0;const s=t.endsWith(".css"),l=s?'[rel="stylesheet"]':"";if(!!a)for(let d=o.length-1;d>=0;d--){const u=o[d];if(u.href===t&&(!s||u.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${t}"]${l}`))return;const c=document.createElement("link");if(c.rel=s?"stylesheet":Vi,s||(c.as="script",c.crossOrigin=""),c.href=t,document.head.appendChild(c),s)return new Promise((d,u)=>{c.addEventListener("load",d),c.addEventListener("error",()=>u(new Error(`Unable to preload CSS for ${t}`)))})})).then(()=>r()).catch(t=>{const s=new Event("vite:preloadError",{cancelable:!0});if(s.payload=t,window.dispatchEvent(s),!s.defaultPrevented)throw t})};function go(e,r){const n=Object.create(null),a=e.split(",");for(let o=0;o<a.length;o++)n[a[o]]=!0;return r?o=>!!n[o.toLowerCase()]:o=>!!n[o]}const Ee={},an=[],tr=()=>{},Yi=()=>!1,$i=/^on[^a-z]/,Nn=e=>$i.test(e),fo=e=>e.startsWith("onUpdate:"),xe=Object.assign,vo=(e,r)=>{const n=e.indexOf(r);n>-1&&e.splice(n,1)},Xi=Object.prototype.hasOwnProperty,pe=(e,r)=>Xi.call(e,r),Q=Array.isArray,on=e=>Ea(e)==="[object Map]",hs=e=>Ea(e)==="[object Set]",se=e=>typeof e=="function",ve=e=>typeof e=="string",bo=e=>typeof e=="symbol",ke=e=>e!==null&&typeof e=="object",gs=e=>ke(e)&&se(e.then)&&se(e.catch),fs=Object.prototype.toString,Ea=e=>fs.call(e),Qi=e=>Ea(e).slice(8,-1),vs=e=>Ea(e)==="[object Object]",yo=e=>ve(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,jn=go(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),ka=e=>{const r=Object.create(null);return n=>r[n]||(r[n]=e(n))},Zi=/-(\w)/g,ur=ka(e=>e.replace(Zi,(r,n)=>n?n.toUpperCase():"")),el=/\B([A-Z])/g,Yr=ka(e=>e.replace(el,"-$1").toLowerCase()),Ca=ka(e=>e.charAt(0).toUpperCase()+e.slice(1)),Ma=ka(e=>e?`on${Ca(e)}`:""),_n=(e,r)=>!Object.is(e,r),Oa=(e,r)=>{for(let n=0;n<e.length;n++)e[n](r)},ca=(e,r,n)=>{Object.defineProperty(e,r,{configurable:!0,enumerable:!1,value:n})},rl=e=>{const r=parseFloat(e);return isNaN(r)?e:r},nl=e=>{const r=ve(e)?Number(e):NaN;return isNaN(r)?e:r};let rt;const Qa=()=>rt||(rt=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function Fn(e){if(Q(e)){const r={};for(let n=0;n<e.length;n++){const a=e[n],o=ve(a)?sl(a):Fn(a);if(o)for(const t in o)r[t]=o[t]}return r}else{if(ve(e))return e;if(ke(e))return e}}const al=/;(?![^(]*\))/g,ol=/:([^]+)/,tl=/\/\*[^]*?\*\//g;function sl(e){const r={};return e.replace(tl,"").split(al).forEach(n=>{if(n){const a=n.split(ol);a.length>1&&(r[a[0].trim()]=a[1].trim())}}),r}function Ge(e){let r="";if(ve(e))r=e;else if(Q(e))for(let n=0;n<e.length;n++){const a=Ge(e[n]);a&&(r+=a+" ")}else if(ke(e))for(const n in e)e[n]&&(r+=n+" ");return r.trim()}const il="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",ll=go(il);function bs(e){return!!e||e===""}const _e=e=>ve(e)?e:e==null?"":Q(e)||ke(e)&&(e.toString===fs||!se(e.toString))?JSON.stringify(e,ys,2):String(e),ys=(e,r)=>r&&r.__v_isRef?ys(e,r.value):on(r)?{[`Map(${r.size})`]:[...r.entries()].reduce((n,[a,o])=>(n[`${a} =>`]=o,n),{})}:hs(r)?{[`Set(${r.size})`]:[...r.values()]}:ke(r)&&!Q(r)&&!vs(r)?String(r):r;let Ye;class cl{constructor(r=!1){this.detached=r,this._active=!0,this.effects=[],this.cleanups=[],this.parent=Ye,!r&&Ye&&(this.index=(Ye.scopes||(Ye.scopes=[])).push(this)-1)}get active(){return this._active}run(r){if(this._active){const n=Ye;try{return Ye=this,r()}finally{Ye=n}}}on(){Ye=this}off(){Ye=this.parent}stop(r){if(this._active){let n,a;for(n=0,a=this.effects.length;n<a;n++)this.effects[n].stop();for(n=0,a=this.cleanups.length;n<a;n++)this.cleanups[n]();if(this.scopes)for(n=0,a=this.scopes.length;n<a;n++)this.scopes[n].stop(!0);if(!this.detached&&this.parent&&!r){const o=this.parent.scopes.pop();o&&o!==this&&(this.parent.scopes[this.index]=o,o.index=this.index)}this.parent=void 0,this._active=!1}}}function dl(e,r=Ye){r&&r.active&&r.effects.push(e)}function Ss(){return Ye}function ul(e){Ye&&Ye.cleanups.push(e)}const So=e=>{const r=new Set(e);return r.w=0,r.n=0,r},ws=e=>(e.w&Lr)>0,Ps=e=>(e.n&Lr)>0,ml=({deps:e})=>{if(e.length)for(let r=0;r<e.length;r++)e[r].w|=Lr},pl=e=>{const{deps:r}=e;if(r.length){let n=0;for(let a=0;a<r.length;a++){const o=r[a];ws(o)&&!Ps(o)?o.delete(e):r[n++]=o,o.w&=~Lr,o.n&=~Lr}r.length=n}},da=new WeakMap;let kn=0,Lr=1;const Za=30;let ar;const Gr=Symbol(""),eo=Symbol("");class wo{constructor(r,n=null,a){this.fn=r,this.scheduler=n,this.active=!0,this.deps=[],this.parent=void 0,dl(this,a)}run(){if(!this.active)return this.fn();let r=ar,n=xr;for(;r;){if(r===this)return;r=r.parent}try{return this.parent=ar,ar=this,xr=!0,Lr=1<<++kn,kn<=Za?ml(this):nt(this),this.fn()}finally{kn<=Za&&pl(this),Lr=1<<--kn,ar=this.parent,xr=n,this.parent=void 0,this.deferStop&&this.stop()}}stop(){ar===this?this.deferStop=!0:this.active&&(nt(this),this.onStop&&this.onStop(),this.active=!1)}}function nt(e){const{deps:r}=e;if(r.length){for(let n=0;n<r.length;n++)r[n].delete(e);r.length=0}}let xr=!0;const Es=[];function gn(){Es.push(xr),xr=!1}function fn(){const e=Es.pop();xr=e===void 0?!0:e}function Ve(e,r,n){if(xr&&ar){let a=da.get(e);a||da.set(e,a=new Map);let o=a.get(n);o||a.set(n,o=So()),ks(o)}}function ks(e,r){let n=!1;kn<=Za?Ps(e)||(e.n|=Lr,n=!ws(e)):n=!e.has(ar),n&&(e.add(ar),ar.deps.push(e))}function br(e,r,n,a,o,t){const s=da.get(e);if(!s)return;let l=[];if(r==="clear")l=[...s.values()];else if(n==="length"&&Q(e)){const i=Number(a);s.forEach((c,d)=>{(d==="length"||d>=i)&&l.push(c)})}else switch(n!==void 0&&l.push(s.get(n)),r){case"add":Q(e)?yo(n)&&l.push(s.get("length")):(l.push(s.get(Gr)),on(e)&&l.push(s.get(eo)));break;case"delete":Q(e)||(l.push(s.get(Gr)),on(e)&&l.push(s.get(eo)));break;case"set":on(e)&&l.push(s.get(Gr));break}if(l.length===1)l[0]&&ro(l[0]);else{const i=[];for(const c of l)c&&i.push(...c);ro(So(i))}}function ro(e,r){const n=Q(e)?e:[...e];for(const a of n)a.computed&&at(a);for(const a of n)a.computed||at(a)}function at(e,r){(e!==ar||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}function hl(e,r){var n;return(n=da.get(e))==null?void 0:n.get(r)}const gl=go("__proto__,__v_isRef,__isVue"),Cs=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(bo)),fl=Po(),vl=Po(!1,!0),bl=Po(!0),ot=yl();function yl(){const e={};return["includes","indexOf","lastIndexOf"].forEach(r=>{e[r]=function(...n){const a=ge(this);for(let t=0,s=this.length;t<s;t++)Ve(a,"get",t+"");const o=a[r](...n);return o===-1||o===!1?a[r](...n.map(ge)):o}}),["push","pop","shift","unshift","splice"].forEach(r=>{e[r]=function(...n){gn();const a=ge(this)[r].apply(this,n);return fn(),a}}),e}function Sl(e){const r=ge(this);return Ve(r,"has",e),r.hasOwnProperty(e)}function Po(e=!1,r=!1){return function(a,o,t){if(o==="__v_isReactive")return!e;if(o==="__v_isReadonly")return e;if(o==="__v_isShallow")return r;if(o==="__v_raw"&&t===(e?r?Ml:xs:r?As:Is).get(a))return a;const s=Q(a);if(!e){if(s&&pe(ot,o))return Reflect.get(ot,o,t);if(o==="hasOwnProperty")return Sl}const l=Reflect.get(a,o,t);return(bo(o)?Cs.has(o):gl(o))||(e||Ve(a,"get",o),r)?l:Re(l)?s&&yo(o)?l:l.value:ke(l)?e?vn(l):Bn(l):l}}const wl=js(),Pl=js(!0);function js(e=!1){return function(n,a,o,t){let s=n[a];if(cn(s)&&Re(s)&&!Re(o))return!1;if(!e&&(!ua(o)&&!cn(o)&&(s=ge(s),o=ge(o)),!Q(n)&&Re(s)&&!Re(o)))return s.value=o,!0;const l=Q(n)&&yo(a)?Number(a)<n.length:pe(n,a),i=Reflect.set(n,a,o,t);return n===ge(t)&&(l?_n(o,s)&&br(n,"set",a,o):br(n,"add",a,o)),i}}function El(e,r){const n=pe(e,r);e[r];const a=Reflect.deleteProperty(e,r);return a&&n&&br(e,"delete",r,void 0),a}function kl(e,r){const n=Reflect.has(e,r);return(!bo(r)||!Cs.has(r))&&Ve(e,"has",r),n}function Cl(e){return Ve(e,"iterate",Q(e)?"length":Gr),Reflect.ownKeys(e)}const qs={get:fl,set:wl,deleteProperty:El,has:kl,ownKeys:Cl},jl={get:bl,set(e,r){return!0},deleteProperty(e,r){return!0}},ql=xe({},qs,{get:vl,set:Pl}),Eo=e=>e,ja=e=>Reflect.getPrototypeOf(e);function Kn(e,r,n=!1,a=!1){e=e.__v_raw;const o=ge(e),t=ge(r);n||(r!==t&&Ve(o,"get",r),Ve(o,"get",t));const{has:s}=ja(o),l=a?Eo:n?jo:Ln;if(s.call(o,r))return l(e.get(r));if(s.call(o,t))return l(e.get(t));e!==o&&e.get(r)}function Yn(e,r=!1){const n=this.__v_raw,a=ge(n),o=ge(e);return r||(e!==o&&Ve(a,"has",e),Ve(a,"has",o)),e===o?n.has(e):n.has(e)||n.has(o)}function $n(e,r=!1){return e=e.__v_raw,!r&&Ve(ge(e),"iterate",Gr),Reflect.get(e,"size",e)}function tt(e){e=ge(e);const r=ge(this);return ja(r).has.call(r,e)||(r.add(e),br(r,"add",e,e)),this}function st(e,r){r=ge(r);const n=ge(this),{has:a,get:o}=ja(n);let t=a.call(n,e);t||(e=ge(e),t=a.call(n,e));const s=o.call(n,e);return n.set(e,r),t?_n(r,s)&&br(n,"set",e,r):br(n,"add",e,r),this}function it(e){const r=ge(this),{has:n,get:a}=ja(r);let o=n.call(r,e);o||(e=ge(e),o=n.call(r,e)),a&&a.call(r,e);const t=r.delete(e);return o&&br(r,"delete",e,void 0),t}function lt(){const e=ge(this),r=e.size!==0,n=e.clear();return r&&br(e,"clear",void 0,void 0),n}function Xn(e,r){return function(a,o){const t=this,s=t.__v_raw,l=ge(s),i=r?Eo:e?jo:Ln;return!e&&Ve(l,"iterate",Gr),s.forEach((c,d)=>a.call(o,i(c),i(d),t))}}function Qn(e,r,n){return function(...a){const o=this.__v_raw,t=ge(o),s=on(t),l=e==="entries"||e===Symbol.iterator&&s,i=e==="keys"&&s,c=o[e](...a),d=n?Eo:r?jo:Ln;return!r&&Ve(t,"iterate",i?eo:Gr),{next(){const{value:u,done:m}=c.next();return m?{value:u,done:m}:{value:l?[d(u[0]),d(u[1])]:d(u),done:m}},[Symbol.iterator](){return this}}}}function kr(e){return function(...r){return e==="delete"?!1:this}}function Il(){const e={get(t){return Kn(this,t)},get size(){return $n(this)},has:Yn,add:tt,set:st,delete:it,clear:lt,forEach:Xn(!1,!1)},r={get(t){return Kn(this,t,!1,!0)},get size(){return $n(this)},has:Yn,add:tt,set:st,delete:it,clear:lt,forEach:Xn(!1,!0)},n={get(t){return Kn(this,t,!0)},get size(){return $n(this,!0)},has(t){return Yn.call(this,t,!0)},add:kr("add"),set:kr("set"),delete:kr("delete"),clear:kr("clear"),forEach:Xn(!0,!1)},a={get(t){return Kn(this,t,!0,!0)},get size(){return $n(this,!0)},has(t){return Yn.call(this,t,!0)},add:kr("add"),set:kr("set"),delete:kr("delete"),clear:kr("clear"),forEach:Xn(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(t=>{e[t]=Qn(t,!1,!1),n[t]=Qn(t,!0,!1),r[t]=Qn(t,!1,!0),a[t]=Qn(t,!0,!0)}),[e,n,r,a]}const[Al,xl,Tl,_l]=Il();function ko(e,r){const n=r?e?_l:Tl:e?xl:Al;return(a,o,t)=>o==="__v_isReactive"?!e:o==="__v_isReadonly"?e:o==="__v_raw"?a:Reflect.get(pe(n,o)&&o in a?n:a,o,t)}const Ll={get:ko(!1,!1)},Rl={get:ko(!1,!0)},Dl={get:ko(!0,!1)},Is=new WeakMap,As=new WeakMap,xs=new WeakMap,Ml=new WeakMap;function Ol(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function zl(e){return e.__v_skip||!Object.isExtensible(e)?0:Ol(Qi(e))}function Bn(e){return cn(e)?e:Co(e,!1,qs,Ll,Is)}function Ts(e){return Co(e,!1,ql,Rl,As)}function vn(e){return Co(e,!0,jl,Dl,xs)}function Co(e,r,n,a,o){if(!ke(e)||e.__v_raw&&!(r&&e.__v_isReactive))return e;const t=o.get(e);if(t)return t;const s=zl(e);if(s===0)return e;const l=new Proxy(e,s===2?a:n);return o.set(e,l),l}function tn(e){return cn(e)?tn(e.__v_raw):!!(e&&e.__v_isReactive)}function cn(e){return!!(e&&e.__v_isReadonly)}function ua(e){return!!(e&&e.__v_isShallow)}function _s(e){return tn(e)||cn(e)}function ge(e){const r=e&&e.__v_raw;return r?ge(r):e}function Ls(e){return ca(e,"__v_skip",!0),e}const Ln=e=>ke(e)?Bn(e):e,jo=e=>ke(e)?vn(e):e;function qo(e){xr&&ar&&(e=ge(e),ks(e.dep||(e.dep=So())))}function Io(e,r){e=ge(e);const n=e.dep;n&&ro(n)}function Re(e){return!!(e&&e.__v_isRef===!0)}function fe(e){return Rs(e,!1)}function Ao(e){return Rs(e,!0)}function Rs(e,r){return Re(e)?e:new Nl(e,r)}class Nl{constructor(r,n){this.__v_isShallow=n,this.dep=void 0,this.__v_isRef=!0,this._rawValue=n?r:ge(r),this._value=n?r:Ln(r)}get value(){return qo(this),this._value}set value(r){const n=this.__v_isShallow||ua(r)||cn(r);r=n?r:ge(r),_n(r,this._rawValue)&&(this._rawValue=r,this._value=n?r:Ln(r),Io(this))}}function re(e){return Re(e)?e.value:e}const Fl={get:(e,r,n)=>re(Reflect.get(e,r,n)),set:(e,r,n,a)=>{const o=e[r];return Re(o)&&!Re(n)?(o.value=n,!0):Reflect.set(e,r,n,a)}};function Ds(e){return tn(e)?e:new Proxy(e,Fl)}class Bl{constructor(r){this.dep=void 0,this.__v_isRef=!0;const{get:n,set:a}=r(()=>qo(this),()=>Io(this));this._get=n,this._set=a}get value(){return this._get()}set value(r){this._set(r)}}function Ul(e){return new Bl(e)}function qa(e){const r=Q(e)?new Array(e.length):{};for(const n in e)r[n]=Jl(e,n);return r}class Hl{constructor(r,n,a){this._object=r,this._key=n,this._defaultValue=a,this.__v_isRef=!0}get value(){const r=this._object[this._key];return r===void 0?this._defaultValue:r}set value(r){this._object[this._key]=r}get dep(){return hl(ge(this._object),this._key)}}function Jl(e,r,n){const a=e[r];return Re(a)?a:new Hl(e,r,n)}class Wl{constructor(r,n,a,o){this._setter=n,this.dep=void 0,this.__v_isRef=!0,this.__v_isReadonly=!1,this._dirty=!0,this.effect=new wo(r,()=>{this._dirty||(this._dirty=!0,Io(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!o,this.__v_isReadonly=a}get value(){const r=ge(this);return qo(r),(r._dirty||!r._cacheable)&&(r._dirty=!1,r._value=r.effect.run()),r._value}set value(r){this._setter(r)}}function Gl(e,r,n=!1){let a,o;const t=se(e);return t?(a=e,o=tr):(a=e.get,o=e.set),new Wl(a,o,t||!o,n)}function Tr(e,r,n,a){let o;try{o=a?e(...a):e()}catch(t){Un(t,r,n)}return o}function Ze(e,r,n,a){if(se(e)){const t=Tr(e,r,n,a);return t&&gs(t)&&t.catch(s=>{Un(s,r,n)}),t}const o=[];for(let t=0;t<e.length;t++)o.push(Ze(e[t],r,n,a));return o}function Un(e,r,n,a=!0){const o=r?r.vnode:null;if(r){let t=r.parent;const s=r.proxy,l=n;for(;t;){const c=t.ec;if(c){for(let d=0;d<c.length;d++)if(c[d](e,s,l)===!1)return}t=t.parent}const i=r.appContext.config.errorHandler;if(i){Tr(i,null,10,[e,s,l]);return}}Vl(e,n,o,a)}function Vl(e,r,n,a=!0){console.error(e)}let Rn=!1,no=!1;const Fe=[];let dr=0;const sn=[];let gr=null,Ur=0;const Ms=Promise.resolve();let xo=null;function Hn(e){const r=xo||Ms;return e?r.then(this?e.bind(this):e):r}function Kl(e){let r=dr+1,n=Fe.length;for(;r<n;){const a=r+n>>>1;Dn(Fe[a])<e?r=a+1:n=a}return r}function Ia(e){(!Fe.length||!Fe.includes(e,Rn&&e.allowRecurse?dr+1:dr))&&(e.id==null?Fe.push(e):Fe.splice(Kl(e.id),0,e),Os())}function Os(){!Rn&&!no&&(no=!0,xo=Ms.then(zs))}function Yl(e){const r=Fe.indexOf(e);r>dr&&Fe.splice(r,1)}function $l(e){Q(e)?sn.push(...e):(!gr||!gr.includes(e,e.allowRecurse?Ur+1:Ur))&&sn.push(e),Os()}function ct(e,r=Rn?dr+1:0){for(;r<Fe.length;r++){const n=Fe[r];n&&n.pre&&(Fe.splice(r,1),r--,n())}}function ma(e){if(sn.length){const r=[...new Set(sn)];if(sn.length=0,gr){gr.push(...r);return}for(gr=r,gr.sort((n,a)=>Dn(n)-Dn(a)),Ur=0;Ur<gr.length;Ur++)gr[Ur]();gr=null,Ur=0}}const Dn=e=>e.id==null?1/0:e.id,Xl=(e,r)=>{const n=Dn(e)-Dn(r);if(n===0){if(e.pre&&!r.pre)return-1;if(r.pre&&!e.pre)return 1}return n};function zs(e){no=!1,Rn=!0,Fe.sort(Xl);const r=tr;try{for(dr=0;dr<Fe.length;dr++){const n=Fe[dr];n&&n.active!==!1&&Tr(n,null,14)}}finally{dr=0,Fe.length=0,ma(),Rn=!1,xo=null,(Fe.length||sn.length)&&zs()}}function Ql(e,r,...n){if(e.isUnmounted)return;const a=e.vnode.props||Ee;let o=n;const t=r.startsWith("update:"),s=t&&r.slice(7);if(s&&s in a){const d=`${s==="modelValue"?"model":s}Modifiers`,{number:u,trim:m}=a[d]||Ee;m&&(o=n.map(f=>ve(f)?f.trim():f)),u&&(o=n.map(rl))}let l,i=a[l=Ma(r)]||a[l=Ma(ur(r))];!i&&t&&(i=a[l=Ma(Yr(r))]),i&&Ze(i,e,6,o);const c=a[l+"Once"];if(c){if(!e.emitted)e.emitted={};else if(e.emitted[l])return;e.emitted[l]=!0,Ze(c,e,6,o)}}function Ns(e,r,n=!1){const a=r.emitsCache,o=a.get(e);if(o!==void 0)return o;const t=e.emits;let s={},l=!1;if(!se(e)){const i=c=>{const d=Ns(c,r,!0);d&&(l=!0,xe(s,d))};!n&&r.mixins.length&&r.mixins.forEach(i),e.extends&&i(e.extends),e.mixins&&e.mixins.forEach(i)}return!t&&!l?(ke(e)&&a.set(e,null),null):(Q(t)?t.forEach(i=>s[i]=null):xe(s,t),ke(e)&&a.set(e,s),s)}function Aa(e,r){return!e||!Nn(r)?!1:(r=r.slice(2).replace(/Once$/,""),pe(e,r[0].toLowerCase()+r.slice(1))||pe(e,Yr(r))||pe(e,r))}let Oe=null,Fs=null;function pa(e){const r=Oe;return Oe=e,Fs=e&&e.type.__scopeId||null,r}function Me(e,r=Oe,n){if(!r||e._n)return e;const a=(...o)=>{a._d&&wt(-1);const t=pa(r);let s;try{s=e(...o)}finally{pa(t),a._d&&wt(1)}return s};return a._n=!0,a._c=!0,a._d=!0,a}function za(e){const{type:r,vnode:n,proxy:a,withProxy:o,props:t,propsOptions:[s],slots:l,attrs:i,emit:c,render:d,renderCache:u,data:m,setupState:f,ctx:w,inheritAttrs:P}=e;let k,v;const S=pa(e);try{if(n.shapeFlag&4){const A=o||a;k=nr(d.call(A,A,u,t,f,m,w)),v=i}else{const A=r;k=nr(A.length>1?A(t,{attrs:i,slots:l,emit:c}):A(t,null)),v=r.props?i:Zl(i)}}catch(A){An.length=0,Un(A,e,1),k=ne($e)}let x=k;if(v&&P!==!1){const A=Object.keys(v),{shapeFlag:G}=x;A.length&&G&7&&(s&&A.some(fo)&&(v=ec(v,s)),x=Dr(x,v))}return n.dirs&&(x=Dr(x),x.dirs=x.dirs?x.dirs.concat(n.dirs):n.dirs),n.transition&&(x.transition=n.transition),k=x,pa(S),k}const Zl=e=>{let r;for(const n in e)(n==="class"||n==="style"||Nn(n))&&((r||(r={}))[n]=e[n]);return r},ec=(e,r)=>{const n={};for(const a in e)(!fo(a)||!(a.slice(9)in r))&&(n[a]=e[a]);return n};function rc(e,r,n){const{props:a,children:o,component:t}=e,{props:s,children:l,patchFlag:i}=r,c=t.emitsOptions;if(r.dirs||r.transition)return!0;if(n&&i>=0){if(i&1024)return!0;if(i&16)return a?dt(a,s,c):!!s;if(i&8){const d=r.dynamicProps;for(let u=0;u<d.length;u++){const m=d[u];if(s[m]!==a[m]&&!Aa(c,m))return!0}}}else return(o||l)&&(!l||!l.$stable)?!0:a===s?!1:a?s?dt(a,s,c):!0:!!s;return!1}function dt(e,r,n){const a=Object.keys(r);if(a.length!==Object.keys(e).length)return!0;for(let o=0;o<a.length;o++){const t=a[o];if(r[t]!==e[t]&&!Aa(n,t))return!0}return!1}function nc({vnode:e,parent:r},n){for(;r&&r.subTree===e;)(e=r.vnode).el=n,r=r.parent}const ac=e=>e.__isSuspense;function Bs(e,r){r&&r.pendingBranch?Q(e)?r.effects.push(...e):r.effects.push(e):$l(e)}function Us(e,r){return To(e,null,r)}const Zn={};function er(e,r,n){return To(e,r,n)}function To(e,r,{immediate:n,deep:a,flush:o,onTrack:t,onTrigger:s}=Ee){var l;const i=Ss()===((l=Te)==null?void 0:l.scope)?Te:null;let c,d=!1,u=!1;if(Re(e)?(c=()=>e.value,d=ua(e)):tn(e)?(c=()=>e,a=!0):Q(e)?(u=!0,d=e.some(A=>tn(A)||ua(A)),c=()=>e.map(A=>{if(Re(A))return A.value;if(tn(A))return Wr(A);if(se(A))return Tr(A,i,2)})):se(e)?r?c=()=>Tr(e,i,2):c=()=>{if(!(i&&i.isUnmounted))return m&&m(),Ze(e,i,3,[f])}:c=tr,r&&a){const A=c;c=()=>Wr(A())}let m,f=A=>{m=S.onStop=()=>{Tr(A,i,4)}},w;if(mn)if(f=tr,r?n&&Ze(r,i,3,[c(),u?[]:void 0,f]):c(),o==="sync"){const A=Qc();w=A.__watcherHandles||(A.__watcherHandles=[])}else return tr;let P=u?new Array(e.length).fill(Zn):Zn;const k=()=>{if(S.active)if(r){const A=S.run();(a||d||(u?A.some((G,Z)=>_n(G,P[Z])):_n(A,P)))&&(m&&m(),Ze(r,i,3,[A,P===Zn?void 0:u&&P[0]===Zn?[]:P,f]),P=A)}else S.run()};k.allowRecurse=!!r;let v;o==="sync"?v=k:o==="post"?v=()=>We(k,i&&i.suspense):(k.pre=!0,i&&(k.id=i.uid),v=()=>Ia(k));const S=new wo(c,v);r?n?k():P=S.run():o==="post"?We(S.run.bind(S),i&&i.suspense):S.run();const x=()=>{S.stop(),i&&i.scope&&vo(i.scope.effects,S)};return w&&w.push(x),x}function oc(e,r,n){const a=this.proxy,o=ve(e)?e.includes(".")?Hs(a,e):()=>a[e]:e.bind(a,a);let t;se(r)?t=r:(t=r.handler,n=r);const s=Te;un(this);const l=To(o,t.bind(a),n);return s?un(s):Kr(),l}function Hs(e,r){const n=r.split(".");return()=>{let a=e;for(let o=0;o<n.length&&a;o++)a=a[n[o]];return a}}function Wr(e,r){if(!ke(e)||e.__v_skip||(r=r||new Set,r.has(e)))return e;if(r.add(e),Re(e))Wr(e.value,r);else if(Q(e))for(let n=0;n<e.length;n++)Wr(e[n],r);else if(hs(e)||on(e))e.forEach(n=>{Wr(n,r)});else if(vs(e))for(const n in e)Wr(e[n],r);return e}function ha(e,r){const n=Oe;if(n===null)return e;const a=La(n)||n.proxy,o=e.dirs||(e.dirs=[]);for(let t=0;t<r.length;t++){let[s,l,i,c=Ee]=r[t];s&&(se(s)&&(s={mounted:s,updated:s}),s.deep&&Wr(l),o.push({dir:s,instance:a,value:l,oldValue:void 0,arg:i,modifiers:c}))}return e}function cr(e,r,n,a){const o=e.dirs,t=r&&r.dirs;for(let s=0;s<o.length;s++){const l=o[s];t&&(l.oldValue=t[s].value);let i=l.dir[a];i&&(gn(),Ze(i,n,8,[e.el,l,e,r]),fn())}}function tc(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return He(()=>{e.isMounted=!0}),Wn(()=>{e.isUnmounting=!0}),e}const Xe=[Function,Array],Js={mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Xe,onEnter:Xe,onAfterEnter:Xe,onEnterCancelled:Xe,onBeforeLeave:Xe,onLeave:Xe,onAfterLeave:Xe,onLeaveCancelled:Xe,onBeforeAppear:Xe,onAppear:Xe,onAfterAppear:Xe,onAppearCancelled:Xe},sc={name:"BaseTransition",props:Js,setup(e,{slots:r}){const n=Do(),a=tc();let o;return()=>{const t=r.default&&Gs(r.default(),!0);if(!t||!t.length)return;let s=t[0];if(t.length>1){for(const P of t)if(P.type!==$e){s=P;break}}const l=ge(e),{mode:i}=l;if(a.isLeaving)return Na(s);const c=ut(s);if(!c)return Na(s);const d=ao(c,l,a,n);oo(c,d);const u=n.subTree,m=u&&ut(u);let f=!1;const{getTransitionKey:w}=c.type;if(w){const P=w();o===void 0?o=P:P!==o&&(o=P,f=!0)}if(m&&m.type!==$e&&(!Hr(c,m)||f)){const P=ao(m,l,a,n);if(oo(m,P),i==="out-in")return a.isLeaving=!0,P.afterLeave=()=>{a.isLeaving=!1,n.update.active!==!1&&n.update()},Na(s);i==="in-out"&&c.type!==$e&&(P.delayLeave=(k,v,S)=>{const x=Ws(a,m);x[String(m.key)]=m,k._leaveCb=()=>{v(),k._leaveCb=void 0,delete d.delayedLeave},d.delayedLeave=S})}return s}}},ic=sc;function Ws(e,r){const{leavingVNodes:n}=e;let a=n.get(r.type);return a||(a=Object.create(null),n.set(r.type,a)),a}function ao(e,r,n,a){const{appear:o,mode:t,persisted:s=!1,onBeforeEnter:l,onEnter:i,onAfterEnter:c,onEnterCancelled:d,onBeforeLeave:u,onLeave:m,onAfterLeave:f,onLeaveCancelled:w,onBeforeAppear:P,onAppear:k,onAfterAppear:v,onAppearCancelled:S}=r,x=String(e.key),A=Ws(n,e),G=(g,J)=>{g&&Ze(g,a,9,J)},Z=(g,J)=>{const F=J[1];G(g,J),Q(g)?g.every(Y=>Y.length<=1)&&F():g.length<=1&&F()},M={mode:t,persisted:s,beforeEnter(g){let J=l;if(!n.isMounted)if(o)J=P||l;else return;g._leaveCb&&g._leaveCb(!0);const F=A[x];F&&Hr(e,F)&&F.el._leaveCb&&F.el._leaveCb(),G(J,[g])},enter(g){let J=i,F=c,Y=d;if(!n.isMounted)if(o)J=k||i,F=v||c,Y=S||d;else return;let q=!1;const L=g._enterCb=R=>{q||(q=!0,R?G(Y,[g]):G(F,[g]),M.delayedLeave&&M.delayedLeave(),g._enterCb=void 0)};J?Z(J,[g,L]):L()},leave(g,J){const F=String(e.key);if(g._enterCb&&g._enterCb(!0),n.isUnmounting)return J();G(u,[g]);let Y=!1;const q=g._leaveCb=L=>{Y||(Y=!0,J(),L?G(w,[g]):G(f,[g]),g._leaveCb=void 0,A[F]===e&&delete A[F])};A[F]=e,m?Z(m,[g,q]):q()},clone(g){return ao(g,r,n,a)}};return M}function Na(e){if(Jn(e))return e=Dr(e),e.children=null,e}function ut(e){return Jn(e)?e.children?e.children[0]:void 0:e}function oo(e,r){e.shapeFlag&6&&e.component?oo(e.component.subTree,r):e.shapeFlag&128?(e.ssContent.transition=r.clone(e.ssContent),e.ssFallback.transition=r.clone(e.ssFallback)):e.transition=r}function Gs(e,r=!1,n){let a=[],o=0;for(let t=0;t<e.length;t++){let s=e[t];const l=n==null?s.key:String(n)+String(s.key!=null?s.key:t);s.type===Pe?(s.patchFlag&128&&o++,a=a.concat(Gs(s.children,r,l))):(r||s.type!==$e)&&a.push(l!=null?Dr(s,{key:l}):s)}if(o>1)for(let t=0;t<a.length;t++)a[t].patchFlag=-2;return a}function ue(e,r){return se(e)?(()=>xe({name:e.name},r,{setup:e}))():e}const ln=e=>!!e.type.__asyncLoader;function D(e){se(e)&&(e={loader:e});const{loader:r,loadingComponent:n,errorComponent:a,delay:o=200,timeout:t,suspensible:s=!0,onError:l}=e;let i=null,c,d=0;const u=()=>(d++,i=null,m()),m=()=>{let f;return i||(f=i=r().catch(w=>{if(w=w instanceof Error?w:new Error(String(w)),l)return new Promise((P,k)=>{l(w,()=>P(u()),()=>k(w),d+1)});throw w}).then(w=>f!==i&&i?i:(w&&(w.__esModule||w[Symbol.toStringTag]==="Module")&&(w=w.default),c=w,w)))};return ue({name:"AsyncComponentWrapper",__asyncLoader:m,get __asyncResolved(){return c},setup(){const f=Te;if(c)return()=>Fa(c,f);const w=S=>{i=null,Un(S,f,13,!a)};if(s&&f.suspense||mn)return m().then(S=>()=>Fa(S,f)).catch(S=>(w(S),()=>a?ne(a,{error:S}):null));const P=fe(!1),k=fe(),v=fe(!!o);return o&&setTimeout(()=>{v.value=!1},o),t!=null&&setTimeout(()=>{if(!P.value&&!k.value){const S=new Error(`Async component timed out after ${t}ms.`);w(S),k.value=S}},t),m().then(()=>{P.value=!0,f.parent&&Jn(f.parent.vnode)&&Ia(f.parent.update)}).catch(S=>{w(S),k.value=S}),()=>{if(P.value&&c)return Fa(c,f);if(k.value&&a)return ne(a,{error:k.value});if(n&&!v.value)return ne(n)}}})}function Fa(e,r){const{ref:n,props:a,children:o,ce:t}=r.vnode,s=ne(e,a,o);return s.ref=n,s.ce=t,delete r.vnode.ce,s}const Jn=e=>e.type.__isKeepAlive;function lc(e,r){Vs(e,"a",r)}function cc(e,r){Vs(e,"da",r)}function Vs(e,r,n=Te){const a=e.__wdc||(e.__wdc=()=>{let o=n;for(;o;){if(o.isDeactivated)return;o=o.parent}return e()});if(xa(r,a,n),n){let o=n.parent;for(;o&&o.parent;)Jn(o.parent.vnode)&&dc(a,r,n,o),o=o.parent}}function dc(e,r,n,a){const o=xa(r,e,a,!0);Ta(()=>{vo(a[r],o)},n)}function xa(e,r,n=Te,a=!1){if(n){const o=n[e]||(n[e]=[]),t=r.__weh||(r.__weh=(...s)=>{if(n.isUnmounted)return;gn(),un(n);const l=Ze(r,n,e,s);return Kr(),fn(),l});return a?o.unshift(t):o.push(t),t}}const Sr=e=>(r,n=Te)=>(!mn||e==="sp")&&xa(e,(...a)=>r(...a),n),uc=Sr("bm"),He=Sr("m"),mc=Sr("bu"),pc=Sr("u"),Wn=Sr("bum"),Ta=Sr("um"),hc=Sr("sp"),gc=Sr("rtg"),fc=Sr("rtc");function vc(e,r=Te){xa("ec",e,r)}const Ks="components";function yr(e,r){return yc(Ks,e,!0,r)||e}const bc=Symbol.for("v-ndc");function yc(e,r,n=!0,a=!1){const o=Oe||Te;if(o){const t=o.type;if(e===Ks){const l=Yc(t,!1);if(l&&(l===r||l===ur(r)||l===Ca(ur(r))))return t}const s=mt(o[e]||t[e],r)||mt(o.appContext[e],r);return!s&&a?t:s}}function mt(e,r){return e&&(e[r]||e[ur(r)]||e[Ca(ur(r))])}function Rr(e,r,n,a){let o;const t=n&&n[a];if(Q(e)||ve(e)){o=new Array(e.length);for(let s=0,l=e.length;s<l;s++)o[s]=r(e[s],s,void 0,t&&t[s])}else if(typeof e=="number"){o=new Array(e);for(let s=0;s<e;s++)o[s]=r(s+1,s,void 0,t&&t[s])}else if(ke(e))if(e[Symbol.iterator])o=Array.from(e,(s,l)=>r(s,l,void 0,t&&t[l]));else{const s=Object.keys(e);o=new Array(s.length);for(let l=0,i=s.length;l<i;l++){const c=s[l];o[l]=r(e[c],c,l,t&&t[l])}}else o=[];return n&&(n[a]=o),o}function we(e,r,n={},a,o){if(Oe.isCE||Oe.parent&&ln(Oe.parent)&&Oe.parent.isCE)return r!=="default"&&(n.name=r),ne("slot",n,a&&a());let t=e[r];t&&t._c&&(t._d=!1),U();const s=t&&Ys(t(n)),l=Ae(Pe,{key:n.key||s&&s.key||`_${r}`},s||(a?a():[]),s&&e._===1?64:-2);return!o&&l.scopeId&&(l.slotScopeIds=[l.scopeId+"-s"]),t&&t._c&&(t._d=!0),l}function Ys(e){return e.some(r=>ba(r)?!(r.type===$e||r.type===Pe&&!Ys(r.children)):!0)?e:null}const to=e=>e?si(e)?La(e)||e.proxy:to(e.parent):null,qn=xe(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>to(e.parent),$root:e=>to(e.root),$emit:e=>e.emit,$options:e=>_o(e),$forceUpdate:e=>e.f||(e.f=()=>Ia(e.update)),$nextTick:e=>e.n||(e.n=Hn.bind(e.proxy)),$watch:e=>oc.bind(e)}),Ba=(e,r)=>e!==Ee&&!e.__isScriptSetup&&pe(e,r),Sc={get({_:e},r){const{ctx:n,setupState:a,data:o,props:t,accessCache:s,type:l,appContext:i}=e;let c;if(r[0]!=="$"){const f=s[r];if(f!==void 0)switch(f){case 1:return a[r];case 2:return o[r];case 4:return n[r];case 3:return t[r]}else{if(Ba(a,r))return s[r]=1,a[r];if(o!==Ee&&pe(o,r))return s[r]=2,o[r];if((c=e.propsOptions[0])&&pe(c,r))return s[r]=3,t[r];if(n!==Ee&&pe(n,r))return s[r]=4,n[r];so&&(s[r]=0)}}const d=qn[r];let u,m;if(d)return r==="$attrs"&&Ve(e,"get",r),d(e);if((u=l.__cssModules)&&(u=u[r]))return u;if(n!==Ee&&pe(n,r))return s[r]=4,n[r];if(m=i.config.globalProperties,pe(m,r))return m[r]},set({_:e},r,n){const{data:a,setupState:o,ctx:t}=e;return Ba(o,r)?(o[r]=n,!0):a!==Ee&&pe(a,r)?(a[r]=n,!0):pe(e.props,r)||r[0]==="$"&&r.slice(1)in e?!1:(t[r]=n,!0)},has({_:{data:e,setupState:r,accessCache:n,ctx:a,appContext:o,propsOptions:t}},s){let l;return!!n[s]||e!==Ee&&pe(e,s)||Ba(r,s)||(l=t[0])&&pe(l,s)||pe(a,s)||pe(qn,s)||pe(o.config.globalProperties,s)},defineProperty(e,r,n){return n.get!=null?e._.accessCache[r]=0:pe(n,"value")&&this.set(e,r,n.value,null),Reflect.defineProperty(e,r,n)}};function pt(e){return Q(e)?e.reduce((r,n)=>(r[n]=null,r),{}):e}let so=!0;function wc(e){const r=_o(e),n=e.proxy,a=e.ctx;so=!1,r.beforeCreate&&ht(r.beforeCreate,e,"bc");const{data:o,computed:t,methods:s,watch:l,provide:i,inject:c,created:d,beforeMount:u,mounted:m,beforeUpdate:f,updated:w,activated:P,deactivated:k,beforeDestroy:v,beforeUnmount:S,destroyed:x,unmounted:A,render:G,renderTracked:Z,renderTriggered:M,errorCaptured:g,serverPrefetch:J,expose:F,inheritAttrs:Y,components:q,directives:L,filters:R}=r;if(c&&Pc(c,a,null),s)for(const oe in s){const te=s[oe];se(te)&&(a[oe]=te.bind(n))}if(o){const oe=o.call(n,n);ke(oe)&&(e.data=Bn(oe))}if(so=!0,t)for(const oe in t){const te=t[oe],ze=se(te)?te.bind(n,n):se(te.get)?te.get.bind(n,n):tr,De=!se(te)&&se(te.set)?te.set.bind(n):tr,Je=N({get:ze,set:De});Object.defineProperty(a,oe,{enumerable:!0,configurable:!0,get:()=>Je.value,set:Ne=>Je.value=Ne})}if(l)for(const oe in l)$s(l[oe],a,n,oe);if(i){const oe=se(i)?i.call(n):i;Reflect.ownKeys(oe).forEach(te=>{Vr(te,oe[te])})}d&&ht(d,e,"c");function W(oe,te){Q(te)?te.forEach(ze=>oe(ze.bind(n))):te&&oe(te.bind(n))}if(W(uc,u),W(He,m),W(mc,f),W(pc,w),W(lc,P),W(cc,k),W(vc,g),W(fc,Z),W(gc,M),W(Wn,S),W(Ta,A),W(hc,J),Q(F))if(F.length){const oe=e.exposed||(e.exposed={});F.forEach(te=>{Object.defineProperty(oe,te,{get:()=>n[te],set:ze=>n[te]=ze})})}else e.exposed||(e.exposed={});G&&e.render===tr&&(e.render=G),Y!=null&&(e.inheritAttrs=Y),q&&(e.components=q),L&&(e.directives=L)}function Pc(e,r,n=tr){Q(e)&&(e=io(e));for(const a in e){const o=e[a];let t;ke(o)?"default"in o?t=qe(o.from||a,o.default,!0):t=qe(o.from||a):t=qe(o),Re(t)?Object.defineProperty(r,a,{enumerable:!0,configurable:!0,get:()=>t.value,set:s=>t.value=s}):r[a]=t}}function ht(e,r,n){Ze(Q(e)?e.map(a=>a.bind(r.proxy)):e.bind(r.proxy),r,n)}function $s(e,r,n,a){const o=a.includes(".")?Hs(n,a):()=>n[a];if(ve(e)){const t=r[e];se(t)&&er(o,t)}else if(se(e))er(o,e.bind(n));else if(ke(e))if(Q(e))e.forEach(t=>$s(t,r,n,a));else{const t=se(e.handler)?e.handler.bind(n):r[e.handler];se(t)&&er(o,t,e)}}function _o(e){const r=e.type,{mixins:n,extends:a}=r,{mixins:o,optionsCache:t,config:{optionMergeStrategies:s}}=e.appContext,l=t.get(r);let i;return l?i=l:!o.length&&!n&&!a?i=r:(i={},o.length&&o.forEach(c=>ga(i,c,s,!0)),ga(i,r,s)),ke(r)&&t.set(r,i),i}function ga(e,r,n,a=!1){const{mixins:o,extends:t}=r;t&&ga(e,t,n,!0),o&&o.forEach(s=>ga(e,s,n,!0));for(const s in r)if(!(a&&s==="expose")){const l=Ec[s]||n&&n[s];e[s]=l?l(e[s],r[s]):r[s]}return e}const Ec={data:gt,props:ft,emits:ft,methods:Cn,computed:Cn,beforeCreate:Be,created:Be,beforeMount:Be,mounted:Be,beforeUpdate:Be,updated:Be,beforeDestroy:Be,beforeUnmount:Be,destroyed:Be,unmounted:Be,activated:Be,deactivated:Be,errorCaptured:Be,serverPrefetch:Be,components:Cn,directives:Cn,watch:Cc,provide:gt,inject:kc};function gt(e,r){return r?e?function(){return xe(se(e)?e.call(this,this):e,se(r)?r.call(this,this):r)}:r:e}function kc(e,r){return Cn(io(e),io(r))}function io(e){if(Q(e)){const r={};for(let n=0;n<e.length;n++)r[e[n]]=e[n];return r}return e}function Be(e,r){return e?[...new Set([].concat(e,r))]:r}function Cn(e,r){return e?xe(Object.create(null),e,r):r}function ft(e,r){return e?Q(e)&&Q(r)?[...new Set([...e,...r])]:xe(Object.create(null),pt(e),pt(r??{})):r}function Cc(e,r){if(!e)return r;if(!r)return e;const n=xe(Object.create(null),e);for(const a in r)n[a]=Be(e[a],r[a]);return n}function Xs(){return{app:null,config:{isNativeTag:Yi,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let jc=0;function qc(e,r){return function(a,o=null){se(a)||(a=xe({},a)),o!=null&&!ke(o)&&(o=null);const t=Xs(),s=new Set;let l=!1;const i=t.app={_uid:jc++,_component:a,_props:o,_container:null,_context:t,_instance:null,version:Zc,get config(){return t.config},set config(c){},use(c,...d){return s.has(c)||(c&&se(c.install)?(s.add(c),c.install(i,...d)):se(c)&&(s.add(c),c(i,...d))),i},mixin(c){return t.mixins.includes(c)||t.mixins.push(c),i},component(c,d){return d?(t.components[c]=d,i):t.components[c]},directive(c,d){return d?(t.directives[c]=d,i):t.directives[c]},mount(c,d,u){if(!l){const m=ne(a,o);return m.appContext=t,d&&r?r(m,c):e(m,c,u),l=!0,i._container=c,c.__vue_app__=i,La(m.component)||m.component.proxy}},unmount(){l&&(e(null,i._container),delete i._container.__vue_app__)},provide(c,d){return t.provides[c]=d,i},runWithContext(c){fa=i;try{return c()}finally{fa=null}}};return i}}let fa=null;function Vr(e,r){if(Te){let n=Te.provides;const a=Te.parent&&Te.parent.provides;a===n&&(n=Te.provides=Object.create(a)),n[e]=r}}function qe(e,r,n=!1){const a=Te||Oe;if(a||fa){const o=a?a.parent==null?a.vnode.appContext&&a.vnode.appContext.provides:a.parent.provides:fa._context.provides;if(o&&e in o)return o[e];if(arguments.length>1)return n&&se(r)?r.call(a&&a.proxy):r}}function Ic(e,r,n,a=!1){const o={},t={};ca(t,_a,1),e.propsDefaults=Object.create(null),Qs(e,r,o,t);for(const s in e.propsOptions[0])s in o||(o[s]=void 0);n?e.props=a?o:Ts(o):e.type.props?e.props=o:e.props=t,e.attrs=t}function Ac(e,r,n,a){const{props:o,attrs:t,vnode:{patchFlag:s}}=e,l=ge(o),[i]=e.propsOptions;let c=!1;if((a||s>0)&&!(s&16)){if(s&8){const d=e.vnode.dynamicProps;for(let u=0;u<d.length;u++){let m=d[u];if(Aa(e.emitsOptions,m))continue;const f=r[m];if(i)if(pe(t,m))f!==t[m]&&(t[m]=f,c=!0);else{const w=ur(m);o[w]=lo(i,l,w,f,e,!1)}else f!==t[m]&&(t[m]=f,c=!0)}}}else{Qs(e,r,o,t)&&(c=!0);let d;for(const u in l)(!r||!pe(r,u)&&((d=Yr(u))===u||!pe(r,d)))&&(i?n&&(n[u]!==void 0||n[d]!==void 0)&&(o[u]=lo(i,l,u,void 0,e,!0)):delete o[u]);if(t!==l)for(const u in t)(!r||!pe(r,u))&&(delete t[u],c=!0)}c&&br(e,"set","$attrs")}function Qs(e,r,n,a){const[o,t]=e.propsOptions;let s=!1,l;if(r)for(let i in r){if(jn(i))continue;const c=r[i];let d;o&&pe(o,d=ur(i))?!t||!t.includes(d)?n[d]=c:(l||(l={}))[d]=c:Aa(e.emitsOptions,i)||(!(i in a)||c!==a[i])&&(a[i]=c,s=!0)}if(t){const i=ge(n),c=l||Ee;for(let d=0;d<t.length;d++){const u=t[d];n[u]=lo(o,i,u,c[u],e,!pe(c,u))}}return s}function lo(e,r,n,a,o,t){const s=e[n];if(s!=null){const l=pe(s,"default");if(l&&a===void 0){const i=s.default;if(s.type!==Function&&!s.skipFactory&&se(i)){const{propsDefaults:c}=o;n in c?a=c[n]:(un(o),a=c[n]=i.call(null,r),Kr())}else a=i}s[0]&&(t&&!l?a=!1:s[1]&&(a===""||a===Yr(n))&&(a=!0))}return a}function Zs(e,r,n=!1){const a=r.propsCache,o=a.get(e);if(o)return o;const t=e.props,s={},l=[];let i=!1;if(!se(e)){const d=u=>{i=!0;const[m,f]=Zs(u,r,!0);xe(s,m),f&&l.push(...f)};!n&&r.mixins.length&&r.mixins.forEach(d),e.extends&&d(e.extends),e.mixins&&e.mixins.forEach(d)}if(!t&&!i)return ke(e)&&a.set(e,an),an;if(Q(t))for(let d=0;d<t.length;d++){const u=ur(t[d]);vt(u)&&(s[u]=Ee)}else if(t)for(const d in t){const u=ur(d);if(vt(u)){const m=t[d],f=s[u]=Q(m)||se(m)?{type:m}:xe({},m);if(f){const w=St(Boolean,f.type),P=St(String,f.type);f[0]=w>-1,f[1]=P<0||w<P,(w>-1||pe(f,"default"))&&l.push(u)}}}const c=[s,l];return ke(e)&&a.set(e,c),c}function vt(e){return e[0]!=="$"}function bt(e){const r=e&&e.toString().match(/^\s*(function|class) (\w+)/);return r?r[2]:e===null?"null":""}function yt(e,r){return bt(e)===bt(r)}function St(e,r){return Q(r)?r.findIndex(n=>yt(n,e)):se(r)&&yt(r,e)?0:-1}const ei=e=>e[0]==="_"||e==="$stable",Lo=e=>Q(e)?e.map(nr):[nr(e)],xc=(e,r,n)=>{if(r._n)return r;const a=Me((...o)=>Lo(r(...o)),n);return a._c=!1,a},ri=(e,r,n)=>{const a=e._ctx;for(const o in e){if(ei(o))continue;const t=e[o];if(se(t))r[o]=xc(o,t,a);else if(t!=null){const s=Lo(t);r[o]=()=>s}}},ni=(e,r)=>{const n=Lo(r);e.slots.default=()=>n},Tc=(e,r)=>{if(e.vnode.shapeFlag&32){const n=r._;n?(e.slots=ge(r),ca(r,"_",n)):ri(r,e.slots={})}else e.slots={},r&&ni(e,r);ca(e.slots,_a,1)},_c=(e,r,n)=>{const{vnode:a,slots:o}=e;let t=!0,s=Ee;if(a.shapeFlag&32){const l=r._;l?n&&l===1?t=!1:(xe(o,r),!n&&l===1&&delete o._):(t=!r.$stable,ri(r,o)),s=r}else r&&(ni(e,r),s={default:1});if(t)for(const l in o)!ei(l)&&!(l in s)&&delete o[l]};function va(e,r,n,a,o=!1){if(Q(e)){e.forEach((m,f)=>va(m,r&&(Q(r)?r[f]:r),n,a,o));return}if(ln(a)&&!o)return;const t=a.shapeFlag&4?La(a.component)||a.component.proxy:a.el,s=o?null:t,{i:l,r:i}=e,c=r&&r.r,d=l.refs===Ee?l.refs={}:l.refs,u=l.setupState;if(c!=null&&c!==i&&(ve(c)?(d[c]=null,pe(u,c)&&(u[c]=null)):Re(c)&&(c.value=null)),se(i))Tr(i,l,12,[s,d]);else{const m=ve(i),f=Re(i);if(m||f){const w=()=>{if(e.f){const P=m?pe(u,i)?u[i]:d[i]:i.value;o?Q(P)&&vo(P,t):Q(P)?P.includes(t)||P.push(t):m?(d[i]=[t],pe(u,i)&&(u[i]=d[i])):(i.value=[t],e.k&&(d[e.k]=i.value))}else m?(d[i]=s,pe(u,i)&&(u[i]=s)):f&&(i.value=s,e.k&&(d[e.k]=s))};s?(w.id=-1,We(w,n)):w()}}}let Cr=!1;const ea=e=>/svg/.test(e.namespaceURI)&&e.tagName!=="foreignObject",ra=e=>e.nodeType===8;function Lc(e){const{mt:r,p:n,o:{patchProp:a,createText:o,nextSibling:t,parentNode:s,remove:l,insert:i,createComment:c}}=e,d=(v,S)=>{if(!S.hasChildNodes()){n(null,v,S),ma(),S._vnode=v;return}Cr=!1,u(S.firstChild,v,null,null,null),ma(),S._vnode=v,Cr&&console.error("Hydration completed but contains mismatches.")},u=(v,S,x,A,G,Z=!1)=>{const M=ra(v)&&v.data==="[",g=()=>P(v,S,x,A,G,M),{type:J,ref:F,shapeFlag:Y,patchFlag:q}=S;let L=v.nodeType;S.el=v,q===-2&&(Z=!1,S.dynamicChildren=null);let R=null;switch(J){case dn:L!==3?S.children===""?(i(S.el=o(""),s(v),v),R=v):R=g():(v.data!==S.children&&(Cr=!0,v.data=S.children),R=t(v));break;case $e:L!==8||M?R=g():R=t(v);break;case In:if(M&&(v=t(v),L=v.nodeType),L===1||L===3){R=v;const ie=!S.children.length;for(let W=0;W<S.staticCount;W++)ie&&(S.children+=R.nodeType===1?R.outerHTML:R.data),W===S.staticCount-1&&(S.anchor=R),R=t(R);return M?t(R):R}else g();break;case Pe:M?R=w(v,S,x,A,G,Z):R=g();break;default:if(Y&1)L!==1||S.type.toLowerCase()!==v.tagName.toLowerCase()?R=g():R=m(v,S,x,A,G,Z);else if(Y&6){S.slotScopeIds=G;const ie=s(v);if(r(S,ie,null,x,A,ea(ie),Z),R=M?k(v):t(v),R&&ra(R)&&R.data==="teleport end"&&(R=t(R)),ln(S)){let W;M?(W=ne(Pe),W.anchor=R?R.previousSibling:ie.lastChild):W=v.nodeType===3?Mr(""):ne("div"),W.el=v,S.component.subTree=W}}else Y&64?L!==8?R=g():R=S.type.hydrate(v,S,x,A,G,Z,e,f):Y&128&&(R=S.type.hydrate(v,S,x,A,ea(s(v)),G,Z,e,u))}return F!=null&&va(F,null,A,S),R},m=(v,S,x,A,G,Z)=>{Z=Z||!!S.dynamicChildren;const{type:M,props:g,patchFlag:J,shapeFlag:F,dirs:Y}=S,q=M==="input"&&Y||M==="option";if(q||J!==-1){if(Y&&cr(S,null,x,"created"),g)if(q||!Z||J&48)for(const R in g)(q&&R.endsWith("value")||Nn(R)&&!jn(R))&&a(v,R,null,g[R],!1,void 0,x);else g.onClick&&a(v,"onClick",null,g.onClick,!1,void 0,x);let L;if((L=g&&g.onVnodeBeforeMount)&&Qe(L,x,S),Y&&cr(S,null,x,"beforeMount"),((L=g&&g.onVnodeMounted)||Y)&&Bs(()=>{L&&Qe(L,x,S),Y&&cr(S,null,x,"mounted")},A),F&16&&!(g&&(g.innerHTML||g.textContent))){let R=f(v.firstChild,S,v,x,A,G,Z);for(;R;){Cr=!0;const ie=R;R=R.nextSibling,l(ie)}}else F&8&&v.textContent!==S.children&&(Cr=!0,v.textContent=S.children)}return v.nextSibling},f=(v,S,x,A,G,Z,M)=>{M=M||!!S.dynamicChildren;const g=S.children,J=g.length;for(let F=0;F<J;F++){const Y=M?g[F]:g[F]=nr(g[F]);if(v)v=u(v,Y,A,G,Z,M);else{if(Y.type===dn&&!Y.children)continue;Cr=!0,n(null,Y,x,null,A,G,ea(x),Z)}}return v},w=(v,S,x,A,G,Z)=>{const{slotScopeIds:M}=S;M&&(G=G?G.concat(M):M);const g=s(v),J=f(t(v),S,g,x,A,G,Z);return J&&ra(J)&&J.data==="]"?t(S.anchor=J):(Cr=!0,i(S.anchor=c("]"),g,J),J)},P=(v,S,x,A,G,Z)=>{if(Cr=!0,S.el=null,Z){const J=k(v);for(;;){const F=t(v);if(F&&F!==J)l(F);else break}}const M=t(v),g=s(v);return l(v),n(null,S,g,M,x,A,ea(g),G),M},k=v=>{let S=0;for(;v;)if(v=t(v),v&&ra(v)&&(v.data==="["&&S++,v.data==="]")){if(S===0)return t(v);S--}return v};return[d,u]}const We=Bs;function Rc(e){return Dc(e,Lc)}function Dc(e,r){const n=Qa();n.__VUE__=!0;const{insert:a,remove:o,patchProp:t,createElement:s,createText:l,createComment:i,setText:c,setElementText:d,parentNode:u,nextSibling:m,setScopeId:f=tr,insertStaticContent:w}=e,P=(p,h,b,E=null,j=null,I=null,B=!1,_=null,z=!!h.dynamicChildren)=>{if(p===h)return;p&&!Hr(p,h)&&(E=C(p),Ne(p,j,I,!0),p=null),h.patchFlag===-2&&(z=!1,h.dynamicChildren=null);const{type:T,ref:$,shapeFlag:V}=h;switch(T){case dn:k(p,h,b,E);break;case $e:v(p,h,b,E);break;case In:p==null&&S(h,b,E,B);break;case Pe:q(p,h,b,E,j,I,B,_,z);break;default:V&1?G(p,h,b,E,j,I,B,_,z):V&6?L(p,h,b,E,j,I,B,_,z):(V&64||V&128)&&T.process(p,h,b,E,j,I,B,_,z,O)}$!=null&&j&&va($,p&&p.ref,I,h||p,!h)},k=(p,h,b,E)=>{if(p==null)a(h.el=l(h.children),b,E);else{const j=h.el=p.el;h.children!==p.children&&c(j,h.children)}},v=(p,h,b,E)=>{p==null?a(h.el=i(h.children||""),b,E):h.el=p.el},S=(p,h,b,E)=>{[p.el,p.anchor]=w(p.children,h,b,E,p.el,p.anchor)},x=({el:p,anchor:h},b,E)=>{let j;for(;p&&p!==h;)j=m(p),a(p,b,E),p=j;a(h,b,E)},A=({el:p,anchor:h})=>{let b;for(;p&&p!==h;)b=m(p),o(p),p=b;o(h)},G=(p,h,b,E,j,I,B,_,z)=>{B=B||h.type==="svg",p==null?Z(h,b,E,j,I,B,_,z):J(p,h,j,I,B,_,z)},Z=(p,h,b,E,j,I,B,_)=>{let z,T;const{type:$,props:V,shapeFlag:X,transition:ae,dirs:le}=p;if(z=p.el=s(p.type,I,V&&V.is,V),X&8?d(z,p.children):X&16&&g(p.children,z,null,E,j,I&&$!=="foreignObject",B,_),le&&cr(p,null,E,"created"),M(z,p,p.scopeId,B,E),V){for(const ye in V)ye!=="value"&&!jn(ye)&&t(z,ye,null,V[ye],I,p.children,E,j,Le);"value"in V&&t(z,"value",null,V.value),(T=V.onVnodeBeforeMount)&&Qe(T,E,p)}le&&cr(p,null,E,"beforeMount");const Se=(!j||j&&!j.pendingBranch)&&ae&&!ae.persisted;Se&&ae.beforeEnter(z),a(z,h,b),((T=V&&V.onVnodeMounted)||Se||le)&&We(()=>{T&&Qe(T,E,p),Se&&ae.enter(z),le&&cr(p,null,E,"mounted")},j)},M=(p,h,b,E,j)=>{if(b&&f(p,b),E)for(let I=0;I<E.length;I++)f(p,E[I]);if(j){let I=j.subTree;if(h===I){const B=j.vnode;M(p,B,B.scopeId,B.slotScopeIds,j.parent)}}},g=(p,h,b,E,j,I,B,_,z=0)=>{for(let T=z;T<p.length;T++){const $=p[T]=_?Ir(p[T]):nr(p[T]);P(null,$,h,b,E,j,I,B,_)}},J=(p,h,b,E,j,I,B)=>{const _=h.el=p.el;let{patchFlag:z,dynamicChildren:T,dirs:$}=h;z|=p.patchFlag&16;const V=p.props||Ee,X=h.props||Ee;let ae;b&&zr(b,!1),(ae=X.onVnodeBeforeUpdate)&&Qe(ae,b,h,p),$&&cr(h,p,b,"beforeUpdate"),b&&zr(b,!0);const le=j&&h.type!=="foreignObject";if(T?F(p.dynamicChildren,T,_,b,E,le,I):B||te(p,h,_,null,b,E,le,I,!1),z>0){if(z&16)Y(_,h,V,X,b,E,j);else if(z&2&&V.class!==X.class&&t(_,"class",null,X.class,j),z&4&&t(_,"style",V.style,X.style,j),z&8){const Se=h.dynamicProps;for(let ye=0;ye<Se.length;ye++){const Ie=Se[ye],rr=V[Ie],Qr=X[Ie];(Qr!==rr||Ie==="value")&&t(_,Ie,rr,Qr,j,p.children,b,E,Le)}}z&1&&p.children!==h.children&&d(_,h.children)}else!B&&T==null&&Y(_,h,V,X,b,E,j);((ae=X.onVnodeUpdated)||$)&&We(()=>{ae&&Qe(ae,b,h,p),$&&cr(h,p,b,"updated")},E)},F=(p,h,b,E,j,I,B)=>{for(let _=0;_<h.length;_++){const z=p[_],T=h[_],$=z.el&&(z.type===Pe||!Hr(z,T)||z.shapeFlag&70)?u(z.el):b;P(z,T,$,null,E,j,I,B,!0)}},Y=(p,h,b,E,j,I,B)=>{if(b!==E){if(b!==Ee)for(const _ in b)!jn(_)&&!(_ in E)&&t(p,_,b[_],null,B,h.children,j,I,Le);for(const _ in E){if(jn(_))continue;const z=E[_],T=b[_];z!==T&&_!=="value"&&t(p,_,T,z,B,h.children,j,I,Le)}"value"in E&&t(p,"value",b.value,E.value)}},q=(p,h,b,E,j,I,B,_,z)=>{const T=h.el=p?p.el:l(""),$=h.anchor=p?p.anchor:l("");let{patchFlag:V,dynamicChildren:X,slotScopeIds:ae}=h;ae&&(_=_?_.concat(ae):ae),p==null?(a(T,b,E),a($,b,E),g(h.children,b,$,j,I,B,_,z)):V>0&&V&64&&X&&p.dynamicChildren?(F(p.dynamicChildren,X,b,j,I,B,_),(h.key!=null||j&&h===j.subTree)&&ai(p,h,!0)):te(p,h,b,$,j,I,B,_,z)},L=(p,h,b,E,j,I,B,_,z)=>{h.slotScopeIds=_,p==null?h.shapeFlag&512?j.ctx.activate(h,b,E,B,z):R(h,b,E,j,I,B,z):ie(p,h,z)},R=(p,h,b,E,j,I,B)=>{const _=p.component=Jc(p,E,j);if(Jn(p)&&(_.ctx.renderer=O),Wc(_),_.asyncDep){if(j&&j.registerDep(_,W),!p.el){const z=_.subTree=ne($e);v(null,z,h,b)}return}W(_,p,h,b,j,I,B)},ie=(p,h,b)=>{const E=h.component=p.component;if(rc(p,h,b))if(E.asyncDep&&!E.asyncResolved){oe(E,h,b);return}else E.next=h,Yl(E.update),E.update();else h.el=p.el,E.vnode=h},W=(p,h,b,E,j,I,B)=>{const _=()=>{if(p.isMounted){let{next:$,bu:V,u:X,parent:ae,vnode:le}=p,Se=$,ye;zr(p,!1),$?($.el=le.el,oe(p,$,B)):$=le,V&&Oa(V),(ye=$.props&&$.props.onVnodeBeforeUpdate)&&Qe(ye,ae,$,le),zr(p,!0);const Ie=za(p),rr=p.subTree;p.subTree=Ie,P(rr,Ie,u(rr.el),C(rr),p,j,I),$.el=Ie.el,Se===null&&nc(p,Ie.el),X&&We(X,j),(ye=$.props&&$.props.onVnodeUpdated)&&We(()=>Qe(ye,ae,$,le),j)}else{let $;const{el:V,props:X}=h,{bm:ae,m:le,parent:Se}=p,ye=ln(h);if(zr(p,!1),ae&&Oa(ae),!ye&&($=X&&X.onVnodeBeforeMount)&&Qe($,Se,h),zr(p,!0),V&&de){const Ie=()=>{p.subTree=za(p),de(V,p.subTree,p,j,null)};ye?h.type.__asyncLoader().then(()=>!p.isUnmounted&&Ie()):Ie()}else{const Ie=p.subTree=za(p);P(null,Ie,b,E,p,j,I),h.el=Ie.el}if(le&&We(le,j),!ye&&($=X&&X.onVnodeMounted)){const Ie=h;We(()=>Qe($,Se,Ie),j)}(h.shapeFlag&256||Se&&ln(Se.vnode)&&Se.vnode.shapeFlag&256)&&p.a&&We(p.a,j),p.isMounted=!0,h=b=E=null}},z=p.effect=new wo(_,()=>Ia(T),p.scope),T=p.update=()=>z.run();T.id=p.uid,zr(p,!0),T()},oe=(p,h,b)=>{h.component=p;const E=p.vnode.props;p.vnode=h,p.next=null,Ac(p,h.props,E,b),_c(p,h.children,b),gn(),ct(),fn()},te=(p,h,b,E,j,I,B,_,z=!1)=>{const T=p&&p.children,$=p?p.shapeFlag:0,V=h.children,{patchFlag:X,shapeFlag:ae}=h;if(X>0){if(X&128){De(T,V,b,E,j,I,B,_,z);return}else if(X&256){ze(T,V,b,E,j,I,B,_,z);return}}ae&8?($&16&&Le(T,j,I),V!==T&&d(b,V)):$&16?ae&16?De(T,V,b,E,j,I,B,_,z):Le(T,j,I,!0):($&8&&d(b,""),ae&16&&g(V,b,E,j,I,B,_,z))},ze=(p,h,b,E,j,I,B,_,z)=>{p=p||an,h=h||an;const T=p.length,$=h.length,V=Math.min(T,$);let X;for(X=0;X<V;X++){const ae=h[X]=z?Ir(h[X]):nr(h[X]);P(p[X],ae,b,null,j,I,B,_,z)}T>$?Le(p,j,I,!0,!1,V):g(h,b,E,j,I,B,_,z,V)},De=(p,h,b,E,j,I,B,_,z)=>{let T=0;const $=h.length;let V=p.length-1,X=$-1;for(;T<=V&&T<=X;){const ae=p[T],le=h[T]=z?Ir(h[T]):nr(h[T]);if(Hr(ae,le))P(ae,le,b,null,j,I,B,_,z);else break;T++}for(;T<=V&&T<=X;){const ae=p[V],le=h[X]=z?Ir(h[X]):nr(h[X]);if(Hr(ae,le))P(ae,le,b,null,j,I,B,_,z);else break;V--,X--}if(T>V){if(T<=X){const ae=X+1,le=ae<$?h[ae].el:E;for(;T<=X;)P(null,h[T]=z?Ir(h[T]):nr(h[T]),b,le,j,I,B,_,z),T++}}else if(T>X)for(;T<=V;)Ne(p[T],j,I,!0),T++;else{const ae=T,le=T,Se=new Map;for(T=le;T<=X;T++){const Ke=h[T]=z?Ir(h[T]):nr(h[T]);Ke.key!=null&&Se.set(Ke.key,T)}let ye,Ie=0;const rr=X-le+1;let Qr=!1,Xo=0;const yn=new Array(rr);for(T=0;T<rr;T++)yn[T]=0;for(T=ae;T<=V;T++){const Ke=p[T];if(Ie>=rr){Ne(Ke,j,I,!0);continue}let lr;if(Ke.key!=null)lr=Se.get(Ke.key);else for(ye=le;ye<=X;ye++)if(yn[ye-le]===0&&Hr(Ke,h[ye])){lr=ye;break}lr===void 0?Ne(Ke,j,I,!0):(yn[lr-le]=T+1,lr>=Xo?Xo=lr:Qr=!0,P(Ke,h[lr],b,null,j,I,B,_,z),Ie++)}const Qo=Qr?Mc(yn):an;for(ye=Qo.length-1,T=rr-1;T>=0;T--){const Ke=le+T,lr=h[Ke],Zo=Ke+1<$?h[Ke+1].el:E;yn[T]===0?P(null,lr,b,Zo,j,I,B,_,z):Qr&&(ye<0||T!==Qo[ye]?Je(lr,b,Zo,2):ye--)}}},Je=(p,h,b,E,j=null)=>{const{el:I,type:B,transition:_,children:z,shapeFlag:T}=p;if(T&6){Je(p.component.subTree,h,b,E);return}if(T&128){p.suspense.move(h,b,E);return}if(T&64){B.move(p,h,b,O);return}if(B===Pe){a(I,h,b);for(let V=0;V<z.length;V++)Je(z[V],h,b,E);a(p.anchor,h,b);return}if(B===In){x(p,h,b);return}if(E!==2&&T&1&&_)if(E===0)_.beforeEnter(I),a(I,h,b),We(()=>_.enter(I),j);else{const{leave:V,delayLeave:X,afterLeave:ae}=_,le=()=>a(I,h,b),Se=()=>{V(I,()=>{le(),ae&&ae()})};X?X(I,le,Se):Se()}else a(I,h,b)},Ne=(p,h,b,E=!1,j=!1)=>{const{type:I,props:B,ref:_,children:z,dynamicChildren:T,shapeFlag:$,patchFlag:V,dirs:X}=p;if(_!=null&&va(_,null,b,p,!0),$&256){h.ctx.deactivate(p);return}const ae=$&1&&X,le=!ln(p);let Se;if(le&&(Se=B&&B.onVnodeBeforeUnmount)&&Qe(Se,h,p),$&6)ir(p.component,b,E);else{if($&128){p.suspense.unmount(b,E);return}ae&&cr(p,null,h,"beforeUnmount"),$&64?p.type.remove(p,h,b,j,O,E):T&&(I!==Pe||V>0&&V&64)?Le(T,h,b,!1,!0):(I===Pe&&V&384||!j&&$&16)&&Le(z,h,b),E&&Pr(p)}(le&&(Se=B&&B.onVnodeUnmounted)||ae)&&We(()=>{Se&&Qe(Se,h,p),ae&&cr(p,null,h,"unmounted")},b)},Pr=p=>{const{type:h,el:b,anchor:E,transition:j}=p;if(h===Pe){Er(b,E);return}if(h===In){A(p);return}const I=()=>{o(b),j&&!j.persisted&&j.afterLeave&&j.afterLeave()};if(p.shapeFlag&1&&j&&!j.persisted){const{leave:B,delayLeave:_}=j,z=()=>B(b,I);_?_(p.el,I,z):z()}else I()},Er=(p,h)=>{let b;for(;p!==h;)b=m(p),o(p),p=b;o(h)},ir=(p,h,b)=>{const{bum:E,scope:j,update:I,subTree:B,um:_}=p;E&&Oa(E),j.stop(),I&&(I.active=!1,Ne(B,p,h,b)),_&&We(_,h),We(()=>{p.isUnmounted=!0},h),h&&h.pendingBranch&&!h.isUnmounted&&p.asyncDep&&!p.asyncResolved&&p.suspenseId===h.pendingId&&(h.deps--,h.deps===0&&h.resolve())},Le=(p,h,b,E=!1,j=!1,I=0)=>{for(let B=I;B<p.length;B++)Ne(p[B],h,b,E,j)},C=p=>p.shapeFlag&6?C(p.component.subTree):p.shapeFlag&128?p.suspense.next():m(p.anchor||p.el),H=(p,h,b)=>{p==null?h._vnode&&Ne(h._vnode,null,null,!0):P(h._vnode||null,p,h,null,null,null,b),ct(),ma(),h._vnode=p},O={p:P,um:Ne,m:Je,r:Pr,mt:R,mc:g,pc:te,pbc:F,n:C,o:e};let K,de;return r&&([K,de]=r(O)),{render:H,hydrate:K,createApp:qc(H,K)}}function zr({effect:e,update:r},n){e.allowRecurse=r.allowRecurse=n}function ai(e,r,n=!1){const a=e.children,o=r.children;if(Q(a)&&Q(o))for(let t=0;t<a.length;t++){const s=a[t];let l=o[t];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=o[t]=Ir(o[t]),l.el=s.el),n||ai(s,l)),l.type===dn&&(l.el=s.el)}}function Mc(e){const r=e.slice(),n=[0];let a,o,t,s,l;const i=e.length;for(a=0;a<i;a++){const c=e[a];if(c!==0){if(o=n[n.length-1],e[o]<c){r[a]=o,n.push(a);continue}for(t=0,s=n.length-1;t<s;)l=t+s>>1,e[n[l]]<c?t=l+1:s=l;c<e[n[t]]&&(t>0&&(r[a]=n[t-1]),n[t]=a)}}for(t=n.length,s=n[t-1];t-- >0;)n[t]=s,s=r[s];return n}const Oc=e=>e.__isTeleport,Pe=Symbol.for("v-fgt"),dn=Symbol.for("v-txt"),$e=Symbol.for("v-cmt"),In=Symbol.for("v-stc"),An=[];let or=null;function U(e=!1){An.push(or=e?null:[])}function zc(){An.pop(),or=An[An.length-1]||null}let Mn=1;function wt(e){Mn+=e}function oi(e){return e.dynamicChildren=Mn>0?or||an:null,zc(),Mn>0&&or&&or.push(e),e}function ee(e,r,n,a,o,t){return oi(he(e,r,n,a,o,t,!0))}function Ae(e,r,n,a,o){return oi(ne(e,r,n,a,o,!0))}function ba(e){return e?e.__v_isVNode===!0:!1}function Hr(e,r){return e.type===r.type&&e.key===r.key}const _a="__vInternal",ti=({key:e})=>e??null,ia=({ref:e,ref_key:r,ref_for:n})=>(typeof e=="number"&&(e=""+e),e!=null?ve(e)||Re(e)||se(e)?{i:Oe,r:e,k:r,f:!!n}:e:null);function he(e,r=null,n=null,a=0,o=null,t=e===Pe?0:1,s=!1,l=!1){const i={__v_isVNode:!0,__v_skip:!0,type:e,props:r,key:r&&ti(r),ref:r&&ia(r),scopeId:Fs,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:t,patchFlag:a,dynamicProps:o,dynamicChildren:null,appContext:null,ctx:Oe};return l?(Ro(i,n),t&128&&e.normalize(i)):n&&(i.shapeFlag|=ve(n)?8:16),Mn>0&&!s&&or&&(i.patchFlag>0||t&6)&&i.patchFlag!==32&&or.push(i),i}const ne=Nc;function Nc(e,r=null,n=null,a=0,o=null,t=!1){if((!e||e===bc)&&(e=$e),ba(e)){const l=Dr(e,r,!0);return n&&Ro(l,n),Mn>0&&!t&&or&&(l.shapeFlag&6?or[or.indexOf(e)]=l:or.push(l)),l.patchFlag|=-2,l}if($c(e)&&(e=e.__vccOpts),r){r=Fc(r);let{class:l,style:i}=r;l&&!ve(l)&&(r.class=Ge(l)),ke(i)&&(_s(i)&&!Q(i)&&(i=xe({},i)),r.style=Fn(i))}const s=ve(e)?1:ac(e)?128:Oc(e)?64:ke(e)?4:se(e)?2:0;return he(e,r,n,a,o,s,t,!0)}function Fc(e){return e?_s(e)||_a in e?xe({},e):e:null}function Dr(e,r,n=!1){const{props:a,ref:o,patchFlag:t,children:s}=e,l=r?co(a||{},r):a;return{__v_isVNode:!0,__v_skip:!0,type:e.type,props:l,key:l&&ti(l),ref:r&&r.ref?n&&o?Q(o)?o.concat(ia(r)):[o,ia(r)]:ia(r):o,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:s,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:r&&e.type!==Pe?t===-1?16:t|16:t,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Dr(e.ssContent),ssFallback:e.ssFallback&&Dr(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce}}function Mr(e=" ",r=0){return ne(dn,null,e,r)}function Bc(e,r){const n=ne(In,null,e);return n.staticCount=r,n}function je(e="",r=!1){return r?(U(),Ae($e,null,e)):ne($e,null,e)}function nr(e){return e==null||typeof e=="boolean"?ne($e):Q(e)?ne(Pe,null,e.slice()):typeof e=="object"?Ir(e):ne(dn,null,String(e))}function Ir(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Dr(e)}function Ro(e,r){let n=0;const{shapeFlag:a}=e;if(r==null)r=null;else if(Q(r))n=16;else if(typeof r=="object")if(a&65){const o=r.default;o&&(o._c&&(o._d=!1),Ro(e,o()),o._c&&(o._d=!0));return}else{n=32;const o=r._;!o&&!(_a in r)?r._ctx=Oe:o===3&&Oe&&(Oe.slots._===1?r._=1:(r._=2,e.patchFlag|=1024))}else se(r)?(r={default:r,_ctx:Oe},n=32):(r=String(r),a&64?(n=16,r=[Mr(r)]):n=8);e.children=r,e.shapeFlag|=n}function co(...e){const r={};for(let n=0;n<e.length;n++){const a=e[n];for(const o in a)if(o==="class")r.class!==a.class&&(r.class=Ge([r.class,a.class]));else if(o==="style")r.style=Fn([r.style,a.style]);else if(Nn(o)){const t=r[o],s=a[o];s&&t!==s&&!(Q(t)&&t.includes(s))&&(r[o]=t?[].concat(t,s):s)}else o!==""&&(r[o]=a[o])}return r}function Qe(e,r,n,a=null){Ze(e,r,7,[n,a])}const Uc=Xs();let Hc=0;function Jc(e,r,n){const a=e.type,o=(r?r.appContext:e.appContext)||Uc,t={uid:Hc++,vnode:e,type:a,parent:r,appContext:o,root:null,next:null,subTree:null,effect:null,update:null,scope:new cl(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:r?r.provides:Object.create(o.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Zs(a,o),emitsOptions:Ns(a,o),emit:null,emitted:null,propsDefaults:Ee,inheritAttrs:a.inheritAttrs,ctx:Ee,data:Ee,props:Ee,attrs:Ee,slots:Ee,refs:Ee,setupState:Ee,setupContext:null,attrsProxy:null,slotsProxy:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return t.ctx={_:t},t.root=r?r.root:t,t.emit=Ql.bind(null,t),e.ce&&e.ce(t),t}let Te=null;const Do=()=>Te||Oe;let Mo,Zr,Pt="__VUE_INSTANCE_SETTERS__";(Zr=Qa()[Pt])||(Zr=Qa()[Pt]=[]),Zr.push(e=>Te=e),Mo=e=>{Zr.length>1?Zr.forEach(r=>r(e)):Zr[0](e)};const un=e=>{Mo(e),e.scope.on()},Kr=()=>{Te&&Te.scope.off(),Mo(null)};function si(e){return e.vnode.shapeFlag&4}let mn=!1;function Wc(e,r=!1){mn=r;const{props:n,children:a}=e.vnode,o=si(e);Ic(e,n,o,r),Tc(e,a);const t=o?Gc(e,r):void 0;return mn=!1,t}function Gc(e,r){const n=e.type;e.accessCache=Object.create(null),e.proxy=Ls(new Proxy(e.ctx,Sc));const{setup:a}=n;if(a){const o=e.setupContext=a.length>1?Kc(e):null;un(e),gn();const t=Tr(a,e,0,[e.props,o]);if(fn(),Kr(),gs(t)){if(t.then(Kr,Kr),r)return t.then(s=>{Et(e,s,r)}).catch(s=>{Un(s,e,0)});e.asyncDep=t}else Et(e,t,r)}else ii(e,r)}function Et(e,r,n){se(r)?e.type.__ssrInlineRender?e.ssrRender=r:e.render=r:ke(r)&&(e.setupState=Ds(r)),ii(e,n)}let kt;function ii(e,r,n){const a=e.type;if(!e.render){if(!r&&kt&&!a.render){const o=a.template||_o(e).template;if(o){const{isCustomElement:t,compilerOptions:s}=e.appContext.config,{delimiters:l,compilerOptions:i}=a,c=xe(xe({isCustomElement:t,delimiters:l},s),i);a.render=kt(o,c)}}e.render=a.render||tr}un(e),gn(),wc(e),fn(),Kr()}function Vc(e){return e.attrsProxy||(e.attrsProxy=new Proxy(e.attrs,{get(r,n){return Ve(e,"get","$attrs"),r[n]}}))}function Kc(e){const r=n=>{e.exposed=n||{}};return{get attrs(){return Vc(e)},slots:e.slots,emit:e.emit,expose:r}}function La(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(Ds(Ls(e.exposed)),{get(r,n){if(n in r)return r[n];if(n in qn)return qn[n](e)},has(r,n){return n in r||n in qn}}))}function Yc(e,r=!0){return se(e)?e.displayName||e.name:e.name||r&&e.__name}function $c(e){return se(e)&&"__vccOpts"in e}const N=(e,r)=>Gl(e,r,mn);function ce(e,r,n){const a=arguments.length;return a===2?ke(r)&&!Q(r)?ba(r)?ne(e,null,[r]):ne(e,r):ne(e,null,r):(a>3?n=Array.prototype.slice.call(arguments,2):a===3&&ba(n)&&(n=[n]),ne(e,r,n))}const Xc=Symbol.for("v-scx"),Qc=()=>qe(Xc),Zc="3.3.4",ed="http://www.w3.org/2000/svg",Jr=typeof document<"u"?document:null,Ct=Jr&&Jr.createElement("template"),rd={insert:(e,r,n)=>{r.insertBefore(e,n||null)},remove:e=>{const r=e.parentNode;r&&r.removeChild(e)},createElement:(e,r,n,a)=>{const o=r?Jr.createElementNS(ed,e):Jr.createElement(e,n?{is:n}:void 0);return e==="select"&&a&&a.multiple!=null&&o.setAttribute("multiple",a.multiple),o},createText:e=>Jr.createTextNode(e),createComment:e=>Jr.createComment(e),setText:(e,r)=>{e.nodeValue=r},setElementText:(e,r)=>{e.textContent=r},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Jr.querySelector(e),setScopeId(e,r){e.setAttribute(r,"")},insertStaticContent(e,r,n,a,o,t){const s=n?n.previousSibling:r.lastChild;if(o&&(o===t||o.nextSibling))for(;r.insertBefore(o.cloneNode(!0),n),!(o===t||!(o=o.nextSibling)););else{Ct.innerHTML=a?`<svg>${e}</svg>`:e;const l=Ct.content;if(a){const i=l.firstChild;for(;i.firstChild;)l.appendChild(i.firstChild);l.removeChild(i)}r.insertBefore(l,n)}return[s?s.nextSibling:r.firstChild,n?n.previousSibling:r.lastChild]}};function nd(e,r,n){const a=e._vtc;a&&(r=(r?[r,...a]:[...a]).join(" ")),r==null?e.removeAttribute("class"):n?e.setAttribute("class",r):e.className=r}function ad(e,r,n){const a=e.style,o=ve(n);if(n&&!o){if(r&&!ve(r))for(const t in r)n[t]==null&&uo(a,t,"");for(const t in n)uo(a,t,n[t])}else{const t=a.display;o?r!==n&&(a.cssText=n):r&&e.removeAttribute("style"),"_vod"in e&&(a.display=t)}}const jt=/\s*!important$/;function uo(e,r,n){if(Q(n))n.forEach(a=>uo(e,r,a));else if(n==null&&(n=""),r.startsWith("--"))e.setProperty(r,n);else{const a=od(e,r);jt.test(n)?e.setProperty(Yr(a),n.replace(jt,""),"important"):e[a]=n}}const qt=["Webkit","Moz","ms"],Ua={};function od(e,r){const n=Ua[r];if(n)return n;let a=ur(r);if(a!=="filter"&&a in e)return Ua[r]=a;a=Ca(a);for(let o=0;o<qt.length;o++){const t=qt[o]+a;if(t in e)return Ua[r]=t}return r}const It="http://www.w3.org/1999/xlink";function td(e,r,n,a,o){if(a&&r.startsWith("xlink:"))n==null?e.removeAttributeNS(It,r.slice(6,r.length)):e.setAttributeNS(It,r,n);else{const t=ll(r);n==null||t&&!bs(n)?e.removeAttribute(r):e.setAttribute(r,t?"":n)}}function sd(e,r,n,a,o,t,s){if(r==="innerHTML"||r==="textContent"){a&&s(a,o,t),e[r]=n??"";return}const l=e.tagName;if(r==="value"&&l!=="PROGRESS"&&!l.includes("-")){e._value=n;const c=l==="OPTION"?e.getAttribute("value"):e.value,d=n??"";c!==d&&(e.value=d),n==null&&e.removeAttribute(r);return}let i=!1;if(n===""||n==null){const c=typeof e[r];c==="boolean"?n=bs(n):n==null&&c==="string"?(n="",i=!0):c==="number"&&(n=0,i=!0)}try{e[r]=n}catch{}i&&e.removeAttribute(r)}function id(e,r,n,a){e.addEventListener(r,n,a)}function ld(e,r,n,a){e.removeEventListener(r,n,a)}function cd(e,r,n,a,o=null){const t=e._vei||(e._vei={}),s=t[r];if(a&&s)s.value=a;else{const[l,i]=dd(r);if(a){const c=t[r]=pd(a,o);id(e,l,c,i)}else s&&(ld(e,l,s,i),t[r]=void 0)}}const At=/(?:Once|Passive|Capture)$/;function dd(e){let r;if(At.test(e)){r={};let a;for(;a=e.match(At);)e=e.slice(0,e.length-a[0].length),r[a[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):Yr(e.slice(2)),r]}let Ha=0;const ud=Promise.resolve(),md=()=>Ha||(ud.then(()=>Ha=0),Ha=Date.now());function pd(e,r){const n=a=>{if(!a._vts)a._vts=Date.now();else if(a._vts<=n.attached)return;Ze(hd(a,n.value),r,5,[a])};return n.value=e,n.attached=md(),n}function hd(e,r){if(Q(r)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},r.map(a=>o=>!o._stopped&&a&&a(o))}else return r}const xt=/^on[a-z]/,gd=(e,r,n,a,o=!1,t,s,l,i)=>{r==="class"?nd(e,a,o):r==="style"?ad(e,n,a):Nn(r)?fo(r)||cd(e,r,n,a,s):(r[0]==="."?(r=r.slice(1),!0):r[0]==="^"?(r=r.slice(1),!1):fd(e,r,a,o))?sd(e,r,a,t,s,l,i):(r==="true-value"?e._trueValue=a:r==="false-value"&&(e._falseValue=a),td(e,r,a,o))};function fd(e,r,n,a){return a?!!(r==="innerHTML"||r==="textContent"||r in e&&xt.test(r)&&se(n)):r==="spellcheck"||r==="draggable"||r==="translate"||r==="form"||r==="list"&&e.tagName==="INPUT"||r==="type"&&e.tagName==="TEXTAREA"||xt.test(r)&&ve(n)?!1:r in e}const jr="transition",Sn="animation",Gn=(e,{slots:r})=>ce(ic,vd(e),r);Gn.displayName="Transition";const li={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};Gn.props=xe({},Js,li);const Nr=(e,r=[])=>{Q(e)?e.forEach(n=>n(...r)):e&&e(...r)},Tt=e=>e?Q(e)?e.some(r=>r.length>1):e.length>1:!1;function vd(e){const r={};for(const q in e)q in li||(r[q]=e[q]);if(e.css===!1)return r;const{name:n="v",type:a,duration:o,enterFromClass:t=`${n}-enter-from`,enterActiveClass:s=`${n}-enter-active`,enterToClass:l=`${n}-enter-to`,appearFromClass:i=t,appearActiveClass:c=s,appearToClass:d=l,leaveFromClass:u=`${n}-leave-from`,leaveActiveClass:m=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=e,w=bd(o),P=w&&w[0],k=w&&w[1],{onBeforeEnter:v,onEnter:S,onEnterCancelled:x,onLeave:A,onLeaveCancelled:G,onBeforeAppear:Z=v,onAppear:M=S,onAppearCancelled:g=x}=r,J=(q,L,R)=>{Fr(q,L?d:l),Fr(q,L?c:s),R&&R()},F=(q,L)=>{q._isLeaving=!1,Fr(q,u),Fr(q,f),Fr(q,m),L&&L()},Y=q=>(L,R)=>{const ie=q?M:S,W=()=>J(L,q,R);Nr(ie,[L,W]),_t(()=>{Fr(L,q?i:t),qr(L,q?d:l),Tt(ie)||Lt(L,a,P,W)})};return xe(r,{onBeforeEnter(q){Nr(v,[q]),qr(q,t),qr(q,s)},onBeforeAppear(q){Nr(Z,[q]),qr(q,i),qr(q,c)},onEnter:Y(!1),onAppear:Y(!0),onLeave(q,L){q._isLeaving=!0;const R=()=>F(q,L);qr(q,u),wd(),qr(q,m),_t(()=>{q._isLeaving&&(Fr(q,u),qr(q,f),Tt(A)||Lt(q,a,k,R))}),Nr(A,[q,R])},onEnterCancelled(q){J(q,!1),Nr(x,[q])},onAppearCancelled(q){J(q,!0),Nr(g,[q])},onLeaveCancelled(q){F(q),Nr(G,[q])}})}function bd(e){if(e==null)return null;if(ke(e))return[Ja(e.enter),Ja(e.leave)];{const r=Ja(e);return[r,r]}}function Ja(e){return nl(e)}function qr(e,r){r.split(/\s+/).forEach(n=>n&&e.classList.add(n)),(e._vtc||(e._vtc=new Set)).add(r)}function Fr(e,r){r.split(/\s+/).forEach(a=>a&&e.classList.remove(a));const{_vtc:n}=e;n&&(n.delete(r),n.size||(e._vtc=void 0))}function _t(e){requestAnimationFrame(()=>{requestAnimationFrame(e)})}let yd=0;function Lt(e,r,n,a){const o=e._endId=++yd,t=()=>{o===e._endId&&a()};if(n)return setTimeout(t,n);const{type:s,timeout:l,propCount:i}=Sd(e,r);if(!s)return a();const c=s+"end";let d=0;const u=()=>{e.removeEventListener(c,m),t()},m=f=>{f.target===e&&++d>=i&&u()};setTimeout(()=>{d<i&&u()},l+1),e.addEventListener(c,m)}function Sd(e,r){const n=window.getComputedStyle(e),a=w=>(n[w]||"").split(", "),o=a(`${jr}Delay`),t=a(`${jr}Duration`),s=Rt(o,t),l=a(`${Sn}Delay`),i=a(`${Sn}Duration`),c=Rt(l,i);let d=null,u=0,m=0;r===jr?s>0&&(d=jr,u=s,m=t.length):r===Sn?c>0&&(d=Sn,u=c,m=i.length):(u=Math.max(s,c),d=u>0?s>c?jr:Sn:null,m=d?d===jr?t.length:i.length:0);const f=d===jr&&/\b(transform|all)(,|$)/.test(a(`${jr}Property`).toString());return{type:d,timeout:u,propCount:m,hasTransform:f}}function Rt(e,r){for(;e.length<r.length;)e=e.concat(e);return Math.max(...r.map((n,a)=>Dt(n)+Dt(e[a])))}function Dt(e){return Number(e.slice(0,-1).replace(",","."))*1e3}function wd(){return document.body.offsetHeight}const Pd={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},Ed=(e,r)=>n=>{if(!("key"in n))return;const a=Yr(n.key);if(r.some(o=>o===a||Pd[o]===a))return e(n)},ya={beforeMount(e,{value:r},{transition:n}){e._vod=e.style.display==="none"?"":e.style.display,n&&r?n.beforeEnter(e):wn(e,r)},mounted(e,{value:r},{transition:n}){n&&r&&n.enter(e)},updated(e,{value:r,oldValue:n},{transition:a}){!r!=!n&&(a?r?(a.beforeEnter(e),wn(e,!0),a.enter(e)):a.leave(e,()=>{wn(e,!1)}):wn(e,r))},beforeUnmount(e,{value:r}){wn(e,r)}};function wn(e,r){e.style.display=r?e._vod:"none"}const kd=xe({patchProp:gd},rd);let Wa,Mt=!1;function Cd(){return Wa=Mt?Wa:Rc(kd),Mt=!0,Wa}const jd=(...e)=>{const r=Cd().createApp(...e),{mount:n}=r;return r.mount=a=>{const o=qd(a);if(o)return n(o,!0,o instanceof SVGElement)},r};function qd(e){return ve(e)?document.querySelector(e):e}const Id={"v-8daa1a0e":()=>y(()=>import("./index.html-f133f0c9.js"),[]).then(({data:e})=>e),"v-705d1b76":()=>y(()=>import("./test_page.html-dd9bfa0c.js"),[]).then(({data:e})=>e),"v-2d0a870d":()=>y(()=>import("./index.html-ad205d14.js"),[]).then(({data:e})=>e),"v-2d0a87a8":()=>y(()=>import("./index.html-1ed2bcbc.js"),[]).then(({data:e})=>e),"v-5aa74f15":()=>y(()=>import("./concurrency.html-cea8977e.js"),[]).then(({data:e})=>e),"v-b73e5022":()=>y(()=>import("./index.html-19fea898.js"),[]).then(({data:e})=>e),"v-4b0532d0":()=>y(()=>import("./operatingsystem.html-6c654d81.js"),[]).then(({data:e})=>e),"v-3f423939":()=>y(()=>import("./process.html-68032138.js"),[]).then(({data:e})=>e),"v-0532b77b":()=>y(()=>import("./console_annex.html-f30139a8.js"),[]).then(({data:e})=>e),"v-8100edac":()=>y(()=>import("./curl_annex.html-e84ae368.js"),[]).then(({data:e})=>e),"v-b73e4fe4":()=>y(()=>import("./index.html-5f3d69e7.js"),[]).then(({data:e})=>e),"v-74406b7a":()=>y(()=>import("./iostreams.html-140df912.js"),[]).then(({data:e})=>e),"v-ecf5776a":()=>y(()=>import("./ipc.html-0ef38476.js"),[]).then(({data:e})=>e),"v-348bab3f":()=>y(()=>import("./processbuilder.html-40adaec1.js"),[]).then(({data:e})=>e),"v-1daecb0f":()=>y(()=>import("./runtime.html-2b8c591d.js"),[]).then(({data:e})=>e),"v-5bb12cb4":()=>y(()=>import("./alternatives.html-f009a03f.js"),[]).then(({data:e})=>e),"v-10f2297a":()=>y(()=>import("./arraylist_annex.html-3e0b1784.js"),[]).then(({data:e})=>e),"v-737de6d4":()=>y(()=>import("./debugger_annex.html-018103fd.js"),[]).then(({data:e})=>e),"v-3714d943":()=>y(()=>import("./hashmap_annex.html-53e5f82a.js"),[]).then(({data:e})=>e),"v-b73e4fa6":()=>y(()=>import("./index.html-0431a5b4.js"),[]).then(({data:e})=>e),"v-30e3afd6":()=>y(()=>import("./producer-consumer.html-2a4cbf44.js"),[]).then(({data:e})=>e),"v-27271e62":()=>y(()=>import("./runnable.html-3c85a447.js"),[]).then(({data:e})=>e),"v-1dbfca26":()=>y(()=>import("./synchronization.html-3c3f8e9a.js"),[]).then(({data:e})=>e),"v-b73e4f68":()=>y(()=>import("./index.html-67e08c72.js"),[]).then(({data:e})=>e),"v-14f705b1":()=>y(()=>import("./sockets-tcp.html-5b25a688.js"),[]).then(({data:e})=>e),"v-9c83245e":()=>y(()=>import("./sockets-udp.html-bd9f199f.js"),[]).then(({data:e})=>e),"v-17f557b3":()=>y(()=>import("./stateful-protocols.html-3fd4c7da.js"),[]).then(({data:e})=>e),"v-de8e734c":()=>y(()=>import("./tcp-ip.html-bc436d60.js"),[]).then(({data:e})=>e),"v-1885fe22":()=>y(()=>import("./ftp.html-09d58d22.js"),[]).then(({data:e})=>e),"v-71b551b1":()=>y(()=>import("./gmail_annex.html-26fccf52.js"),[]).then(({data:e})=>e),"v-b73e4f2a":()=>y(()=>import("./index.html-37bf6cea.js"),[]).then(({data:e})=>e),"v-44aca577":()=>y(()=>import("./mail.html-698e276d.js"),[]).then(({data:e})=>e),"v-7768b66a":()=>y(()=>import("./urls.html-3dc9aa78.js"),[]).then(({data:e})=>e),"v-6e11e1d8":()=>y(()=>import("./asymmetric-keys.html-e727e87b.js"),[]).then(({data:e})=>e),"v-4e4467f3":()=>y(()=>import("./hash-functions.html-94dfd17b.js"),[]).then(({data:e})=>e),"v-b73e4eec":()=>y(()=>import("./index.html-57957c4e.js"),[]).then(({data:e})=>e),"v-6fa59714":()=>y(()=>import("./jsse.html-0ed7504b.js"),[]).then(({data:e})=>e),"v-2c8673f4":()=>y(()=>import("./log4j_annex.html-a22ab4e6.js"),[]).then(({data:e})=>e),"v-2e9c294f":()=>y(()=>import("./security.html-ad09f3a7.js"),[]).then(({data:e})=>e),"v-0b29848c":()=>y(()=>import("./symmetric-key.html-b6694a4a.js"),[]).then(({data:e})=>e),"v-46af1970":()=>y(()=>import("./concurrency.html-4ae60790.js"),[]).then(({data:e})=>e),"v-a8728f6c":()=>y(()=>import("./index.html-448dd084.js"),[]).then(({data:e})=>e),"v-e2dae91a":()=>y(()=>import("./operatingsystem.html-a3343488.js"),[]).then(({data:e})=>e),"v-75292dd8":()=>y(()=>import("./process.html-ab2b48f9.js"),[]).then(({data:e})=>e),"v-0e715716":()=>y(()=>import("./console_annex.html-23e5de55.js"),[]).then(({data:e})=>e),"v-3277876f":()=>y(()=>import("./curl_annex.html-c4d00569.js"),[]).then(({data:e})=>e),"v-a8728f2e":()=>y(()=>import("./index.html-eacea1db.js"),[]).then(({data:e})=>e),"v-14dd1095":()=>y(()=>import("./iostreams.html-7a9eae09.js"),[]).then(({data:e})=>e),"v-1d42ccb4":()=>y(()=>import("./ipc.html-356ca3e1.js"),[]).then(({data:e})=>e),"v-5320ff04":()=>y(()=>import("./processbuilder.html-974cf72f.js"),[]).then(({data:e})=>e),"v-b8500a2c":()=>y(()=>import("./runtime.html-b3314bfe.js"),[]).then(({data:e})=>e),"v-6718eaab":()=>y(()=>import("./alternatives.html-eea36f39.js"),[]).then(({data:e})=>e),"v-75f16356":()=>y(()=>import("./arraylist_annex.html-5ecf0008.js"),[]).then(({data:e})=>e),"v-36533f4a":()=>y(()=>import("./debugger_annex.html-adce6756.js"),[]).then(({data:e})=>e),"v-405378de":()=>y(()=>import("./hashmap_annex.html-9f09e7a7.js"),[]).then(({data:e})=>e),"v-a8728ef0":()=>y(()=>import("./index.html-8ed0d755.js"),[]).then(({data:e})=>e),"v-2a24fba0":()=>y(()=>import("./producer-consumer.html-16c718ae.js"),[]).then(({data:e})=>e),"v-2b693c54":()=>y(()=>import("./runnable.html-ad558aac.js"),[]).then(({data:e})=>e),"v-5c5621fe":()=>y(()=>import("./synchronization.html-01f361a1.js"),[]).then(({data:e})=>e),"v-a8728eb2":()=>y(()=>import("./index.html-facd1414.js"),[]).then(({data:e})=>e),"v-00fed00c":()=>y(()=>import("./sockets-tcp.html-09501448.js"),[]).then(({data:e})=>e),"v-c4738fa8":()=>y(()=>import("./sockets-udp.html-b60d9320.js"),[]).then(({data:e})=>e),"v-fefd7e10":()=>y(()=>import("./stateful-protocols.html-4718b1d1.js"),[]).then(({data:e})=>e),"v-d5e6a1c2":()=>y(()=>import("./tcp-ip.html-a6d36f4c.js"),[]).then(({data:e})=>e),"v-ff415906":()=>y(()=>import("./ftp.html-645107b0.js"),[]).then(({data:e})=>e),"v-5dbd1c0c":()=>y(()=>import("./gmail_annex.html-3289abd5.js"),[]).then(({data:e})=>e),"v-a8728e74":()=>y(()=>import("./index.html-439589b4.js"),[]).then(({data:e})=>e),"v-50040908":()=>y(()=>import("./mail.html-b599082c.js"),[]).then(({data:e})=>e),"v-0aba0c6f":()=>y(()=>import("./urls.html-fe972418.js"),[]).then(({data:e})=>e),"v-222706b3":()=>y(()=>import("./asymmetric-keys.html-e4a841cb.js"),[]).then(({data:e})=>e),"v-6cd9bbb8":()=>y(()=>import("./hash-functions.html-73ecb3c4.js"),[]).then(({data:e})=>e),"v-a8728e36":()=>y(()=>import("./index.html-6ccfa24f.js"),[]).then(({data:e})=>e),"v-02f6ed19":()=>y(()=>import("./jsse.html-61571fe3.js"),[]).then(({data:e})=>e),"v-188e3e4f":()=>y(()=>import("./log4j_annex.html-a7339c1a.js"),[]).then(({data:e})=>e),"v-6d98f4d4":()=>y(()=>import("./security.html-bc737f6b.js"),[]).then(({data:e})=>e),"v-03a9dd55":()=>y(()=>import("./symmetric-key.html-96f1b884.js"),[]).then(({data:e})=>e),"v-3706649a":()=>y(()=>import("./404.html-60b35caa.js"),[]).then(({data:e})=>e)},Ad=JSON.parse('{"base":"/psp_pages/","lang":"en-US","title":"PSP","description":"PSP, CFGS DAM, FP, Programacion, Java, IES Doctor Balmis","head":[["meta",{"name":"theme-color","content":"#3eaf7c"}],["meta",{"name":"apple-mobile-web-app-capable","content":"yes"}],["meta",{"name":"apple-mobile-web-app-status-bar-style","content":"black"}],["link",{"rel":"icon","href":"/psp_pages/psp_favicon.png"}]],"locales":{"/en/":{"lang":"en-US","title":"Process and Service Programming","description":"2nd DAM PSP Module"},"/es/":{"lang":"es-ES","title":"Programación de Servicios y Procesos","description":"Módulo PSP de 2º DAM"}}}');var xd=([e,r,n])=>e==="meta"&&r.name?`${e}.${r.name}`:["title","base"].includes(e)?e:e==="template"&&r.id?`${e}.${r.id}`:JSON.stringify([e,r,n]),Td=e=>{const r=new Set,n=[];return e.forEach(a=>{const o=xd(a);r.has(o)||(r.add(o),n.push(a))}),n},Vn=e=>/^(https?:)?\/\//.test(e),_d=e=>/^mailto:/.test(e),Ld=e=>/^tel:/.test(e),Oo=e=>Object.prototype.toString.call(e)==="[object Object]",ci=e=>e[e.length-1]==="/"?e.slice(0,-1):e,di=e=>e[0]==="/"?e.slice(1):e,ui=(e,r)=>{const n=Object.keys(e).sort((a,o)=>{const t=o.split("/").length-a.split("/").length;return t!==0?t:o.length-a.length});for(const a of n)if(r.startsWith(a))return a;return"/"};const mi={"v-8daa1a0e":D(()=>y(()=>import("./index.html-a7f2d0d6.js"),[])),"v-705d1b76":D(()=>y(()=>import("./test_page.html-b5188f9a.js"),[])),"v-2d0a870d":D(()=>y(()=>import("./index.html-57727aac.js"),[])),"v-2d0a87a8":D(()=>y(()=>import("./index.html-681e5872.js"),[])),"v-5aa74f15":D(()=>y(()=>import("./concurrency.html-72f85e43.js"),["assets/concurrency.html-72f85e43.js","assets/gantt_parallel-4671b441.js"])),"v-b73e5022":D(()=>y(()=>import("./index.html-b9d3ba67.js"),[])),"v-4b0532d0":D(()=>y(()=>import("./operatingsystem.html-5996df94.js"),["assets/operatingsystem.html-5996df94.js","assets/roundrobin-3-a33bd40e.js"])),"v-3f423939":D(()=>y(()=>import("./process.html-f6633a9d.js"),["assets/process.html-f6633a9d.js","assets/threads_vs_process-2faff9a6.js"])),"v-0532b77b":D(()=>y(()=>import("./console_annex.html-654c101b.js"),[])),"v-8100edac":D(()=>y(()=>import("./curl_annex.html-0fb8ef48.js"),[])),"v-b73e4fe4":D(()=>y(()=>import("./index.html-0c1b2174.js"),[])),"v-74406b7a":D(()=>y(()=>import("./iostreams.html-40343e1e.js"),["assets/iostreams.html-40343e1e.js","assets/Java_Stream_Readers_BufferedReaders-a3f2ee86.js"])),"v-ecf5776a":D(()=>y(()=>import("./ipc.html-923db1b6.js"),[])),"v-348bab3f":D(()=>y(()=>import("./processbuilder.html-e98762dc.js"),["assets/processbuilder.html-e98762dc.js","assets/comandotree-12a93745.js"])),"v-1daecb0f":D(()=>y(()=>import("./runtime.html-d6c6e1ab.js"),[])),"v-5bb12cb4":D(()=>y(()=>import("./alternatives.html-d3ad2b7b.js"),[])),"v-10f2297a":D(()=>y(()=>import("./arraylist_annex.html-88db9d47.js"),["assets/arraylist_annex.html-88db9d47.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-737de6d4":D(()=>y(()=>import("./debugger_annex.html-8644410a.js"),["assets/debugger_annex.html-8644410a.js","assets/NetbeansDebug5-6a6c582c.js"])),"v-3714d943":D(()=>y(()=>import("./hashmap_annex.html-e2fa31e9.js"),["assets/hashmap_annex.html-e2fa31e9.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-b73e4fa6":D(()=>y(()=>import("./index.html-8c1212d1.js"),[])),"v-30e3afd6":D(()=>y(()=>import("./producer-consumer.html-ae684fa2.js"),["assets/producer-consumer.html-ae684fa2.js","assets/ProducerConsumer-a4b1ac79.js"])),"v-27271e62":D(()=>y(()=>import("./runnable.html-499662b9.js"),[])),"v-1dbfca26":D(()=>y(()=>import("./synchronization.html-6c7e048a.js"),["assets/synchronization.html-6c7e048a.js","assets/Monitor_queues-4b4465b3.js"])),"v-b73e4f68":D(()=>y(()=>import("./index.html-07ee21e9.js"),[])),"v-14f705b1":D(()=>y(()=>import("./sockets-tcp.html-616da690.js"),["assets/sockets-tcp.html-616da690.js","assets/multithread_server_sequence-89666c43.js"])),"v-9c83245e":D(()=>y(()=>import("./sockets-udp.html-125fa1a3.js"),["assets/sockets-udp.html-125fa1a3.js","assets/udp_process-df2d3e58.js"])),"v-17f557b3":D(()=>y(()=>import("./stateful-protocols.html-4dd222bd.js"),["assets/stateful-protocols.html-4dd222bd.js","assets/client_sample_state_protocol-61e731a5.js"])),"v-de8e734c":D(()=>y(()=>import("./tcp-ip.html-c9b9e5dc.js"),["assets/tcp-ip.html-c9b9e5dc.js","assets/5-Graphic-UDP-Vs-TCP-be6b3666.js"])),"v-1885fe22":D(()=>y(()=>import("./ftp.html-867925f6.js"),["assets/ftp.html-867925f6.js","assets/FileZilla-Server-Interface-aa9c48b2.js"])),"v-71b551b1":D(()=>y(()=>import("./gmail_annex.html-0cb88db1.js"),["assets/gmail_annex.html-0cb88db1.js","assets/Google-Settings-2.3-2c14aa8a.js"])),"v-b73e4f2a":D(()=>y(()=>import("./index.html-ac2671b2.js"),[])),"v-44aca577":D(()=>y(()=>import("./mail.html-5da62f21.js"),["assets/mail.html-5da62f21.js","assets/e-mail_multipart_structure-37b2dbb2.js"])),"v-7768b66a":D(()=>y(()=>import("./urls.html-2d67b491.js"),[])),"v-6e11e1d8":D(()=>y(()=>import("./asymmetric-keys.html-a4a3c720.js"),["assets/asymmetric-keys.html-a4a3c720.js","assets/digital-signature-sign-verify-148d6b7b.js"])),"v-4e4467f3":D(()=>y(()=>import("./hash-functions.html-4ea3094e.js"),[])),"v-b73e4eec":D(()=>y(()=>import("./index.html-4448e1b6.js"),[])),"v-6fa59714":D(()=>y(()=>import("./jsse.html-55703244.js"),["assets/jsse.html-55703244.js","assets/VM_Options-afb4ac41.js"])),"v-2c8673f4":D(()=>y(()=>import("./log4j_annex.html-267859f5.js"),[])),"v-2e9c294f":D(()=>y(()=>import("./security.html-cb766253.js"),[])),"v-0b29848c":D(()=>y(()=>import("./symmetric-key.html-e1153fc5.js"),["assets/symmetric-key.html-e1153fc5.js","assets/symmetric-encryption-primitive-db389e98.js"])),"v-46af1970":D(()=>y(()=>import("./concurrency.html-dfcecdda.js"),["assets/concurrency.html-dfcecdda.js","assets/gantt_parallel-4671b441.js"])),"v-a8728f6c":D(()=>y(()=>import("./index.html-0c5ae1bd.js"),[])),"v-e2dae91a":D(()=>y(()=>import("./operatingsystem.html-f7611290.js"),["assets/operatingsystem.html-f7611290.js","assets/roundrobin-3-a33bd40e.js"])),"v-75292dd8":D(()=>y(()=>import("./process.html-77616cf4.js"),["assets/process.html-77616cf4.js","assets/threads_vs_process-2faff9a6.js"])),"v-0e715716":D(()=>y(()=>import("./console_annex.html-ebcb4c10.js"),[])),"v-3277876f":D(()=>y(()=>import("./curl_annex.html-23096a08.js"),[])),"v-a8728f2e":D(()=>y(()=>import("./index.html-7c00552c.js"),[])),"v-14dd1095":D(()=>y(()=>import("./iostreams.html-f6a0241d.js"),["assets/iostreams.html-f6a0241d.js","assets/Java_Stream_Readers_BufferedReaders-a3f2ee86.js"])),"v-1d42ccb4":D(()=>y(()=>import("./ipc.html-ca2c059b.js"),[])),"v-5320ff04":D(()=>y(()=>import("./processbuilder.html-8f459073.js"),["assets/processbuilder.html-8f459073.js","assets/comandotree-12a93745.js"])),"v-b8500a2c":D(()=>y(()=>import("./runtime.html-d39696e5.js"),[])),"v-6718eaab":D(()=>y(()=>import("./alternatives.html-ce700925.js"),[])),"v-75f16356":D(()=>y(()=>import("./arraylist_annex.html-8f8c2b84.js"),["assets/arraylist_annex.html-8f8c2b84.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-36533f4a":D(()=>y(()=>import("./debugger_annex.html-eb645595.js"),["assets/debugger_annex.html-eb645595.js","assets/NetbeansDebug5-6a6c582c.js"])),"v-405378de":D(()=>y(()=>import("./hashmap_annex.html-923a1610.js"),["assets/hashmap_annex.html-923a1610.js","assets/Collections_class_diagram-3137e6d8.js"])),"v-a8728ef0":D(()=>y(()=>import("./index.html-cb0b1dd5.js"),[])),"v-2a24fba0":D(()=>y(()=>import("./producer-consumer.html-7a1fa36b.js"),["assets/producer-consumer.html-7a1fa36b.js","assets/ProducerConsumer-a4b1ac79.js"])),"v-2b693c54":D(()=>y(()=>import("./runnable.html-851465c9.js"),[])),"v-5c5621fe":D(()=>y(()=>import("./synchronization.html-b24e5645.js"),["assets/synchronization.html-b24e5645.js","assets/Monitor_queues-4b4465b3.js"])),"v-a8728eb2":D(()=>y(()=>import("./index.html-8a9c60b7.js"),[])),"v-00fed00c":D(()=>y(()=>import("./sockets-tcp.html-c8dac399.js"),["assets/sockets-tcp.html-c8dac399.js","assets/multithread_server_sequence-89666c43.js"])),"v-c4738fa8":D(()=>y(()=>import("./sockets-udp.html-62f8dc45.js"),["assets/sockets-udp.html-62f8dc45.js","assets/udp_process-df2d3e58.js"])),"v-fefd7e10":D(()=>y(()=>import("./stateful-protocols.html-62e943fd.js"),["assets/stateful-protocols.html-62e943fd.js","assets/client_sample_state_protocol-61e731a5.js"])),"v-d5e6a1c2":D(()=>y(()=>import("./tcp-ip.html-0d9d339b.js"),["assets/tcp-ip.html-0d9d339b.js","assets/5-Graphic-UDP-Vs-TCP-be6b3666.js"])),"v-ff415906":D(()=>y(()=>import("./ftp.html-28f83b18.js"),["assets/ftp.html-28f83b18.js","assets/FileZilla-Server-Interface-aa9c48b2.js"])),"v-5dbd1c0c":D(()=>y(()=>import("./gmail_annex.html-46d7dbc7.js"),["assets/gmail_annex.html-46d7dbc7.js","assets/Google-Settings-2.3-2c14aa8a.js"])),"v-a8728e74":D(()=>y(()=>import("./index.html-9f128b60.js"),[])),"v-50040908":D(()=>y(()=>import("./mail.html-a4a5e753.js"),["assets/mail.html-a4a5e753.js","assets/e-mail_multipart_structure-37b2dbb2.js"])),"v-0aba0c6f":D(()=>y(()=>import("./urls.html-3e351ccb.js"),[])),"v-222706b3":D(()=>y(()=>import("./asymmetric-keys.html-918475a3.js"),["assets/asymmetric-keys.html-918475a3.js","assets/digital-signature-sign-verify-148d6b7b.js"])),"v-6cd9bbb8":D(()=>y(()=>import("./hash-functions.html-1af4117e.js"),[])),"v-a8728e36":D(()=>y(()=>import("./index.html-7bdf5a65.js"),[])),"v-02f6ed19":D(()=>y(()=>import("./jsse.html-10432f89.js"),["assets/jsse.html-10432f89.js","assets/VM_Options-afb4ac41.js"])),"v-188e3e4f":D(()=>y(()=>import("./log4j_annex.html-79b5da0e.js"),[])),"v-6d98f4d4":D(()=>y(()=>import("./security.html-bde759c7.js"),[])),"v-03a9dd55":D(()=>y(()=>import("./symmetric-key.html-853d8bcf.js"),["assets/symmetric-key.html-853d8bcf.js","assets/symmetric-encryption-primitive-db389e98.js"])),"v-3706649a":D(()=>y(()=>import("./404.html-59108678.js"),[]))};var Rd=Symbol(""),pi=Symbol(""),Dd=vn({key:"",path:"",title:"",lang:"",frontmatter:{},headers:[]}),_r=()=>{const e=qe(pi);if(!e)throw new Error("pageData() is called without provider.");return e},hi=Symbol(""),fr=()=>{const e=qe(hi);if(!e)throw new Error("usePageFrontmatter() is called without provider.");return e},gi=Symbol(""),Md=()=>{const e=qe(gi);if(!e)throw new Error("usePageHead() is called without provider.");return e},Od=Symbol(""),fi=Symbol(""),zd=()=>{const e=qe(fi);if(!e)throw new Error("usePageLang() is called without provider.");return e},vi=Symbol(""),Nd=()=>{const e=qe(vi);if(!e)throw new Error("usePageLayout() is called without provider.");return e},Fd=fe(Id),zo=Symbol(""),bn=()=>{const e=qe(zo);if(!e)throw new Error("useRouteLocale() is called without provider.");return e},nn=fe(Ad),bi=()=>nn,yi=Symbol(""),No=()=>{const e=qe(yi);if(!e)throw new Error("useSiteLocaleData() is called without provider.");return e},Bd=Symbol(""),Ud="Layout",Hd="NotFound",pr=Bn({resolveLayouts:e=>e.reduce((r,n)=>({...r,...n.layouts}),{}),resolvePageData:async e=>{const r=Fd.value[e];return await(r==null?void 0:r())??Dd},resolvePageFrontmatter:e=>e.frontmatter,resolvePageHead:(e,r,n)=>{const a=ve(r.description)?r.description:n.description,o=[...Q(r.head)?r.head:[],...n.head,["title",{},e],["meta",{name:"description",content:a}]];return Td(o)},resolvePageHeadTitle:(e,r)=>[e.title,r.title].filter(n=>!!n).join(" | "),resolvePageLang:(e,r)=>e.lang||r.lang||"en-US",resolvePageLayout:(e,r)=>{let n;if(e.path){const a=e.frontmatter.layout;ve(a)?n=a:n=Ud}else n=Hd;return r[n]},resolveRouteLocale:(e,r)=>ui(e,r),resolveSiteLocaleData:(e,r)=>({...e,...e.locales[r]})}),Fo=ue({name:"ClientOnly",setup(e,r){const n=fe(!1);return He(()=>{n.value=!0}),()=>{var a,o;return n.value?(o=(a=r.slots).default)==null?void 0:o.call(a):null}}}),Jd=ue({name:"Content",props:{pageKey:{type:String,required:!1,default:""}},setup(e){const r=_r(),n=N(()=>mi[e.pageKey||r.value.key]);return()=>n.value?ce(n.value):ce("div","404 Not Found")}}),wr=(e={})=>e,Bo=e=>Vn(e)?e:`/psp_pages/${di(e)}`;function Si(e,r,n){var a,o,t;r===void 0&&(r=50),n===void 0&&(n={});var s=(a=n.isImmediate)!=null&&a,l=(o=n.callback)!=null&&o,i=n.maxWait,c=Date.now(),d=[];function u(){if(i!==void 0){var f=Date.now()-c;if(f+r>=i)return i-f}return r}var m=function(){var f=[].slice.call(arguments),w=this;return new Promise(function(P,k){var v=s&&t===void 0;if(t!==void 0&&clearTimeout(t),t=setTimeout(function(){if(t=void 0,c=Date.now(),!s){var x=e.apply(w,f);l&&l(x),d.forEach(function(A){return(0,A.resolve)(x)}),d=[]}},u()),v){var S=e.apply(w,f);return l&&l(S),P(S)}d.push({resolve:P,reject:k})})};return m.cancel=function(f){t!==void 0&&clearTimeout(t),d.forEach(function(w){return(0,w.reject)(f)}),d=[]},m}/*!
  * vue-router v4.2.4
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */const rn=typeof window<"u";function Wd(e){return e.__esModule||e[Symbol.toStringTag]==="Module"}const be=Object.assign;function Ga(e,r){const n={};for(const a in r){const o=r[a];n[a]=sr(o)?o.map(e):e(o)}return n}const xn=()=>{},sr=Array.isArray,Gd=/\/$/,Vd=e=>e.replace(Gd,"");function Va(e,r,n="/"){let a,o={},t="",s="";const l=r.indexOf("#");let i=r.indexOf("?");return l<i&&l>=0&&(i=-1),i>-1&&(a=r.slice(0,i),t=r.slice(i+1,l>-1?l:r.length),o=e(t)),l>-1&&(a=a||r.slice(0,l),s=r.slice(l,r.length)),a=Xd(a??r,n),{fullPath:a+(t&&"?")+t+s,path:a,query:o,hash:s}}function Kd(e,r){const n=r.query?e(r.query):"";return r.path+(n&&"?")+n+(r.hash||"")}function Ot(e,r){return!r||!e.toLowerCase().startsWith(r.toLowerCase())?e:e.slice(r.length)||"/"}function Yd(e,r,n){const a=r.matched.length-1,o=n.matched.length-1;return a>-1&&a===o&&pn(r.matched[a],n.matched[o])&&wi(r.params,n.params)&&e(r.query)===e(n.query)&&r.hash===n.hash}function pn(e,r){return(e.aliasOf||e)===(r.aliasOf||r)}function wi(e,r){if(Object.keys(e).length!==Object.keys(r).length)return!1;for(const n in e)if(!$d(e[n],r[n]))return!1;return!0}function $d(e,r){return sr(e)?zt(e,r):sr(r)?zt(r,e):e===r}function zt(e,r){return sr(r)?e.length===r.length&&e.every((n,a)=>n===r[a]):e.length===1&&e[0]===r}function Xd(e,r){if(e.startsWith("/"))return e;if(!e)return r;const n=r.split("/"),a=e.split("/"),o=a[a.length-1];(o===".."||o===".")&&a.push("");let t=n.length-1,s,l;for(s=0;s<a.length;s++)if(l=a[s],l!==".")if(l==="..")t>1&&t--;else break;return n.slice(0,t).join("/")+"/"+a.slice(s-(s===a.length?1:0)).join("/")}var On;(function(e){e.pop="pop",e.push="push"})(On||(On={}));var Tn;(function(e){e.back="back",e.forward="forward",e.unknown=""})(Tn||(Tn={}));function Qd(e){if(!e)if(rn){const r=document.querySelector("base");e=r&&r.getAttribute("href")||"/",e=e.replace(/^\w+:\/\/[^\/]+/,"")}else e="/";return e[0]!=="/"&&e[0]!=="#"&&(e="/"+e),Vd(e)}const Zd=/^[^#]+#/;function eu(e,r){return e.replace(Zd,"#")+r}function ru(e,r){const n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{behavior:r.behavior,left:a.left-n.left-(r.left||0),top:a.top-n.top-(r.top||0)}}const Ra=()=>({left:window.pageXOffset,top:window.pageYOffset});function nu(e){let r;if("el"in e){const n=e.el,a=typeof n=="string"&&n.startsWith("#"),o=typeof n=="string"?a?document.getElementById(n.slice(1)):document.querySelector(n):n;if(!o)return;r=ru(o,e)}else r=e;"scrollBehavior"in document.documentElement.style?window.scrollTo(r):window.scrollTo(r.left!=null?r.left:window.pageXOffset,r.top!=null?r.top:window.pageYOffset)}function Nt(e,r){return(history.state?history.state.position-r:-1)+e}const mo=new Map;function au(e,r){mo.set(e,r)}function ou(e){const r=mo.get(e);return mo.delete(e),r}let tu=()=>location.protocol+"//"+location.host;function Pi(e,r){const{pathname:n,search:a,hash:o}=r,t=e.indexOf("#");if(t>-1){let l=o.includes(e.slice(t))?e.slice(t).length:1,i=o.slice(l);return i[0]!=="/"&&(i="/"+i),Ot(i,"")}return Ot(n,e)+a+o}function su(e,r,n,a){let o=[],t=[],s=null;const l=({state:m})=>{const f=Pi(e,location),w=n.value,P=r.value;let k=0;if(m){if(n.value=f,r.value=m,s&&s===w){s=null;return}k=P?m.position-P.position:0}else a(f);o.forEach(v=>{v(n.value,w,{delta:k,type:On.pop,direction:k?k>0?Tn.forward:Tn.back:Tn.unknown})})};function i(){s=n.value}function c(m){o.push(m);const f=()=>{const w=o.indexOf(m);w>-1&&o.splice(w,1)};return t.push(f),f}function d(){const{history:m}=window;m.state&&m.replaceState(be({},m.state,{scroll:Ra()}),"")}function u(){for(const m of t)m();t=[],window.removeEventListener("popstate",l),window.removeEventListener("beforeunload",d)}return window.addEventListener("popstate",l),window.addEventListener("beforeunload",d,{passive:!0}),{pauseListeners:i,listen:c,destroy:u}}function Ft(e,r,n,a=!1,o=!1){return{back:e,current:r,forward:n,replaced:a,position:window.history.length,scroll:o?Ra():null}}function iu(e){const{history:r,location:n}=window,a={value:Pi(e,n)},o={value:r.state};o.value||t(a.value,{back:null,current:a.value,forward:null,position:r.length-1,replaced:!0,scroll:null},!0);function t(i,c,d){const u=e.indexOf("#"),m=u>-1?(n.host&&document.querySelector("base")?e:e.slice(u))+i:tu()+e+i;try{r[d?"replaceState":"pushState"](c,"",m),o.value=c}catch(f){console.error(f),n[d?"replace":"assign"](m)}}function s(i,c){const d=be({},r.state,Ft(o.value.back,i,o.value.forward,!0),c,{position:o.value.position});t(i,d,!0),a.value=i}function l(i,c){const d=be({},o.value,r.state,{forward:i,scroll:Ra()});t(d.current,d,!0);const u=be({},Ft(a.value,i,null),{position:d.position+1},c);t(i,u,!1),a.value=i}return{location:a,state:o,push:l,replace:s}}function lu(e){e=Qd(e);const r=iu(e),n=su(e,r.state,r.location,r.replace);function a(t,s=!0){s||n.pauseListeners(),history.go(t)}const o=be({location:"",base:e,go:a,createHref:eu.bind(null,e)},r,n);return Object.defineProperty(o,"location",{enumerable:!0,get:()=>r.location.value}),Object.defineProperty(o,"state",{enumerable:!0,get:()=>r.state.value}),o}function cu(e){return typeof e=="string"||e&&typeof e=="object"}function Ei(e){return typeof e=="string"||typeof e=="symbol"}const hr={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},ki=Symbol("");var Bt;(function(e){e[e.aborted=4]="aborted",e[e.cancelled=8]="cancelled",e[e.duplicated=16]="duplicated"})(Bt||(Bt={}));function hn(e,r){return be(new Error,{type:e,[ki]:!0},r)}function mr(e,r){return e instanceof Error&&ki in e&&(r==null||!!(e.type&r))}const Ut="[^/]+?",du={sensitive:!1,strict:!1,start:!0,end:!0},uu=/[.+*?^${}()[\]/\\]/g;function mu(e,r){const n=be({},du,r),a=[];let o=n.start?"^":"";const t=[];for(const c of e){const d=c.length?[]:[90];n.strict&&!c.length&&(o+="/");for(let u=0;u<c.length;u++){const m=c[u];let f=40+(n.sensitive?.25:0);if(m.type===0)u||(o+="/"),o+=m.value.replace(uu,"\\$&"),f+=40;else if(m.type===1){const{value:w,repeatable:P,optional:k,regexp:v}=m;t.push({name:w,repeatable:P,optional:k});const S=v||Ut;if(S!==Ut){f+=10;try{new RegExp(`(${S})`)}catch(A){throw new Error(`Invalid custom RegExp for param "${w}" (${S}): `+A.message)}}let x=P?`((?:${S})(?:/(?:${S}))*)`:`(${S})`;u||(x=k&&c.length<2?`(?:/${x})`:"/"+x),k&&(x+="?"),o+=x,f+=20,k&&(f+=-8),P&&(f+=-20),S===".*"&&(f+=-50)}d.push(f)}a.push(d)}if(n.strict&&n.end){const c=a.length-1;a[c][a[c].length-1]+=.7000000000000001}n.strict||(o+="/?"),n.end?o+="$":n.strict&&(o+="(?:/|$)");const s=new RegExp(o,n.sensitive?"":"i");function l(c){const d=c.match(s),u={};if(!d)return null;for(let m=1;m<d.length;m++){const f=d[m]||"",w=t[m-1];u[w.name]=f&&w.repeatable?f.split("/"):f}return u}function i(c){let d="",u=!1;for(const m of e){(!u||!d.endsWith("/"))&&(d+="/"),u=!1;for(const f of m)if(f.type===0)d+=f.value;else if(f.type===1){const{value:w,repeatable:P,optional:k}=f,v=w in c?c[w]:"";if(sr(v)&&!P)throw new Error(`Provided param "${w}" is an array but it is not repeatable (* or + modifiers)`);const S=sr(v)?v.join("/"):v;if(!S)if(k)m.length<2&&(d.endsWith("/")?d=d.slice(0,-1):u=!0);else throw new Error(`Missing required param "${w}"`);d+=S}}return d||"/"}return{re:s,score:a,keys:t,parse:l,stringify:i}}function pu(e,r){let n=0;for(;n<e.length&&n<r.length;){const a=r[n]-e[n];if(a)return a;n++}return e.length<r.length?e.length===1&&e[0]===40+40?-1:1:e.length>r.length?r.length===1&&r[0]===40+40?1:-1:0}function hu(e,r){let n=0;const a=e.score,o=r.score;for(;n<a.length&&n<o.length;){const t=pu(a[n],o[n]);if(t)return t;n++}if(Math.abs(o.length-a.length)===1){if(Ht(a))return 1;if(Ht(o))return-1}return o.length-a.length}function Ht(e){const r=e[e.length-1];return e.length>0&&r[r.length-1]<0}const gu={type:0,value:""},fu=/[a-zA-Z0-9_]/;function vu(e){if(!e)return[[]];if(e==="/")return[[gu]];if(!e.startsWith("/"))throw new Error(`Invalid path "${e}"`);function r(f){throw new Error(`ERR (${n})/"${c}": ${f}`)}let n=0,a=n;const o=[];let t;function s(){t&&o.push(t),t=[]}let l=0,i,c="",d="";function u(){c&&(n===0?t.push({type:0,value:c}):n===1||n===2||n===3?(t.length>1&&(i==="*"||i==="+")&&r(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),t.push({type:1,value:c,regexp:d,repeatable:i==="*"||i==="+",optional:i==="*"||i==="?"})):r("Invalid state to consume buffer"),c="")}function m(){c+=i}for(;l<e.length;){if(i=e[l++],i==="\\"&&n!==2){a=n,n=4;continue}switch(n){case 0:i==="/"?(c&&u(),s()):i===":"?(u(),n=1):m();break;case 4:m(),n=a;break;case 1:i==="("?n=2:fu.test(i)?m():(u(),n=0,i!=="*"&&i!=="?"&&i!=="+"&&l--);break;case 2:i===")"?d[d.length-1]=="\\"?d=d.slice(0,-1)+i:n=3:d+=i;break;case 3:u(),n=0,i!=="*"&&i!=="?"&&i!=="+"&&l--,d="";break;default:r("Unknown state");break}}return n===2&&r(`Unfinished custom RegExp for param "${c}"`),u(),s(),o}function bu(e,r,n){const a=mu(vu(e.path),n),o=be(a,{record:e,parent:r,children:[],alias:[]});return r&&!o.record.aliasOf==!r.record.aliasOf&&r.children.push(o),o}function yu(e,r){const n=[],a=new Map;r=Gt({strict:!1,end:!0,sensitive:!1},r);function o(d){return a.get(d)}function t(d,u,m){const f=!m,w=Su(d);w.aliasOf=m&&m.record;const P=Gt(r,d),k=[w];if("alias"in d){const x=typeof d.alias=="string"?[d.alias]:d.alias;for(const A of x)k.push(be({},w,{components:m?m.record.components:w.components,path:A,aliasOf:m?m.record:w}))}let v,S;for(const x of k){const{path:A}=x;if(u&&A[0]!=="/"){const G=u.record.path,Z=G[G.length-1]==="/"?"":"/";x.path=u.record.path+(A&&Z+A)}if(v=bu(x,u,P),m?m.alias.push(v):(S=S||v,S!==v&&S.alias.push(v),f&&d.name&&!Wt(v)&&s(d.name)),w.children){const G=w.children;for(let Z=0;Z<G.length;Z++)t(G[Z],v,m&&m.children[Z])}m=m||v,(v.record.components&&Object.keys(v.record.components).length||v.record.name||v.record.redirect)&&i(v)}return S?()=>{s(S)}:xn}function s(d){if(Ei(d)){const u=a.get(d);u&&(a.delete(d),n.splice(n.indexOf(u),1),u.children.forEach(s),u.alias.forEach(s))}else{const u=n.indexOf(d);u>-1&&(n.splice(u,1),d.record.name&&a.delete(d.record.name),d.children.forEach(s),d.alias.forEach(s))}}function l(){return n}function i(d){let u=0;for(;u<n.length&&hu(d,n[u])>=0&&(d.record.path!==n[u].record.path||!Ci(d,n[u]));)u++;n.splice(u,0,d),d.record.name&&!Wt(d)&&a.set(d.record.name,d)}function c(d,u){let m,f={},w,P;if("name"in d&&d.name){if(m=a.get(d.name),!m)throw hn(1,{location:d});P=m.record.name,f=be(Jt(u.params,m.keys.filter(S=>!S.optional).map(S=>S.name)),d.params&&Jt(d.params,m.keys.map(S=>S.name))),w=m.stringify(f)}else if("path"in d)w=d.path,m=n.find(S=>S.re.test(w)),m&&(f=m.parse(w),P=m.record.name);else{if(m=u.name?a.get(u.name):n.find(S=>S.re.test(u.path)),!m)throw hn(1,{location:d,currentLocation:u});P=m.record.name,f=be({},u.params,d.params),w=m.stringify(f)}const k=[];let v=m;for(;v;)k.unshift(v.record),v=v.parent;return{name:P,path:w,params:f,matched:k,meta:Pu(k)}}return e.forEach(d=>t(d)),{addRoute:t,resolve:c,removeRoute:s,getRoutes:l,getRecordMatcher:o}}function Jt(e,r){const n={};for(const a of r)a in e&&(n[a]=e[a]);return n}function Su(e){return{path:e.path,redirect:e.redirect,name:e.name,meta:e.meta||{},aliasOf:void 0,beforeEnter:e.beforeEnter,props:wu(e),children:e.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in e?e.components||null:e.component&&{default:e.component}}}function wu(e){const r={},n=e.props||!1;if("component"in e)r.default=n;else for(const a in e.components)r[a]=typeof n=="object"?n[a]:n;return r}function Wt(e){for(;e;){if(e.record.aliasOf)return!0;e=e.parent}return!1}function Pu(e){return e.reduce((r,n)=>be(r,n.meta),{})}function Gt(e,r){const n={};for(const a in e)n[a]=a in r?r[a]:e[a];return n}function Ci(e,r){return r.children.some(n=>n===e||Ci(e,n))}const ji=/#/g,Eu=/&/g,ku=/\//g,Cu=/=/g,ju=/\?/g,qi=/\+/g,qu=/%5B/g,Iu=/%5D/g,Ii=/%5E/g,Au=/%60/g,Ai=/%7B/g,xu=/%7C/g,xi=/%7D/g,Tu=/%20/g;function Uo(e){return encodeURI(""+e).replace(xu,"|").replace(qu,"[").replace(Iu,"]")}function _u(e){return Uo(e).replace(Ai,"{").replace(xi,"}").replace(Ii,"^")}function po(e){return Uo(e).replace(qi,"%2B").replace(Tu,"+").replace(ji,"%23").replace(Eu,"%26").replace(Au,"`").replace(Ai,"{").replace(xi,"}").replace(Ii,"^")}function Lu(e){return po(e).replace(Cu,"%3D")}function Ru(e){return Uo(e).replace(ji,"%23").replace(ju,"%3F")}function Du(e){return e==null?"":Ru(e).replace(ku,"%2F")}function Sa(e){try{return decodeURIComponent(""+e)}catch{}return""+e}function Mu(e){const r={};if(e===""||e==="?")return r;const a=(e[0]==="?"?e.slice(1):e).split("&");for(let o=0;o<a.length;++o){const t=a[o].replace(qi," "),s=t.indexOf("="),l=Sa(s<0?t:t.slice(0,s)),i=s<0?null:Sa(t.slice(s+1));if(l in r){let c=r[l];sr(c)||(c=r[l]=[c]),c.push(i)}else r[l]=i}return r}function Vt(e){let r="";for(let n in e){const a=e[n];if(n=Lu(n),a==null){a!==void 0&&(r+=(r.length?"&":"")+n);continue}(sr(a)?a.map(t=>t&&po(t)):[a&&po(a)]).forEach(t=>{t!==void 0&&(r+=(r.length?"&":"")+n,t!=null&&(r+="="+t))})}return r}function Ou(e){const r={};for(const n in e){const a=e[n];a!==void 0&&(r[n]=sr(a)?a.map(o=>o==null?null:""+o):a==null?a:""+a)}return r}const zu=Symbol(""),Kt=Symbol(""),Da=Symbol(""),Ho=Symbol(""),ho=Symbol("");function Pn(){let e=[];function r(a){return e.push(a),()=>{const o=e.indexOf(a);o>-1&&e.splice(o,1)}}function n(){e=[]}return{add:r,list:()=>e.slice(),reset:n}}function Ar(e,r,n,a,o){const t=a&&(a.enterCallbacks[o]=a.enterCallbacks[o]||[]);return()=>new Promise((s,l)=>{const i=u=>{u===!1?l(hn(4,{from:n,to:r})):u instanceof Error?l(u):cu(u)?l(hn(2,{from:r,to:u})):(t&&a.enterCallbacks[o]===t&&typeof u=="function"&&t.push(u),s())},c=e.call(a&&a.instances[o],r,n,i);let d=Promise.resolve(c);e.length<3&&(d=d.then(i)),d.catch(u=>l(u))})}function Ka(e,r,n,a){const o=[];for(const t of e)for(const s in t.components){let l=t.components[s];if(!(r!=="beforeRouteEnter"&&!t.instances[s]))if(Nu(l)){const c=(l.__vccOpts||l)[r];c&&o.push(Ar(c,n,a,t,s))}else{let i=l();o.push(()=>i.then(c=>{if(!c)return Promise.reject(new Error(`Couldn't resolve component "${s}" at "${t.path}"`));const d=Wd(c)?c.default:c;t.components[s]=d;const m=(d.__vccOpts||d)[r];return m&&Ar(m,n,a,t,s)()}))}}return o}function Nu(e){return typeof e=="object"||"displayName"in e||"props"in e||"__vccOpts"in e}function Yt(e){const r=qe(Da),n=qe(Ho),a=N(()=>r.resolve(re(e.to))),o=N(()=>{const{matched:i}=a.value,{length:c}=i,d=i[c-1],u=n.matched;if(!d||!u.length)return-1;const m=u.findIndex(pn.bind(null,d));if(m>-1)return m;const f=$t(i[c-2]);return c>1&&$t(d)===f&&u[u.length-1].path!==f?u.findIndex(pn.bind(null,i[c-2])):m}),t=N(()=>o.value>-1&&Hu(n.params,a.value.params)),s=N(()=>o.value>-1&&o.value===n.matched.length-1&&wi(n.params,a.value.params));function l(i={}){return Uu(i)?r[re(e.replace)?"replace":"push"](re(e.to)).catch(xn):Promise.resolve()}return{route:a,href:N(()=>a.value.href),isActive:t,isExactActive:s,navigate:l}}const Fu=ue({name:"RouterLink",compatConfig:{MODE:3},props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:Yt,setup(e,{slots:r}){const n=Bn(Yt(e)),{options:a}=qe(Da),o=N(()=>({[Xt(e.activeClass,a.linkActiveClass,"router-link-active")]:n.isActive,[Xt(e.exactActiveClass,a.linkExactActiveClass,"router-link-exact-active")]:n.isExactActive}));return()=>{const t=r.default&&r.default(n);return e.custom?t:ce("a",{"aria-current":n.isExactActive?e.ariaCurrentValue:null,href:n.href,onClick:n.navigate,class:o.value},t)}}}),Bu=Fu;function Uu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)&&!e.defaultPrevented&&!(e.button!==void 0&&e.button!==0)){if(e.currentTarget&&e.currentTarget.getAttribute){const r=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(r))return}return e.preventDefault&&e.preventDefault(),!0}}function Hu(e,r){for(const n in r){const a=r[n],o=e[n];if(typeof a=="string"){if(a!==o)return!1}else if(!sr(o)||o.length!==a.length||a.some((t,s)=>t!==o[s]))return!1}return!0}function $t(e){return e?e.aliasOf?e.aliasOf.path:e.path:""}const Xt=(e,r,n)=>e??r??n,Ju=ue({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},compatConfig:{MODE:3},setup(e,{attrs:r,slots:n}){const a=qe(ho),o=N(()=>e.route||a.value),t=qe(Kt,0),s=N(()=>{let c=re(t);const{matched:d}=o.value;let u;for(;(u=d[c])&&!u.components;)c++;return c}),l=N(()=>o.value.matched[s.value]);Vr(Kt,N(()=>s.value+1)),Vr(zu,l),Vr(ho,o);const i=fe();return er(()=>[i.value,l.value,e.name],([c,d,u],[m,f,w])=>{d&&(d.instances[u]=c,f&&f!==d&&c&&c===m&&(d.leaveGuards.size||(d.leaveGuards=f.leaveGuards),d.updateGuards.size||(d.updateGuards=f.updateGuards))),c&&d&&(!f||!pn(d,f)||!m)&&(d.enterCallbacks[u]||[]).forEach(P=>P(c))},{flush:"post"}),()=>{const c=o.value,d=e.name,u=l.value,m=u&&u.components[d];if(!m)return Qt(n.default,{Component:m,route:c});const f=u.props[d],w=f?f===!0?c.params:typeof f=="function"?f(c):f:null,k=ce(m,be({},w,r,{onVnodeUnmounted:v=>{v.component.isUnmounted&&(u.instances[d]=null)},ref:i}));return Qt(n.default,{Component:k,route:c})||k}}});function Qt(e,r){if(!e)return null;const n=e(r);return n.length===1?n[0]:n}const Ti=Ju;function Wu(e){const r=yu(e.routes,e),n=e.parseQuery||Mu,a=e.stringifyQuery||Vt,o=e.history,t=Pn(),s=Pn(),l=Pn(),i=Ao(hr);let c=hr;rn&&e.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const d=Ga.bind(null,C=>""+C),u=Ga.bind(null,Du),m=Ga.bind(null,Sa);function f(C,H){let O,K;return Ei(C)?(O=r.getRecordMatcher(C),K=H):K=C,r.addRoute(K,O)}function w(C){const H=r.getRecordMatcher(C);H&&r.removeRoute(H)}function P(){return r.getRoutes().map(C=>C.record)}function k(C){return!!r.getRecordMatcher(C)}function v(C,H){if(H=be({},H||i.value),typeof C=="string"){const b=Va(n,C,H.path),E=r.resolve({path:b.path},H),j=o.createHref(b.fullPath);return be(b,E,{params:m(E.params),hash:Sa(b.hash),redirectedFrom:void 0,href:j})}let O;if("path"in C)O=be({},C,{path:Va(n,C.path,H.path).path});else{const b=be({},C.params);for(const E in b)b[E]==null&&delete b[E];O=be({},C,{params:u(b)}),H.params=u(H.params)}const K=r.resolve(O,H),de=C.hash||"";K.params=d(m(K.params));const p=Kd(a,be({},C,{hash:_u(de),path:K.path})),h=o.createHref(p);return be({fullPath:p,hash:de,query:a===Vt?Ou(C.query):C.query||{}},K,{redirectedFrom:void 0,href:h})}function S(C){return typeof C=="string"?Va(n,C,i.value.path):be({},C)}function x(C,H){if(c!==C)return hn(8,{from:H,to:C})}function A(C){return M(C)}function G(C){return A(be(S(C),{replace:!0}))}function Z(C){const H=C.matched[C.matched.length-1];if(H&&H.redirect){const{redirect:O}=H;let K=typeof O=="function"?O(C):O;return typeof K=="string"&&(K=K.includes("?")||K.includes("#")?K=S(K):{path:K},K.params={}),be({query:C.query,hash:C.hash,params:"path"in K?{}:C.params},K)}}function M(C,H){const O=c=v(C),K=i.value,de=C.state,p=C.force,h=C.replace===!0,b=Z(O);if(b)return M(be(S(b),{state:typeof b=="object"?be({},de,b.state):de,force:p,replace:h}),H||O);const E=O;E.redirectedFrom=H;let j;return!p&&Yd(a,K,O)&&(j=hn(16,{to:E,from:K}),Je(K,K,!0,!1)),(j?Promise.resolve(j):F(E,K)).catch(I=>mr(I)?mr(I,2)?I:De(I):te(I,E,K)).then(I=>{if(I){if(mr(I,2))return M(be({replace:h},S(I.to),{state:typeof I.to=="object"?be({},de,I.to.state):de,force:p}),H||E)}else I=q(E,K,!0,h,de);return Y(E,K,I),I})}function g(C,H){const O=x(C,H);return O?Promise.reject(O):Promise.resolve()}function J(C){const H=Er.values().next().value;return H&&typeof H.runWithContext=="function"?H.runWithContext(C):C()}function F(C,H){let O;const[K,de,p]=Gu(C,H);O=Ka(K.reverse(),"beforeRouteLeave",C,H);for(const b of K)b.leaveGuards.forEach(E=>{O.push(Ar(E,C,H))});const h=g.bind(null,C,H);return O.push(h),Le(O).then(()=>{O=[];for(const b of t.list())O.push(Ar(b,C,H));return O.push(h),Le(O)}).then(()=>{O=Ka(de,"beforeRouteUpdate",C,H);for(const b of de)b.updateGuards.forEach(E=>{O.push(Ar(E,C,H))});return O.push(h),Le(O)}).then(()=>{O=[];for(const b of p)if(b.beforeEnter)if(sr(b.beforeEnter))for(const E of b.beforeEnter)O.push(Ar(E,C,H));else O.push(Ar(b.beforeEnter,C,H));return O.push(h),Le(O)}).then(()=>(C.matched.forEach(b=>b.enterCallbacks={}),O=Ka(p,"beforeRouteEnter",C,H),O.push(h),Le(O))).then(()=>{O=[];for(const b of s.list())O.push(Ar(b,C,H));return O.push(h),Le(O)}).catch(b=>mr(b,8)?b:Promise.reject(b))}function Y(C,H,O){l.list().forEach(K=>J(()=>K(C,H,O)))}function q(C,H,O,K,de){const p=x(C,H);if(p)return p;const h=H===hr,b=rn?history.state:{};O&&(K||h?o.replace(C.fullPath,be({scroll:h&&b&&b.scroll},de)):o.push(C.fullPath,de)),i.value=C,Je(C,H,O,h),De()}let L;function R(){L||(L=o.listen((C,H,O)=>{if(!ir.listening)return;const K=v(C),de=Z(K);if(de){M(be(de,{replace:!0}),K).catch(xn);return}c=K;const p=i.value;rn&&au(Nt(p.fullPath,O.delta),Ra()),F(K,p).catch(h=>mr(h,12)?h:mr(h,2)?(M(h.to,K).then(b=>{mr(b,20)&&!O.delta&&O.type===On.pop&&o.go(-1,!1)}).catch(xn),Promise.reject()):(O.delta&&o.go(-O.delta,!1),te(h,K,p))).then(h=>{h=h||q(K,p,!1),h&&(O.delta&&!mr(h,8)?o.go(-O.delta,!1):O.type===On.pop&&mr(h,20)&&o.go(-1,!1)),Y(K,p,h)}).catch(xn)}))}let ie=Pn(),W=Pn(),oe;function te(C,H,O){De(C);const K=W.list();return K.length?K.forEach(de=>de(C,H,O)):console.error(C),Promise.reject(C)}function ze(){return oe&&i.value!==hr?Promise.resolve():new Promise((C,H)=>{ie.add([C,H])})}function De(C){return oe||(oe=!C,R(),ie.list().forEach(([H,O])=>C?O(C):H()),ie.reset()),C}function Je(C,H,O,K){const{scrollBehavior:de}=e;if(!rn||!de)return Promise.resolve();const p=!O&&ou(Nt(C.fullPath,0))||(K||!O)&&history.state&&history.state.scroll||null;return Hn().then(()=>de(C,H,p)).then(h=>h&&nu(h)).catch(h=>te(h,C,H))}const Ne=C=>o.go(C);let Pr;const Er=new Set,ir={currentRoute:i,listening:!0,addRoute:f,removeRoute:w,hasRoute:k,getRoutes:P,resolve:v,options:e,push:A,replace:G,go:Ne,back:()=>Ne(-1),forward:()=>Ne(1),beforeEach:t.add,beforeResolve:s.add,afterEach:l.add,onError:W.add,isReady:ze,install(C){const H=this;C.component("RouterLink",Bu),C.component("RouterView",Ti),C.config.globalProperties.$router=H,Object.defineProperty(C.config.globalProperties,"$route",{enumerable:!0,get:()=>re(i)}),rn&&!Pr&&i.value===hr&&(Pr=!0,A(o.location).catch(de=>{}));const O={};for(const de in hr)Object.defineProperty(O,de,{get:()=>i.value[de],enumerable:!0});C.provide(Da,H),C.provide(Ho,Ts(O)),C.provide(ho,i);const K=C.unmount;Er.add(C),C.unmount=function(){Er.delete(C),Er.size<1&&(c=hr,L&&L(),L=null,i.value=hr,Pr=!1,oe=!1),K()}}};function Le(C){return C.reduce((H,O)=>H.then(()=>J(O)),Promise.resolve())}return ir}function Gu(e,r){const n=[],a=[],o=[],t=Math.max(r.matched.length,e.matched.length);for(let s=0;s<t;s++){const l=r.matched[s];l&&(e.matched.find(c=>pn(c,l))?a.push(l):n.push(l));const i=e.matched[s];i&&(r.matched.find(c=>pn(c,i))||o.push(i))}return[n,a,o]}function $r(){return qe(Da)}function Xr(){return qe(Ho)}const Vu=({headerLinkSelector:e,headerAnchorSelector:r,delay:n,offset:a=5})=>{const o=$r(),s=Si(()=>{var P,k;const l=Math.max(window.scrollY,document.documentElement.scrollTop,document.body.scrollTop);if(Math.abs(l-0)<a){Zt(o,"");return}const c=window.innerHeight+l,d=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),u=Math.abs(d-c)<a,m=Array.from(document.querySelectorAll(e)),w=Array.from(document.querySelectorAll(r)).filter(v=>m.some(S=>S.hash===v.hash));for(let v=0;v<w.length;v++){const S=w[v],x=w[v+1],A=l>=(((P=S.parentElement)==null?void 0:P.offsetTop)??0)-a,G=!x||l<(((k=x.parentElement)==null?void 0:k.offsetTop)??0)-a;if(!(A&&G))continue;const M=decodeURIComponent(o.currentRoute.value.hash),g=decodeURIComponent(S.hash);if(M===g)return;if(u){for(let J=v+1;J<w.length;J++)if(M===decodeURIComponent(w[J].hash))return}Zt(o,g);return}},n);He(()=>{window.addEventListener("scroll",s)}),Wn(()=>{window.removeEventListener("scroll",s)})},Zt=async(e,r)=>{const{scrollBehavior:n}=e.options;e.options.scrollBehavior=void 0,await e.replace({query:e.currentRoute.value.query,hash:r}).finally(()=>e.options.scrollBehavior=n)},Ku="a.sidebar-item",Yu=".header-anchor",$u=300,Xu=5,Qu=wr({setup(){Vu({headerLinkSelector:Ku,headerAnchorSelector:Yu,delay:$u,offset:Xu})}}),es=()=>window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,Zu=()=>window.scrollTo({top:0,behavior:"smooth"});const em=ue({name:"BackToTop",setup(){const e=fe(0),r=N(()=>e.value>300),n=Si(()=>{e.value=es()},100);He(()=>{e.value=es(),window.addEventListener("scroll",()=>n())});const a=ce("div",{class:"back-to-top",onClick:Zu});return()=>ce(Gn,{name:"back-to-top"},()=>r.value?a:null)}}),rm=wr({rootComponents:[em]});const nm=ce("svg",{class:"external-link-icon",xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"},[ce("path",{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}),ce("polygon",{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"})]),am=ue({name:"ExternalLinkIcon",props:{locales:{type:Object,required:!1,default:()=>({})}},setup(e){const r=bn(),n=N(()=>e.locales[r.value]??{openInNewWindow:"open in new window"});return()=>ce("span",[nm,ce("span",{class:"external-link-icon-sr-only"},n.value.openInNewWindow)])}}),om={"/en/":{openInNewWindow:"Open in new window"},"/es/":{openInNewWindow:"Abrir en una ventana nueva"},"/":{openInNewWindow:"open in new window"}},tm=wr({enhance({app:e}){e.component("ExternalLinkIcon",ce(am,{locales:om}))}});/**
 * NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT
 */const me={settings:{minimum:.08,easing:"ease",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,barSelector:'[role="bar"]',parent:"body",template:'<div class="bar" role="bar"></div>'},status:null,set:e=>{const r=me.isStarted();e=Ya(e,me.settings.minimum,1),me.status=e===1?null:e;const n=me.render(!r),a=n.querySelector(me.settings.barSelector),o=me.settings.speed,t=me.settings.easing;return n.offsetWidth,sm(s=>{na(a,{transform:"translate3d("+rs(e)+"%,0,0)",transition:"all "+o+"ms "+t}),e===1?(na(n,{transition:"none",opacity:"1"}),n.offsetWidth,setTimeout(function(){na(n,{transition:"all "+o+"ms linear",opacity:"0"}),setTimeout(function(){me.remove(),s()},o)},o)):setTimeout(()=>s(),o)}),me},isStarted:()=>typeof me.status=="number",start:()=>{me.status||me.set(0);const e=()=>{setTimeout(()=>{me.status&&(me.trickle(),e())},me.settings.trickleSpeed)};return me.settings.trickle&&e(),me},done:e=>!e&&!me.status?me:me.inc(.3+.5*Math.random()).set(1),inc:e=>{let r=me.status;return r?(typeof e!="number"&&(e=(1-r)*Ya(Math.random()*r,.1,.95)),r=Ya(r+e,0,.994),me.set(r)):me.start()},trickle:()=>me.inc(Math.random()*me.settings.trickleRate),render:e=>{if(me.isRendered())return document.getElementById("nprogress");ns(document.documentElement,"nprogress-busy");const r=document.createElement("div");r.id="nprogress",r.innerHTML=me.settings.template;const n=r.querySelector(me.settings.barSelector),a=e?"-100":rs(me.status||0),o=document.querySelector(me.settings.parent);return na(n,{transition:"all 0 linear",transform:"translate3d("+a+"%,0,0)"}),o!==document.body&&ns(o,"nprogress-custom-parent"),o==null||o.appendChild(r),r},remove:()=>{as(document.documentElement,"nprogress-busy"),as(document.querySelector(me.settings.parent),"nprogress-custom-parent");const e=document.getElementById("nprogress");e&&im(e)},isRendered:()=>!!document.getElementById("nprogress")},Ya=(e,r,n)=>e<r?r:e>n?n:e,rs=e=>(-1+e)*100,sm=function(){const e=[];function r(){const n=e.shift();n&&n(r)}return function(n){e.push(n),e.length===1&&r()}}(),na=function(){const e=["Webkit","O","Moz","ms"],r={};function n(s){return s.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,function(l,i){return i.toUpperCase()})}function a(s){const l=document.body.style;if(s in l)return s;let i=e.length;const c=s.charAt(0).toUpperCase()+s.slice(1);let d;for(;i--;)if(d=e[i]+c,d in l)return d;return s}function o(s){return s=n(s),r[s]??(r[s]=a(s))}function t(s,l,i){l=o(l),s.style[l]=i}return function(s,l){for(const i in l){const c=l[i];c!==void 0&&Object.prototype.hasOwnProperty.call(l,i)&&t(s,i,c)}}}(),_i=(e,r)=>(typeof e=="string"?e:Jo(e)).indexOf(" "+r+" ")>=0,ns=(e,r)=>{const n=Jo(e),a=n+r;_i(n,r)||(e.className=a.substring(1))},as=(e,r)=>{const n=Jo(e);if(!_i(e,r))return;const a=n.replace(" "+r+" "," ");e.className=a.substring(1,a.length-1)},Jo=e=>(" "+(e.className||"")+" ").replace(/\s+/gi," "),im=e=>{e&&e.parentNode&&e.parentNode.removeChild(e)};const lm=()=>{He(()=>{const e=$r(),r=new Set;r.add(e.currentRoute.value.path),e.beforeEach(n=>{r.has(n.path)||me.start()}),e.afterEach(n=>{r.add(n.path),me.done()})})},cm=wr({setup(){lm()}}),dm=JSON.parse(`{"logo":"/LogoIES.png","repo":"psp2dam/psp_sources2022","repoLabel":"GitHub","editLink":true,"docsRepo":"https://github.com/psp2dam/psp_sources2022","docsBranch":"main","docsDir":"docs","lastUpdated":true,"sidebarDepth":2,"locales":{"/en/":{"home":"/en/","selectLanguageText":"Languages","selectLanguageName":"English","selectLanguageAriaLabel":"Languages","editLink":false,"editLinkText":"Help us improve this page on GitHub!","lastUpdatedText":"Last updated","notFound":["Resource not found in the site"],"backToHome":"Back to home","openInNewWindow":"Open in new window","toggleSidebar":"Show/Hide","serviceWorker":{"updatePopup":{"message":"New content is available.","buttonText":"Refresh"}},"navbar":[{"text":"Aules FP","link":"https://aules.edu.gva.es/fp/"},{"text":"Course Index","children":[{"text":"Unit 1 - Introduction to concurrent programming","link":"/en/unit1/"},{"text":"Unit 2 - Process programming in Java","link":"/en/unit2/"},{"text":"Unit 3 - Multithread programming in Java","link":"/en/unit3/"},{"text":"Unit 4 - Network programming in Java","link":"/en/unit4/"},{"text":"Unit 5 - Network services","link":"/en/unit5/"},{"text":"Unit 6 - Secure programming techniques","link":"/en/unit6/"}]}],"sidebar":{"/en/":[{"text":"PSP > Home","link":"/en/README.md","children":[]}],"/en/unit1/":[{"isGroup":true,"text":"Unit 1 - Introduction to concurrent programming","children":["index.md","process.md","concurrency.md","operatingsystem.md"]}],"/en/unit2/":[{"isGroup":true,"text":"Unit 2 - Process Programming in Java","children":["index.md","ipc.md","processbuilder.md","iostreams.md","console_annex.md","curl_annex.md"]}],"/en/unit3/":[{"isGroup":true,"text":"Unit 3 - Multithread Programming in Java","children":["index.md","runnable.md","synchronization.md","producer-consumer.md","alternatives.md","debugger_annex.md"]}],"/en/unit4/":[{"isGroup":true,"text":"Unit 4 - Network Programming in Java","children":["index.md","tcp-ip.md","sockets-tcp.md","sockets-udp.md","stateful-protocols.md"]}],"/en/unit5/":[{"isGroup":true,"text":"Unit 5 - Network Services","children":["index.md","mail.md","ftp.md","gmail_annex.md"]}],"/en/unit6/":[{"isGroup":true,"text":"Unit 6 - Secure programming techniques","children":["index.md","security.md","hash-functions.md","symmetric-key.md","asymmetric-keys.md","jsse.md","log4j_annex.md"]}]}},"/es/":{"home":"/es/","selectLanguageText":"Idioma","selectLanguageName":"Castellano","selectLanguageAriaLabel":"Idioma","editLink":false,"editLinkText":"Ayúdanos a mejorar esta página en GitHub!","lastUpdatedText":"Última actualización","contributorsText":"Editores","notFound":["No se ha encontrado el recurso solicitado"],"backToHome":"Inicio","openInNewWindow":"Abrir en una ventana nueva","toggleSidebar":"Mostrar/Ocultar","navbar":[{"text":"Aules FP Semi","link":"https://aules.edu.gva.es/semipresencial/"},{"text":"Contenido del curso","children":[{"text":"Tema 1 - Introducción a la programación concurrente","link":"/es/unit1/"},{"text":"Tema 2 - Programación de procesos en Java","link":"/es/unit2/"},{"text":"Tema 3 - Programación multihilo en Java","link":"/es/unit3/"},{"text":"Tema 4 - Programación en red en Java","link":"/es/unit4/"},{"text":"Tema 5 - Servicios en red","link":"/es/unit5/"},{"text":"Tema 6 - Técnicas de programación segura","link":"/es/unit6/"}]}],"sidebar":{"/es/":[{"text":"PSP > Inicio","link":"/es/README.md","children":[]}],"/es/unit1/":[{"isGroup":true,"text":"Tema 1 - Introducción a la programación concurrente","children":["index.md","process.md","concurrency.md","operatingsystem.md"]}],"/es/unit2/":[{"isGroup":true,"text":"Tema 2 - Programación de procesos en Java","children":["index.md","ipc.md","processbuilder.md","iostreams.md","console_annex.md","curl_annex.md"]}],"/es/unit3/":[{"isGroup":true,"text":"Tema 3 - Programación multihilo en Java","children":["index.md","runnable.md","synchronization.md","producer-consumer.md","alternatives.md","debugger_annex.md"]}],"/es/unit4/":[{"isGroup":true,"text":"Tema 4 - Programación en red en Java","children":["index.md","tcp-ip.md","sockets-tcp.md","sockets-udp.md","stateful-protocols.md"]}],"/es/unit5/":[{"isGroup":true,"text":"Tema 5 - Servicios en red","children":["index.md","mail.md","ftp.md","gmail_annex.md"]}],"/es/unit6/":[{"isGroup":true,"text":"Tema 6 - Técnicas de programación segura","children":["index.md","security.md","hash-functions.md","symmetric-key.md","asymmetric-keys.md","jsse.md","log4j_annex.md"]}]}},"/":{"selectLanguageName":"English"}},"colorMode":"auto","colorModeSwitch":true,"navbar":[],"selectLanguageText":"Languages","selectLanguageAriaLabel":"Select language","sidebar":"auto","editLinkText":"Edit this page","lastUpdatedText":"Last Updated","contributors":true,"contributorsText":"Contributors","notFound":["There's nothing here.","How did we get here?","That's a Four-Oh-Four.","Looks like we've got some broken links."],"backToHome":"Take me home","openInNewWindow":"open in new window","toggleColorMode":"toggle color mode","toggleSidebar":"toggle sidebar"}`),um=fe(dm),Li=()=>um,Ri=Symbol(""),mm=()=>{const e=qe(Ri);if(!e)throw new Error("useThemeLocaleData() is called without provider.");return e},pm=(e,r)=>{const{locales:n,...a}=e;return{...a,...n==null?void 0:n[r]}},hm=wr({enhance({app:e}){const r=Li(),n=e._context.provides[zo],a=N(()=>pm(r.value,n.value));e.provide(Ri,a),Object.defineProperties(e.config.globalProperties,{$theme:{get(){return r.value}},$themeLocale:{get(){return a.value}}})}}),gm=ue({__name:"Badge",props:{type:{type:String,required:!1,default:"tip"},text:{type:String,required:!1,default:""},vertical:{type:String,required:!1,default:void 0}},setup(e){return(r,n)=>(U(),ee("span",{class:Ge(["badge",e.type]),style:Fn({verticalAlign:e.vertical})},[we(r.$slots,"default",{},()=>[Mr(_e(e.text),1)])],6))}}),Ce=(e,r)=>{const n=e.__vccOpts||e;for(const[a,o]of r)n[a]=o;return n},fm=Ce(gm,[["__file","Badge.vue"]]),vm=ue({name:"CodeGroup",slots:Object,setup(e,{slots:r}){const n=fe(-1),a=fe([]),o=(l=n.value)=>{l<a.value.length-1?n.value=l+1:n.value=0,a.value[n.value].focus()},t=(l=n.value)=>{l>0?n.value=l-1:n.value=a.value.length-1,a.value[n.value].focus()},s=(l,i)=>{l.key===" "||l.key==="Enter"?(l.preventDefault(),n.value=i):l.key==="ArrowRight"?(l.preventDefault(),o(i)):l.key==="ArrowLeft"&&(l.preventDefault(),t(i))};return()=>{var i;const l=(((i=r.default)==null?void 0:i.call(r))||[]).filter(c=>c.type.name==="CodeGroupItem").map(c=>(c.props===null&&(c.props={}),c));return l.length===0?null:(n.value<0||n.value>l.length-1?(n.value=l.findIndex(c=>c.props.active===""||c.props.active===!0),n.value===-1&&(n.value=0)):l.forEach((c,d)=>{c.props.active=d===n.value}),ce("div",{class:"code-group"},[ce("div",{class:"code-group__nav"},ce("ul",{class:"code-group__ul"},l.map((c,d)=>{const u=d===n.value;return ce("li",{class:"code-group__li"},ce("button",{ref:m=>{m&&(a.value[d]=m)},class:{"code-group__nav-tab":!0,"code-group__nav-tab-active":u},ariaPressed:u,ariaExpanded:u,onClick:()=>n.value=d,onKeydown:m=>s(m,d)},c.props.title))}))),l]))}}}),bm=["aria-selected"],ym=ue({name:"CodeGroupItem"}),Sm=ue({...ym,props:{title:{type:String,required:!0},active:{type:Boolean,required:!1,default:!1}},setup(e){return(r,n)=>(U(),ee("div",{class:Ge(["code-group-item",{"code-group-item__active":e.active}]),"aria-selected":e.active},[we(r.$slots,"default")],10,bm))}}),wm=Ce(Sm,[["__file","CodeGroupItem.vue"]]);function os(e,r){var n;const a=Ao();return Us(()=>{a.value=e()},{...r,flush:(n=r==null?void 0:r.flush)!=null?n:"sync"}),vn(a)}function Pm(e,r){let n,a,o;const t=fe(!0),s=()=>{t.value=!0,o()};er(e,s,{flush:"sync"});const l=typeof r=="function"?r:r.get,i=typeof r=="function"?void 0:r.set,c=Ul((d,u)=>(a=d,o=u,{get(){return t.value&&(n=l(),t.value=!1),a(),n},set(m){i==null||i(m)}}));return Object.isExtensible(c)&&(c.trigger=s),c}function Wo(e){return Ss()?(ul(e),!0):!1}function Or(e){return typeof e=="function"?e():re(e)}const Go=typeof window<"u"&&typeof document<"u",Em=Object.prototype.toString,km=e=>Em.call(e)==="[object Object]",Cm=()=>{};function jm(e,r){function n(...a){return new Promise((o,t)=>{Promise.resolve(e(()=>r.apply(this,a),{fn:r,thisArg:this,args:a})).then(o).catch(t)})}return n}const Di=e=>e();function qm(e=Di){const r=fe(!0);function n(){r.value=!1}function a(){r.value=!0}const o=(...t)=>{r.value&&e(...t)};return{isActive:vn(r),pause:n,resume:a,eventFilter:o}}function Im(e,r,n={}){const{eventFilter:a=Di,...o}=n;return er(e,jm(a,r),o)}function Am(e,r,n={}){const{eventFilter:a,...o}=n,{eventFilter:t,pause:s,resume:l,isActive:i}=qm(a);return{stop:Im(e,r,{...o,eventFilter:t}),pause:s,resume:l,isActive:i}}function xm(e,r,n={}){const{immediate:a=!0}=n,o=fe(!1);let t=null;function s(){t&&(clearTimeout(t),t=null)}function l(){o.value=!1,s()}function i(...c){s(),o.value=!0,t=setTimeout(()=>{o.value=!1,t=null,e(...c)},Or(r))}return a&&(o.value=!0,Go&&i()),Wo(l),{isPending:vn(o),start:i,stop:l}}function Tm(e=!1,r={}){const{truthyValue:n=!0,falsyValue:a=!1}=r,o=Re(e),t=fe(e);function s(l){if(arguments.length)return t.value=l,t.value;{const i=Or(n);return t.value=t.value===i?Or(a):i,t.value}}return o?s:[t,s]}function _m(e){var r;const n=Or(e);return(r=n==null?void 0:n.$el)!=null?r:n}const wa=Go?window:void 0,Lm=Go?window.navigator:void 0;function Pa(...e){let r,n,a,o;if(typeof e[0]=="string"||Array.isArray(e[0])?([n,a,o]=e,r=wa):[r,n,a,o]=e,!r)return Cm;Array.isArray(n)||(n=[n]),Array.isArray(a)||(a=[a]);const t=[],s=()=>{t.forEach(d=>d()),t.length=0},l=(d,u,m,f)=>(d.addEventListener(u,m,f),()=>d.removeEventListener(u,m,f)),i=er(()=>[_m(r),Or(o)],([d,u])=>{if(s(),!d)return;const m=km(u)?{...u}:u;t.push(...n.flatMap(f=>a.map(w=>l(d,f,w,m))))},{immediate:!0,flush:"post"}),c=()=>{i(),s()};return Wo(c),c}function Rm(){const e=fe(!1);return Do()&&He(()=>{e.value=!0}),e}function Mi(e){const r=Rm();return N(()=>(r.value,!!e()))}function Dm(e,r={}){const{window:n=wa}=r,a=Mi(()=>n&&"matchMedia"in n&&typeof n.matchMedia=="function");let o;const t=fe(!1),s=c=>{t.value=c.matches},l=()=>{o&&("removeEventListener"in o?o.removeEventListener("change",s):o.removeListener(s))},i=Us(()=>{a.value&&(l(),o=n.matchMedia(Or(e)),"addEventListener"in o?o.addEventListener("change",s):o.addListener(s),t.value=o.matches)});return Wo(()=>{i(),l(),o=void 0}),t}function Mm(e={}){const{navigator:r=Lm,read:n=!1,source:a,copiedDuring:o=1500,legacy:t=!1}=e,s=Mi(()=>r&&"clipboard"in r),l=N(()=>s.value||t),i=fe(""),c=fe(!1),d=xm(()=>c.value=!1,o);function u(){s.value?r.clipboard.readText().then(P=>{i.value=P}):i.value=w()}l.value&&n&&Pa(["copy","cut"],u);async function m(P=Or(a)){l.value&&P!=null&&(s.value?await r.clipboard.writeText(P):f(P),i.value=P,c.value=!0,d.start())}function f(P){const k=document.createElement("textarea");k.value=P??"",k.style.position="absolute",k.style.opacity="0",document.body.appendChild(k),k.select(),document.execCommand("copy"),k.remove()}function w(){var P,k,v;return(v=(k=(P=document==null?void 0:document.getSelection)==null?void 0:P.call(document))==null?void 0:k.toString())!=null?v:""}return{isSupported:l,text:i,copied:c,copy:m}}const aa=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},oa="__vueuse_ssr_handlers__",Om=zm();function zm(){return oa in aa||(aa[oa]=aa[oa]||{}),aa[oa]}function Nm(e,r){return Om[e]||r}function Fm(e){return e==null?"any":e instanceof Set?"set":e instanceof Map?"map":e instanceof Date?"date":typeof e=="boolean"?"boolean":typeof e=="string"?"string":typeof e=="object"?"object":Number.isNaN(e)?"any":"number"}const Bm={boolean:{read:e=>e==="true",write:e=>String(e)},object:{read:e=>JSON.parse(e),write:e=>JSON.stringify(e)},number:{read:e=>Number.parseFloat(e),write:e=>String(e)},any:{read:e=>e,write:e=>String(e)},string:{read:e=>e,write:e=>String(e)},map:{read:e=>new Map(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e.entries()))},set:{read:e=>new Set(JSON.parse(e)),write:e=>JSON.stringify(Array.from(e))},date:{read:e=>new Date(e),write:e=>e.toISOString()}},ts="vueuse-storage";function Um(e,r,n,a={}){var o;const{flush:t="pre",deep:s=!0,listenToStorageChanges:l=!0,writeDefaults:i=!0,mergeDefaults:c=!1,shallow:d,window:u=wa,eventFilter:m,onError:f=g=>{console.error(g)}}=a,w=(d?Ao:fe)(r);if(!n)try{n=Nm("getDefaultStorage",()=>{var g;return(g=wa)==null?void 0:g.localStorage})()}catch(g){f(g)}if(!n)return w;const P=Or(r),k=Fm(P),v=(o=a.serializer)!=null?o:Bm[k],{pause:S,resume:x}=Am(w,()=>A(w.value),{flush:t,deep:s,eventFilter:m});return u&&l&&(Pa(u,"storage",M),Pa(u,ts,Z)),M(),w;function A(g){try{if(g==null)n.removeItem(e);else{const J=v.write(g),F=n.getItem(e);F!==J&&(n.setItem(e,J),u&&u.dispatchEvent(new CustomEvent(ts,{detail:{key:e,oldValue:F,newValue:J,storageArea:n}})))}}catch(J){f(J)}}function G(g){const J=g?g.newValue:n.getItem(e);if(J==null)return i&&P!==null&&n.setItem(e,v.write(P)),P;if(!g&&c){const F=v.read(J);return typeof c=="function"?c(F,P):k==="object"&&!Array.isArray(F)?{...P,...F}:F}else return typeof J!="string"?J:v.read(J)}function Z(g){M(g.detail)}function M(g){if(!(g&&g.storageArea!==n)){if(g&&g.key==null){w.value=P;return}if(!(g&&g.key!==e)){S();try{(g==null?void 0:g.newValue)!==v.write(w.value)&&(w.value=G(g))}catch(J){f(J)}finally{g?Hn(x):x()}}}}}function Hm(e){return Dm("(prefers-color-scheme: dark)",e)}const Jm=()=>Li(),Ue=()=>mm(),Oi=Symbol(""),Vo=()=>{const e=qe(Oi);if(!e)throw new Error("useDarkMode() is called without provider.");return e},Wm=()=>{const e=Ue(),r=Hm(),n=Um("vuepress-color-scheme",e.value.colorMode),a=N({get(){return e.value.colorModeSwitch?n.value==="auto"?r.value:n.value==="dark":e.value.colorMode==="dark"},set(o){o===r.value?n.value="auto":n.value=o?"dark":"light"}});Vr(Oi,a),Gm(a)},Gm=e=>{const r=(n=e.value)=>{const a=window==null?void 0:window.document.querySelector("html");a==null||a.classList.toggle("dark",n)};He(()=>{er(e,r,{immediate:!0})}),Ta(()=>r())},zi=(...e)=>{const n=$r().resolve(...e),a=n.matched[n.matched.length-1];if(!(a!=null&&a.redirect))return n;const{redirect:o}=a,t=se(o)?o(n):o,s=ve(t)?{path:t}:t;return zi({hash:n.hash,query:n.query,params:n.params,...s})},Ko=e=>{const r=zi(encodeURI(e));return{text:r.meta.title||e,link:r.name==="404"?e:r.fullPath}};let $a=null,En=null;const Vm={wait:()=>$a,pending:()=>{$a=new Promise(e=>En=e)},resolve:()=>{En==null||En(),$a=null,En=null}},Ni=()=>Vm,Fi=Symbol("sidebarItems"),Yo=()=>{const e=qe(Fi);if(!e)throw new Error("useSidebarItems() is called without provider.");return e},Km=()=>{const e=Ue(),r=fr(),n=N(()=>Ym(r.value,e.value));Vr(Fi,n)},Ym=(e,r)=>{const n=e.sidebar??r.sidebar??"auto",a=e.sidebarDepth??r.sidebarDepth??2;return e.home||n===!1?[]:n==="auto"?Xm(a):Q(n)?Bi(n,a):Oo(n)?Qm(n,a):[]},$m=(e,r)=>({text:e.title,link:e.link,children:$o(e.children,r)}),$o=(e,r)=>r>0?e.map(n=>$m(n,r-1)):[],Xm=e=>{const r=_r();return[{text:r.value.title,children:$o(r.value.headers,e)}]},Bi=(e,r)=>{const n=Xr(),a=_r(),o=t=>{var l;let s;if(ve(t)?s=Ko(t):s=t,s.children)return{...s,children:s.children.map(i=>o(i))};if(s.link===n.path){const i=((l=a.value.headers[0])==null?void 0:l.level)===1?a.value.headers[0].children:a.value.headers;return{...s,children:$o(i,r)}}return s};return e.map(t=>o(t))},Qm=(e,r)=>{const n=Xr(),a=ui(e,n.path),o=e[a]??[];return Bi(o,r)},Zm="2048px",ep={mobile:Zm};var zn;(function(e){e.MOBILE="mobile"})(zn||(zn={}));var ps;const rp={[zn.MOBILE]:Number.parseInt((ps=ep.mobile)==null?void 0:ps.replace("px",""),10)},Ui=(e,r)=>{const n=rp[e];Number.isInteger(n)&&He(()=>{r(n),window.addEventListener("resize",()=>r(n),!1),window.addEventListener("orientationchange",()=>r(n),!1)})},np={},ap={class:"theme-default-content"};function op(e,r){const n=yr("Content");return U(),ee("div",ap,[ne(n)])}const tp=Ce(np,[["render",op],["__file","HomeContent.vue"]]),sp={key:0,class:"features"},ip=ue({__name:"HomeFeatures",setup(e){const r=fr(),n=N(()=>Q(r.value.features)?r.value.features:[]);return(a,o)=>n.value.length?(U(),ee("div",sp,[(U(!0),ee(Pe,null,Rr(n.value,t=>(U(),ee("div",{key:t.title,class:"feature"},[he("h2",null,_e(t.title),1),he("p",null,_e(t.details),1)]))),128))])):je("v-if",!0)}}),lp=Ce(ip,[["__file","HomeFeatures.vue"]]),cp=["innerHTML"],dp=["textContent"],up=ue({__name:"HomeFooter",setup(e){const r=fr(),n=N(()=>r.value.footer),a=N(()=>r.value.footerHtml);return(o,t)=>n.value?(U(),ee(Pe,{key:0},[je(" eslint-disable-next-line vue/no-v-html "),a.value?(U(),ee("div",{key:0,class:"footer",innerHTML:n.value},null,8,cp)):(U(),ee("div",{key:1,class:"footer",textContent:_e(n.value)},null,8,dp))],64)):je("v-if",!0)}}),mp=Ce(up,[["__file","HomeFooter.vue"]]),pp=["href","rel","target","aria-label"],hp=ue({inheritAttrs:!1}),gp=ue({...hp,__name:"AutoLink",props:{item:{type:Object,required:!0}},setup(e){const r=e,n=Xr(),a=bi(),{item:o}=qa(r),t=N(()=>Vn(o.value.link)),s=N(()=>_d(o.value.link)||Ld(o.value.link)),l=N(()=>{if(!s.value){if(o.value.target)return o.value.target;if(t.value)return"_blank"}}),i=N(()=>l.value==="_blank"),c=N(()=>!t.value&&!s.value&&!i.value),d=N(()=>{if(!s.value){if(o.value.rel)return o.value.rel;if(i.value)return"noopener noreferrer"}}),u=N(()=>o.value.ariaLabel||o.value.text),m=N(()=>{const P=Object.keys(a.value.locales);return P.length?!P.some(k=>k===o.value.link):o.value.link!=="/"}),f=N(()=>m.value?n.path.startsWith(o.value.link):!1),w=N(()=>c.value?o.value.activeMatch?new RegExp(o.value.activeMatch).test(n.path):f.value:!1);return(P,k)=>{const v=yr("RouterLink"),S=yr("AutoLinkExternalIcon");return c.value?(U(),Ae(v,co({key:0,class:{"router-link-active":w.value},to:re(o).link,"aria-label":u.value},P.$attrs),{default:Me(()=>[we(P.$slots,"before"),Mr(" "+_e(re(o).text)+" ",1),we(P.$slots,"after")]),_:3},16,["class","to","aria-label"])):(U(),ee("a",co({key:1,class:"external-link",href:re(o).link,rel:d.value,target:l.value,"aria-label":u.value},P.$attrs),[we(P.$slots,"before"),Mr(" "+_e(re(o).text)+" ",1),i.value?(U(),Ae(S,{key:0})):je("v-if",!0),we(P.$slots,"after")],16,pp))}}}),vr=Ce(gp,[["__file","AutoLink.vue"]]),fp={class:"hero"},vp={key:0,id:"main-title"},bp={key:1,class:"description"},yp={key:2,class:"actions"},Sp=ue({__name:"HomeHero",setup(e){const r=fr(),n=No(),a=Vo(),o=N(()=>a.value&&r.value.heroImageDark!==void 0?r.value.heroImageDark:r.value.heroImage),t=N(()=>r.value.heroAlt||l.value||"hero"),s=N(()=>r.value.heroHeight||280),l=N(()=>r.value.heroText===null?null:r.value.heroText||n.value.title||"Hello"),i=N(()=>r.value.tagline===null?null:r.value.tagline||n.value.description||"Welcome to your VuePress site"),c=N(()=>Q(r.value.actions)?r.value.actions.map(({text:u,link:m,type:f="primary"})=>({text:u,link:m,type:f})):[]),d=()=>{if(!o.value)return null;const u=ce("img",{src:Bo(o.value),alt:t.value,height:s.value});return r.value.heroImageDark===void 0?u:ce(Fo,()=>u)};return(u,m)=>(U(),ee("header",fp,[ne(d),l.value?(U(),ee("h1",vp,_e(l.value),1)):je("v-if",!0),i.value?(U(),ee("p",bp,_e(i.value),1)):je("v-if",!0),c.value.length?(U(),ee("p",yp,[(U(!0),ee(Pe,null,Rr(c.value,f=>(U(),Ae(vr,{key:f.text,class:Ge(["action-button",[f.type]]),item:f},null,8,["class","item"]))),128))])):je("v-if",!0)]))}}),wp=Ce(Sp,[["__file","HomeHero.vue"]]),Pp={class:"home"},Ep=ue({__name:"Home",setup(e){return(r,n)=>(U(),ee("main",Pp,[ne(wp),ne(lp),ne(tp),ne(mp)]))}}),kp=Ce(Ep,[["__file","Home.vue"]]),Cp=ue({__name:"NavbarBrand",setup(e){const r=bn(),n=No(),a=Ue(),o=Vo(),t=N(()=>a.value.home||r.value),s=N(()=>n.value.title),l=N(()=>o.value&&a.value.logoDark!==void 0?a.value.logoDark:a.value.logo),i=()=>{if(!l.value)return null;const c=ce("img",{class:"logo",src:Bo(l.value),alt:s.value});return a.value.logoDark===void 0?c:ce(Fo,()=>c)};return(c,d)=>{const u=yr("RouterLink");return U(),Ae(u,{to:t.value},{default:Me(()=>[ne(i),s.value?(U(),ee("span",{key:0,class:Ge(["site-name",{"can-hide":l.value}])},_e(s.value),3)):je("v-if",!0)]),_:1},8,["to"])}}}),jp=Ce(Cp,[["__file","NavbarBrand.vue"]]),qp=ue({__name:"DropdownTransition",setup(e){const r=a=>{a.style.height=a.scrollHeight+"px"},n=a=>{a.style.height=""};return(a,o)=>(U(),Ae(Gn,{name:"dropdown",onEnter:r,onAfterEnter:n,onBeforeLeave:r},{default:Me(()=>[we(a.$slots,"default")]),_:3}))}}),Hi=Ce(qp,[["__file","DropdownTransition.vue"]]),Ip=["aria-label"],Ap={class:"title"},xp=he("span",{class:"arrow down"},null,-1),Tp=["aria-label"],_p={class:"title"},Lp={class:"navbar-dropdown"},Rp={class:"navbar-dropdown-subtitle"},Dp={key:1},Mp={class:"navbar-dropdown-subitem-wrapper"},Op=ue({__name:"NavbarDropdown",props:{item:{type:Object,required:!0}},setup(e){const r=e,{item:n}=qa(r),a=N(()=>n.value.ariaLabel||n.value.text),o=fe(!1),t=Xr();er(()=>t.path,()=>{o.value=!1});const s=i=>{i.detail===0?o.value=!o.value:o.value=!1},l=(i,c)=>c[c.length-1]===i;return(i,c)=>(U(),ee("div",{class:Ge(["navbar-dropdown-wrapper",{open:o.value}])},[he("button",{class:"navbar-dropdown-title",type:"button","aria-label":a.value,onClick:s},[he("span",Ap,_e(re(n).text),1),xp],8,Ip),he("button",{class:"navbar-dropdown-title-mobile",type:"button","aria-label":a.value,onClick:c[0]||(c[0]=d=>o.value=!o.value)},[he("span",_p,_e(re(n).text),1),he("span",{class:Ge(["arrow",o.value?"down":"right"])},null,2)],8,Tp),ne(Hi,null,{default:Me(()=>[ha(he("ul",Lp,[(U(!0),ee(Pe,null,Rr(re(n).children,d=>(U(),ee("li",{key:d.text,class:"navbar-dropdown-item"},[d.children?(U(),ee(Pe,{key:0},[he("h4",Rp,[d.link?(U(),Ae(vr,{key:0,item:d,onFocusout:u=>l(d,re(n).children)&&d.children.length===0&&(o.value=!1)},null,8,["item","onFocusout"])):(U(),ee("span",Dp,_e(d.text),1))]),he("ul",Mp,[(U(!0),ee(Pe,null,Rr(d.children,u=>(U(),ee("li",{key:u.link,class:"navbar-dropdown-subitem"},[ne(vr,{item:u,onFocusout:m=>l(u,d.children)&&l(d,re(n).children)&&(o.value=!1)},null,8,["item","onFocusout"])]))),128))])],64)):(U(),Ae(vr,{key:1,item:d,onFocusout:u=>l(d,re(n).children)&&(o.value=!1)},null,8,["item","onFocusout"]))]))),128))],512),[[ya,o.value]])]),_:1})],2))}}),zp=Ce(Op,[["__file","NavbarDropdown.vue"]]),ss=e=>decodeURI(e).replace(/#.*$/,"").replace(/(index)?\.(md|html)$/,""),Np=(e,r)=>{if(r.hash===e)return!0;const n=ss(r.path),a=ss(e);return n===a},Ji=(e,r)=>e.link&&Np(e.link,r)?!0:e.children?e.children.some(n=>Ji(n,r)):!1,Wi=e=>!Vn(e)||/github\.com/.test(e)?"GitHub":/bitbucket\.org/.test(e)?"Bitbucket":/gitlab\.com/.test(e)?"GitLab":/gitee\.com/.test(e)?"Gitee":null,Fp={GitHub:":repo/edit/:branch/:path",GitLab:":repo/-/edit/:branch/:path",Gitee:":repo/edit/:branch/:path",Bitbucket:":repo/src/:branch/:path?mode=edit&spa=0&at=:branch&fileviewer=file-view-default"},Bp=({docsRepo:e,editLinkPattern:r})=>{if(r)return r;const n=Wi(e);return n!==null?Fp[n]:null},Up=({docsRepo:e,docsBranch:r,docsDir:n,filePathRelative:a,editLinkPattern:o})=>{if(!a)return null;const t=Bp({docsRepo:e,editLinkPattern:o});return t?t.replace(/:repo/,Vn(e)?e:`https://github.com/${e}`).replace(/:branch/,r).replace(/:path/,di(`${ci(n)}/${a}`)):null},Hp={key:0,class:"navbar-items"},Jp=ue({__name:"NavbarItems",setup(e){const r=()=>{const d=$r(),u=bn(),m=bi(),f=No(),w=Jm(),P=Ue();return N(()=>{const k=Object.keys(m.value.locales);if(k.length<2)return[];const v=d.currentRoute.value.path,S=d.currentRoute.value.fullPath;return[{text:`${P.value.selectLanguageText}`,ariaLabel:`${P.value.selectLanguageAriaLabel??P.value.selectLanguageText}`,children:k.map(A=>{var F,Y;const G=((F=m.value.locales)==null?void 0:F[A])??{},Z=((Y=w.value.locales)==null?void 0:Y[A])??{},M=`${G.lang}`,g=Z.selectLanguageName??M;let J;if(M===f.value.lang)J=S;else{const q=v.replace(u.value,A);d.getRoutes().some(L=>L.path===q)?J=S.replace(v,q):J=Z.home??A}return{text:g,link:J}})}]})},n=()=>{const d=Ue(),u=N(()=>d.value.repo),m=N(()=>u.value?Wi(u.value):null),f=N(()=>u.value&&!Vn(u.value)?`https://github.com/${u.value}`:u.value),w=N(()=>f.value?d.value.repoLabel?d.value.repoLabel:m.value===null?"Source":m.value:null);return N(()=>!f.value||!w.value?[]:[{text:w.value,link:f.value}])},a=d=>ve(d)?Ko(d):d.children?{...d,children:d.children.map(a)}:d,o=()=>{const d=Ue();return N(()=>(d.value.navbar||[]).map(a))},t=fe(!1),s=o(),l=r(),i=n(),c=N(()=>[...s.value,...l.value,...i.value]);return Ui(zn.MOBILE,d=>{window.innerWidth<d?t.value=!0:t.value=!1}),(d,u)=>c.value.length?(U(),ee("nav",Hp,[(U(!0),ee(Pe,null,Rr(c.value,m=>(U(),ee("div",{key:m.text,class:"navbar-item"},[m.children?(U(),Ae(zp,{key:0,item:m,class:Ge(t.value?"mobile":"")},null,8,["item","class"])):(U(),Ae(vr,{key:1,item:m},null,8,["item"]))]))),128))])):je("v-if",!0)}}),Gi=Ce(Jp,[["__file","NavbarItems.vue"]]),Wp=["title"],Gp={class:"icon",focusable:"false",viewBox:"0 0 32 32"},Vp=Bc('<path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path>',9),Kp=[Vp],Yp={class:"icon",focusable:"false",viewBox:"0 0 32 32"},$p=he("path",{d:"M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z",fill:"currentColor"},null,-1),Xp=[$p],Qp=ue({__name:"ToggleColorModeButton",setup(e){const r=Ue(),n=Vo(),a=()=>{n.value=!n.value};return(o,t)=>(U(),ee("button",{class:"toggle-color-mode-button",title:re(r).toggleColorMode,onClick:a},[ha((U(),ee("svg",Gp,Kp,512)),[[ya,!re(n)]]),ha((U(),ee("svg",Yp,Xp,512)),[[ya,re(n)]])],8,Wp))}}),Zp=Ce(Qp,[["__file","ToggleColorModeButton.vue"]]),eh=["title"],rh=he("div",{class:"icon","aria-hidden":"true"},[he("span"),he("span"),he("span")],-1),nh=[rh],ah=ue({__name:"ToggleSidebarButton",emits:["toggle"],setup(e){const r=Ue();return(n,a)=>(U(),ee("div",{class:"toggle-sidebar-button",title:re(r).toggleSidebar,"aria-expanded":"false",role:"button",tabindex:"0",onClick:a[0]||(a[0]=o=>n.$emit("toggle"))},nh,8,eh))}}),oh=Ce(ah,[["__file","ToggleSidebarButton.vue"]]),th=ue({__name:"Navbar",emits:["toggle-sidebar"],setup(e){const r=Ue(),n=fe(null),a=fe(null),o=fe(0),t=N(()=>o.value?{maxWidth:o.value+"px"}:{});Ui(zn.MOBILE,l=>{var c;const i=s(n.value,"paddingLeft")+s(n.value,"paddingRight");window.innerWidth<l?o.value=0:o.value=n.value.offsetWidth-i-(((c=a.value)==null?void 0:c.offsetWidth)||0)});function s(l,i){var u,m,f;const c=(f=(m=(u=l==null?void 0:l.ownerDocument)==null?void 0:u.defaultView)==null?void 0:m.getComputedStyle(l,null))==null?void 0:f[i],d=Number.parseInt(c,10);return Number.isNaN(d)?0:d}return(l,i)=>{const c=yr("NavbarSearch");return U(),ee("header",{ref_key:"navbar",ref:n,class:"navbar"},[ne(oh,{onToggle:i[0]||(i[0]=d=>l.$emit("toggle-sidebar"))}),he("span",{ref_key:"navbarBrand",ref:a},[ne(jp)],512),he("div",{class:"navbar-items-wrapper",style:Fn(t.value)},[we(l.$slots,"before"),ne(Gi,{class:"can-hide"}),we(l.$slots,"after"),re(r).colorModeSwitch?(U(),Ae(Zp,{key:0})):je("v-if",!0),ne(c)],4)],512)}}}),sh=Ce(th,[["__file","Navbar.vue"]]),ih={class:"page-meta"},lh={key:0,class:"meta-item edit-link"},ch={key:1,class:"meta-item last-updated"},dh={class:"meta-item-label"},uh={class:"meta-item-info"},mh={key:2,class:"meta-item contributors"},ph={class:"meta-item-label"},hh={class:"meta-item-info"},gh=["title"],fh=ue({__name:"PageMeta",setup(e){const r=()=>{const i=Ue(),c=_r(),d=fr();return N(()=>{if(!(d.value.editLink??i.value.editLink??!0))return null;const{repo:m,docsRepo:f=m,docsBranch:w="main",docsDir:P="",editLinkText:k}=i.value;if(!f)return null;const v=Up({docsRepo:f,docsBranch:w,docsDir:P,filePathRelative:c.value.filePathRelative,editLinkPattern:d.value.editLinkPattern??i.value.editLinkPattern});return v?{text:k??"Edit this page",link:v}:null})},n=()=>{const i=Ue(),c=_r(),d=fr();return N(()=>{var f,w;return!(d.value.lastUpdated??i.value.lastUpdated??!0)||!((f=c.value.git)!=null&&f.updatedTime)?null:new Date((w=c.value.git)==null?void 0:w.updatedTime).toLocaleString()})},a=()=>{const i=Ue(),c=_r(),d=fr();return N(()=>{var m;return d.value.contributors??i.value.contributors??!0?((m=c.value.git)==null?void 0:m.contributors)??null:null})},o=Ue(),t=r(),s=n(),l=a();return(i,c)=>{const d=yr("ClientOnly");return U(),ee("footer",ih,[re(t)?(U(),ee("div",lh,[ne(vr,{class:"meta-item-label",item:re(t)},null,8,["item"])])):je("v-if",!0),re(s)?(U(),ee("div",ch,[he("span",dh,_e(re(o).lastUpdatedText)+": ",1),ne(d,null,{default:Me(()=>[he("span",uh,_e(re(s)),1)]),_:1})])):je("v-if",!0),re(l)&&re(l).length?(U(),ee("div",mh,[he("span",ph,_e(re(o).contributorsText)+": ",1),he("span",hh,[(U(!0),ee(Pe,null,Rr(re(l),(u,m)=>(U(),ee(Pe,{key:m},[he("span",{class:"contributor",title:`email: ${u.email}`},_e(u.name),9,gh),m!==re(l).length-1?(U(),ee(Pe,{key:0},[Mr(", ")],64)):je("v-if",!0)],64))),128))])])):je("v-if",!0)])}}}),vh=Ce(fh,[["__file","PageMeta.vue"]]),bh={key:0,class:"page-nav"},yh={class:"inner"},Sh={key:0,class:"prev"},wh={key:1,class:"next"},Ph=ue({__name:"PageNav",setup(e){const r=i=>i===!1?null:ve(i)?Ko(i):Oo(i)?i:!1,n=(i,c,d)=>{const u=i.findIndex(m=>m.link===c);if(u!==-1){const m=i[u+d];return m!=null&&m.link?m:null}for(const m of i)if(m.children){const f=n(m.children,c,d);if(f)return f}return null},a=fr(),o=Yo(),t=Xr(),s=N(()=>{const i=r(a.value.prev);return i!==!1?i:n(o.value,t.path,-1)}),l=N(()=>{const i=r(a.value.next);return i!==!1?i:n(o.value,t.path,1)});return(i,c)=>s.value||l.value?(U(),ee("nav",bh,[he("p",yh,[s.value?(U(),ee("span",Sh,[ne(vr,{item:s.value},null,8,["item"])])):je("v-if",!0),l.value?(U(),ee("span",wh,[ne(vr,{item:l.value},null,8,["item"])])):je("v-if",!0)])])):je("v-if",!0)}}),Eh=Ce(Ph,[["__file","PageNav.vue"]]),kh={class:"page"},Ch={class:"theme-default-content"},jh=ue({__name:"Page",setup(e){return(r,n)=>{const a=yr("Content");return U(),ee("main",kh,[we(r.$slots,"top"),he("div",Ch,[we(r.$slots,"content-top"),ne(a),we(r.$slots,"content-bottom")]),ne(vh),ne(Eh),we(r.$slots,"bottom")])}}}),qh=Ce(jh,[["__file","Page.vue"]]),Ih=["onKeydown"],Ah={class:"sidebar-item-children"},xh=ue({__name:"SidebarItem",props:{item:{type:Object,required:!0},depth:{type:Number,required:!1,default:0}},setup(e){const r=e,{item:n,depth:a}=qa(r),o=Xr(),t=$r(),s=N(()=>Ji(n.value,o)),l=N(()=>({"sidebar-item":!0,"sidebar-heading":a.value===0,active:s.value,collapsible:n.value.collapsible})),i=N(()=>n.value.collapsible?s.value:!0),[c,d]=Tm(i.value),u=f=>{n.value.collapsible&&(f.preventDefault(),d())},m=t.afterEach(f=>{Hn(()=>{c.value=i.value})});return Wn(()=>{m()}),(f,w)=>{var k;const P=yr("SidebarItem",!0);return U(),ee("li",null,[re(n).link?(U(),Ae(vr,{key:0,class:Ge(l.value),item:re(n)},null,8,["class","item"])):(U(),ee("p",{key:1,tabindex:"0",class:Ge(l.value),onClick:u,onKeydown:Ed(u,["enter"])},[Mr(_e(re(n).text)+" ",1),re(n).collapsible?(U(),ee("span",{key:0,class:Ge(["arrow",re(c)?"down":"right"])},null,2)):je("v-if",!0)],42,Ih)),(k=re(n).children)!=null&&k.length?(U(),Ae(Hi,{key:2},{default:Me(()=>[ha(he("ul",Ah,[(U(!0),ee(Pe,null,Rr(re(n).children,v=>(U(),Ae(P,{key:`${re(a)}${v.text}${v.link}`,item:v,depth:re(a)+1},null,8,["item","depth"]))),128))],512),[[ya,re(c)]])]),_:1})):je("v-if",!0)])}}}),Th=Ce(xh,[["__file","SidebarItem.vue"]]),_h={key:0,class:"sidebar-items"},Lh=ue({__name:"SidebarItems",setup(e){const r=Xr(),n=Yo();return He(()=>{er(()=>r.hash,a=>{const o=document.querySelector(".sidebar");if(!o)return;const t=document.querySelector(`.sidebar a.sidebar-item[href="${r.path}${a}"]`);if(!t)return;const{top:s,height:l}=o.getBoundingClientRect(),{top:i,height:c}=t.getBoundingClientRect();i<s?t.scrollIntoView(!0):i+c>s+l&&t.scrollIntoView(!1)})}),(a,o)=>re(n).length?(U(),ee("ul",_h,[(U(!0),ee(Pe,null,Rr(re(n),t=>(U(),Ae(Th,{key:`${t.text}${t.link}`,item:t},null,8,["item"]))),128))])):je("v-if",!0)}}),Rh=Ce(Lh,[["__file","SidebarItems.vue"]]),Dh={class:"sidebar"},Mh=ue({__name:"Sidebar",setup(e){return(r,n)=>(U(),ee("aside",Dh,[ne(Gi),we(r.$slots,"top"),ne(Rh),we(r.$slots,"bottom")]))}}),Oh=Ce(Mh,[["__file","Sidebar.vue"]]),zh=ue({__name:"Layout",setup(e){const r=_r(),n=fr(),a=Ue(),o=N(()=>n.value.navbar!==!1&&a.value.navbar!==!1),t=Yo(),s=fe(!1),l=k=>{s.value=typeof k=="boolean"?k:!s.value},i={x:0,y:0},c=k=>{i.x=k.changedTouches[0].clientX,i.y=k.changedTouches[0].clientY},d=k=>{const v=k.changedTouches[0].clientX-i.x,S=k.changedTouches[0].clientY-i.y;Math.abs(v)>Math.abs(S)&&Math.abs(v)>40&&(v>0&&i.x<=80?l(!0):l(!1))},u=N(()=>[{"no-navbar":!o.value,"no-sidebar":!t.value.length,"sidebar-open":s.value},n.value.pageClass]);let m;He(()=>{m=$r().afterEach(()=>{l(!1)})}),Ta(()=>{m()});const f=Ni(),w=f.resolve,P=f.pending;return(k,v)=>(U(),ee("div",{class:Ge(["theme-container",u.value]),onTouchstart:c,onTouchend:d},[we(k.$slots,"navbar",{},()=>[o.value?(U(),Ae(sh,{key:0,onToggleSidebar:l},{before:Me(()=>[we(k.$slots,"navbar-before")]),after:Me(()=>[we(k.$slots,"navbar-after")]),_:3})):je("v-if",!0)]),he("div",{class:"sidebar-mask",onClick:v[0]||(v[0]=S=>l(!1))}),we(k.$slots,"sidebar",{},()=>[ne(Oh,null,{top:Me(()=>[we(k.$slots,"sidebar-top")]),bottom:Me(()=>[we(k.$slots,"sidebar-bottom")]),_:3})]),we(k.$slots,"page",{},()=>[re(n).home?(U(),Ae(kp,{key:0})):(U(),Ae(Gn,{key:1,name:"fade-slide-y",mode:"out-in",onBeforeEnter:re(w),onBeforeLeave:re(P)},{default:Me(()=>[(U(),Ae(qh,{key:re(r).path},{top:Me(()=>[we(k.$slots,"page-top")]),"content-top":Me(()=>[we(k.$slots,"page-content-top")]),"content-bottom":Me(()=>[we(k.$slots,"page-content-bottom")]),bottom:Me(()=>[we(k.$slots,"page-bottom")]),_:3}))]),_:3},8,["onBeforeEnter","onBeforeLeave"]))])],34))}}),Nh=Ce(zh,[["__file","Layout.vue"]]),Fh={class:"theme-container"},Bh={class:"page"},Uh={class:"theme-default-content"},Hh=he("h1",null,"404",-1),Jh=ue({__name:"NotFound",setup(e){const r=bn(),n=Ue(),a=n.value.notFound??["Not Found"],o=()=>a[Math.floor(Math.random()*a.length)],t=n.value.home??r.value,s=n.value.backToHome??"Back to home";return(l,i)=>{const c=yr("RouterLink");return U(),ee("div",Fh,[he("main",Bh,[he("div",Uh,[Hh,he("blockquote",null,_e(o()),1),ne(c,{to:re(t)},{default:Me(()=>[Mr(_e(re(s)),1)]),_:1},8,["to"])])])])}}}),Wh=Ce(Jh,[["__file","NotFound.vue"]]);const Gh=wr({enhance({app:e,router:r}){e.component("Badge",fm),e.component("CodeGroup",vm),e.component("CodeGroupItem",wm),e.component("AutoLinkExternalIcon",()=>{const a=e.component("ExternalLinkIcon");return a?ce(a):null}),e.component("NavbarSearch",()=>{const a=e.component("Docsearch")||e.component("SearchBox");return a?ce(a):null});const n=r.options.scrollBehavior;r.options.scrollBehavior=async(...a)=>(await Ni().wait(),n(...a))},setup(){Wm(),Km()},layouts:{Layout:Nh,NotFound:Wh}}),Vh={enhance:({app:e})=>{e.component("CCLicense-component",D(()=>y(()=>import("./CCLicense-component-80ae505b.js"),[]))),e.component("DocumentCover-component",D(()=>y(()=>import("./DocumentCover-component-c5a9b584.js"),[]))),e.component("DownloadPDF-component",D(()=>y(()=>import("./DownloadPDF-component-370f1aed.js"),[])))}};/*! medium-zoom 1.0.8 | MIT License | https://github.com/francoischalifour/medium-zoom */var Br=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var n=arguments[r];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},ta=function(r){return r.tagName==="IMG"},Kh=function(r){return NodeList.prototype.isPrototypeOf(r)},la=function(r){return r&&r.nodeType===1},is=function(r){var n=r.currentSrc||r.src;return n.substr(-4).toLowerCase()===".svg"},ls=function(r){try{return Array.isArray(r)?r.filter(ta):Kh(r)?[].slice.call(r).filter(ta):la(r)?[r].filter(ta):typeof r=="string"?[].slice.call(document.querySelectorAll(r)).filter(ta):[]}catch{throw new TypeError(`The provided selector is invalid.
Expects a CSS selector, a Node element, a NodeList or an array.
See: https://github.com/francoischalifour/medium-zoom`)}},Yh=function(r){var n=document.createElement("div");return n.classList.add("medium-zoom-overlay"),n.style.background=r,n},$h=function(r){var n=r.getBoundingClientRect(),a=n.top,o=n.left,t=n.width,s=n.height,l=r.cloneNode(),i=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,c=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return l.removeAttribute("id"),l.style.position="absolute",l.style.top=a+i+"px",l.style.left=o+c+"px",l.style.width=t+"px",l.style.height=s+"px",l.style.transform="",l},en=function(r,n){var a=Br({bubbles:!1,cancelable:!1,detail:void 0},n);if(typeof window.CustomEvent=="function")return new CustomEvent(r,a);var o=document.createEvent("CustomEvent");return o.initCustomEvent(r,a.bubbles,a.cancelable,a.detail),o},Xh=function e(r){var n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},a=window.Promise||function(q){function L(){}q(L,L)},o=function(q){var L=q.target;if(L===J){w();return}x.indexOf(L)!==-1&&P({target:L})},t=function(){if(!(G||!g.original)){var q=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(Z-q)>M.scrollOffset&&setTimeout(w,150)}},s=function(q){var L=q.key||q.keyCode;(L==="Escape"||L==="Esc"||L===27)&&w()},l=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},L=q;if(q.background&&(J.style.background=q.background),q.container&&q.container instanceof Object&&(L.container=Br({},M.container,q.container)),q.template){var R=la(q.template)?q.template:document.querySelector(q.template);L.template=R}return M=Br({},M,L),x.forEach(function(ie){ie.dispatchEvent(en("medium-zoom:update",{detail:{zoom:F}}))}),F},i=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};return e(Br({},M,q))},c=function(){for(var q=arguments.length,L=Array(q),R=0;R<q;R++)L[R]=arguments[R];var ie=L.reduce(function(W,oe){return[].concat(W,ls(oe))},[]);return ie.filter(function(W){return x.indexOf(W)===-1}).forEach(function(W){x.push(W),W.classList.add("medium-zoom-image")}),A.forEach(function(W){var oe=W.type,te=W.listener,ze=W.options;ie.forEach(function(De){De.addEventListener(oe,te,ze)})}),F},d=function(){for(var q=arguments.length,L=Array(q),R=0;R<q;R++)L[R]=arguments[R];g.zoomed&&w();var ie=L.length>0?L.reduce(function(W,oe){return[].concat(W,ls(oe))},[]):x;return ie.forEach(function(W){W.classList.remove("medium-zoom-image"),W.dispatchEvent(en("medium-zoom:detach",{detail:{zoom:F}}))}),x=x.filter(function(W){return ie.indexOf(W)===-1}),F},u=function(q,L){var R=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return x.forEach(function(ie){ie.addEventListener("medium-zoom:"+q,L,R)}),A.push({type:"medium-zoom:"+q,listener:L,options:R}),F},m=function(q,L){var R=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return x.forEach(function(ie){ie.removeEventListener("medium-zoom:"+q,L,R)}),A=A.filter(function(ie){return!(ie.type==="medium-zoom:"+q&&ie.listener.toString()===L.toString())}),F},f=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},L=q.target,R=function(){var W={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},oe=void 0,te=void 0;if(M.container)if(M.container instanceof Object)W=Br({},W,M.container),oe=W.width-W.left-W.right-M.margin*2,te=W.height-W.top-W.bottom-M.margin*2;else{var ze=la(M.container)?M.container:document.querySelector(M.container),De=ze.getBoundingClientRect(),Je=De.width,Ne=De.height,Pr=De.left,Er=De.top;W=Br({},W,{width:Je,height:Ne,left:Pr,top:Er})}oe=oe||W.width-M.margin*2,te=te||W.height-M.margin*2;var ir=g.zoomedHd||g.original,Le=is(ir)?oe:ir.naturalWidth||oe,C=is(ir)?te:ir.naturalHeight||te,H=ir.getBoundingClientRect(),O=H.top,K=H.left,de=H.width,p=H.height,h=Math.min(Math.max(de,Le),oe)/de,b=Math.min(Math.max(p,C),te)/p,E=Math.min(h,b),j=(-K+(oe-de)/2+M.margin+W.left)/E,I=(-O+(te-p)/2+M.margin+W.top)/E,B="scale("+E+") translate3d("+j+"px, "+I+"px, 0)";g.zoomed.style.transform=B,g.zoomedHd&&(g.zoomedHd.style.transform=B)};return new a(function(ie){if(L&&x.indexOf(L)===-1){ie(F);return}var W=function Je(){G=!1,g.zoomed.removeEventListener("transitionend",Je),g.original.dispatchEvent(en("medium-zoom:opened",{detail:{zoom:F}})),ie(F)};if(g.zoomed){ie(F);return}if(L)g.original=L;else if(x.length>0){var oe=x;g.original=oe[0]}else{ie(F);return}if(g.original.dispatchEvent(en("medium-zoom:open",{detail:{zoom:F}})),Z=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,G=!0,g.zoomed=$h(g.original),document.body.appendChild(J),M.template){var te=la(M.template)?M.template:document.querySelector(M.template);g.template=document.createElement("div"),g.template.appendChild(te.content.cloneNode(!0)),document.body.appendChild(g.template)}if(g.original.parentElement&&g.original.parentElement.tagName==="PICTURE"&&g.original.currentSrc&&(g.zoomed.src=g.original.currentSrc),document.body.appendChild(g.zoomed),window.requestAnimationFrame(function(){document.body.classList.add("medium-zoom--opened")}),g.original.classList.add("medium-zoom-image--hidden"),g.zoomed.classList.add("medium-zoom-image--opened"),g.zoomed.addEventListener("click",w),g.zoomed.addEventListener("transitionend",W),g.original.getAttribute("data-zoom-src")){g.zoomedHd=g.zoomed.cloneNode(),g.zoomedHd.removeAttribute("srcset"),g.zoomedHd.removeAttribute("sizes"),g.zoomedHd.removeAttribute("loading"),g.zoomedHd.src=g.zoomed.getAttribute("data-zoom-src"),g.zoomedHd.onerror=function(){clearInterval(ze),console.warn("Unable to reach the zoom image target "+g.zoomedHd.src),g.zoomedHd=null,R()};var ze=setInterval(function(){g.zoomedHd.complete&&(clearInterval(ze),g.zoomedHd.classList.add("medium-zoom-image--opened"),g.zoomedHd.addEventListener("click",w),document.body.appendChild(g.zoomedHd),R())},10)}else if(g.original.hasAttribute("srcset")){g.zoomedHd=g.zoomed.cloneNode(),g.zoomedHd.removeAttribute("sizes"),g.zoomedHd.removeAttribute("loading");var De=g.zoomedHd.addEventListener("load",function(){g.zoomedHd.removeEventListener("load",De),g.zoomedHd.classList.add("medium-zoom-image--opened"),g.zoomedHd.addEventListener("click",w),document.body.appendChild(g.zoomedHd),R()})}else R()})},w=function(){return new a(function(q){if(G||!g.original){q(F);return}var L=function R(){g.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(g.zoomed),g.zoomedHd&&document.body.removeChild(g.zoomedHd),document.body.removeChild(J),g.zoomed.classList.remove("medium-zoom-image--opened"),g.template&&document.body.removeChild(g.template),G=!1,g.zoomed.removeEventListener("transitionend",R),g.original.dispatchEvent(en("medium-zoom:closed",{detail:{zoom:F}})),g.original=null,g.zoomed=null,g.zoomedHd=null,g.template=null,q(F)};G=!0,document.body.classList.remove("medium-zoom--opened"),g.zoomed.style.transform="",g.zoomedHd&&(g.zoomedHd.style.transform=""),g.template&&(g.template.style.transition="opacity 150ms",g.template.style.opacity=0),g.original.dispatchEvent(en("medium-zoom:close",{detail:{zoom:F}})),g.zoomed.addEventListener("transitionend",L)})},P=function(){var q=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},L=q.target;return g.original?w():f({target:L})},k=function(){return M},v=function(){return x},S=function(){return g.original},x=[],A=[],G=!1,Z=0,M=n,g={original:null,zoomed:null,zoomedHd:null,template:null};Object.prototype.toString.call(r)==="[object Object]"?M=r:(r||typeof r=="string")&&c(r),M=Br({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},M);var J=Yh(M.background);document.addEventListener("click",o),document.addEventListener("keyup",s),document.addEventListener("scroll",t),window.addEventListener("resize",w);var F={open:f,close:w,toggle:P,update:l,clone:i,attach:c,detach:d,on:u,off:m,getOptions:k,getImages:v,getZoomedImage:S};return F};function Qh(e,r){r===void 0&&(r={});var n=r.insertAt;if(!(!e||typeof document>"u")){var a=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css",n==="top"&&a.firstChild?a.insertBefore(o,a.firstChild):a.appendChild(o),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(document.createTextNode(e))}}var Zh=".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";Qh(Zh);const eg=Xh,rg=Symbol("mediumZoom");const ng=":not(a) > img",ag={},og=500,tg=wr({enhance({app:e,router:r}){const n=eg(ag);n.refresh=(a=ng)=>{n.detach(),n.attach(a)},e.provide(rg,n),r.afterEach(()=>{setTimeout(()=>n.refresh(),og)})}}),sg=e=>e instanceof Element?document.activeElement===e&&(["TEXTAREA","SELECT","INPUT"].includes(e.tagName)||e.hasAttribute("contenteditable")):!1,ig=(e,r)=>r.some(n=>{if(ve(n))return n===e.key;const{key:a,ctrl:o=!1,shift:t=!1,alt:s=!1}=n;return a===e.key&&o===e.ctrlKey&&t===e.shiftKey&&s===e.altKey}),lg=/[^\x00-\x7F]/,cg=e=>e.split(/\s+/g).map(r=>r.trim()).filter(r=>!!r),cs=e=>e.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"),ds=(e,r)=>{const n=r.join(" "),a=cg(e);if(lg.test(e))return a.some(s=>n.toLowerCase().indexOf(s)>-1);const o=e.endsWith(" ");return new RegExp(a.map((s,l)=>a.length===l+1&&!o?`(?=.*\\b${cs(s)})`:`(?=.*\\b${cs(s)}\\b)`).join("")+".+","gi").test(n)},dg=({input:e,hotKeys:r})=>{if(r.value.length===0)return;const n=a=>{e.value&&ig(a,r.value)&&!sg(a.target)&&(a.preventDefault(),e.value.focus())};He(()=>{document.addEventListener("keydown",n)}),Wn(()=>{document.removeEventListener("keydown",n)})},ug=[{title:"",headers:[],path:"/",pathLocale:"/",extraFields:[`---\r
home: true\r
title: \r
heroImage: /images/quote.jpg\r
tagline: \r
actions:\r
- text: PSP (English)    →\r
  link: /en/\r
  type: secondary\r
- text: PSP (Castellano) →\r
  link: /es/\r
  type: secondary \r
features:\r
- title: CFGS DAM\r
  details: Módulo de 2º curso\r
- title: Profesor\r
  details: Vicente Martínez Martínez\r
- title: Centro\r
  details: IES Doctor Balmis (Alicante)\r
footer: © 2024/2025\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Except where otherwise noted, content on this site (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources">PSP class notes</a>) by <span property="cc:attributionName">Vicente Martínez</span> is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>    \r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Excepto donde se indique lo contrario, el contenido de este sitio (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources/es/">Apuntes de PSP</a>) creado por <span property="cc:attributionName">Vicente Martínez</span> está bajo una licencia  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>\r
`]},{title:"PSP",headers:[{level:2,title:"Acerca de",slug:"acerca-de",link:"#acerca-de",children:[]},{level:2,title:"Segundo apartado",slug:"segundo-apartado",link:"#segundo-apartado",children:[]},{level:2,title:"Segundo apartado",slug:"segundo-apartado-1",link:"#segundo-apartado-1",children:[]}],path:"/test_page.html",pathLocale:"/",extraFields:[`---\r
title: PSP\r
---\r
\r
<div class="pagebreak"></div>\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="PSP" />\r
\r
# PSP\r
\r
[[toc]]\r
\r
## Acerca de\r
\r
::: info\r
["Google"](http://www.google.es)\r
:::\r
\r
::: tip Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: warning Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: danger Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: question Chech your skills\r
¿Qué pasará ahora?\r
:::\r
<div class="pagebreak"></div>\r
\r
## Segundo apartado\r
\r
\`\`\`java\r
public static void main() {\r
    return;\r
}\r
\`\`\`\r
\r
::: info\r
["Google"](http://www.google.es)\r
:::\r
\r
::: tip Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: warning Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: danger Aviso\r
 ["Google"](http://www.google.es)\r
:::\r
\r
::: question Chech your skills\r
¿Qué pasará ahora?\r
:::\r
<div class="pagebreak"></div>\r
\r
## Segundo apartado\r
\r
\`\`\`java\r
public static void main() {\r
    return;\r
}\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
\r
<!--\r
## Diagrama de flujo\r
![diagrama de sequencia|, 20%](/media/puml_sequence_test.png)\r
\r
\`\`\`puml {align="center", style="zoom:1"}\r
@startuml\r
skinparam handwritten true\r
title Protocolo validación user/passwd\r
header Prueba\r
footer Prueba\r
hide footbox\r
skinparam sequence {\r
ParticipantBorderColor DeepSkyBlue\r
ParticipantBackgroundColor DodgerBlue\r
} \r
note left of Cliente: El programa cliente lee por teclado\\nun usuario y una contraseña \r
Cliente->Servidor: Usuario\r
Cliente->Servidor: Password\r
note right of Servidor: El programa servidor comprueba\\n- Si el usuario es "vicente"\\n     contesta "USEROK" \\nsino \\n    contesta "USERERROR"\r
note right of Servidor: El programa servidor comprueba\\n- Si el password es "psp"\\n     contesta "PASSOK" \\nsino \\n    contesta "PASSERROR"\r
Servidor->Cliente: USEROK ó USERERROR\r
Servidor->Cliente: PASSOK ó PASSERROR\r
note left of Cliente: El programa mostrará un mensaje\\nen base a la información recibida\\nIndicando si el usuario y la contraseña\\nenviadas han diso correctas o no\r
@enduml\r
\`\`\`\r
-->\r
`]},{title:"PSP - Documentation Site",headers:[],path:"/en/",pathLocale:"/en/",extraFields:[`---\r
home: true\r
title: PSP - Documentation Site\r
heroImage: /LogoPSP_en.png\r
tagline: Class notes\r
actions:\r
- text: Unit 1 (  Intro  )    →\r
  link: /en/unit1/\r
  type: secondary\r
- text: Unit 2 (  Processes  )    →\r
  link: /en/unit2/\r
  type: secondary\r
- text: Unit 3 (  Threads  )    →\r
  link: /en/unit3/\r
  type: secondary\r
- text: Unit 4 (  Sockets  )    →\r
  link: /en/unit4/\r
  type: secondary\r
- text: Unit 5 (  Services  )    →\r
  link: /en/unit5/\r
  type: secondary\r
- text: Unit 6 (  Security  )    →\r
  link: /en/unit6/\r
  type: secondary\r
features:\r
- title: \r
  details: \r
- title: \r
  details: \r
- title: \r
  details: \r
footer: © 2024/2025\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Except where otherwise noted, content on this site (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources">PSP class notes</a>) by <span property="cc:attributionName">Vicente Martínez</span> is licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>    \r
`]},{title:"PSP - Página  de documentación",headers:[],path:"/es/",pathLocale:"/es/",extraFields:[`---\r
home: true\r
title: PSP - Página  de documentación\r
heroImage: /LogoPSP_es.png\r
tagline: Apuntes de clase\r
actions: \r
- text: Tema 1 (  Intro  )       →\r
  link: /es/unit1/\r
  type: secondary\r
- text: Tema 2 (  Procesos  )       →\r
  link: /es/unit2/\r
  type: secondary\r
- text: Tema 3 (  Hilos  )       →\r
  link: /es/unit3/\r
  type: secondary\r
- text: Tema 4 (  Sockets  )    →\r
  link: /es/unit4/\r
  type: secondary\r
- text: Tema 5 (  Servicios  )    →\r
  link: /es/unit5/\r
  type: secondary\r
- text: Tema 6 (  Seguridad  )    →\r
  link: /es/unit6/\r
  type: secondary\r
features:\r
- title: \r
  details: \r
- title: \r
  details: \r
- title: \r
  details: \r
footer: © 2024 / 2025\r
---\r
\r
<div class="cclicense" align="center">\r
  <p xmlns:cc="http://creativecommons.org/ns#" xmlns:dct="http://purl.org/dc/terms/">Excepto donde se indique lo contrario, el contenido de este sitio (<a property="dct:title" rel="cc:attributionURL" href="https://psp2dam.github.io/psp_sources/es/">Apuntes de PSP</a>) creado por <span property="cc:attributionName">Vicente Martínez</span> está bajo una licencia  <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.es" target="_blank" rel="license noopener noreferrer" style="display:inline-block;"> CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></p>\r
</div>`]},{title:"1.2 Concurrency",headers:[{level:2,title:"1.2.1. Concurrency vs Parallelism",slug:"_1-2-1-concurrency-vs-parallelism",link:"#_1-2-1-concurrency-vs-parallelism",children:[{level:3,title:"Monoprocess",slug:"monoprocess",link:"#monoprocess",children:[]},{level:3,title:"Multitasking",slug:"multitasking",link:"#multitasking",children:[]},{level:3,title:"Parallelism",slug:"parallelism",link:"#parallelism",children:[]}]},{level:2,title:"1.2.2. Distributed systems",slug:"_1-2-2-distributed-systems",link:"#_1-2-2-distributed-systems",children:[]},{level:2,title:"1.2.3. Advantages and disadvantages",slug:"_1-2-3-advantages-and-disadvantages",link:"#_1-2-3-advantages-and-disadvantages",children:[]},{level:2,title:"1.2.4. Bernstein's conditions",slug:"_1-2-4-bernstein-s-conditions",link:"#_1-2-4-bernstein-s-conditions",children:[]}],path:"/en/unit1/concurrency.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.2 Concurrency\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.2. Concurrency" />\r
\r
# 1.2. Concurrency\r
\r
[[toc]]\r
\r
According to the [Collins dictionary](https://www.collinsdictionary.com/es/diccionario/ingles/concurrency) some of the senses os the word concurrency are\r
> Cooperation or combination. Simultaneous occurrence; coincidence.\r
\r
If we change occurrence to  \`process\`, we get a definition closer to its sense in the computer science.\r
\r
This is not the first time the word  \`process\` appears, that is because they are one of the most important concepts in programming.\r
\r
## 1.2.1. Concurrency vs Parallelism\r
\r
Now that we already know what a process is, let's look at its relationship with the hardware where they are run.\r
\r
### Monoprocess\r
\r
Maybe we want to run many processes at the same time, but if we only have one processor unit, it's absolutely impossible to have more than one task running at the same time.\r
\r
One possibility is to run the tasks in sequence. The system starts running one process and it doesn't start with the next one until the current task has completely finished. That is what happens in systems that are able to do one task at a time, something really strange nowadays.\r
\r
![Sequential execution of tasks (monoprocessor system)](./../../media/unit1/gantt_sequential.svg)\r
\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Sequential execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1       :done, t1, 0, 4s\r
Process 2     : active, t2, after t1, 5s\r
Process 3     : crit, t3, after t2, 2s\r
Process 4    : t4, after t3, 5s\r
\`\`\`\r
-->\r
\r
### Multitasking\r
\r
In a multiprogramming system there are one or more programs loaded in main memory which are ready to execute. Only one program at a time is able to get the CPU for executing its instructions while all the others are waiting their turn.\r
\r
The main idea of multiprogramming is to maximize the use of CPU time. Indeed, suppose the currently running process is performing an I/O task (which, by definition, does not need the CPU to be accomplished). Then, the OS may interrupt that process and give the control to one of the other in-main-memory programs that are ready to execute (i.e. process context switching).  It is said that running processes are multiplexed on time.\r
\r
This way, the OS gives as the illusion that many processes are running simultaneously. That is commonly called \`multitasking\`.\r
\r
![Concurrent execution of tasks (monoprocessor system)](./../../media/unit1/gantt_concurrent.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Concurrent execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 3  :crit, t3, after t2, 2s\r
Process 4  : t4, after t3, 1s\r
Process 1  :done, t5, after t4, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 4  : t7, after t6, 3s\r
Process 2  :active, t8, after t7, 2s\r
Process 4  : t9, after t8, 1s\r
\`\`\`\r
-->\r
\r
On both previous images can be observed how the total CPU time to complete all processes is the same in both models. Nonetheless, on the second model the user has the sensation that all tasks are running at the same time.\r
\r
### Parallelism\r
\r
Multiprocessing sometimes refers to executing multiple processes (programs) at the same time. This might be misleading because we have already introduced the term “multiprogramming” to describe that before.\r
In fact, multiprocessing refers to the hardware (i.e., the CPU units) rather than the software (i.e., running processes). If the underlying hardware provides more than one processor then that is multiprocessing. Several variations on the basic scheme exist, e.g., multiple cores on one die or multiple dies in one package or multiple packages in one system.\r
Anyway, a system can be both multiprogrammed by having multiple programs running at the same time and multiprocessing by having more than one physical processor.\r
\r
Nowadays most devices, from desktop to laptops through mobile devices and IoT, all of them offer multiprocess capabilities, that is, they have mor than one processing unit to really do many tasks at the same time, no simulate it.\r
This kind of execution is called \`parallelism\`.\r
\r
![Parallel execution of tasks (dual processor system)](./../../media/unit1/gantt_parallel.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Parallel execution of tasks (dual processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 1  :done, t5, after t2, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 2  :active, t8, after t6, 2s\r
section Processor 2\r
Process 3  :crit, t3, 0, 2s\r
Process 4  : t4, after t3, 1s\r
Process 4  : t7, after t4, 3s\r
Process 4  : t9, after t7, 1s\r
\`\`\`\r
-->\r
\r
The bigger the processor units number is, the less time the tasks it takes to run and the user will have a better experience. This is one of the goals of operating systems, schedule properly the tasks to minimize running times, wait times and to maximize the resources use , mainly the processors.\r
\r
::: question cores vs threads\r
have you bought a microprocessor recently? Are you up-to-date in the state of the art of hardware? Then, you'll probably know that one of the main characteristics of a microprocessor are its  **cores number** (4, 8, 16).\r
\r
Moreover, the number of cores is completed with another configuration, **treads number**, that usually is twice the number of cores.\r
\r
¿What is the relationship between processor threads and concurrency? ¿A computer system with 8 cores / 16 threads means that it can run up to 16 process in parallel?\r
:::\r
\r
## 1.2.2. Distributed systems\r
\r
> "A collection of independent computers that appears to its users as a single. coherent system"\r
>\r
> "Andrew S. Tanembaum"\r
\r
This definition has several important aspects:\r
\r
- The first one is that a distributed system consists of components (i.e., computers) that are autonomous.\r
- A second aspect is that users (people or programs) think they are dealing with a single system. This means that one way or the other the autonomous components need to collaborate. How to establish this collaboration lies at the heart of developing distributed systems\r
\r
The most known and famous example of distributed system is \`the Internet\`. The Internet is seen by the users as a single huge documents repository, that is, a single system able to provide almost any information or service. Notwithstanding the above, we know that is made up of millions of devices located all over the world and interconnected.\r
\r
It began with the need to share resources. Actually the state-of-the-art on these systems are \`Cloud Computing\` or cloud services. It's said that a distributed system is where software components are distributed on a network and they communicate and coordinate with each other by using message passing.\r
\r
Let's concentrate on important characteristics of distributed systems:\r
\r
- Concurrency. Allows running multiple process in parallel.\r
- Global watch independency. Implies synchronization using messaging.\r
- Scalability: distributed systems should also be relatively easy to expand or scale. This characteristic is a direct consequence of having independent computers, but at the same time, hiding how these computers actually take part in the system as a whole.\r
- Fault tolerance: A distributed system will normally be continuously available, although perhaps some parts may be temporarily out of order.\r
\r
## 1.2.3. Advantages and disadvantages\r
\r
Pros of parallel processing:\r
\r
- Simultaneous running of tasks\r
- Reduce total running time\r
- Helps to solve big and complex problems\r
- Use of non local resources on the network\r
- Reduce expenses by taking advantage of shared resources. It's not necessary to invest on a supercomputer because it's possible to have the same processing power with smaller computers distributed\r
\r
Cons of parallel processing:\r
\r
- Compilers and development environments are more complex to develop.\r
- Parallel programs are more difficult to write\r
- Higher power consumption\r
- Bigger data access complexity\r
- High communication and synchronization complexity on subtasks <Badge type="danger" text="warning" vertical="middle" />\r
\r
Pros of distributed programming\r
\r
- Resource & data sharing\r
- Scale under demand\r
- Bigger flexibility to distribute processing load\r
- High availability\r
- Support for distributed applications\r
- Open philosophy and heterogeneous development\r
\r
::: question Scalability\r
Scalability means the possibility of increase the processing, storage, and capabilities of a system\r
\r
Research about differences, pros and cons of  \`vertical scaling\` vs \`horizontal scaling\`.\r
:::\r
\r
Cons of distributed programming\r
\r
- Increase system complexity\r
- New specialized software is needed\r
- Communication problems (data lost, overflows, saturation, etc.)\r
- Security problems, DDoS attacks\r
\r
Distributed and parallel programming examples\r
\r
- Weather forecast analysis and research\r
- Human genome research\r
- Biosphere modelling\r
- Seismic predictions\r
- Molecule simulation\r
\r
::: info Example of parallel and distributed programming\r
[Allien intelligence research- SETI Project](https://setiathome.berkeley.edu/sah_about.php)\r
:::\r
\r
## 1.2.4. Bernstein's conditions\r
\r
Once we know what a concurrent program is and the different hardware architectures that support them, let's try to identify which program parts can be executed concurrently.\r
\r
If we look at the following code we can determine that the first sentence must be run before the second one in order to get always the same result (for the same input data set).\r
\r
\`\`\`java\r
x = x + 1;\r
y = x + 1;\r
\`\`\`\r
\r
Though in the following code the order isn't important at all and doesn't change the final result (output data set). In this situation all of them cam be run at the same time increasing processing speed.\r
\r
\`\`\`java\r
x = 1;\r
y = 2;\r
z = 3;\r
\`\`\`\r
\r
A.J. Bernstein’s Conditions are the conditions applied on two statements S1 and S2 that are to be executed in the processor. It states that three conditions that are explained below must be satisfied for two successive statements S<sub>i</sub> y S<sub>j</sub> to be executed concurrently and still produce the same result\r
\r
Bernstein conditions are rely on the subsequent two sets of variables:\r
\r
- R(S<sub>k</sub>) = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...} read set consists of all variables that are read during execution of k statements set\r
- W(S<sub>k</sub>) = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, ...} write set consists of all variables that are written (updated) during execution of k statements set.\r
\r
To run concurrently both statement sets  S<sub>i</sub> y S<sub>j</sub> these three conditions must be matched simultaneously:\r
\r
- R(S<sub>i</sub>) ∩ W(S<sub>j</sub>)\r
- W(S<sub>i</sub>) ∩ R(S<sub>j</sub>)\r
- W(S<sub>i</sub>) ∩ W(S<sub>j</sub>)\r
  \r
::: question Which of these instructions can be run concurrently?\r
\r
\`\`\`java\r
a = x + y;\r
b = z - 1;\r
c = a - b;\r
w = c + 1;\r
\`\`\`\r
\r
:::\r
\r
First of all we must get R & W sets for each sentence\r
\r
> R(S<sub>1</sub>) = {x, y}\r
> \r
> W(S<sub>1</sub>) = {a}\r
\r
> R(S<sub>2</sub>) = {z}  \r
> \r
> W(S<sub>2</sub>) = {b}\r
\r
> R(S<sub>3</sub>) = {a, b}\r
> \r
> W(S<sub>3</sub>) = {c}\r
\r
> R(S<sub>4</sub>) = {c}\r
> \r
> W(S<sub>4</sub>) = {w}\r
\r
And now let's apply the rules for each pair of sentences\r
\r
>R(S<sub>1</sub>) ∩ W(S<sub>2</sub>) = ∅\r
>\r
>W(S<sub>1</sub>) ∩ R(S<sub>2</sub>) = ∅\r
>\r
>W(S<sub>1</sub>) ∩ W(S<sub>2</sub>) = ∅         // They can be run simultaneously\r
\r
>R(S<sub>1</sub>) ∩ W(S<sub>3</sub>) = ∅\r
>\r
>W(S<sub>1</sub>) ∩ R(S<sub>3</sub>) = {a} ≠ ∅\r
>\r
>W(S<sub>1</sub>) ∩ W(S<sub>3</sub>) = ∅         // NO parallelism without problems\r
\r
>R(S<sub>1</sub>) ∩ W(S<sub>4</sub>) = ∅\r
>\r
>W(S<sub>1</sub>) ∩ R(S<sub>4</sub>) = ∅\r
>\r
>W(S<sub>1</sub>) ∩ W(S<sub>4</sub>) = ∅         // They can be run simultaneously\r
\r
>R(S<sub>2</sub>) ∩ W(S<sub>3</sub>) = ∅\r
>\r
>W(S<sub>2</sub>) ∩ R(S<sub>3</sub>) = {b] ≠ ∅\r
>\r
>W(S<sub>2</sub>) ∩ W(S<sub>3</sub>) = ∅         // NO parallelism without problems\r
\r
>R(S<sub>2</sub>) ∩ W(S<sub>4</sub>) = ∅\r
>\r
>W(S<sub>2</sub>) ∩ R(S<sub>4</sub>) = ∅\r
>\r
>W(S<sub>2</sub>) ∩ W(S<sub>4</sub>) = ∅         // They can be run simultaneously\r
\r
>R(S<sub>3</sub>) ∩ W(S<sub>4</sub>) = ∅\r
>\r
>W(S<sub>3</sub>) ∩ R(S<sub>4</sub>) = {c} ≠ ∅\r
>\r
>W(S<sub>3</sub>) ∩ W(S<sub>4</sub>) = ∅         // NO parallelism without problems\r
`]},{title:"1 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit1/",pathLocale:"/en/",extraFields:[`---\r
title: 1 Introduction\r
---\r
\r
# Unit 1. Concurrent programming\r
\r
In this first unit we will learn about topic keys related to concurrent programming together with most of the vocabulary that we are going to use in this course.\r
\r
Digital technology has transformed nearly every aspect of modern life. Travel, work, shopping, entertainment, and communications are just some of the areas that have been revolutionized in recent decades. It's now rare to find an electronic device or piece of machinery that doesn't incorporate digital technology in some way.\r
\r
Digital technology means that devices can be more compact, faster, lighter, and more versatile. Huge amounts of information can be stored locally or remotely and moved around virtually instantaneously. Even the term "information" has expanded to include media such as photos, audio, and video, and no longer refers to just words and numbers.\r
\r
As programmers we should be capable of getting the maximum from software and hardware in our applications.\r
\r
There are a lot of tasks that need higher processing power to consume a huge amount of data. Two examples of this are \`Big Data\` and \`AI\` applications. These computing fields are rising in importance and require all the power the concurrent programming and the underlying hardware can offer.\r
\r
::: details What dou you think concurrency is?\r
We are gonna discuss it at class.\r
We will define the concept bit by bit throughout this course\r
:::\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To differentiate process and program\r
- To understand what concurrency is\r
- To know about relationship and differences between the two basic execution units: processes and threads.\r
- To know the basics about concurrent programming\r
- To know how concurrency performs on OS and hardware.\r
`]},{title:"1.3 Processes in the OS",headers:[{level:2,title:"1.3.1. The OS kernel",slug:"_1-3-1-the-os-kernel",link:"#_1-3-1-the-os-kernel",children:[]},{level:2,title:"1.3.2. Process conntrol in GNU/Linux",slug:"_1-3-2-process-conntrol-in-gnu-linux",link:"#_1-3-2-process-conntrol-in-gnu-linux",children:[{level:3,title:"Command to get the process PiD",slug:"command-to-get-the-process-pid",link:"#command-to-get-the-process-pid",children:[]},{level:3,title:"Commands to view active processes in GNU/Linux",slug:"commands-to-view-active-processes-in-gnu-linux",link:"#commands-to-view-active-processes-in-gnu-linux",children:[]},{level:3,title:"Process control",slug:"process-control",link:"#process-control",children:[]}]},{level:2,title:"1.3.3. Process states",slug:"_1-3-3-process-states",link:"#_1-3-3-process-states",children:[]},{level:2,title:"1.3.4 Process scheduler",slug:"_1-3-4-process-scheduler",link:"#_1-3-4-process-scheduler",children:[]},{level:2,title:"1.3.5. Process scheduling algorithms",slug:"_1-3-5-process-scheduling-algorithms",link:"#_1-3-5-process-scheduling-algorithms",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",link:"#fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",link:"#sjf-shortest-job-first",children:[]},{level:3,title:"Priority scheduling",slug:"priority-scheduling",link:"#priority-scheduling",children:[]},{level:3,title:"Round Robin",slug:"round-robin",link:"#round-robin",children:[]},{level:3,title:"Scheduler with I/O operations or locks",slug:"scheduler-with-i-o-operations-or-locks",link:"#scheduler-with-i-o-operations-or-locks",children:[]}]}],path:"/en/unit1/operatingsystem.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.3 Processes in the OS\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.3. Processes in the OS" />\r
\r
# 1.3. Processes in the Operating System\r
\r
[[toc]]\r
\r
## 1.3.1. The OS kernel\r
\r
The \`kernel or OS core\` is the responsible of the basic functions on the system and the resources management. It's accessed by systems calls. it is the smaller part of the OS and usually it's coded in low-level languages to improve its performance. The rest of the OS is called system apps.\r
\r
Essentially, a process is what a program becomes when it is loaded into memory from a secondary storage medium like a hard disk drive or an removable drive. Each process has its own address space, which typically contains both program instructions and data. Despite the fact that an individual processor or processor core can only execute one program instruction at a time, a large number of processes can be executed over a relatively short period of time by briefly assigning each process to the processor in turn.\r
\r
When a user starts an application program, the operating system's \`high-level scheduler (HLS)\` loads all or part of the program code from secondary storage into memory. It then creates a data structure in memory called a process control block (PCB) that will be used to hold information about the process, such as its current status and where in memory it is located.\r
\r
The operating system also maintains a separate process table in memory that lists all the user processes currently loaded. When a new process is created, it is given a unique process identification number (PID) and a new record is created for it in the process table which includes the address of the process control block in memory.\r
\r
As well as allocating memory space, loading the process, and creating the necessary data structures, the operating system must also allocate resources such as access to I/O devices and disk space if the process requires them. Information about the resources allocated to a process is also held within the process control block. The operating system's \`low-level scheduler (LLS)\` is **responsible for allocating CPU time to each process in turn**.\r
\r
When a process makes the transition from one state to another, the operating system updates the information in its PCB. When the process is terminated, the operating system removes it from the process table and frees the memory and any other resources allocated to the process so that they become available to other processes. The diagram below illustrates the relationship between the process table and the various process control blocks.\r
\r
These \`context changes\` are time and resource consuming. We will talk about this later, with a smaller running unit \`threads\`, that solve this problem partially.\r
\r
![Process Control Block](./../../media/unit1/process_control_blocks.gif)\r
\r
The process control block (PCB) maintains information that the operating system needs in order to manage a process. PCBs typically include information such as the process ID, the current state of the process (e.g. running, ready, blocked, etc.), the number of the next program instruction to be executed, and the starting address of the process in memory. The PCB also stores the contents of various processor registers (the execution context), which are saved when a process leaves the running state and which are restored to the processor when the process returns to the running state.\r
\r
## 1.3.2. Process conntrol in GNU/Linux\r
\r
Because Linux is a multi-user system, meaning different users can be running various programs on the system, each running instance of a program must be identified uniquely by the kernel.\r
\r
And a program is identified by its process ID (PID) as well as it’s parent processes ID (PPID), therefore processes can further be categorized into:\r
\r
- Parent processes – these are processes that create other processes during run-time.\r
- Child processes – these processes are created by other processes during run-time.\r
\r
Init process is the mother (parent) of all processes on the system, it’s the first program that is executed when the Linux system boots up; it manages all other processes on the system. It is started by the kernel itself, so in principle it does not have a parent process.\r
\r
::: info init process\r
The init process always has process ID of 1.\r
\r
It functions as an adoptive parent for all orphaned processes.\r
:::\r
\r
### Command to get the process PiD\r
\r
In Linux every process on a system has a PID (Process Identification Number) which can be used to kill the process. The command \`pidof cmdname\` shows all processes related to that command. Remember that every time we start a command or application a nes process is created.\r
\r
Shell variables \`$$\` and \`$PPID\` show the actual process PID and its PPID respectively.\r
\r
\`\`\`bash\r
# pidof systemd\r
1\r
# pidof top\r
2060\r
# pidof httpd\r
2103 2102 2101 2100 2099 1076\r
# Process pid\r
echo $$\r
2109\r
# Process parent pid\r
echo $PPID\r
2106\r
\`\`\`\r
\r
### Commands to view active processes in GNU/Linux\r
\r
There are several Linux tools for viewing/listing running processes on the system, the two traditional and well known are \`ps\` and \`top\` commands:\r
\r
The \`ps\` command displays information about a selection of the active processes on the system, along with some process information,  as shown below:\r
\r
This command offers many options to show more or less information about the processes, as well as our user's processes ot others' processes, including statistics about resource usage, etc.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD\r
root         1     0  0   223   576   5 11:00 ?        00:00:00 /init\r
root         7     1  0   223    80   3 11:00 ?        00:00:00 /init\r
root         8     7  0   223    80   1 11:00 ?        00:00:00 /init\r
vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash\r
vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF\r
vicente@Desktop-Vicente:~$ ps -auxf\r
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r
root         1  0.0  0.0    892   576 ?        Sl   11:00   0:00 /init\r
root         7  0.0  0.0    892    80 ?        Ss   11:00   0:00 /init\r
root         8  0.0  0.0    892    80 ?        S    11:00   0:00  \\_ /init\r
vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash\r
vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf\r
\`\`\`\r
\r
::: info Useful ‘ps’ examples for Linux process monitoring\r
[https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/](https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/)\r
:::\r
\r
The \`top\`command  is a powerful tool that offers you a dynamic real-time view of a running system as shown in the screenshot below:\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00\r
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie\r
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r
MiB Mem :  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache\r
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem\r
\r
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r
    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init\r
    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init\r
    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init\r
    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash\r
   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top\r
\`\`\`\r
\r
::: info ‘top’ examples in Linux\r
[https://www.tecmint.com/12-top-command-examples-in-linux/](https://www.tecmint.com/12-top-command-examples-in-linux/)\r
:::\r
\r
### Process control\r
\r
Process management is one of the important aspects of System Administration in Linux, and it includes killing of processes using the \`kill\` command.\r
\r
When killing processes, the kill command is used to send a named signal to a named process or groups of processes. The default signal is the TERM signal.\r
\r
A waiting process that can be interrupted by signals is called \`Interruptible\`, while a waiting process that is directly waiting on hardware conditions and cannot be interrupted under any conditions is called \`uninterruptible\`.\r
\r
\`\`\`bash\r
# Get Firefox PID after it freezes\r
$ pidof firefox\r
2687\r
# Send the SIGKILL (9) signal to end the process immediately\r
$ kill 9 2687\r
\`\`\`\r
\r
::: info How to control Linux process Using kill, pkill and kilall\r
[https://www.tecmint.com/how-to-kill-a-process-in-linux/](https://www.tecmint.com/how-to-kill-a-process-in-linux/)\r
:::\r
\r
The kernel stores a great deal of information about processes including process priority which is simply the scheduling priority attached to a process. Processes with a higher priority will be executed before those with a lower priority, while processes with the same priority are scheduled one after the next, repeatedly.\r
\r
A user with *root* privileges can modify processes priority. This value can be seen in the NI (nice) columns of \`top\`output. This value also influences the PRI (priority) column, meaning the priority the OS gives to a process.\r
\r
The priority is a nice value (niceness) which ranges from -20 (highest priority value) to 19 (lowest priority value) and the default is 0. Using the \`nice\` command we can guarantee that in high load CPU periods some processes will make a priority use of the CPU\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ nice\r
0\r
vicente@Desktop-Vicente:~$ nice -n 10 bash\r
vicente@Desktop-Vicente:~$ nice\r
10\r
vicente@Desktop-Vicente:~$\r
\`\`\`\r
\r
::: tip Process control in Windows\r
In Windows systems most of previous actions can be performed from the task manager, though commands **tasklist** and **taskkill** can be used in console mode..\r
\r
*tasklist /svc /fi “imagename eq svchost.exe”*\r
Will display you the result with Image name, PID and Service name to know which services are being run under the process svchost.exe, generic host services for services run from dynamic link libraries (DLL). There are so many processes for security reasons in order to avoid risks just in case one fails, not to hang the whole system.\r
:::\r
\r
## 1.3.3. Process states\r
\r
The simple process state diagram below shows three main states for a process. They are shown as ready (the process is ready to execute when a processor becomes available), running (the process is currently being executed by a processor) and waiting (the process is waiting for a specific event to occur before it can proceed). The lines connecting the states represent possible transitions from one state to another.\r
\r
At any instant, a process will exist in one of these three states. On a single-processor computer, only one process can be in the running state at any one time. The remaining processes will either be ready or blocked, and for each of these states there will be a queue of processes waiting for some event.\r
\r
![Process states](./../../media/unit1/process_state.png)\r
\r
- **Created**. The process is created from a program and loaded into the system\r
- **Ready**. The process is not running but it is ready to do so. The OS still hasn't assigned a processor to run. and the OS scheduler will be responsible of selecting the process to start running.\r
- **Running**. While a process is executing it has complete control of the processor, but at some point the operating system needs to regain control, such as when it must assign the processor to the next process. Execution of a particular process will be suspended if that process requests an I/O operation, if an interrupt occurs, or if the process times out.\r
- **Waiting**. The process is blocked waiting for an event to happen. For instance it can be waiting for an I/O operation to finish or a synchronization operation with another process. When the event occurs the process goes back to ready state until the OS scheduler decides to move it to running state.\r
- **Terminated**. The process ends its processing and frees its resources and all memory space (PCB). The process is the responsible to do a system call to tell the OS it has finished although the OS can interrupt it forcing its termination by using an exception (special interruption).\r
\r
States transitions:\r
\r
- **Running to waiting**: a process changes from running to waiting when it depends on an external event or operation.\r
- **De Waiting to ready**: a process changes from waiting to ready when the external event or operation it was waiting for occurs.\r
- **Ready to running**: a process changes from ready to running when the OS scheduler gives it CPU time.\r
- **Running to ready**: a process changes from running to ready when the CPU time given by the OS scheduler runs out.\r
\r
## 1.3.4 Process scheduler\r
\r
Process scheduling is a major element in process management, since the efficiency with which processes are assigned to the processor will affect the overall performance of the system. It is essentially a matter of managing queues, with the aim of minimizing delay while making the most effective use of the processor's time. The operating system carries out four types of process scheduling:\r
\r
- Process queue: contains all system processes\r
- Ready queue: contains all processes ready to be run.\r
- Devices queues: contains processes waiting for an IO operation to finish.\r
\r
![Scheduler process queues](./../../media/unit1/process_queues.gif)\r
\r
Scheduler is the one who manages processes movements into the queues.There's a short-term and a long-term scheduling:\r
\r
- The task of the \`short-term scheduler\` (sometimes referred to as the dispatcher) is to determine which process to execute next. This will occur each time the currently running process is halted. A process may cease execution because it requests an I/O operation, or because it times out, or because a hardware interrupt has occurred. The objectives of short-term scheduling are to ensure efficient utilization of the processor and to provide an acceptable response time to users.\r
  - Non-Preemptive Scheduling: a process only changes its state if it has finished or it gets locked.\r
  - Preemptive Scheduling: a process only changes its state if it has finished, it gets locked or a higher priority process is waiting.\r
  - Shared time: every amount of clock cicles (quantum), a process is moved to waiting and a new process changes from ready to running. All processes are considered to have the same priority\r
- The \`long-term scheduler\` determines which programs are admitted to the system for processing, and as such controls the degree of multiprogramming.\r
  - Before accepting a new program, the long-term scheduler must first decide whether the processor is able to cope effectively with another process. The more active processes there are, the smaller the percentage of the processor's time that can be allocated to each process.\r
\r
::: warning Context switch\r
The changeover from one process to the next is called a **context switch**. During a context switch, the processor obviously cannot perform any useful computation, and because of the frequency with which context switches occur, operating systems must minimize the context-switching time in order to reduce system overhead.\r
:::\r
\r
## 1.3.5. Process scheduling algorithms\r
\r
Scheduling algorithms are use to improve system performance and thus user experience.\r
\r
To set objective parameters and be able to compare different scenarios, a CPU scheduling algorithm tries to maximize and minimize the following:\r
\r
- **Waiting time**: Waiting time is an amount of time a process waits in the ready queue or in the waiting queue.\r
- **Turnaround Time**: Turnaround time is the amount of time to execute a specific process. It is the calculation of the total time spent waiting to get into the memory, waiting in the queue, locked for I/O operations and executing on the CPU. The period between the time of process submission to the completion time is the turnaround time.\r
- **CPU utilization**: CPU usage is the main task in which the operating system needs to make sure that CPU remains as busy as possible. It can range from 0 to 100 percent.\r
  \r
> In 1 processor systems\r
> ![1 CPU usage](./../../media/unit1/usage1cpu.gif)\r
<!--$\\frac{\\#\\ instants\\ of\\ time\\ the\\ processor\\ is\\ busy}{time\\ last\\ process\\ ends}$\\ \\ x \\ 100-->\r
>In N processor systems\r
![2 CPU usage](./../../media/unit1/usage2cpu.gif)\r
<!--$\\frac{\\sum_{n=1}^{N}\\#\\ instants\\ of\\ time\\ the\\ processor_n\\ is\\ busy}{instant\\ of\\ time\\ when\\ the\\ last\\ process\\ ends\\ *\\ N}$\\ \\ x\\  100-->\r
\r
- **Throughput**: The number of processes that finish their execution per unit time is known as \`throughput\`. So, when the CPU is busy executing the process, at that time, work is being done, and the work completed per unit time is called throughput.\r
![Throughput](./../../media/unit1/throughput.gif)\r
<!-- $\\frac{\\# \\ of\\ processes}{instant\\ of\\ time\\ when\\ the\\ last\\ process\\ ends}$-->\r
\r
| Process | Arrival | CPU time | Priority |\r
| :-----: | :-----: | :------: | :------: |\r
|   P1    |    0    |    10    |    5     |\r
|   P2    |    1    |    6     |    10    |\r
|   P3    |    2    |    3     |    7     |\r
\r
With this parameters let's compare the scheduling algorithms performance.\r
\r
### FCFS - First Come First Served\r
\r
First Come First Serve is the full form of FCFS. It is the easiest and most simple CPU scheduling algorithm. In this type of algorithm, the process which requests the CPU gets the CPU allocation first. This scheduling method can be managed with a FIFO queue.\r
\r
As the process enters the ready queue, its PCB (Process Control Block) is linked with the tail of the queue. So, when CPU becomes free, it should be assigned to the process at the beginning of the queue.\r
\r
Characteristics of FCFS method:\r
\r
- It offers non-preemptive and pre-emptive scheduling algorithm.\r
- Jobs are always executed on a first-come, first-serve basis\r
- It is easy to implement and use.\r
- However, this method is poor in performance, and the general wait time is quite high.\r
\r
![FCFS monoprocessor](./../../media/unit1/fcfs-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 2     : active,t2, after t1, 6s\r
Process 3     : crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      9       |       15        |             |\r
|   P3    |      14      |       17        |             |\r
|         |\r
|  Mean   |     7,6      |       14        |    100%     |    0,15    |\r
\r
![FCFS dual processor](./../../media/unit1/fcfs-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### SJF - Shortest Job First\r
\r
SJF is a full form of (Shortest job first) is a scheduling algorithm in which the process with the shortest execution time should be selected for execution next. This scheduling method can be preemptive or non-preemptive. It significantly reduces the average waiting time for other processes awaiting execution.\r
\r
Characteristics of SJF Scheduling\r
\r
- It is associated with each job as a unit of time to complete.\r
- In this method, when the CPU is available, the next process or job with the shortest completion time will be executed first.\r
- It is Implemented with non-preemptive policy.\r
- This algorithm method is useful for batch-type processing, where waiting for jobs to complete is not critical.\r
- It improves job output by offering shorter jobs, which should be executed first, which mostly have a shorter turnaround time. There can be situations where longer jobs would never been run, that's called \`starvation\`.\r
\r
![SJF monoprocessor](./../../media/unit1/sjf-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title SJF (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      12      |       18        |             |\r
|   P3    |      8       |       11        |             |\r
|         |\r
|  Mean   |     6,6      |       13        |    100%     |    0,15    |\r
\r
![SJF dual processor](./../../media/unit1/sjf-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### Priority scheduling\r
\r
Priority scheduling is a method of scheduling processes based on priority. In this method, the scheduler selects the tasks to work as per the priority.\r
\r
Priority scheduling also helps OS to involve priority assignments. The processes with higher priority should be carried out first, whereas jobs with equal priorities are carried out on a round-robin or FCFS basis. Priority can be decided based on memory requirements, time requirements, etc.\r
\r
As with SJF, with this algorithm low priority processes are in risk of starvation.\r
\r
![Prioridad monoprocessor](./../../media/unit1/prioridad-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      12      |       18        |             |\r
|   P3    |      8       |       11        |             |\r
|         |\r
|  Mean   |     6,6      |       13        |    100%     |    0,15    |\r
\r
![Prioridad dual processor](./../../media/unit1/prioridad-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      0       |       10        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      5       |        8        |             |\r
|         |\r
|  Mean   |     1,6      |        6        |     95%     |    0,3     |\r
\r
### Round Robin\r
\r
Round robin is the oldest, simplest scheduling algorithm. The name of this algorithm comes from the round-robin principle, where each person gets an equal share of something in turn (\`quantum\`). It is mostly used for scheduling algorithms in multitasking. This algorithm method helps for starvation free execution of processes.\r
\r
Characteristics of Round-Robin Scheduling\r
\r
- Round robin is a hybrid model which is clock-driven\r
- Time slice should be minimum, which is assigned for a specific task to be processed. However, it may vary for different processes.\r
- It is a real time system which responds to the event within a specific time limit.\r
\r
We can find two situations with this method:\r
\r
- The process, or its remaining time, is less than the quantum. So, when the process finishes, a new process is run.\r
- The process, or its remaining time, is greater than the quantum. So, when the quantum times out the process is moved to ready and next scheduled process is moved to running.\r
\r
![RR monoprocessor](./../../media/unit1/roundrobin-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 2s\r
Process 2     : active,t2, after t1, 2s\r
Process 3     : crit, t3, after t2, 2s\r
Process 1      :done, t4, after t3, 2s\r
Process 2     : active,t5, after t4, 2s\r
Process 3     : crit, t6, after t5, 1s\r
Process 1      :done, t7, after t6, 2s\r
Process 2     : active,t8, after t7, 2s\r
Process 1      :done, t9, after t8, 2s\r
Process 1      :done, t10, after t9, 2s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      9       |       19        |             |\r
|   P2    |      8       |       14        |             |\r
|   P3    |      6       |        9        |             |\r
|         |\r
|  Mean   |     7,6      |       14        |    100%     |    0,15    |\r
\r
![RR dual processor](./../../media/unit1/roundrobin-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1_1, 0, 2s\r
Process 3     :crit, t3_1, after t1_1, 2s\r
Process 1     :done, t1_2, after t3_1, 2s\r
Process 3     :crit, t3_2, after t1_2, 1s\r
Process 1     :done, t1_3, after t3_2, 2s\r
Process 1     :done, t1_4, after t1_3, 2s\r
Process 1     :done, t1_5, after t1_4, 2s\r
section Processor 2\r
.     :active, ., 0, 0s\r
Process 2     :active, t2_1, 1, 2s\r
Process 2     :active, t2_2, after t2_1, 2s\r
Process 2     :active, t2_3, after t2_2, 2s\r
\`\`\`\r
-->\r
\r
| Process | Waiting time | Turnaround time | % CPU usage | Throughput |\r
| :-----: | :----------: | :-------------: | :---------: | :--------: |\r
|   P1    |      3       |       13        |             |\r
|   P2    |      0       |        6        |             |\r
|   P3    |      2       |        5        |             |\r
|         |\r
|  Mean   |     1,6      |       7,6       |     73%     |    0,23    |\r
\r
::: question Combined scheduling\r
As a matter of fact, not only one scheduling algorithm is used but more than one are combined to improve performance and avoid problems like starvation. We have done so, in Round-Robin we have also used FCFS.\r
\r
¿Do you dare to plan the previous sample using Round-Robin with priority? Keep in mind that it will work mainly with the quantum and, the priority will be used to select the next process to change from ready to running.\r
:::\r
\r
### Scheduler with I/O operations or locks\r
\r
In previous examples all processes have expend all their time in CPU, the have not made any IO operation nor any interruption, but that behavior is far away from reality. Processes sometimes have to get locked to wait for a user input, read or store information on any storage or simply wait for another process to finish an operation and send to it a data before it can go on (synchronization).\r
\r
As we have already comment, when a process leaves the running state another one can start running and make use of the CPU. Once the process finishes its lock, it can go back to ready state to keep on executing its sentences.\r
\r
The next graph has a two activities specification in which before running their last sentence block, process 1 last IO operation must have finished.\r
\r
![Procesos con E/S](./../../media/unit1/operaciones_es.svg)\r
<!--\r
\`\`\`mermaid\r
graph LR\r
\r
subgraph Process 2\r
    p2_1["run for 2"]--p2_2["E/S for 3"]--p2_3["run for 4"]--p2_5["run for 3"]\r
end\r
subgraph Process 1\r
    p1_1["run for 3"]--p1_2["E/S for 1"]--p1_3["run for 5"]--p1_4["E/S for 2"]--p1_5["run for 4"]\r
    p1_4--p2_5\r
end\r
\`\`\`\r
-->\r
\r
Let's see how this affects the scheduling, guessing both processes arrive at the same time.\r
\r
![RR dual processor](./../../media/unit1/roundrobin-3.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Task 1\r
P1 runs 2 (exits because of q expiration)      :done, t1_1, 0, 2s\r
P1 runs 1 (exits and has to wait 1 for E/S)      :done, t1_2, after t2_1, 1s\r
E/S :crit, es1_1, after t1_2, 1s\r
P1 runs 2 (exits because of q expiration)      :done, t1_3, after es1_1, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_4, after t2_2, 2s\r
P1 runs 2 (exits and has to wait 1 for E/S)      :done, t1_5, after t2_3, 1s\r
E/S :crit, es1_2, after t1_5, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_6, after es1_2, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_7, after t2_4, 2s\r
\r
section Task 2 \r
P2 runs 2 (exits and has to wait 3 for E/S) :active, t2_1, after t1_1, 2s\r
E/S :crit, es2_1, after t2_1, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_2, after t1_3, 2s\r
P2 runs 2 (exits because of q expiration)      :active, t2_3, after t1_4, 2s\r
Locked waiting :crit, es2_2, after t2_3, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_4, after t1_6, 2s\r
P2 runs 2 (ends execution)      :active, t2_5, after t1_7, 1s\r
'''\r
-->\r
`]},{title:"1.1 Processes, programs, threads",headers:[{level:2,title:"1.1.1. Processes and programs",slug:"_1-1-1-processes-and-programs",link:"#_1-1-1-processes-and-programs",children:[]},{level:2,title:"1.1.2. Concurrent programming",slug:"_1-1-2-concurrent-programming",link:"#_1-1-2-concurrent-programming",children:[{level:3,title:"What for?",slug:"what-for",link:"#what-for",children:[]},{level:3,title:"Process communication and synchronization",slug:"process-communication-and-synchronization",link:"#process-communication-and-synchronization",children:[]}]},{level:2,title:"1.1.3. Services and threads",slug:"_1-1-3-services-and-threads",link:"#_1-1-3-services-and-threads",children:[{level:3,title:"Sequential program (Von Neumann architecture)",slug:"sequential-program-von-neumann-architecture",link:"#sequential-program-von-neumann-architecture",children:[]},{level:3,title:"Concurrent program",slug:"concurrent-program",link:"#concurrent-program",children:[]},{level:3,title:"Threads vs processes",slug:"threads-vs-processes",link:"#threads-vs-processes",children:[]}]}],path:"/en/unit1/process.html",pathLocale:"/en/",extraFields:[`---\r
title: 1.1 Processes, programs, threads\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.1. Processes, programs, threads" />\r
\r
# 1.1. Processes, programs, threads\r
\r
[[toc]]\r
\r
## 1.1.1. Processes and programs\r
\r
A program and a process are related terms. A \`program\` is a group of instructions to carry out a specified task with some input data.\r
\r
::: tip Black box\r
Black-box testing is a method of software testing that examines the functionality of an application without peering into its internal structures or workings, just by setting some input data set and checking if the output data set meets the expected one.\r
:::\r
\r
While a \`process\` can be described as an instance of a program running on a computer. A program becomes a process when loaded into memory and thus is an active entity While a program is considered to be a passive one.\r
\r
A process has a high resource requirement, it needs resources like CPU, memory address, I/O during its lifetime. It has its own control block called Process Control Block where relevant information as program counter, registers, stack, *executable code*, state, ... and all it needs to be run by the OS is stored.\r
\r
![Process in memory](./../../media/unit1/proceso_memoria.png)\r
\r
Each process is an independent entity. There exist a many-to-one relationship between process and program, which means one program can be invoked multiple times getting several processes in memory running the same copy of the program.\r
\r
## 1.1.2. Concurrent programming\r
\r
In computer science, concurrency is the ability of different parts or units of a program to be executed out-of-order or at the same time simultaneously.\r
\r
This allows for \`parallel\` execution of the concurrent units, which can significantly improve overall speed of the execution in \`multi-processor and multi-core\` machines.\r
\r
The concept of concurrent computing is frequently confused with the related but distinct concept of parallel computing, although both can be described as *multiple processes executing during the same period of time*.\r
\r
- In parallel computing, execution occurs at the same physical instant: for example, on separate processors of a multi-processor machine, with the goal of speeding up computations.\r
- This parallel computing is impossible on a \`one-core single processor\`, as only one computation can occur at any instant (during any single clock cycle). By contrast, concurrent computing consists of process lifetimes overlapping, but execution need not happen at the same instant. The goal here is to model processes in the outside world that happen concurrently using \`multitask\`.\r
\r
![Concurrency vs parallelism](./../../media/unit1/concurrencia_vs_paralelismo.jpg)\r
\r
::: tip Concurrency\r
By and large, both previously described scenarios are gonna be referred to as **concurrency**.\r
:::\r
\r
### What for?\r
\r
The Real World is Massively Complex\r
\r
- In the natural world, many complex, interrelated events are happening at the same time, yet within a temporal sequence.\r
- Compared to serial computing, parallel computing is much better suited for modeling, simulating and understanding complex, real world phenomena.\r
\r
Imagine modeling these serially: climate change, rush hour traffic, weather forecast, galaxy formation, ...\r
\r
Main Reasons for Using Parallel Programming\r
\r
- Save time and money. In theory, throwing more resources at a task will shorten its time to completion, with potential cost savings.\r
  - Parallel computers can be built from cheap, commodity components.\r
- Solve larger and more complex problems.  Many problems are so large and/or complex that it is impractical or impossible to solve them using a serial program, especially given limited computer memory.\r
  - *Grand Challenge Problems* (en.wikipedia.org/wiki/Grand_Challenge) requiring petaflops and petabytes of computing resources.\r
  - Web search engines/databases processing millions of transactions every second\r
- Take advantage of non-local resources. Using compute resources on a wide area network, or even the Internet when local compute resources are scarce or insufficient.\r
  - *SETI@home* (setiathome.berkeley.edu) has over 1.7 million users in nearly every country in the world. (May, 2018).\r
- Make better use of underlying parallel hardware. Modern computers, even laptops, are parallel in architecture with multiple processors/cores.\r
  - Parallel software is specifically intended for parallel hardware with multiple cores, threads, etc.\r
  - In most cases, serial programs run on modern computers "waste" potential computing power.\r
- Increase security. Each task can be isolated in a different process, so debug and check the security, even finishing it when it's not working properly, can be done without hanging the whole system.\r
\r
Historically, parallel computing has been considered to be "the high end of computing", and has been used to model difficult problems in many areas of science and engineering.\r
Today, commercial applications provide an equal or greater driving force in the development of faster computers. These applications require the processing of large amounts of data in sophisticated ways. For example:\r
\r
New hardware environments can be classified in terms of:\r
\r
- Microprocessor with many cores sharing system memory.\r
- Multiprocessor systems with shared memory\r
- Distributed systems and cloud services.\r
\r
### Process communication and synchronization\r
\r
The concurrent running of many processes may suppose the collaboration of some of them in order to complete a common task, while they can also be competing for system resources.\r
\r
In both cases it is compulsory to add communication and synchronization techniques for the processes.\r
\r
:::info Concurrent programming\r
Concurrent programming and PSP is just about that, the knowledge of these **communication and synchronization techniques**.\r
:::\r
\r
When thinking about the way a process can communicate with each other, there are two main options:\r
\r
- Message passing: It's commonly used when processes are running on different devices. They exchange information following a protocol previously set and agreed by the parts.\r
- Shared resources / memory: It's only available when both processes are running on the same device and allows process synchronization based on a shared resource value or state.\r
\r
We can also classify the communication by the synchronization the processes use during the message passing process:\r
\r
- Synchronous communication happens when messages can only be exchanged in real time. It requires that the transmitter and receiver are present in the same time and/or space. Sender is blocked until receiver gets the message. Both processes are synchronized at the reception time.\r
  - Examples of synchronous communication are phone calls or video meetings.\r
- Asynchronous communication happens when information can be exchanged independent of time. It doesn’t require the recipient’s immediate attention, allowing them to respond to the message at their convenience. Sender continues with it processing just after delivering the message to the receiver, not being blocked.\r
  - Examples of asynchronous communication are emails, online forums, and collaborative documents.\r
\r
## 1.1.3. Services and threads\r
\r
A program, as previously said, is a group of sentences (actions and checks) and a running workflow. The workflow line determines the execution order for the sentences, with dependency of the program structure and it's data.\r
\r
Based on the number of workflow lines a program can have, processes are classified in terms of::\r
\r
- Sequential: The have only one control workflow (monothread)\r
- Concurrent: They have multiple control workflows (multithread).\r
\r
### Sequential program (Von Neumann architecture)\r
\r
The classical Von Neumann model of computation4 is a familiar model of sequential behavior. According to this, when we start learning to code we learn the classical way, following Von Neummann's conceptual model.\r
\r
Sequential programs have a single workflow line. instructions on these applications are strictly sorted as a lineal time sequence.\r
\r
The program's behavior is a function of the kind of instructions it is made of and the order they are run (set by its input data)\r
\r
In sequential programs the time every sentence takes to complete has no consequences on the final result.\r
\r
![Sequential flowchart example](./../../media/unit1/sequential_flowchart.png)\r
\r
The way to test a sequential program (\`verify\` or \`debug\`) is so easy:\r
\r
- Every sentence gives the right output.\r
- The sentences are executed in the expected order.\r
\r
That's the basis of many basic test methods, as the "white-box" model.\r
\r
### Concurrent program\r
\r
In concurrent programs there are many workflow lines. The sentences are not run following the same order as in a sequential program the would do.\r
\r
In concurrent programs sequential order between sentences is still relevant. Nevertheless, in concurrent programs the order is only partial while in sequential programs the order is strict.\r
\r
![Concurrent flowchart example](./../../media/unit1/concurrent_flowchart.png)\r
\r
In concurrent programs the *sequencing* for concurrent processes is called **synchronization**.\r
\r
The partial order implies that concurrent programs does not have to be deterministic, that is, the application results with the same input data will not always be equal.\r
\r
::: danger Indeterminism\r
Having different outputs for the same inputs does not means that a concurrent program has any bug or malfunction.\r
:::\r
\r
Look at the following pseudo code example\r
\r
\`\`\`java {16-17,25-28}\r
public class TestClass {\r
    int x;\r
\r
    public void testMethod1() {\r
        for (int i=1; i <= 5; i++) {\r
            x++;\r
        }\r
    }\r
    public void testMethod2() {\r
        for (int j=1; j <= 5; j++) {\r
            x++;\r
        }\r
    }\r
    public void sequential() {\r
        x = 0;\r
        testMethod1();\r
        testMethod2();\r
        System.out.println(x);\r
    }\r
    public void parallel() {\r
        x = 0;\r
        // cobegin-coend means that both methods are run simultaneously\r
        // These sentences doesn't exist in Java. They are used for \r
        // sample purposes\r
        cobegin\r
            testMethod1();\r
            testMethod2();\r
        coend\r
        System.out.println(x);\r
    }\r
}\r
\`\`\`\r
\r
::: question\r
¿Which is the value for variable x after sequential method is run?\r
\r
¿Which is the value for variable x after parallel method is run?\r
:::\r
\r
::: info Historical review\r
The nature and models of interaction between processes of a concurrent program were studied and described by  **Dijkstra** (1968), Brinch **Hansen** (1973) and **Hoare** (1974).\r
\r
The academic study of concurrent algorithms started in the 1960s and they are the foundation for multiprocess operating systems in the 70's and 80's.\r
:::\r
\r
Concurrent programs inherent indeterminism makes its analysis and validation more complex. However, to test a concurrent program (\`verify\` or \`debug\`) the same techniques as for sequential ones are needed, adding these new ones:\r
\r
- Sentences can be validated individually only if the are not engaged to shared variables.\r
- If shared variables are used there can be many interference effects for concurrent sentences and testing can also become very difficult. <Badge type="danger" text="warning" vertical="middle" />\r
- Only when sequencing between tasks is made by using explicit **synchronization** sentences, time is not relevant on the result.\r
\r
::: warning Important\r
Three previous topics described above are the basis of concurrent programming.\r
\r
:eye: To know them, to understand them and to apply them in the right way is all about what we are gonna learn all this course.\r
:::\r
\r
### Threads vs processes\r
\r
A thread is the unit of execution within a process. A thread is just one of the workflow lines a concurrent process can have. A process is a heavyweight running unit.\r
\r
 A process can have anywhere from just one thread (the main thread) to many threads. If a process has more than one thread, every thread is a lightweight running unit.\r
\r
| Processes                        | Threads                                 |\r
| :------------------------------- | :-------------------------------------- |\r
| Have more than one thread        | A thread always exists within a process |\r
| They are independent from others | They share the process resources        |\r
| The OS manages them              | The process manages them                |\r
| they can communicate on the OS  | The process manages their communication |\r
\r
![Threads vs Processes](./../../media/unit1/threads_vs_process.jpg)\r
\r
In the above image you can see the relationship in the way a thread is created and its related process.\r
\r
- The process resides in its memory address space. Threads share that memory area. In the process's address space every thread has its reserved area, but all of them can share the process's global memory and his open resources (files, sockets, etc.)..\r
- We have already described a process PCD with the process information..\r
- In a similar way, have their TCB (Thread Control Block) where the threads store their specific information (program counter, stack pointer, thread status, registers and a PCB pointer).\r
\r
::: info Services\r
A service is a process commonly started during OS boot. As it does not need user interaction services are run as **daemons** run in *background mode*.\r
\r
They are called services because once started they are waiting for a process to ask them to do a task.  As they have to manage request from several processes they usually are multithread programs.\r
:::\r
`]},{title:"2.4 Annex I - System properties and console programming",headers:[{level:2,title:"I.1 System properties and command shells",slug:"i-1-system-properties-and-command-shells",link:"#i-1-system-properties-and-command-shells",children:[]},{level:2,title:"I.2 Console I/O format",slug:"i-2-console-i-o-format",link:"#i-2-console-i-o-format",children:[{level:3,title:"Console output",slug:"console-output",link:"#console-output",children:[]},{level:3,title:"Console input",slug:"console-input",link:"#console-input",children:[]},{level:3,title:"String format",slug:"string-format",link:"#string-format",children:[]},{level:3,title:"Number format",slug:"number-format",link:"#number-format",children:[]},{level:3,title:"Colours in console applications",slug:"colours-in-console-applications",link:"#colours-in-console-applications",children:[]}]}],path:"/en/unit2/console_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.4 Annex I - System properties and console programming\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.4 Annex I - System properties and console programming" />\r
\r
# 2.4 Annex I - System properties and console programming\r
\r
[[toc]]\r
\r
## I.1 System properties and command shells\r
\r
If we plan to code platform independent applications, we have to deal with many issues because of differences between OS. So sometimes we need to deal with specific OS information. A useful way to get that information is by getting System properties.\r
\r
[Specification System.getProperties](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#getProperties())\r
\r
Some examples are provided here using System properties. Similar solutions can be used for other issues.\r
\r
::: danger File separator\r
For file path or directory separator, the Unix system introduced the slash character / as directory separator, and the Microsoft Windows introduced backslash character \\ as the directory separator. In a nutshell, this is / on UNIX and \\ on Windows.\r
\r
Then, ¿how can we code OS independent applications??\r
\r
In Java, we can use the following three methods to get the platform-independent file path separator.\r
\r
- System.getProperty("file.separator")\r
- FileSystems.getDefault().getSeparator() (Java NIO)\r
- File.separator Java IO\r
\r
From now on, we are gonna use System properties in our applications for several situations using \`System.getProperty(String propName)\`. These properties are configured by the OS and the JVM, though we can modify them by setting the JVM running setting\r
\r
> String separator = System.getProperty("file.separator");\r
\r
or\r
\r
> -Dfile.separator\r
\r
Nevertheless is always a good practice to use slash character **/** in paths as Java is able to convert them to the system it is running on.\r
:::\r
\r
If we want to run an OS command we have to do it as we usually do, by using the command shell, where once again we find the troubleshot with UNIX / Windows.\r
\r
Let's take a look at the way we can use the system properties, once again, to get a list of files in the user personal folder.\r
\r
\`\`\`java\r
// First we get the user folder path\r
String homeDirectory = System.getProperty("user.home");\r
// And then we set which OS are we running on\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info non-interactive shell mode\r
In the previous code example, both for Windows and UNIX modifier **c** is used for command shells. This modifier tells the system to open a command shell, to run the companion command and close the shell after it has finished.\r
:::\r
\r
Next you can look at a handler event manager for a mouse clic, into a graphic application, to open a web site in a browser. The code shows how to do it in  *X like operating system and one way to do it in Windows systems is commented.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Our first applications in java is not gonna be an easy one.\r
\r
Using methods from System class and Runtime class, write the code for an app that shows\r
\r
- all the system properties configured in your OS\r
- total memory, free memory, used memory and processors available\r
\r
Make a research into Runtime class methods. For System properties try to get a list or iterable data estructure to show each of the system properties and their values.\r
:::\r
\r
::: details Proposed solution to previous activity\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
## I.2 Console I/O format\r
\r
::: warning Character codification\r
One aspect to take into account when working with streams is the encoding of the information exchanged between processes, which depends on the operating system we are working on. Most systems (GNU/Linux, Mac OS, Android, iOS...) use UTF-8 encoding, based on the Unicode standard. \r
\r
For its part, MS Windows uses its own formats, incompatible with the rest, such as Windows-1252. So to correctly handle data in Java when using more advanced inter-process communication mechanisms, it will be necessary to take into account the type of encoding that the system itself uses.\r
\r
\`\`\`java\r
// Getting the default encoding\r
System.out.println(System.getProperty("file.encoding"));\r
// Setting the encoding\r
System.setProperty("file.encoding", "UTF-8");\r
\r
// Reading with a specific encoding\r
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));\r
// Writing with a specific encoding\r
PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out, "UTF-8"));\r
\r
// Stdin with a specific encoding\r
Scanner scanner = new Scanner(System.in, "UTF-8");\r
// Stdout with a specific encoding\r
System.out.println(new String("Hello, World!".getBytes("UTF-8")));\r
\`\`\`\r
\r
:::\r
\r
### Console output\r
\r
In Java, we can use the \`System.out\` object to print to the console. We can use the \`println\` method to print a line to the console.\r
\r
\`\`\`java:no-line-numbers\r
System.out.println("Hello, World!");\r
\`\`\`\r
\r
### Console input\r
\r
In Java, we can use the \`System.in\` object to read from the console. We can use the \`Scanner\` class to read from the console.\r
\r
\`\`\`java:no-line-numbers\r
Scanner scanner = new Scanner(System.in);\r
String name = scanner.nextLine();\r
\`\`\`\r
\r
### String format\r
\r
In Java, we can use the \`String\` class to format the output. We can use the \`format\` method to format the output. This method is similar to the \`printf\` method in C.\r
\r
\`\`\`java:no-line-numbers\r
String.format("The value of PI is %.2f", Math.PI);\r
\`\`\`\r
\r
### Number format\r
\r
In any programming language we have many different ways to format the information shown to the user. As in this first applications we are using the console as the system output, let's check the two main techniques we can use in Java\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Using NumberFormat class or any of its descendants we can get control on how the numbers are shown with high precision, using numeric patterns.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Hashes can be used instead of zeros to allow .30 to be shown as 0.3\r
// (additional digits are optional)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Similar to C's printf syntax, we can use the java.util.Formatter syntax to set how data is visualized.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// numbers after % print preceding spaces to fill \r
// and justify numbers.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
### Colours in console applications\r
\r
There is a way to print in different colours when using the console. Here you have got an example code with some colours and the way to use it.\r
\r
\`\`\`java:no-line-numbers\r
public class UsingColoursInConsole {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hello" \r
                          + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Bye bye" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
`]},{title:"2.5 Annex II - Curl",headers:[{level:2,title:"II.1 Get curl",slug:"ii-1-get-curl",link:"#ii-1-get-curl",children:[]},{level:2,title:"II.2 Calling a GET method",slug:"ii-2-calling-a-get-method",link:"#ii-2-calling-a-get-method",children:[]},{level:2,title:"II.3 Endpoints and routes",slug:"ii-3-endpoints-and-routes",link:"#ii-3-endpoints-and-routes",children:[]},{level:2,title:"II.4 HTTP methods and headers",slug:"ii-4-http-methods-and-headers",link:"#ii-4-http-methods-and-headers",children:[]},{level:2,title:"II.5 Authentication",slug:"ii-5-authentication",link:"#ii-5-authentication",children:[]},{level:2,title:"II.6 References",slug:"ii-6-references",link:"#ii-6-references",children:[]}],path:"/en/unit2/curl_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.5 Annex II - Curl\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.5 Annex II - Curl" />\r
\r
# 2.5 Annex II - Curl\r
\r
[[toc]]\r
\r
Whether it’s testing the output of a REST API on development or before deploying it to production, simply fetching a response from a website (for instance, to check it’s not down), or getting response times from a site / API Curl is practically omnipresent.\r
\r
Curl is a command-line tool that allows us to do HTTP requests from shell. This is its main use.\r
\r
::: info\r
The tool was about uploading and downloading data specified with a URL. It was a client-side program (the 'c'), a URL client, and would show the data (by default). So 'c' for Client and URL: cURL.\r
\r
Most of us pronounce "curl" with an initial k sound, just like the English word curl. It rhymes with words like girl.\r
\r
But it can also be spelled as c-URL which means see-URL, that is also a good definition about what the tool does.\r
:::\r
\r
Curl supports protocols that allow "data transfers" in either or both directions. It supports protocols which have a "URI format" and are described in an RFC, as curl works primarily with URLs (URIs really) as the input key that specifies the transfer.\r
\r
Curl actually supports these protocols:\r
\r
>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP.\r
\r
## II.1 Get curl\r
\r
curl is totally free, open and available. There are numerous ways to get it and install it for most operating systems and architecture. Some operating systems include curl by default.\r
\r
You can always download the source from [CURL official site](http://curl.se) or find binary packages to download from there.\r
\r
- Linux (Ubuntu / Debian). curl is installed by default. Anyway, you can add with the APT package manager\r
  > apt install curl\r
- Windows 10 comes with the curl tool bundled with the operating system since version 1804\r
    > download the latest official curl release for Windows from [curl windows binaries](http://curl.se/windows) and install that.\r
- MacOS comes with the curl tool bundled with the operating system since many years. If you want to upgrade to the latest version shipped by the curl project, we recommend installing homebrew (a macOS software package manager)\r
    > brew install curl\r
\r
## II.2 Calling a GET method\r
\r
In its most basic form, a curl command will look like this:\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl http://www.net.net\r
<head><title>Document Moved</title></head>\r
<body><h1>Object Moved</h1>This document may be found <a HREF="http://net.net">here</a></body>\r
\r
\`\`\`\r
\r
The default behavior for curl is to invoke an HTTP GET method on the given URL. This way, the program’s output for that command will be the whole HTTP response’s body (in this case, HTML which will be written as given on stdout.\r
\r
Many times we’ll wish to direct the response’s contents into a file. This is done with the \`-o (--output)\` argument, like this:\r
\r
> curl -o output.html www.net.net\r
> \r
> // Equivalent to \r
> \r
> curl www.net.net > output.html \r
\r
The URL must be in the last place, but optionally, you can specify the URL of the site you wish to call curl on with a \`-s (--silent) \`argument , allowing you to change the order of your arguments.\r
\r
curl -s http://www.net.net -o output.html\r
\r
In the previous example we are not getting the desired resource, because it has been moved or redirected to another URI. Using the \`-L (--location)\` mode, we can follow redirects and get the destination resource\r
\r
\`\`\`bash:no-line-numbers{1,3,5}\r
$> curl http://www.dataden.tech\r
Redirecting\r
$> curl -L http://www.dataden.tech\r
<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.dataden.tech/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTYzMzM4OTE3OSwiaWF0IjoxNjMzMzgxOTc5LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIycWxmMGdkZmg2YWlzaHMxdjgwdWx0aTQiLCJuYmYiOjE2MzMzODE5NzksInRzIjoxNjMzMzgxOTc5NzgzNzQ1fQ.y5LwDoSoZCpe2tzro_FbX7cSGIw4nx1XweNBqjpLXoo&sid=da601018-2557-11ec-a001-58f389072b17');<\/script></body></html>\r
$> curl -L http://www.net.net\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        <body>\r
                <!-- Begin: Google Analytics -->\r
                <script>\r
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r
                  ga('create', 'UA-32196-28', 'auto');\r
                  ga('send', 'pageview');\r
                <\/script>\r
                <!-- End: Google Analytics -->\r
                <center>\r
                        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\r
                        <font face="impact, Arial, Helvetica, sans-serif" size="14">\r
                                NET.NET\r
                        </font>\r
                        <br /><br /><br /><br />\r
                        <font face="Arial, Helvetica, sans-serif" size="1">\r
                                <a href="http://who.godaddy.com/whoischeck.aspx?domain=NET.NET" target="_blank">NET.NET</a> is the first and the best domain name on the Internet!\r
                                <br />\r
                                Coming Soon...\r
                        </font>\r
                </center>\r
        </body>\r
</html>\r
\`\`\`\r
\r
So far we have only get the html page. If we want to see also the headers of our GET request and response headers, we have to user the \`-v (--verbose)\` option  to get full information about the HTTP protocol.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl -v  http://www.net.net\r
*   Trying 34.250.90.28:80...\r
* TCP_NODELAY set\r
* Connected to net.net (34.250.90.28) port 80 (#0)\r
> GET / HTTP/1.1\r
> Host: net.net\r
> User-Agent: curl/7.68.0\r
> Accept: */*\r
>\r
* Mark bundle as not supporting multiuse\r
< HTTP/1.1 200 OK\r
< Cache-Control: private\r
< Content-Type: text/html\r
< Server: Microsoft-IIS/10.0\r
< Set-Cookie: ASPSESSIONIDASRSRRAR=IMFFLMBBBIFJNLNDHLOACDAI; path=/\r
< X-Powered-By: ASP.NET\r
< Date: Mon, 04 Oct 2021 21:40:49 GMT\r
< Content-Length: 1080\r
<\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        ...\r
\`\`\`\r
\r
In the previous output requests header are marked with \`>\` while response header are marked with \`<\`.\r
\r
::: info short and long command line options\r
Command line options pass on information to curl about how you want it to behave.\r
\r
Single-letter options are convenient since they are quick to write and use, but as there are a limited number of letters and not all options are available like that.\r
Long option names are therefore provided for those. Also, as a convenience and to allow scripts to become more readable, most short options have longer name aliases.\r
\r
Short options are preceded by the minus symbol and a single letter immediately following it. They can be used with just that option name. You can then also combine several single-letter options after the minus.\r
\r
> $> curl -v -L http://example.com\r
> $> curl -vL http://example.com\r
\r
Long options are always written with two dashes and then the name, and you can only write one option name per double-dash.\r
\r
> $> curl --verbose --location http://example.com\r
\r
:::\r
\r
Finally, we can access partially the verbose mode information using the \`-i (--include)\` or \`-I (--head)\` to get the complete answer from the server (headers & data) or just the headers, respectively.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$>  curl -I https://jsonplaceholder.typicode.com/todos/1\r
HTTP/2 200\r
date: Mon, 04 Oct 2021 21:57:55 GMT\r
content-type: application/json; charset=utf-8\r
content-length: 83\r
x-powered-by: Express\r
x-ratelimit-limit: 1000\r
x-ratelimit-remaining: 999\r
x-ratelimit-reset: 1631546224\r
vary: Origin, Accept-Encoding\r
access-control-allow-credentials: true\r
cache-control: max-age=43200\r
pragma: no-cache\r
expires: -1\r
x-content-type-options: nosniff\r
etag: W/"53-hfEnumeNh6YirfjyjaujcOPPT+s"\r
via: 1.1 vegur\r
cf-cache-status: HIT\r
age: 10926\r
accept-ranges: bytes\r
expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"\r
report-to: {"endpoints":[{"url":"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=LxJlkSosQdWmBFBOx1fB6zrbjSbU0iStl7jjtlVL27CtOEPxem%2Ffl9y%2BCajMUopcZINOEsaufiU8A2glOLEmNpO5a40%2FyWb%2B4dBuspS8VGWnCRW4jxBBmh%2F3FbupAEaxy66TUPariKJLqe3PL5iq"}],"group":"cf-nel","max_age":604800}\r
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}\r
server: cloudflare\r
cf-ray: 6991ab2c1a5037c7-MAD\r
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400\r
\`\`\`\r
\r
Finally, adding the \`-w "%{time_total}\\n"\` will simply output the total time it took to fetch the response from the given domain.\r
\r
## II.3 Endpoints and routes\r
\r
The term endpoint is focused on the URL that is used to make a request.\r
\r
For a typical web API, endpoints are URLs, and they are described in the API's documentation so programmers know how to use/consume them. For example, a particular web API may have this endpoint:\r
\r
> GET https://my-api.com/Library/Books\r
\r
This would return a list of all books in the library.\r
\r
A "route" is typically a part of URL endpoint that routes the pages to different components.\r
\r
> GET https://my-api.com/Library/Books/341 \r
\r
This would access book with id 341 using the Library/Books endpoint\r
\r
For instance, for [SWAPI (Star Wars API)](https://swapi.dev/) the endpoint is \`https://swapi.dev/api/\`. That's the entry point for all requests.\r
\r
Thus there are many routes depending on the information we want to access/add/modify/delete.\r
\r
\`\`\`java:no-line-numbers\r
$> curl https://swapi.dev/api/people/1\r
$> curl https://swapi.dev/api/planet/3\r
$> curl https://swapi.dev/api/vehicles\r
\`\`\`\r
\r
## II.4 HTTP methods and headers\r
\r
In every HTTP request, there's a method. Sometimes called a verb. The most commonly used ones are GET, POST, HEAD and PUT.\r
\r
POST is the HTTP method that was invented to send data to a receiving web application, and it is how most common HTML forms on the web works.\r
\r
When the data is sent by a browser it will send it URL encoded, as a serialized name=value pairs separated with ampersand symbols (&).\r
\r
You send such data with curl's \`-d (--data)\` option like this:\r
\r
> curl -d 'name=admin&shoesize=12' http://example.com/\r
\r
Curl selects which methods to use on its own depending on what action to ask for. -d will do POST, -I will do HEAD and so on. If you use the \`-X (--request)\` option you can change the method keyword curl selects.\r
\r
> curl -X POST -d 'imageSize=big&imageType=jpg' http://example.org/\r
\r
POSTing with curl's -d option will make it include a default header that looks like \`Content-Type: application/x-www-form-urlencoded\`. That's what your typical browser will use for a plain POST.\r
\r
If that header is not good enough for you, you should, of course, replace that and instead provide the correct one. Such as if you POST JSON to a server and want to more accurately tell the server about what the content is:\r
\r
> curl -X "POST" -d '{"imageSize":"big","imageType":"jpg","scale":"false"}' -H 'Content-Type: application/json' https://example.com\r
\r
## II.5 Authentication\r
\r
Each HTTP request can be made authenticated. If a server or a proxy wants the user to provide proof that they have the correct credentials to access a URL or perform an action, it can send back a HTTP response code that informs the client that it needs to provide a correct HTTP authentication header in the request to be allowed.\r
\r
To tell curl to do an authenticated HTTP request, you use the \`-u (--user)\` option to provide user name and password (separated with a colon). Like this:\r
\r
> curl --user daniel:secret http://example.com/\r
\r
This will make curl use the default "Basic" HTTP authentication method.\r
\r
Many applications and services make use of a secret key or an Authorization token provided by the service provider when you create the service.\r
\r
[Trello API Introduction](https://developer.atlassian.com/cloud/trello/guides/rest-api/api-introduction/)\r
\r
[Azure Translator API Reference](https://docs.microsoft.com/es-es/azure/cognitive-services/translator/reference/v3-0-translate)\r
\r
If we want to use the Azure service for translate text, first we need to obtain the secret key and send it with each call to identify the user and get the permission to use the service.\r
\r
\`\`\`java:no-line-numbers\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Ocp-Apim-Subscription-Key: <here goes your susbcription key>" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
Sometimes we can get a temporal authorization by getting an Authorization token, that later must be provided to access the service during a short period of time. Once the time expires, another token must be requested.\r
The \`Authorization: Bearer <token>\` header is used.\r
\r
\`\`\`java:no-line-numbers{1,3,5}\r
$> curl -X POST "https://api.cognitive.microsoft.com/sts/v1.0/issueToken" -H "Ocp-Apim-Subscription-Key: <here goes the secret key>" -d {}\r
eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzMwMTUxNywiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.0hyyBNr22E2sIO_ZBlTiBePXM_KE_5hQOCeHxz3US44" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
{"error":{"code":401000,"message":"The request is not authorized because credentials are missing or invalid."}}\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
## II.6 References\r
\r
[Everything curl](https://everything.curl.dev/) is a detailed and totally free book available that explains basically everything there is to know about curl.\r
\r
[freecodecamp.org](https://www.freecodecamp.org/news/how-to-start-using-curl-and-why-a-hands-on-introduction-ea1c913caaaa/)\r
\r
[curl official site](https://curl.se/)\r
`]},{title:"2 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit2/",pathLocale:"/en/",extraFields:[`---\r
title: 2 Introduction\r
---\r
\r
# Unit 2. Process programming\r
\r
Once we know about key concepts in concurrency, we can also differentiate programs and processes. In this second unit we will learn how we can launch a program from our own code, that is, how to create a process from a running process.\r
\r
In addition to launch programs and create new processes, there's a relationship between the parent process and its children that allow them to communicate exchanging information. This is the way our programs will be able to launch other applications, os command or even applications developed by us. Furthermore, parent-child processes allow synchronization and communication among them.\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know Java classes for process management\r
- To monitor and control process lifecycle\r
- To control parent-child communications\r
- To use synchronization methods for processes and sub-processes\r
- To learn how pipes communications works\r
- To learn curl syntax and use it for API REST testing purposes\r
- To create applications that run parallel tasks\r
`]},{title:"2.3 Handling Process Streams",headers:[{level:2,title:"2.3.1  Redirecting Standard Input and Output",slug:"_2-3-1-redirecting-standard-input-and-output",link:"#_2-3-1-redirecting-standard-input-and-output",children:[{level:3,title:"getInputStream()",slug:"getinputstream",link:"#getinputstream",children:[]},{level:3,title:"getErrorStream()",slug:"geterrorstream",link:"#geterrorstream",children:[]},{level:3,title:"getOutputStream()",slug:"getoutputstream",link:"#getoutputstream",children:[]},{level:3,title:"Inheriting the I/O of the parent process",slug:"inheriting-the-i-o-of-the-parent-process",link:"#inheriting-the-i-o-of-the-parent-process",children:[]}]},{level:2,title:"2.3.2 Redirecting Standard Input and Output",slug:"_2-3-2-redirecting-standard-input-and-output",link:"#_2-3-2-redirecting-standard-input-and-output",children:[]}],path:"/en/unit2/iostreams.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.3 Handling Process Streams\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.3 Handling Process Streams" />\r
\r
# 2.3 Handling Process Streams\r
\r
[[toc]]\r
\r
## 2.3.1  Redirecting Standard Input and Output\r
\r
By default, the created subprocess does not have its terminal or console. All its standard I/O (i.e., stdin, stdout, stderr) operations will be sent to the parent process. Thereby the parent process can use these streams to feed input to and get output from the subprocess.\r
\r
Consequently, this gives us a huge amount of flexibility as it gives us control over the input/output of our sub-process.\r
\r
In a parent-child process relationship I/O streams are also redirected from child process to parent, using 3 pipes, one per each standard stream. Those pipes  can be used like in a Linux system.\r
\r
<!--![alt_text](./../../media/unit2/pipe_with_two.jpg)-->\r
![alt_text](./../../media/unit2/ProcessIO.png)\r
\r
### getInputStream()\r
\r
We can fetch the output generated by a subprocess and consume within the parent process thus allowing share information between the processes\r
\r
\`\`\`java\r
Process p = pbuilder.start();\r
BufferedReader processOutput = \r
    new BufferedReader(new InputStreamReader(p.getInputStream()));\r
\r
String linea;    \r
while ((linea = processOutput.readLine()) != null) {\r
    System.out.println("> " + linea);        \r
}            \r
processOutput.close();    \r
\`\`\`\r
\r
![alt_text](./../../media/unit2/Java_Stream_Readers_BufferedReaders.jpg)\r
\r
::: warning Charset and encodings\r
From the time being computer science started we've been in trouble with encodings and charsets. And windows console is not an exception.\r
\r
Terminal in Windows was also known as "DOS prompt": so a way to run DOS programs in Windows, so they keep the code page of DOS. Microsoft dislikes non-backward compatible changes, so your DOS program should works also on Windows terminal without problem.\r
\r
Wikipedia indicates that **CP850** has theoretically been "largely replaced" by **Windows-1252** and, later, Unicode, but yet it's here, right in the OS's terminal.\r
\r
Then, if we want to print information from the console in our applications we must deal with the right charset and encoding, that is, CP-850.\r
\r
Fortunately, InputStreamReader has a constructor to manage streams with any encoding, so we must use it when working with console commands or applications.\r
\r
\`\`\`java:no-line-numbers\r
new InputStreamReader(p.getInputStream(), "CP850");\r
\`\`\`\r
\r
> We can force Netbeans to use a UTF-8 as default encoding. To do so we must modify its config file \`C:/Program Files/Netbeans-xx.x/netbeans/etc/netbeans.conf\`, changing directive \`netbeans_default_option\` and adding **-J-Dfile.encoding=UTF-8** to the end.\r
\r
:::\r
\r
### getErrorStream()\r
\r
Interestingly we can also fetch the errors generated from the subprocess and thereon perform some processing.\r
\r
if error output has been redirected by calling method  \`ProcessBuilder.redirectErrorStream(true)\` then, the error stream and the output stream will be shown using the same stream.\r
\r
If we want to have it differentiated from the output, then we can use asimilar schema than before\r
\r
\`\`\`java\r
Process p = pbuilder.start();\r
BufferedReader processError = \r
    new BufferedReader(new InputStreamReader(p.getErrorStream()));\r
int value = Integer.parseInt(processError.readLine());\r
processError.close();\r
\`\`\`\r
\r
::: info Decorator or Wrapper design pattern\r
In both input and error streams we are getting information from a BufferedReader. Although we are not aware of using a design pattern, we are using the **decorator design pattern"* or the so called **wrapper**.\r
\r
> Decorator is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the required behaviors.\r
\r
[Refactoring.Guru design patterns](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
Let's look at a complete example code using all the above operations\r
\r
\`\`\`java\r
import java.io.*;\r
public class Ejercicio2 {\r
    public static void main(String[] args) {\r
        String comando = "notepad";\r
        ProcessBuilder pbuilder = new ProcessBuilder (comando);\r
        Process p = null;\r
        try {\r
            p = pbuilder.start();\r
            // 1- Procedemos a leer lo que devuelve el proceso hijo\r
            InputStream is = p.getInputStream();\r
            // 2- Lo convertimos en un InputStreamReader\r
            // De esta forma podemos leer caracteres en vez de bytes\r
            // El InputStreamReader nos permite gestionar diferentes codificaciones\r
            InputStreamReader isr = new InputStreamReader(is);\r
            // 2- Para mejorar el rendimiento hacemos un wrapper sobre un BufferedReader\r
            // De esta forma podemos leer enteros, cadenas o incluso líneas.\r
            BufferedReader br = new BufferedReader(isr);\r
\r
            // A Continuación leemos todo como una cadena, línea a línea\r
            String linea;\r
            while ((linea = br.readLine()) != null) \r
                System.out.println(linea);\r
        } catch (Exception e) {\r
            System.out.println("Error en: "+comando);\r
            e.printStackTrace();\r
        } finally {\r
            // Para finalizar, cerramos los recursos abiertos\r
            br.close();\r
            isr.close();\r
            is.close();\r
        }    \r
    }\r
}\r
\`\`\`\r
\r
### getOutputStream()\r
\r
We can even send input to a subprocess from a parent process\r
\r
There are three different ways of sending information to a child process. The first one is based on an OutputStream. Here no wrapper is used and the programmer has to manage all elements of the stream flow. From newline characters and type conversions to force sending information over the stream.\r
\r
\`\`\`java\r
// Low-level objects. We have to manage all elements of communication\r
OutputStream toProcess = p.getOutputStream();\r
toProcess.write((String.valueOf(number1)).getBytes("UTF-8"));\r
toProcess.write("\\n".getBytes());\r
toProcess.flush();\r
\`\`\`\r
\r
The next one is based on a Writer object as a wrapper for the OutputStream, where communication management is easier, but the programmer still has to manage elements as new lines.\r
\r
\`\`\`java\r
Writer w = new OutputStreamWriter(p.getOutputStream(), "UTF-8");\r
w.write("send to child\\n");\r
\`\`\`\r
\r
Finally, the top-level wrapper for using the OutputStream is the PrintWriter object, where we can use the wrapper with the same methods as the System.out to handle child communication flow.\r
\r
\`\`\`java\r
PrintWriter toProcess = new PrintWriter(\r
    new BufferedWriter(\r
        new OutputStreamWriter(\r
            p.getOutputStream(), "UTF-8")), true);\r
toProcess.println("sent to child");\r
\`\`\`\r
\r
### Inheriting the I/O of the parent process\r
\r
With the inheritIO() method We can redirect the sub-process I/O to the standard I/O of the current process (parent process)\r
\r
\`\`\`java\r
ProcessBuilder processBuilder = new ProcessBuilder("/bin/sh", "-c", "echo hello");\r
\r
processBuilder.inheritIO();\r
Process process = processBuilder.start();\r
\r
int exitCode = process.waitFor();\r
\`\`\`\r
\r
In the above example, by using the inheritIO() method we see the output of a simple command in the console in our IDE.\r
\r
::: warning Use it just for debugging purposes\r
This method is useful for debugging purposes, but it's not recommended for production code. It's better to use the getInputStream() and getErrorStream() methods to read the output and error streams of the subprocess, and the getOutputStream() method to write to the subprocess.\r
:::\r
\r
<!--\r
### Pipelines\r
\r
Java 9 introduced the concept of pipelines to the ProcessBuilder API:\r
\r
\`\`\`java:no-line-numbers\r
public static List<Process> startPipeline​(List<ProcessBuilder> builders)\r
\`\`\`\r
\r
Using the startPipeline method we can pass a list of ProcessBuilder objects. This static method will then start a Process for each ProcessBuilder. Thus, creating a pipeline of processes which are linked by their standard output and standard input streams.\r
\r
For example, if we want to run something like this:\r
\r
> find . -name *.java -type f | wc -l\r
\r
What we'd do is create a process builder for each isolated command and compose them into a pipeline\r
\r
\`\`\`java\r
List builders = Arrays.asList(\r
    new ProcessBuilder("find", "src", "-name", "*.java", "-type", "f"), \r
    new ProcessBuilder("wc", "-l"));\r
\r
List processes = ProcessBuilder.startPipeline(builders);\r
Process last = processes.get(processes.size() - 1);\r
\r
// We can get lats process output to get the final results\r
\`\`\`\r
\r
In the example, we're searching for all the java files inside the src directory and piping the results into another process to count them.\r
-->\r
\r
## 2.3.2 Redirecting Standard Input and Output\r
\r
In the real world, we will probably want to capture the results of our running processes inside a log file for further analysis. Luckily the ProcessBuilder API has built-in support for exactly this.\r
\r
By default, our process reads input from a pipe. We can access this pipe via the output stream returned by Process.getOutputStream().\r
\r
However, as we'll see shortly, the standard output may be redirected to another source such as a file using the method \`redirectOutput(File)\`. In this case, getOutputStream() will return a ProcessBuilder.NullOutputStream.\r
\r
::: info Redirect before running the process\r
It's important to notice when we perform each action over a process.\r
\r
Before we've seen that I/O streams are consulted and managed once the process is running, so the methods that give us access to those streams are methods of the \`Process\` class.\r
\r
If we want to redirect I/O, as we are going to see next, we will do it while preparing the process to be executed. So when it's launched its I/O streams are modified. That's why this time the methods that allow us to redirect the I/O of the processes are methods of the \`ProcessBuilder\` class.\r
::::\r
\r
Let's prepare an example to print out the version of Java. But this time let's redirect the output to a log file instead of the standard output pipe:\r
\r
\`\`\`java\r
ProcessBuilder processBuilder = new ProcessBuilder("java", "-version");\r
\r
// Error output will be sent to the same place as the standard\r
processBuilder.redirectErrorStream(true);\r
\r
File log = folder.newFile("java-version.log");\r
processBuilder.redirectOutput(log);\r
\r
Process process = processBuilder.start();\r
\`\`\`\r
\r
In the above example, we create a new temporary file called log and tell our ProcessBuilder to redirect output to this file destination.\r
\r
Es lo mismo que si llamásemos a nuestra aplicación usando el operador de redirección de salida:\r
\r
> java ejemplo-java-version > java-version.log\r
\r
::: tip Código del proceso hijo\r
Si el proceso hijo que lanzamos, en vez de ser un comando del sistema, es otra clase java, en ningún momento tenemos que modificar el código de este proceso para que funcione como hijo.\r
\r
Por lo tanto, el proceso hijo seguirá haciendo\r
\r
> System.out.println("Versión de Java: " + System.getProperty("java.version"));\r
\r
y será el sistema operativo el que se encargue de redirigir las salidas o entradas al fichero, o donde se haya configurado con los métodos de redirección de la clase \`ProcessBuilder\`.\r
:::\r
\r
It's the same as if we called our application using the output redirection operator:\r
\r
> java example-java-version > java-version.log\r
\r
::: tip Child process code\r
If the child process we launch, instead of being a system command, is another Java class, we don't have to modify the code of this process to work as a child.\r
\r
Therefore, the child process will continue to do\r
\r
> System.out.println("Java version: " + System.getProperty("java.version"));\r
\r
and it will be the operating system that will take care of redirecting the outputs or inputs to the file, or where it has been configured with the redirection methods of the \`ProcessBuilder\` class.\r
:::\r
\r
Now let's take a look at a slight variation on this example. For instance when we wish to \`append to\` a log file rather than create a new one each time:\r
\r
\`\`\`java\r
File log = tempFolder.newFile("java-version-append.log");\r
processBuilder.redirectErrorStream(true);\r
processBuilder.redirectOutput(Redirect.appendTo(log));\r
\`\`\`\r
\r
It's also important to mention the call to \`redirectErrorStream(true)\`. In case of any errors, the error output will be merged into the normal process output file.\r
\r
We can also redirect error stream an input stream for the subprocess with methods\r
\r
- redirectError(File)\r
- redirectInput(File)\r
\r
To make the redirections we can use the \`ProcessBuilder.Redirect\` class as a parameter for the overloaded version of the previous methods, using one of the following values\r
\r
| Valor                   | Significado                                                         |\r
| ----------------------- | ------------------------------------------------------------------- |\r
| Redirect.DISCARD        | Information is discarded                                   |\r
| Redirect.to(File)       | Information is saved in the file. If it exists, it's emptied.       |\r
| Redirect.from(File)     | Information is read from the file                                   |\r
| Redirect.appendTo(File) | Information is saved in the file. If it exists, it's not emptied.   |\r
\r
This values are static fields of the Redirect class and can be used as parameters for the overloads of the redirectOutput, redirectError and redirectInput methods.\r
\r
\`\`\`java\r
File log = folder.newFile("sampleInputData.csv");\r
processBuilder.redirectInput(Redirect.from(log));\r
\`\`\`\r
`]},{title:"2.1 Interprocess communication",headers:[{level:2,title:"2.1.1. Communication through I/O",slug:"_2-1-1-communication-through-i-o",link:"#_2-1-1-communication-through-i-o",children:[{level:3,title:"Standard input redirection",slug:"standard-input-redirection",link:"#standard-input-redirection",children:[]},{level:3,title:"Standard output redirection",slug:"standard-output-redirection",link:"#standard-output-redirection",children:[]},{level:3,title:"Standard error output redirection",slug:"standard-error-output-redirection",link:"#standard-error-output-redirection",children:[]},{level:3,title:"Standard input redirection",slug:"standard-input-redirection-1",link:"#standard-input-redirection-1",children:[]}]},{level:2,title:"2.1.2. Redirection of the output of one process to the input of another process",slug:"_2-1-2-redirection-of-the-output-of-one-process-to-the-input-of-another-process",link:"#_2-1-2-redirection-of-the-output-of-one-process-to-the-input-of-another-process",children:[]},{level:2,title:"2.1.3. Communication through signals",slug:"_2-1-3-communication-through-signals",link:"#_2-1-3-communication-through-signals",children:[]},{level:2,title:"2.1.4. Communication through sockets",slug:"_2-1-4-communication-through-sockets",link:"#_2-1-4-communication-through-sockets",children:[]}],path:"/en/unit2/ipc.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.1 Interprocess communication\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1 Interprocess communication" />\r
\r
# 2.1 Interprocess communication\r
\r
[[toc]]\r
\r
Interprocess communication (IPC) is one of the main features of operating systems. In this section, we will focus on the communication between processes that are on the same device.\r
\r
## 2.1.1. Communication through I/O\r
\r
Communication between processes can be done in many ways, but one of the simplest and most common is communication through standard input and output.\r
\r
::: info I/O in Java\r
In Java, communication through standard input and output is done through standard input and output streams, \`System.in\` and \`System.out\` respectively.\r
:::\r
\r
Every process has three standard input and output streams that can be used for communication with other processes. These streams are:\r
\r
- **stdin** (standard input): where the process receives data. By default, it corresponds to the keyboard and the file identifier associated with it is 0.\r
- **stdout** (standard output): where the process sends data. By default, it corresponds to the console and the file identifier associated with it is 1.\r
- **stderr** (standard error output): where the process sends error messages. By default, it corresponds to the console and the file identifier associated with it is 2.\r
\r
A relatively simple IPC mechanism is the communication of processes through the redirection of standard inputs and outputs to/from other sources.\r
\r
::: warning I/O redirection\r
The redirection of standard input and output can be done on the command line of UNIX and Windows systems. In Java, it can be done using the \`ProcessBuilder\` class that we will see in the next section of the unit.\r
:::\r
\r
### Standard input redirection\r
\r
Standard input redirection can be done using the \`<\` operator in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass < input.txt\r
\`\`\`\r
\r
In the previous example, the \`MyClass\` program receives standard input from the \`input.txt\` file instead of from the keyboard.\r
\r
> When standard input is redirected, the program does not have to do anything special to read from a file instead of from the keyboard. The operating system takes care of redirecting the standard input of the program to the file that is indicated.\r
>\r
### Standard output redirection\r
\r
Standard output redirection can be done using the \`>\` and \`>>\` operators in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass > output.txt\r
$> java MyClass >> output2.txt\r
\`\`\`\r
\r
In the previous example, the standard output of the \`MyClass\` program is redirected to the \`output.txt\` file instead of to the console. If the \`output.txt\` file does not exist, it is created, and if the file already exists, its value is overwritten.\r
\r
If the operator is \`>>\`, the output is added to the end of the file instead of overwriting it.\r
\r
> When standard output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the standard output of the program to the file that is indicated.\r
\r
### Standard error output redirection\r
\r
Standard error output redirection can be done using the \`2>\` operator in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass 2> error.txt\r
$> java MyClass 2>> error2.txt\r
\`\`\`\r
\r
In the previous example, the standard error output of the \`MyClass\` program is redirected to the \`error.txt\` file instead of to the console.\r
\r
If the operator is \`2>>\`, the error output is added to the end of the file instead of overwriting it.\r
\r
> When the error output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the error output of the program to the file that is indicated.\r
\r
### Standard input redirection\r
\r
Standard input redirection can be done using the \`<\` operator in UNIX and Windows systems.\r
\r
\`\`\`bash\r
$> java MyClass < input.txt\r
\`\`\`\r
\r
In the previous example, the \`MyClass\` program receives standard input from the \`input.txt\` file instead of from the keyboard.\r
\r
> When standard input is redirected, the program does not have to do anything special to read from a file instead of from the keyboard. The operating system takes care of redirecting the standard input of the program to the file that is indicated.\r
>\r
> ### Standard output redirection\r
>\r
> Standard output redirection can be done using the \`>\` and \`>>\` operators in UNIX and Windows systems.\r
>\r
> \`\`\`bash\r
> $> java MyClass > output.txt\r
> $> java MyClass >> output2.txt\r
> \`\`\`\r
\r
In the previous example, the standard output of the \`MyClass\` program is redirected to the \`output.txt\` file instead of to the console. If the \`output.txt\` file does not exist, it is created, and if the file already exists, its value is overwritten.\r
\r
If the operator is \`>>\`, the output is added to the end of the file instead of overwriting it.\r
\r
> When standard output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the standard output of the program to the file that is indicated.\r
>\r
> ### Standard error output redirection\r
>\r
> Standard error output redirection can be done using the \`2>\` operator in UNIX and Windows systems.\r
>\r
> \`\`\`bash\r
> $> java MyClass 2> error.txt\r
> $> java MyClass 2>> error2.txt\r
> \`\`\`\r
\r
In the previous example, the standard error output of the \`MyClass\` program is redirected to the \`error.txt\` file instead of to the console.\r
\r
If the operator is \`2>>\`, the error output is added to the end of the file instead of overwriting it.\r
\r
> When the error output is redirected, the program does not have to do anything special to write to a file instead of to the console. The operating system takes care of redirecting the error output of the program to the file that is indicated.\r
\r
## 2.1.2. Redirection of the output of one process to the input of another process\r
\r
The redirection of standard output to the standard input of another process can be done using the \`|\` operator in UNIX and Windows systems.\r
\r
Pipes allow you to connect the standard output of one process to the standard input of another, thus establishing a producer-consumer relationship.\r
\r
The use of pipes follows the following syntax:\r
\r
\`\`\`bash\r
$> java MyClass | java MyClass2\r
\`\`\`\r
\r
In the previous example, the standard output of the \`MyClass\` program is redirected to the standard input of the \`MyClass2\` program.\r
\r
> When the standard output of one process is redirected to the standard input of another, the operating system takes care of connecting the output and input streams of the processes.\r
\r
## 2.1.3. Communication through signals\r
\r
Signals are a form of communication between processes that is based on interrupting the execution of a process to perform a specific action.\r
\r
Signals are asynchronous events that are sent to a process to notify it of an event. Signals can be sent by the process itself, by another process, or by the operating system.\r
\r
Signals can be sent to a process using the \`kill\` command in UNIX systems.\r
\r
\`\`\`bash\r
$> kill -s SIGUSR1 1234\r
\`\`\`\r
\r
In the previous example, the \`SIGUSR1\` signal is sent to the process with PID \`1234\`.\r
\r
Signals in the Windows shell can be sent using the \`taskkill\` command.\r
\r
\`\`\`bash\r
$> taskkill /pid 1234 /f\r
\`\`\`\r
\r
In the previous example, the forced termination signal is sent to the process with PID \`1234\`.\r
\r
::: tip Signals\r
You can look at the [UNIX signal list](https://en.wikipedia.org/wiki/Signal_(IPC)) in Wikipedia.\r
\r
And you an read more on [Gestión de procesos en Windows](https://openwebinars.net/blog/gestion-de-procesos-y-servicios-desde-shell-script-en-windows/).\r
:::\r
\r
\r
\r
\r
## 2.1.4. Communication through sockets\r
\r
Sockets can be used for communication between processes on the same device or on different devices.\r
\r
Sockets will be studied in Unit 4, where we will see how they can be used for communication between processes on different devices.\r
`]},{title:"2.2 Process management in Java - ProcessBuilder and Process",headers:[{level:2,title:"2.2.1 Preparation and setting of a process",slug:"_2-2-1-preparation-and-setting-of-a-process",link:"#_2-2-1-preparation-and-setting-of-a-process",children:[{level:3,title:"Setting the command at runtime",slug:"setting-the-command-at-runtime",link:"#setting-the-command-at-runtime",children:[]},{level:3,title:"Additional settings for a process",slug:"additional-settings-for-a-process",link:"#additional-settings-for-a-process",children:[]}]},{level:2,title:"2.2.2 Process control from parent",slug:"_2-2-2-process-control-from-parent",link:"#_2-2-2-process-control-from-parent",children:[]},{level:2,title:"2.2.3 Spawn a java application from a class into the same project",slug:"_2-2-3-spawn-a-java-application-from-a-class-into-the-same-project",link:"#_2-2-3-spawn-a-java-application-from-a-class-into-the-same-project",children:[]},{level:2,title:"2.2.4 Current Java Process Information",slug:"_2-2-4-current-java-process-information",link:"#_2-2-4-current-java-process-information",children:[{level:3,title:"Getting information about the current process",slug:"getting-information-about-the-current-process",link:"#getting-information-about-the-current-process",children:[]},{level:3,title:"Getting information about a child process from parent",slug:"getting-information-about-a-child-process-from-parent",link:"#getting-information-about-a-child-process-from-parent",children:[]}]}],path:"/en/unit2/processbuilder.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.2 Process management in Java - ProcessBuilder and Process\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.2 Process management in Java - ProcessBuilder and Process" />\r
\r
# 2.2 Process management in Java ProcessBuilder and Process\r
\r
[[toc]]\r
\r
## 2.2.1 Preparation and setting of a process\r
\r
The class to set the running attributes for a new process, before it is being run, is the \`ProcessBuilder\` class.\r
\r
> [Specification java.lang.ProcessBuilder](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessBuilder.html)\r
\r
This is an auxiliary class for the Process and is instantiated to manage a collection of process attributes. We can invoke the \`start\` method to create a new process with the attributes defined by the instance of the ProcessBuilder class.\r
\r
Repeated calls to the start method would create a new process with the same attributes.\r
\r
The ProcessBuilder class defines two constructors, such as:\r
\r
\`\`\`java:no-line-numbers\r
ProcessBuilder(List<String> command)\r
ProcessBuilder(String... command)\r
\`\`\`\r
\r
The meaning implied by the parameters passed to both constructors is same. In the first constructor, the command to be executed, along with command line arguments, is passed in a list of strings. And, in the second constructor, the command and the command line arguments are specified through the varargs parameter. We can use either of the constructors, depending upon the way to pass the parameter.\r
\r
::: danger Arguments vs Parameters\r
If we want to launch a command with parameters, the command cannot be sent to ProcessBuilder in raw mode, it must be processed and converted into a List in order to make it work.\r
\r
\`\`\`java\r
// Different modes to pass the command to ProcessBuilder constructors\r
// 1st mode: using a string. It fails with parameters, \r
// Only works with commands having arguments\r
String command1 = "notepad.exe prueba1.txt"\r
ProcessBuilder pb = new ProcessBuilder(command1);\r
\r
// 2nd mode: using an array of strings. It also works with parameters\r
String[] command2 = {"cmd", "/c", "dir", "/o"};\r
ProcessBuilder pb = new ProcessBuilder(command2);\r
\r
// 3rd mode: using a string and splitting it to convert into a List\r
String command3 =  "c:/windows/system32/shutdown -s -t 0";  \r
// Regular expresion \\s means splitting the string by blank spaces\r
ProcessBuilder pb = new ProcessBuilder(command3.split("\\\\s"));\r
\`\`\`\r
\r
:::\r
\r
::: warning OS shutdown\r
You can use shutdown -s command to shutdown system. For windows OS, you need to provide full path of shutdown command e.g. C:\\Windows\\System32\\shutdown.\r
\r
Here you can use -s switch to shutdown system, -r switch to restart system, -h to put the system into hibernation, and -t switch to specify time delay.\r
\r
[Windows shutdown reference](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown)\r
:::\r
\r
::: question Activity psp.activities.U2A1_Shutdowner\r
Create a new Java application project (package psp.activities & main class U2A1_Shutdowner)\r
Using the command line, ask the user for the action he wants to do with the computer (shutdown ,restart or suspend) and how much time he needs before shutting down the system.\r
\r
Find information about the shutdown command in GNU/Linux and make your app work in both systems.\r
\r
Your app has to prepare the right command for the answers the user has given and for the OS it is running on.\r
\r
Get the ProcessBuilder.command() result and show it on the console in a readable format.\r
:::\r
\r
:::details U2A1_Shutdowner solution\r
\r
\`\`\`java\r
public class U2A1_Shutdowner {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Ask for the required information to prepare the command\r
        Scanner keyboard = new Scanner(System.in);\r
        \r
        System.out.print("Select your option (s-shutdown / r-reboot / h-hibernate): ");\r
        String shutdownOption = keyboard.nextLine();        \r
        \r
        System.out.print("How much seconds will the command wait to be run? (0 means immediately): ");\r
        String shutdownTime = keyboard.nextLine();        \r
        \r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "C:/Windows/System32/shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        } else {\r
            command = "shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder shutdowner = new ProcessBuilder(command.split("\\\\s"));\r
        //shutdowner.start();\r
        \r
        // Show the command to be run\r
        System.out.print("El comando a ejecutar es:  ");\r
        for (String commandPart: shutdowner.command()) {\r
            System.out.print(commandPart + " ");\r
        }\r
        System.out.println("");\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
### Setting the command at runtime\r
\r
If we want to set the command to be run at runtime, or at the time the ProcessBuilder instance is created we still don't know the command, it can be set later by using the command(String).\r
\r
The same way as the constructors, we have two versions of command method\r
\r
\`\`\`java:no-line-numbers\r
    command(List<String> command)\r
    command(String... command)\r
\`\`\`\r
\r
and there's also another command method, without parameters, to retrieve the command and parameters already set for the ProcessBuilder instance. Once we have the parameters list, we can modify it using List methods.\r
\r
\`\`\`java\r
// Sets and modifies the command after ProcessBuilder object is created\r
String command = "java -jar install.jar -install"; // tmp dir is missing\r
ProcessBuilder pbuilder = new ProcessBuilder(command.split("\\\\s"));\r
if (isWindows) {\r
    pbuilder.command().add(0, "cmd"); // Sets the 1st element\r
    pbuilder.command().add(1, "/c"); // Sets the 2nd element\r
    pbuilder.command().add("c:/temp"); // Sets the last element\r
    // Command to run cmd /c java -jar install.jar -install c:/temp\r
} else {\r
    pbuilder.command().add(0, "sh"); // Sets the 1st element\r
    pbuilder.command().add(1, "-c"); // Sets the 2nd element\r
    pbuilder.command().add("/tmp"); // Sets the last element\r
    // Command to run: sh -c java -jar install.jar -install /tmp\r
}\r
\r
// Starts the process\r
pbuilder.start();\r
\`\`\`\r
\r
### Additional settings for a process\r
\r
Some of the settings that can be changed for a process are:\r
\r
- Set the working directory where the process will be run\r
  We can override the default working directory of the current process by calling the directory method and passing a File object. **By default, the current working directory is set to the value returned by the user.dir system property**.\r
\r
    \`\`\`java\r
    // Change working directory for the running process\r
    pbuilder.directory(new File(System.getProperty("user.home")));\r
    \`\`\`\r
\r
- Set-up a custom key-value map and modify an existing one using builder.environment()\r
\r
    \`\`\`java\r
    // Retrieve and modify the process environment\r
    Map<String, String> environment = pbuilder.environment();\r
    // Get the PATH environment variable and add a new directory\r
    String systemPath = environment.get("path") + ";c:/users/public";\r
    environment.replace("path", systemPath);\r
    // Add a new environment variable and use it as a part of the command\r
    environment.put("GREETING", "Hola Mundo");\r
    processBuilder.command("/bin/bash", "-c", "echo $GREETING");\r
    \`\`\`\r
\r
    ::: info Environment variables vs System properties\r
    With Runtime we also accessed System properties, that are different from this environment ones.\r
    :::\r
\r
- Redirect input and output streams to custom replacements\r
- Inherit both of them to the streams of the current JVM process using builder.inheritIO()\r
  \r
  *This two settings will be covered later in this unit*.\r
\r
::: question Activity psp.activities.U2A2_WorkingDirectory\r
Create a new Java application project (package psp.activities & main class U2A2_WorkingDirectory    )\r
Prepare a process to run the dir/ls command to check that the directory listing is for the directory pointed by the user.dir property.\r
In the same application, change the value for the user.dir property.\r
Finally, set a working directory for the process.\r
\r
Print the user.dir environment value for the three scenarios after being changed.\r
:::\r
\r
::: details U2A2_WorkingDirectory solution\r
\r
\`\`\`java\r
public class U2A2_WorkingDirectory {\r
\r
    public static void main(String[] args) throws IOException, InterruptedException {\r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "cmd /c dir";\r
        } else {\r
            command = "sh -c ls";\r
        }\r
               \r
        //1st - Default working directory\r
        \r
        // Prepare the process \r
        ProcessBuilder commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir\r
        commander.start().waitFor();\r
        \r
        \r
        //2nd - Change user.dir but not the working directory\r
        \r
        // Change the user.dir system property\r
        System.setProperty("user.dir", System.getProperty("user.home"));\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir        \r
        commander.start().waitFor();\r
        \r
        \r
        // 3rd - Change the working directory\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        commander.directory(new File(System.getProperty("user.home")));             \r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
\r
        // Launch the process and show its result\r
        // Working directory is user.home and the process is run on it\r
        commander.start().waitFor();        \r
    }\r
}\r
\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.2 Process control from parent\r
\r
The \`Process\` is an abstract class defined in the java.lang package that encapsulates the runtime information of a program in execution. The \`start\` method invoked by the ProcessBuilder class returns a reference to this class instance. There is an another way to create an instance of this class, through the \`exec\` method of the Runtime instance.\r
\r
The methods defined by the Process class can be used to perform input/output operations from the process, check the exit status of the process, wait for it to complete, and terminate the process. These methods, however, are not built to work on special processes of the native platform like daemon processes, shell scripts, and so on.\r
\r
> [Specification java.lang.Process](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Process.html)\r
\r
::: warning Input/ output from the child process\r
Intriguingly, **the process created by the start() method does not own a console**. Instead, it redirects (stdin, stdout, stderr) to the parent process. If need be, we can access them via streams obtained using methods defined in the class, such as getInputStream(), getOutputStream() and getErrorSteam(). These are the ways we can feed input to and get results from the sub processes.\r
:::\r
\r
Some of the common methods defined in this class are:\r
\r
| method                                       | Description                                                                                                                                                |\r
| :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| int exitValue()                              | Exit code returned from the process executed                                                                                                              |\r
| Boolean isAlive()                            | Checks if the invoking process is still running.                                                                                                    |\r
| int waitFor()                                | Parent process waits for the child process to end. The integer value returned by the method is the exit code by the process.                                           |\r
| Boolean waitFor(long timeOut, TimeUnit unit) | Overloaded method of previous one. We can specify the wait time. This method returns true if the process has terminated and false if timeout has occurred. |\r
| void destroy()                               | These two methods are used to kill or terminate the process. One, the second, just does it forcibly.                                                       |\r
| Process destroyForcibly()                    |\r
\r
 Let’s write a simple Java program to open an application as a separate process. After it is opened, the program would wait for, say, 10 seconds and then destroy the process, which will immediately close the application.\r
\r
\`\`\`java\r
public class ProcessDemo {\r
\r
   public static void main(String[] args) throws Exception {\r
\r
      ProcessBuilder pb = new ProcessBuilder("C:/Program Files (x86)/Notepad++/notepad++.exe");\r
      // Effectively launch the process\r
      Process p = pb.start();\r
      // Check is process is alive or not\r
      boolean alive = p.isAlive();\r
      // Wait for the process to end for 10 seconds.\r
      if (p.waitFor(10, TimeUnit.SECONDS)) {\r
          System.out.println("Process has finished");\r
      } else {\r
          System.out.println("Timeout. Process hasn't finished");\r
      }\r
      // Force process termination.\r
      p.destroy();\r
      // Check again if process remains alive\r
      alive = p.isAlive();\r
      // Get the process exit value\r
      int status = p.exitValue();        \r
   }\r
}\r
\`\`\`\r
\r
::: info Exit codes\r
An exit code, or sometimes known as a return code, is the code returned to a parent process by an executable. The standard exit code is 0 for success and any number from 1 to 255 for anything else.\r
:::\r
\r
::: question Activity psp.activities.U2A3_ExitValue\r
Create a new Java application project (package psp.activities & main class U2A3_ExitValue)\r
Prepare a process to run different commands (notepad, calc, shell commands) one after each other, and make your application get their exit code. Print it.\r
\r
Commands can be hardcoded. As an **optional** improvement for this activity you can ask the user for the command and make your app interactive. There must be an option to exit the app (empty command for instance).\r
\r
Try with non-existing applications or using wrong arguments/parameters for commands.\r
\r
Can you force a process not to be successful?\r
\r
How can you know your own process exit code?\r
:::\r
\r
::: details U2A3_ExitValue solution\r
\r
\`\`\`java\r
public class U2A3_ExitValue {\r
\r
    public static void main(String[] args) {\r
        do {\r
            // Código para pedir un programa/comando a ejecutar\r
            Scanner teclado = new Scanner(System.in);\r
            System.out.println("Introduce el programa / comando que quieres ejecutar (intro para acabar): ");\r
            String comando = teclado.nextLine();\r
            \r
            if (comando.equals("")) System.exit(0);\r
\r
            try {\r
                // Preparamos el entrono de ejecución del proceso\r
                // Como no sabemos el contenido del comando, forzamos su conversión\r
                // a una lista para que no haya problemas con su ejecución\r
                ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
\r
                // Lanzamos el proceso hijo\r
                Process p = pb.start();          \r
\r
                // Esperamos a que acabe para recoger el valor de salida\r
                int exitValue = p.waitFor();\r
\r
                if (exitValue == 0) {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
                } else {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Código (" + exitValue + ")");\r
                }\r
\r
            } catch (InterruptedException | IOException ex) {\r
                System.err.println(ex.getLocalizedMessage());\r
                ex.printStackTrace();\r
            }                       \r
        } while (true);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
::: danger Exceptions management\r
Call to method **waitFor** implies that the parent process gets locked until child process ends, or until a signal from the system (Exception) is received.\r
\r
It's better to handle exceptions than to throw them to upper levels.\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.3 Spawn a java application from a class into the same project\r
\r
For some activities you'll be required to create the parent and the child processes as Java applications. Then, from one the classes you will need to launch the other one.\r
\r
This implies that both classes are gonna have a main method. So, in the project properties we'll need to set which is the main class that will be run first, usually the \`Launcher\` class (parent process).\r
\r
![Main class](../../media/unit2/seleccionmain.png)\r
\r
Before one class can run the other, at least the second one (child process) must be compiled, that is, the .class file has to be generated into the build/classes directory.\r
\r
![Working directory](../../media/unit2/comandotree.png)\r
\r
Them and only then we can set the process environment to spawn a new process from an existing class. Here is the sample code\r
\r
\`\`\`java\r
// Prepare the environment and the command\r
ProcessBuilder pb = new ProcessBuilder("java", "psp.u2.actividad10.Sumador");\r
pb.directory(new File("build/classes"));\r
Process p = pb.start();\r
\`\`\`\r
\r
::: question Activity psp.activities.U2A4_Launcher\r
Create a new Java application project (package psp.activities & main class U2A4_Launcher).\r
\r
Into the project create another class, U2A4_Commander with a main method that receives a program name as a unique parameter in the main. Make this application to create and run a process for the program and wait until that process has finished.\r
\r
This class will return always the same value the launched program did.\r
\r
> System.exit() method\r
>\r
> - Zero. The zero status code should be used when the program execution went fine, i.e., the program is terminated successfully.\r
> - Non-Zero. A nonzero status code indicates abnormal termination. Java allows us to use different values for different kinds of errors.\r
\r
Now, make the U2A4_Launcher class ask the user for an application name and launch the Commander class passing it the name of the application entered by the user.\r
\r
Get the exitValue from Commander and show it's value, telling if the process worked fine or if it failed.\r
:::\r
\r
::: details U2A4_Launcher solution\r
\r
\`\`\`java\r
public class U2A4_Launcher {\r
\r
    public static void main(String[] args) {\r
\r
        // Código para pedir un programa/comando a ejecutar\r
        Scanner teclado = new Scanner(System.in);\r
        System.out.println("Introduce el programa / comando que quieres ejecutar: ");\r
        String comando = teclado.nextLine();\r
\r
        try {\r
            // Preparamos el entrono de ejecución del proceso\r
            // Como no sabemos el contenido del comando, forzamos su conversión\r
            // a una lista para que no haya problemas con su ejecución\r
            comando = "java psp.activities.U2A4_Commander " + comando;\r
            ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
            pb.directory(new File("build/classes"));\r
\r
            // Lanzamos el proceso hijo\r
            Process p = pb.start();          \r
\r
            // Esperamos a que acabe para recoger el valor de salida\r
            int exitValue = p.waitFor();\r
\r
            if (exitValue == 0) {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
            } else {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Código (" + exitValue + ")");                \r
            }\r
        } catch (InterruptedException | IOException ex) {\r
            System.err.println(ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }                       \r
    }\r
}\r
\r
public class U2A4_Commander {\r
\r
    public static void main(String[] args) throws Exception {       \r
        // Lectura de información desde los parámetros de entrada \r
        // Se supone que recibimos: args[0] args[1] args[2] ..... args[args.length-1 --> comando a ejecutar\r
        String comando = "";\r
        for (int i = 0; i < args.length; i++) {\r
            comando += args[i] + " ";\r
        }\r
        comando.trim();\r
                \r
        ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));            \r
\r
        // Lanzamos el proceso hijo\r
        Process p = pb.start();          \r
\r
        // Esperamos a que acabe para recoger el valor de salida\r
        int exitValue = p.waitFor();\r
\r
        System.exit(exitValue);\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
::: warning Child classes programming\r
Every class must be coded to be run independently or just as a child process. Think that in Netbeans all classes are run as child classes from the IDE.\r
\r
That's why the code, child or parent, needs to be done without thinking how they are gonna be called. The code must be  **independent** just like processes are one from each other.\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.4 Current Java Process Information\r
\r
We can now obtain a lot of information about the process via the API \`java.lang.ProcessHandle.Info\` API:\r
\r
- the command used to start the process\r
- the arguments of the command\r
- time instant when the process was started\r
- total time spent by it and the user who created it\r
\r
### Getting information about the current process\r
\r
Here's how we can do that for the current process:\r
\r
\`\`\`java{2-3}\r
// Get information about the current process\r
ProcessHandle processHandle = ProcessHandle.current();\r
ProcessHandle.Info processInfo = processHandle.info();\r
\r
System.out.println("PID: " + processHandle.pid());\r
System.out.println("Arguments: " + processInfo.arguments());\r
System.out.println("Command: " + processInfo.command());\r
System.out.println("Instant: " + processInfo.startInstant());\r
System.out.println("Total CPU duration: " + processInfo.totalCpuDuration());\r
System.out.println("User: " + processInfo.user());\r
\`\`\`\r
\r
### Getting information about a child process from parent\r
\r
It is also possible to get the process information of a newly spawned process. In this case, after we spawn the process and get an instance of the \`java.lang.Process\`, we invoke the \`toHandle()\` method on it to get an instance of java.lang.ProcessHandle.\r
\r
\`\`\`java{3-4}\r
// Get information about a child process from parent\r
Process process = processBuilder.inheritIO().start();\r
ProcessHandle childProcessHandle = process.toHandle();\r
ProcessHandle.Info childProcessInfo = childProcessHandle.info();\r
\`\`\`\r
\r
The rest of the details remain the same as in the section above\r
`]},{title:"2.1 Running processes in Java with Runtime",headers:[{level:2,title:"2.1.1. Quick process launch",slug:"_2-1-1-quick-process-launch",link:"#_2-1-1-quick-process-launch",children:[]},{level:2,title:"2.1.2 System properties and command shells",slug:"_2-1-2-system-properties-and-command-shells",link:"#_2-1-2-system-properties-and-command-shells",children:[]}],path:"/en/unit2/runtime.html",pathLocale:"/en/",extraFields:[`---\r
title: 2.1 Running processes in Java with Runtime\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Running processes in Java with Runtime" />\r
\r
# 2.1. Running processes in Java with Runtime\r
\r
[[toc]]\r
\r
## 2.1.1. Quick process launch\r
\r
 There are several methods defined in the Runtime class. These methods can be invoked to get the information about the runtime environment such as number of processors available to the JVM, about of memory available, loading native library, explicitly call garbage collector, and so forth.\r
\r
> [Specification java.lang.Runtime](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html)\r
\r
Every Java program has an instance of the Runtime class, which encapsulates the runtime environment of the program. This class cannot be instantiated, but we can get a reference **singleton instance** to the Runtime of the currently running program with the help of the static method **java.lang.Runtime.getRuntime()**.\r
\r
::: question Design patterns: Singleton\r
¿What are design patterns? ¿What is and what is used for the singleton pattern?\r
\r
Look how to implement a class with the singleton pattern.\r
\r
[Refactoring.Guru design patterns](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
The Runtime class method we are interested in, to create a new processes is\r
\r
> public Process exec(String command) throws IOException\r
\r
This is a simple, not yet customizable, way to spawn a new sub-process.\r
\r
\`\`\`java\r
public static void main(String[] args) throws IOException {\r
    // Launch notepad app\r
    Runtime.getRuntime().exec("notepad.exe");\r
\r
    // This way always works\r
    // String separator = System.getProperty("file.separator");\r
    // Runtime.getRuntime()\r
    //    .exec("c:"+separator+"windows"+separator+"notepad.exe");\r
\r
    // This way used to work (UNIX style paths)\r
    // Runtime.getRuntime().exec("c:/windows/notepad.exe");\r
}\r
\`\`\`\r
\r
As you can see the argument to  \`exec\` method is just the program we want to run. In this example, as *notepad* is in the system PATH it's not necessary to tell the path to the program. Otherwise, the path must be specified with the program name.\r
\r
<div class="pagebreak"></div>\r
\r
## 2.1.2 System properties and command shells\r
\r
If we plan to code platform independent applications, we have to deal with many issues because of differences between OS. So sometimes we need to deal with specific OS information. A useful way to get that information is by getting System properties.\r
\r
[Specification System.getProperties](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html#getProperties())\r
\r
Some examples are provided here using System properties. Similar solutions can be used for other issues.\r
\r
::: danger File separator\r
For file path or directory separator, the Unix system introduced the slash character / as directory separator, and the Microsoft Windows introduced backslash character \\ as the directory separator. In a nutshell, this is / on UNIX and \\ on Windows.\r
\r
Then, ¿how can we code OS independent applications??\r
\r
In Java, we can use the following three methods to get the platform-independent file path separator.\r
\r
- System.getProperty("file.separator")\r
- FileSystems.getDefault().getSeparator() (Java NIO)\r
- File.separator Java IO\r
\r
From now on, we are gonna use System properties in our applications for several situations using \`System.getProperty(String propName)\`. These properties are configured by the OS and the JVM, though we can modify them by setting the JVM running setting\r
\r
> String separator = System.getProperty("file.separator");\r
\r
or\r
\r
> -Dfile.separator\r
\r
Nevertheless is always a good practice to use slash character **/** in paths as Java is able to convert them to the system it is running on.\r
:::\r
\r
If we want to run an OS command we have to do it as we usually do, by using the command shell, where once again we find the troubleshot with UNIX / Windows.\r
\r
Let's take a look at the way we can use the system properties, once again, to get a list of files in the user personal folder.\r
\r
\`\`\`java\r
// First we get the user folder path\r
String homeDirectory = System.getProperty("user.home");\r
// And then we set which OS are we running on\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info non-interactive shell mode\r
In the previous code example, both for Windows and UNIX modifier **c** is used for command shells. This modifier tells the system to open a command shell, to run the companion command and close the shell after it has finished.\r
:::\r
\r
Next you can look at a handler event manager for a mouse clic, into a graphic application, to open a web site in a browser. The code shows how to do it in  *X like operating system and one way to do it in Windows systems is commented.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Our first applications in java is not gonna be an easy one.\r
\r
Using methods from System class and Runtime class, write the code for an app that shows\r
\r
- all the system properties configured in your OS\r
- total memory, free memory, used memory and processors available\r
\r
Make a research into Runtime class methods. For System properties try to get a list or iterable data estructure to show each of the system properties and their values.\r
:::\r
\r
::: details Proposed solution to previous activiy\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
::: info Number format\r
In any programming language we have many different ways to format the information shown to the user. As in this first applications we are using the console as the system output, let's check the two main techniques we can use in Java\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Using NumberFormat class or any of its descendants we can get control on how the numbers are shown with high precision, using numeric patterns.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Hashes can be used instead of zeros to allow .30 to be shown as 0.3\r
// (additional digits are optional)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Similar to C's printf syntax, we can use the java.util.Formatter syntax to set how data is visualized.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// numbers after % print preceding spaces to fill \r
// and justify numbers.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
:::\r
\r
::: info Colours in console applications\r
\r
There is a way to print in different colours when using the console. Here you have got an example code with some colours and the way to use it.\r
\r
\`\`\`java:no-line-numbers\r
public class UsingColoursInConsole {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hello" \r
                          + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Bye bye" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
`]},{title:"3.4 Alternative synchronization techniques",headers:[{level:2,title:"3.4.1. Semaphores",slug:"_3-4-1-semaphores",link:"#_3-4-1-semaphores",children:[]},{level:2,title:"3.4.2. High level synchronization techniques",slug:"_3-4-2-high-level-synchronization-techniques",link:"#_3-4-2-high-level-synchronization-techniques",children:[{level:3,title:"Concurrent Queues",slug:"concurrent-queues",link:"#concurrent-queues",children:[]},{level:3,title:"Concurrent Collections",slug:"concurrent-collections",link:"#concurrent-collections",children:[]},{level:3,title:"Atomic variables",slug:"atomic-variables",link:"#atomic-variables",children:[]}]},{level:2,title:"3.4.3 Executors, Callables & Future",slug:"_3-4-3-executors-callables-future",link:"#_3-4-3-executors-callables-future",children:[]}],path:"/en/unit3/alternatives.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.4 Alternative synchronization techniques\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.4 Alternative synchronization techniques" />\r
\r
# 3.4 Alternative synchronization techniques\r
\r
[[toc]]\r
\r
## 3.4.1. Semaphores\r
\r
There are many other ways to synchronize threads, one of the low-level ones ar \`semaphores\`. A semaphore controls access to a shared resource through the use of a counter. If the counter is greater than zero, then access is allowed. If it is zero, then access is denied. What the counter is counting are permits that allow access to the shared resource. Thus, to access the resource, a thread must be granted a permit from the semaphore.\r
\r
> [java.util.concurrent.Semaphore](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html) specification.\r
\r
Semaphores control access to \`critical sections\` where shared resources or variables are handled in a special way. Depending on thi initial value of the semaphore, a number of concurrent threads can access simultaneously to a shared resource.\r
\r
Semaphores can be manages with two methods and their initial value \`permits\`:\r
\r
- release(): When thread no longer needs access to a shared resource, it releases the permit, incrementing the semaphore count. By default the semaphore counter \`permits\` is incremented by 1, though it can get a value and increment the count in that value.\r
- acquire(): If a thread needs to access a shared resource or critical section, then it must get control over the semaphore. If semaphore count > 0, the thread acquires a permit, decrementing the semaphore’s count. Else, the thread is blocked until a permit can be acquired. Other value than 1 can be used to get the semaphore, having \`permits\` to be bigger than that value in order to get semaphore's control\r
- permits: The value of a counting semaphore at any point indicates the maximum number of processes that can enter the critical section at the exact same time. Each thread asks for a permit. if value is bigger than 0 that means free resources are available, so the thread will enter the semaphore and reduce the permit count\r
When the semaphore's permit count reaches to 0 that means no more shared resources are available and threads will be locked waiting for another thread to perform a release action on the semaphore.\r
\r
:::info Mutex\r
Binary semaphore: A binary semaphore only takes only 0 and 1 as values and is used to implement mutual exclusion as well as synchronize concurrent processes.\r
\r
The work similar to synchronized, providing **mut**ual **ex**clusion.\r
:::\r
\r
Let's take a look at this example\r
\r
\`\`\`java {class="line-numbers",5-7,13,15,20,27,37,39,44,51}\r
public class Almacen {\r
\r
  private final int MAX_LIMITE = 20;\r
  private int producto = 0;\r
  private Semaphore productor = new Semaphore(MAX_LIMITE);\r
  private Semaphore consumidor = new Semaphore(0);\r
  private Semaphore mutex = new Semaphore(1);\r
\r
  public void producir(String nombreProductor) {\r
    System.out.println(nombreProductor + " intentando almacenar un producto");\r
    try {\r
        // up to 20 producers can enter at the same time\r
        productor.acquire();\r
        // But only 1 (consumer/producer) at a time can update\r
        mutex.acquire();\r
\r
        producto++;\r
        System.out.println(nombreProductor + " almacena un producto. "\r
            + "Almacén con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
      \r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // Producers allow (notify) consumers to access\r
      consumidor.release();\r
    }\r
\r
  }\r
\r
  public void consumir(String nombreConsumidor) {\r
    System.out.println(nombreConsumidor + " intentando retirar un producto");\r
    try {\r
        // A producer must be run first, before any consumer\r
        consumidor.acquire();\r
        // But only 1 (consumer/producer) at a time can update\r
        mutex.acquire();\r
\r
        producto--;\r
        System.out.println(nombreConsumidor + " retira un producto. "\r
            + "Almacén con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // Consumers allow (notify) producers to add more products\r
      productor.release();\r
\r
    }\r
  }\r
\r
}\r
\`\`\`\r
\r
## 3.4.2. High level synchronization techniques\r
\r
The \`java.util.concurrent\` package provides tools for creating concurrent applications. There are some  \`thread-safe\` classes que to use Collections and basic data types without worrying about concurrent access.\r
\r
Using these classes in our code we can reduce out apps complexity.\r
\r
### Concurrent Queues\r
\r
The **BlockingQueue** interface defines a \`FIFO\` queue that locks threads trying to get elementos from an empty queue until there will be elements in the queue. it can set a maximum number of elements in the queue so that thread are blocked if they try to add elements over that number, having to wait until elements are extracted form the queue.\r
\r
Classes LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue and DelayQueue implement interface BlockingQueue.\r
\r
### Concurrent Collections\r
\r
Besides Queues, this package supplies Collection implementations designed for use in multithreaded contexts: ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArrayList, and CopyOnWriteArraySet. When many threads are expected to access a given collection, a ConcurrentHashMap is normally preferable to a synchronized HashMap, and a ConcurrentSkipListMap is normally preferable to a synchronized TreeMap. A CopyOnWriteArrayList is preferable to a synchronized ArrayList when the expected number of reads and traversals greatly outnumber the number of updates to a list.\r
\r
**ConcurrentMap** is a subinterface of \`java.util.Map\` con with atomic operations to add / replace existing key,value pairs or to add non existing key,value pairs. ConcurrentHashMap is the thread-safe version for HashMap.\r
\r
### Atomic variables\r
\r
Package \`java.util.concurrent.atomic\` contains a small toolkit of classes that support lock-free thread-safe programming on single variables. Instances of Atomic classes maintain values that are accessed and updated using methods otherwise available for fields using associated atomic VarHandle operations.\r
\r
Instances of classes AtomicBoolean, AtomicInteger, AtomicLong, and AtomicReference each provide access and updates to a single variable of the corresponding type. Each class also provides appropriate utility methods for that type. For example, classes AtomicLong and AtomicInteger provide atomic increment methods.\r
\r
## 3.4.3 Executors, Callables & Future\r
\r
Executors is an interface to manage thread pools. Thread pools manage a pool of worker threads. The thread pools contain a work queue which holds tasks waiting to get executed.\r
\r
A thread pool can be described as a collection of Runnable/Callable objects (work queue) and a connection of running threads.\r
\r
These threads are constantly running and are checking the work query for new work. If there is new work to be done they execute this Runnable/Callable.\r
\r
Here you can check an illustrative example on how to use Executors\r
\r
[Executors: Ejemplo supermercado](https://jarroba.com/multitarea-e-hilos-en-java-con-ejemplos-ii-runnable-executors/)\r
\r
We have used a Runnable object to define the tasks that are executed inside a thread. While defining tasks using Runnable is very convenient, it is limited by the fact that the tasks can not return a result.\r
\r
What if you want to return a result from your tasks?\r
\r
Well, Java provides a \`Callable\` interface to define tasks that return a result. A Callable is similar to Runnable except that it can return a result and throw a checked exception.\r
\r
Callable interface has a single method call() which is meant to contain the code that is executed by a thread.\r
\r
\`Future\` interface has methods to obtain the result generated by a Callable object and manage its state. It represents the result of an asynchronous computation.\r
\r
The result can only be retrieved using method get() when the computation has completed, blocking if necessary until it is ready.\r
`]},{title:"3.6 Annex II - ArrayList cheat sheet by students",headers:[{level:2,title:"A. Definición y creación",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de ArrayList",slug:"a-1-constructores-de-arraylist",link:"#a-1-constructores-de-arraylist",children:[]}]},{level:2,title:"B. Métodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creación de un ArrayList",slug:"b-1-creacion-de-un-arraylist",link:"#b-1-creacion-de-un-arraylist",children:[]},{level:3,title:"B.2. Añadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si un elemento ya existe",slug:"b-3-comprobar-si-un-elemento-ya-existe",link:"#b-3-comprobar-si-un-elemento-ya-existe",children:[]},{level:3,title:"B.4. Acceder a un elemento del ArrayList",slug:"b-4-acceder-a-un-elemento-del-arraylist",link:"#b-4-acceder-a-un-elemento-del-arraylist",children:[]},{level:3,title:"B.5. Otras funciones de utilidad",slug:"b-5-otras-funciones-de-utilidad",link:"#b-5-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Añadir datos a un ArrayList",slug:"c-anadir-datos-a-un-arraylist",link:"#c-anadir-datos-a-un-arraylist",children:[{level:3,title:"C.1. Añadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Añadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Añadir / eliminar elementos desde código",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colección",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el método forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colección",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Búsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Búsqueda usando los métodos de la clase",slug:"e-1-busqueda-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Búsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Búsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Búsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtención de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenación de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar usando métodos de Collection",slug:"g-1-ordenar-usando-metodos-de-collection",link:"#g-1-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.2. Ordenar con expresiones lambda",slug:"g-2-ordenar-con-expresiones-lambda",link:"#g-2-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.3. Ordenar con API Stream",slug:"g-3-ordenar-con-api-stream",link:"#g-3-ordenar-con-api-stream",children:[]}]}],path:"/en/unit3/arraylist_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.6 Annex II - ArrayList cheat sheet by students\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Annex II - ArrayList cheat sheet by students" />\r
\r
# 3.6 Annex II - ArrayList cheat sheet by students\r
\r
::: info Autoría\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del módulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la información a la que podréis acceder durante los exámenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definición y creación\r
\r
Una colección representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacén donde poder guardarlos. En Java, se emplea la interfaz genérica \`Collection\` para este propósito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de métodos comunes, como pueden ser: añadir, eliminar, obtener el tamaño de la colección.\r
\r
Partiendo de la interfaz genérica Collection extienden otra serie de interfaces genéricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
La clase ArrayList en Java permite almacenar datos en memoria de forma similar a los Arrays con la ventaja de que el numero de elementos que almacena lo hace de forma dinámica, es decir, que no es necesario declarar su tamaño como pasa con los Arrays. Los elementos pueden añadirse o eliminarse según necesidad.\r
\r
### A.1. Constructores de ArrayList\r
\r
ArrayList proporciona 3 constructores que definen la capacidad inicial de la colección o si la inicializamos a partir de los valores de otra colección.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de ArrayList vacía.\r
ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\r
// ArrayList(int initialCapacity). Crea una instancia de ArrayList con una capacidad inicial especificada. \r
ArrayList<Persona> listaPersonas = new ArrayList<>(10);\r
\r
// ArrayList(Collection c). Crea una instancia de ArrayList a partir de otra colección de datos. Los datos se añaden en el orden en el que el Iterator de la otra colección los recorra.\r
ArrayList<Persona> listaPersonas = new ArrayList<>(c);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Métodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendríamos con la ejecución de estos métodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "García", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martínez", 65, 1.84d, 82, "Hombre");\r
  Persona p3 = new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre");\r
  Persona p4 = new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer");\r
\`\`\`\r
\r
### B.1. Creación de un ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un ArrayList de Personas\r
  ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\`\`\`\r
\r
### B.2. Añadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Añadir un objeto Persona al final del ArrayList\r
  listaPersonas.add(p1);\r
\r
  // Añade el elemento al ArrayList en la posición 'n+1'. \r
  // Cuidado, no podemos insertar en posiciones que no existen.\r
  listaPersonas.add(1, p1);\r
  \r
  // Borra el elemento de la posición 'n+1' del ArrayList   \r
  // Cuidado, no podemos eliminar de posiciones que no existen.\r
  listaPersonas.remove(2);\r
\r
  // Borra el primer objeto pasado encontrado en el ArrayList que se le pasa como parámetro.  \r
  listaPersonas.remove(p1);  \r
\`\`\`\r
\r
::: info Duplicados\r
Si ya existe un elemento en el ArrayList, esta colección no controla la existencia de duplicados, por lo que tendremos el mismo objeto en dos posiciones diferentes.\r
Podemos evitarlo comprobando previamente si ya existe ese objeto, como veremos a continuación.\r
:::\r
\r
### B.3. Comprobar si un elemento ya existe\r
\r
\`\`\`java:no-line-numbers\r
  // Comprueba si existe del objeto que se le pasa como parámetro\r
  listaPersonas.contains(p4);\r
\r
  // Devuelve la posición del primer objeto pasado encontrado en el ArrayList  \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.indexOf(p1);\r
\r
  // Devuelve la posición del último objeto pasado en el ArrayList   \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### B.4. Acceder a un elemento del ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el elemento que esta en la posición 'n+1' del ArrayList\r
  listaPersonas.get(2);\r
\`\`\`\r
\r
### B.5. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el numero de elementos del ArrayList\r
  listaPersonas.size();\r
\r
  //Borra todos los elementos de ArrayList   \r
  listaPersonas.clear();\r
\r
  // Devuelve true si el ArrayList esta vacío. Sino Devuelve false   \r
  listaPersonas.isEmpty();\r
\r
  // Pasa el ArrayList a un Array \r
  Object[] array = listaPersonas.toArray();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Añadir datos a un ArrayList\r
\r
::: info Orden de los elementos en un ArrayList\r
Cuando añadimos elementos a un ArrayList, el orden de inserción se conserva.\r
\r
Una Lista, por definición, siempre mantiene el orden de los elementos. Esto no es solo para ArrayList, sino para todo tipo de listas como LinkedList, Vector, y el resto de clases que implementan el interfaz \`java.util.List\` .\r
\r
:::\r
\r
### C.1. Añadir elementos desde el constructor\r
\r
A la hora de crear el ArrayList, podemos añadirle datos, usando la sintaxis del doble corchete o bien con la construcción List.of o Arrays.asList\r
\r
\`\`\`java:no-line-numbers\r
  // Crea una nueva lista y a la vez la inicializa con valores  \r
  ArrayList<Persona> lista1 = new ArrayList<>() {{\r
      add(p1);\r
      add(p2);\r
  }};\r
\r
  // En este caso indicamos los valores como si de parámetros se tratase\r
  // De esta forma podemos añadir hasta un máximo de 10 elementos\r
  ArrayList<Persona> lista2 = new ArrayList<>(\r
        List.of(p1, p2, p3)\r
  );\r
\r
  // De forma similar al caso anterior, con una construcción a partir de un Array\r
  ArrayList<Persona> lista3 = new ArrayList<>(\r
        Arrays.asList(p1, p2, p3)\r
  );       \r
\`\`\`\r
\r
### C.2. Añadir elementos desde otras colecciones\r
\r
Podemos inicializar un ArrayList, como hemos visto en los ejemplos anteriores, desde varios tipos de colecciones (listas) que poseen características similares.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del código anterior, creamos un nuevo ArrayList a partir de lista2\r
  ArrayList<Persona> lista4 = new ArrayList<>(lista3);  \r
  \r
  // Añade todos los elementos de la lista que indiquemos como argumento al final del ArrayList\r
  lista4.addAll(lista3);\r
\r
  // Hace lo mismo, pero lo inserta en la posición indicada (debe existir al menos la posición anterior)  \r
  lista4.addAll(lista3,2);\r
\`\`\`\r
\r
### C.3. Añadir / eliminar elementos desde código\r
\r
\`\`\`java:no-line-numbers\r
  // Añadir un elemento al final de la lista\r
  lista4.add(p4);\r
  // Añade un elemento en la posición indicada. El elemento que ocupaba esa posición y todos los que había detrás, se mueven una posición a la derecha.\r
  // En el ejemplo, inserta p1 al principio de la lista.\r
  lista4.add(0,p1);   // Inserta p1 al principio de la lista.\r
  \r
  // Eliminar un elemento. Si existe lo elimina y devuelve true, si no devuelve false\r
  boolean existe = lista4.remove(p1);  \r
  // Eliminar un elemento por índice. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = lista4.remove(2);  \r
  // Elimina del ArrayList todos aquellos elementos que coinciden con los indicados en la lista que pasamos como argumento \r
  lista4.removeAll(lista3);\r
  // Elimina del ArrayList todos aquellos elementos que cumplen con el predicado (la condición) descrita como argumento en el método e indicada como expresión lambda\r
  lista4.removeIf(p->p.getEdad()<18);   // Elimina los menores de 18\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colección\r
\r
Vamos a preparar un ArrayList para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList creation\r
  ArrayList<Persona> grupoPersonas = new ArrayList<>() {{\r
    add(new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
    add(new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
    add(new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
    add(new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
    add(new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
    add(new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\r
\`\`\`\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por índice\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(i));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el ArrayList es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colección)\r
\r
\`\`\`java:no-line-numbers\r
    // Obtenemos un objeto de tipo Persona en cada iteración del bucle\r
    for (Persona p: grupoPersonas) {\r
        System.out.println(p);\r
    }\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colección y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un método iterator() que devuelve una instancia de Iterator para recorrer la colección.\r
\r
Iterator tiene 4 métodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento más en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el último elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acción indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la lista\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el método forEach con expresiones lambda\r
\r
En este caso aprovechamos el método foreach de las colecciones para poder realizar una acción concreta sobre cada uno de los elementos de la misma.\r
\r
De forma similar al bucle foreach, indicamos un elemento de la lista y la acción a realizar sobre el mismo\r
\r
\`\`\`java:no-line-numbers\r
  // Para cada persona (p) -> Acción a realizar\r
  grupoPersonas.forEach(p -> System.out.println(p));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colección\r
\r
Mientras se está recorriendo una colección, no con todos los tipos de bucles se puede modificar (añadir/eliminar elementos) de la colección. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendríamos problemas. Al acceder por índice, podemos añadir o eliminar elementos mientras se recorre la colección.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.get(i).getNombre().equals("Jordi")) {\r
      grupoPersonas.remove(i);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Persona p : grupoPersonas) {\r
    if (p.getPeso()>100) {\r
      grupoPersonas.remove(p);\r
    }\r
    System.out.println("Eliminada: " + p);\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Siempre que usemos el método remove de Iterator para eliminar elementos de la colección mientras la recorremos, podremos hacerlo sin que se genere ninguna excepción.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Persona> iterator = grupoPersonas.iterator();\r
  while (iterator.hasNext()) {\r
    Persona p = iterator.next();\r
    if (p.getAltura() < 100) {\r
      // Si borramos usando iterator.remove funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el método forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.forEach((p) -> {if (p.getNombre().equals("Jordi")) grupoPersonas.remove(p);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colección, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Búsqueda de elementos\r
\r
Para buscar elementos en un ArrayList hay distintas formas de hacerlo. Desde los propios métodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Búsqueda usando los métodos de la clase\r
\r
La clase ArrayList nos ofrece diferentes alternativas para buscar y/o saber si un elemento está presente en la colección. Así, podemos usar los métodos\r
\r
\`\`\`java:no-line-numbers\r
  // Comprobar si está el objeto en la colección\r
  boolean existe = grupoPersonas.contains(p1);\r
  // O simplemente obtener su posición, si lo encuentra\r
  grupoPersonas.indexOf(p1);\r
  grupoPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### E.2. Búsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colección hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> it = grupoPersonas.iterator();\r
  while (it.hasNext()) {\r
    Persona p = it.next();\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado: " + p);\r
      break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Búsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado:: " + p);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Búsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestión de las colecciones.\r
Podemos emplear varios métodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolección\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
\r
  // Obtener un subarray con los elementos que cumplan el criterio\r
  grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList());\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);   \r
  }\r
\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuántos cumplen el criterio de búsqueda\r
  grupoPersonas.stream().filter(p -> p.getAltura() > 170).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Persona> first = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .findFirst();\r
\r
  // Obtener cualquiera que cumpla el criterio, o null si no hay ninguno\r
  Persona any = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)                \r
          .findAny()\r
          .orElse(null);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtención de subcolecciones\r
\r
Lo podemos considerar un tipo especial de búsqueda en el que el objetivo es conseguir una colección con los elementos que cumplan un determinado criterio.\r
\r
Así, la forma de buscar es idéntica a la del apartado anterior, pero en este caso lo que obtendremos de esa búsqueda será una nueva lista con un subconjunto de elementos de la original\r
\r
### F.1. Subcolecciones usando bucles\r
\r
Para obtener los elementos podemos aplicar lo aprendido en el anterior punto. Buscaremos elemento a elemento y, cuando se cumpla una condición especificada, añadiremos los elementos encontrados a una nueva colección.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas = new ArrayList<>();\r
  for (Persona p : grupoPersonas) {\r
    if (p.getNombre().startsWith("M")) {\r
      personas.add(p);\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
La idea es similar al punto anterior\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas2 = new ArrayList<>();\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().startsWith("M")) {\r
      personas2.add(p);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener directamente una subcolección mediante el filtrado, haciendo subconjuntos y guardando el resultado.\r
\r
Con API Stream podemos guardar el resultado usando diferentes formas de .collect, que darán como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList de Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas3 = (ArrayList<Persona>) grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toList());\r
\r
  // Conjunto de Personas cuyo nombre empieza por "M"\r
  Set<Persona> personas4 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toSet());\r
  \r
  // Mapa de Personas cuyo nombre empieza por "M"\r
  // En la construcción del mapa, hay que elegir un campo que sirva de clave\r
  Map<String, Persona> personas5 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toMap(Persona::getApellidos, Function.identity()));\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenación de elementos\r
\r
### G.1. Ordenar usando métodos de Collection\r
\r
Si lo que queremos es tener el conjunto ordenados, la forma más fácil es ordenarla usando el método sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Ordena según el método compareTo sobrescrito al implementar el interfaz Comparable\r
  // Si no se ha implementado, ordena según el orden natural\r
  Collections.sort(grupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(grupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su método \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos más adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.2. Ordenar con expresiones lambda\r
\r
De esta forma no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparación que queremos hacer como parámetro del método sort.\r
\r
Así podemos tener distintas formas de ordenar, según nos convenga.\r
\r
\`\`\`java:no-line-numbers\r
  // Indicamos la comparación que queremos hacer. Podemos usar compareTo \r
  Collections.sort(grupoPersonas, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(grupoPersonas);      \r
\r
  // o bien podemos definir nuestro propio comparador\r
  Collections.sort(grupoPersonas, (p1, p2) -> {\r
    String nombreCompleto1 = p1.getApellidos() + ", " + p1.getNombre();\r
    String nombreCompleto2 = p2.getApellidos() + ", " + p2.getNombre();\r
    return nombreCompleto1.compareTo(nombreCompleto2);\r
});\r
\`\`\`\r
\r
### G.3. Ordenar con API Stream\r
\r
Con API Stream usamos también el método sorted para indicar qué comparación se debe realizar. Tenemos varias opciones en función del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el más flexible es aquel en el que indicamos, mediante una expresión lambda, qué comparación realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en una nueva lista con los elementos ordenados\r
  ArrayList<Persona> grupoPersonasOrdenado = (ArrayList<Persona>) grupoPersonas.stream()\r
          // En este caso ordenamos por apellido, ascendente.\r
          .sorted((p1, p2) -> p1.getApellidos().compareTo(p2.getApellidos()))\r
          // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
          //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
          .collect(Collectors.toList());\r
\`\`\`\r
\r
::: info Encadenar métodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolección con los resultados.\r
\r
Es lo más parecido que vamos a encontrar a una consulta SQL para los datos de una colección cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantáneas, sin lugar a bugs, con muy poco código.\r
:::\r
`]},{title:"3.5 Annex I - Debugging multithread apps in Netbeans",headers:[],path:"/en/unit3/debugger_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.5 Annex I - Debugging multithread apps in Netbeans\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.5 Annex I - Debugging multithread apps in Netbeans" />\r
\r
# 3.5 Annex I - Debugging multithread apps in Netbeans\r
\r
Modern IDE provide the user with facilities to debug multithread apps.\r
\r
Just like in monothread apps, we can use breakpoints to stop a thread execution to inspect object state, properties values, etc.\r
\r
If we want to use the Debugging window in NetBeans IDE to debug multi-threaded applications we have to activate it by setting it from menu *Window > Debugging > Debugging (Alt+Shift +9)*\r
\r
![Activate thread debug](../../media/unit3/NetbeansDebug1.jpg)\r
\r
The Debugging window simplifies the debugging process by integrating into one window the information about debugging sessions, application threads and thread call stacks. The Debugging window enables you to easily see the status of application threads and suspend and resume any of the threads in the session.\r
\r
![Debugging dialogue](../../media/unit3/NetbeansDebug2.jpg)\r
\r
- The *current thread* is indicated by a green bar in the margin (it is also highlighted in green).  The current thread is the one we can work on by using StepInto, StepOver, Pause, Continue actions from the debugger. We can also access the variables inspection on that thread.\r
- Threads that invoked the notification, by hitting a breakpoint, are indicated by a yellow bar and the thread icon (orange color) indicates that the thread is suspended by a breakpoint.\r
- In the right side we have a quick access to Resume/Pause each active thread.\r
  \r
![Thread change](../../media/unit3/NetbeansDebug3.jpg)\r
\r
Clicking with the right mouse button over any thread we can make it the *current thread*. This way we get control over it and we can inspect this thread while other are paused or keep on running.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug4.jpg)\r
\r
Furthermore, the cogwheel next to each thread identifier is giving us many information about a thread state.\r
\r
- When the cogwheel is orange that means the thread is suspended and it requires our attention.\r
- When the cogwheel is green that means the thread is running. If we move the mouse over the thread we can get a tip showing the thread state information. As you can observe in the image thread-2 is running but it is in a waiting state. Actually this thread is locked in a join (waiting for another thread to finish)\r
\r
![Thread monitors](../../media/unit3/NetbeansDebug5.jpg)\r
\r
Finally, thread debugging helps us with synchronization using monitors. We can know when a thread owns a monitor (lock) and we can also know which monitors (locks) a thread is waiting for.\r
\r
As an additional tool Netbeans provides an utility (Debug > Check for deadlocks) that checks if any deadlock has happened, telling the monitors owned by each thread and the monitors each thread is waiting for.\r
`]},{title:"3.7 Annex III - HashMap cheat sheet by students",headers:[{level:2,title:"A. Definición y creación",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de HashMap",slug:"a-1-constructores-de-hashmap",link:"#a-1-constructores-de-hashmap",children:[]}]},{level:2,title:"B. Métodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creación de un HashMap",slug:"b-1-creacion-de-un-hashmap",link:"#b-1-creacion-de-un-hashmap",children:[]},{level:3,title:"B.2. Añadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si una clave o un valor existen",slug:"b-3-comprobar-si-una-clave-o-un-valor-existen",link:"#b-3-comprobar-si-una-clave-o-un-valor-existen",children:[]},{level:3,title:"B.4. Acceder a las partes del mapa",slug:"b-4-acceder-a-las-partes-del-mapa",link:"#b-4-acceder-a-las-partes-del-mapa",children:[]},{level:3,title:"B.5. Acceder a un elemento del mapa",slug:"b-5-acceder-a-un-elemento-del-mapa",link:"#b-5-acceder-a-un-elemento-del-mapa",children:[]},{level:3,title:"B.6. Otras funciones de utilidad",slug:"b-6-otras-funciones-de-utilidad",link:"#b-6-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Añadir datos a un HashMap",slug:"c-anadir-datos-a-un-hashmap",link:"#c-anadir-datos-a-un-hashmap",children:[{level:3,title:"C.1. Añadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Añadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Añadir / eliminar elementos desde código",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colección",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el método forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colección",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Búsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Búsqueda por clave o usando los métodos de la clase",slug:"e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Búsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Búsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Búsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtención de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenación de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar por clave",slug:"g-1-ordenar-por-clave",link:"#g-1-ordenar-por-clave",children:[]},{level:3,title:"G.2. Ordenar usando métodos de Collection",slug:"g-2-ordenar-usando-metodos-de-collection",link:"#g-2-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/en/unit3/hashmap_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.7 Annex III - HashMap cheat sheet by students\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.7 Annex III - HashMap cheat sheet by students" />\r
\r
# 3.7 Annex III - HashMap cheat sheet by students\r
\r
::: info Autoría\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del módulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la información a la que podréis acceder durante los exámenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definición y creación\r
\r
Una colección representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacén donde poder guardarlos. En Java, se emplea la interfaz genérica \`Collection\` para este propósito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de métodos comunes, como pueden ser: añadir, eliminar, obtener el tamaño de la colección.\r
\r
Partiendo de la interfaz genérica Collection extienden otra serie de interfaces genéricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
Un HashMap básicamente designa claves únicas para los valores correspondientes que se pueden recuperar en cualquier punto dado, es decir, nos permite almacenar elementos asociando a cada clave un valor.\r
\r
Para cada clave tenemos un valor asociado. Podemos después buscar fácilmente un valor para una determinada clave. Las claves en el diccionario no pueden repetirse.\r
\r
### A.1. Constructores de HashMap\r
\r
HashMap proporciona 4 constructores que definen la capacidad inicial de la colección y en qué momento debe redimensionarse. Son parámetros para mejorar el rendimiento en el uso del HashMap.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de HashMap con una capacidad inicial de 16 y un factor de carga de 0,75.\r
HashMap<Integer, String> hm1 = new HashMap<>(); \r
\r
// HashMap(int initialCapacity). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga de 0,75. \r
HashMap<Integer, String> hm1 = new HashMap<>(10); \r
\r
// HashMap(int initialCapacity, float loadFactor). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga especificados. \r
HashMap<Integer, String> hm1 = new HashMap<>(5, 0.75f); \r
\r
//HashMap(Mapa de mapas) . Crea una instancia de HashMap con las mismas asignaciones que el mapa especificado. \r
HashMap<Integer, String> hm1 = new HashMap<>();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Métodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendríamos con la ejecución de estos métodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "García", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martínez", 65, 1.84d, 82, "Hombre");\r
\`\`\`\r
\r
### B.1. Creación de un HashMap\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un HashMap con claves de tipo String y valores de tipo Persona\r
  HashMap<String,Persona> DNIs = new HashMap<>();\r
\`\`\`\r
\r
### B.2. Añadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Element.put(k,v) - Añade un par clave-valor al mapa.\r
  DNIs.put("390543M",p);\r
  // Element.remove(Object key) - Removes the key and his value.\r
  DNIs.remove("298423Z");// Will remove (“390543M”, p1) from the map.\r
\`\`\`\r
\r
::: warning Clave ya existente\r
Si ya existe un elemento con la misma clave en el mapa, el método put reemplaza el valor existente por el nuevo.\r
Podemos evitarlo comprobando previamente si ya existe esa clave o con el método **DNIs.putIfAbsent(k,v)**.\r
:::\r
\r
### B.3. Comprobar si una clave o un valor existen\r
\r
\`\`\`java:no-line-numbers\r
  // Element.containsKey(Key) – Comprueba si existe la clave dada\r
  DNIs.containsKey("390543M");\r
  // Element.containsValue(Value) – Comprueba si existe el valor dado asociado a alguna clave\r
  DNIs.containsValue(p2);\r
\`\`\`\r
\r
### B.4. Acceder a las partes del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.keySet() - Obtiene el conjunto de claves del mapa\r
  Set<String> claves = DNIs.keySet();\r
  // Element.values() - Obtiene el conjunto de valores almacenados en el mapa\r
  Collection<Persona> valores = DNIs.values();\r
  // Element.entrySet() - Obtiene el conjunto de pares clave-valor del mapa\r
  Set<Entry<String,Persona>> tuplas = DNIs.entrySet();\r
\`\`\`\r
\r
### B.5. Acceder a un elemento del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.get(Key) - Obtiene el valor asociado a la clave\r
  Persona p = DNIs.get("390543")\r
\`\`\`\r
\r
### B.6. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Element.size() - Devuelve el número de elementos en el mapa\r
  int size = DNIs.size();\r
  //Element.clear() - Elimina todas las asignaciones y vacía el mapa\r
  DNIs.clear();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Añadir datos a un HashMap\r
\r
::: info Orden de los elementos en el HashMap\r
Cuando añadimos elementos a una HashMap, el orden de inserción no se conserva. Internamente, para cada elemento, se genera un hash separado y los elementos se indexan en función de este hash para hacerlo más eficiente. Antes de añadir un elemento, como se ha avisado antes, es recomendable comprobar si ya existe para no sustituirlo\r
:::\r
\r
### C.1. Añadir elementos desde el constructor\r
\r
A la hora de crear el Hashmap, podemos añadirle datos, usando la sintaxis del doble corchete o bien con la construcción Map.of\r
\r
\`\`\`java:no-line-numbers\r
  // Crea un nuevo mapa y a la vez lo inicializa con valores  \r
  HashMap<String, Persona> map1 = new HashMap<>() {{\r
    put("390543M", p1);\r
    put("298423Z", p2);\r
  }};\r
  // En este caso indicamos los pares clave valor como si de un array se tratase\r
  // De esta forma podemos añadir hasta un máximo de 10 elementos\r
  HashMap<String, Persona> map2 = new HashMap<>(\r
    Map.of("390543M", p1, "298423Z", p2)\r
  );\r
\`\`\`\r
\r
### C.2. Añadir elementos desde otras colecciones\r
\r
Al ser una colección compuesta por una clave y un valor, la inicialización se limita a los tipos de colecciones que tienen una estructura similar.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del código anterior, creamos un nuevo mapa a partir de map2\r
  HashMap<String, Persona> map3 = new HashMap<>(map2);\r
  // O bien copiando todos los pares clave-valor\r
  map3.putAll(map2);  \r
\`\`\`\r
\r
### C.3. Añadir / eliminar elementos desde código\r
\r
\`\`\`java:no-line-numbers\r
  // Añadir y si existe la clave reemplazarlo\r
  DNIs.put("390543M", p1);\r
  // Añadir sólo si la clave no existe\r
  DNIs.putIfAbsent("390543M", p1);\r
  // Eliminar un elemento. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = map3.remove("390543M");  \r
  // Eliminar un par clave-valor. Si existe la tupla, la elimina y devuelve true, si no devuelve false\r
  boolean existe = map3.remove("390543M", p1);  \r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colección\r
\r
Vamos a preparar un HashMap para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap creation\r
  HashMap<String, Persona> grupoPersonas = new HashMap<>() {{\r
          put("12345678A", new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
          put("23456789B", new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
          put("34567890C", new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
          put("45678901D", new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
          put("56789012E", new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
          put("67890123F", new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\`\`\`\r
\r
::: info Tipos de valores\r
Vamos a mostrar ejemplos de cómo recorrer cada uno de los elementos que componen el HashMap, claves, valores y pares clave-valor.\r
\r
.entrySet() - devuelve el conjunto de pares clave-valor\r
\r
.keySet() - devuelve el conjunto de claves\r
\r
.values() - devuelve la colección de valores\r
:::\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por índice, por lo que vamos a necesitar una forma de obtener el índice (i) de cada elemento para recorrer el HashMap.\r
\r
En este caso, vamos a usar el índice de la clave, a través del método toArray.\r
\r
::: warning Orden de los elementos en el HashMap\r
Es importante recordar y tener en cuenta que los elementos en un HashMap se ordenan automáticamente en base a una función Hash (resumen) que permite realizar una búsqueda muy rápida sobre la clave. Por lo tanto, no podemos esperar que el recorrido por índice coincida con el orden en el que los elementos se añaden al mapa.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(map.keySet().toArray()[i]));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el HashMap es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colección)\r
\r
\`\`\`java:no-line-numbers\r
  // Recorremos la estructura obteniendo la tupla (k,v) en cada iteración\r
  for (Map.Entry<String, Persona> entry : grupoPersonas.entrySet()) {\r
        System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\r
  }\r
\`\`\`\r
\r
o bien para ir mostrando las claves\r
\r
\`\`\`java:no-line-numbers\r
  for (String key : grupoPersonas.keySet()) {\r
    System.out.println("DNI = " + key);\r
  }\r
\`\`\`\r
\r
o los valores\r
\r
\`\`\`java:no-line-numbers\r
  for (Person value : grupoPersonas.values()) {\r
    System.out.println("Value = " + value);\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colección y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un método iterator() que devuelve una instancia de Iterator para recorrer la colección.\r
\r
Iterator tiene 4 métodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento más en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el último elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acción indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la colección\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.values().iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el método forEach con expresiones lambda\r
\r
En este caso aprovechamos el método foreach de las colecciones para poder realizar una acción concreta sobre cada uno de los elementos de la misma\r
\r
\`\`\`java:no-line-numbers\r
  // Pares (clave,valor)\r
  grupoPersonas.forEach((k,v) -> System.out.println("Clave: " + k + ", Values: " + v));\r
  // Claves\r
  grupoPersonas.keySet().forEach(k -> System.out.println("Clave: " + k));\r
  // Valores\r
  grupoPersonas.values().forEach(v -> System.out.println("Values: " + v));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colección\r
\r
Mientras se está recorriendo una colección, no con todos los tipos de bucles se puede modificar (añadir/eliminar elementos) de la colección. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendríamos problemas. Al acceder por índice, podemos añadir o eliminar elementos mientras se recorre la colección.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.keySet().toArray()[i].equals("23456789B")) {\r
      grupoPersonas.remove(grupoPersonas.entrySet().toArray()[i]);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Map.Entry<String, Persona> p : grupoPersonas.entrySet()) {\r
    if (p.getKey().equals("34567890C")) {\r
      personas.remove(p.getKey());\r
    }\r
    System.out.println("Clave: " + p.getKey() + " Valor: " + p.getValue().toString());\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Si usamos el método remove para eliminar elementos de la colección mientras la recorremos, podremos hacerlo sin que se genere ninguna excepción.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Entry<String, Persona>> iterator = grupoPersonas.entrySet().iterator();\r
  while (iterator .hasNext()) {\r
    Map.Entry<String, Persona> p = (Map.Entry<String, Persona>) iterator.next();\r
    if (p.getKey().equals("12345678A")) {\r
      // Si borramos usando iterator.remove o el método remove(key) de HashMap, funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el método forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.keySet().forEach((k) -> {if (k.equals("34567890C")) grupoPersonas.remove(k);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colección, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.values().forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Búsqueda de elementos\r
\r
Para buscar elementos en un HashMap hay distintas formas de hacerlo. Desde los propios métodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Búsqueda por clave o usando los métodos de la clase\r
\r
La clase HashMap nos ofrece diferentes alternativas para buscar y/o saber si un elemento está presente en la colección. Así, podemos usar los métodos\r
\r
\`\`\`java:no-line-numbers\r
  // A partir de una clave, obtener el valor\r
  grupoPersonas.get("34567890C");\r
  // O simplemente comprobar si existe esa clave o ese valor antes de buscarlo\r
  grupoPersonas.containsKey("34567890C");\r
  grupoPersonas.containsValue(person);\r
\`\`\`\r
\r
### E.2. Búsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colección hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
  Iterator<Map.Entry<String, Persona>> it = grupoPersonas.entrySet().iterator();\r
  while (it.hasNext()) {\r
    Map.Entry<String, Persona> entry = it.next();\r
    if (((Persona)entry.getValue()).getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + entry.getKey() + ", Value: " +\r
      entry.getValue());\r
    break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Búsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
  grupoPersonas.forEach((k, v) -> {\r
    if (v.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + k + ", Value: " + v);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Búsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestión de las colecciones.\r
Podemos emplear varios métodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolección\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
\r
  // Obtener un submapa con los elementos que cumplan el criterio\r
  grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("abc"))\r
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Entry<String, Persona> p : grupoPersonas.entrySet().stream()\r
      .filter(k -> k.getKey().equals("abc"))\r
      .collect(Collectors.toList())) {\r
          System.out.println(p.getValue());   // Sacamos el valor de la tupla <clave,valor>\r
  }\r
\r
  for (Persona p : grupoPersonas.entrySet().stream()\r
      .filter((k) -> k.getKey().equals("98761234D"))\r
      .map(Map.Entry::getValue)         // Cogemos sólo los valores del entryMap\r
      .collect(Collectors.toList())) {\r
          System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuántos cumplen el criterio de búsqueda\r
  grupoPersonas.entrySet().stream().filter(k -> k.getKey().equals("abc")).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Entry<String,Persona>> s = grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("6780123F"))\r
    .findFirst();\r
  \`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtención de subcolecciones\r
\r
Lo podemos considerar un tipo especial de búsqueda en el que el objetivo es conseguir una colección con los elementos que cumplan un determinado criterio.\r
\r
Así, la forma de buscar es idéntica a la del apartado anterior, pero en este caso lo que obtendremos de esa búsqueda será un nuevo tipo de colección, no necesariamente otro HashMap.\r
\r
### F.1. Subcolecciones usando bucles\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String,Persona> personas2 = new HashMap<String,Persona>();\r
  for (Entry<String, Persona> e : grupoPersonas.entrySet()) {\r
    if(e.getKey().endsWith("F")) {\r
      personas2.put(e.getKey(), e.getValue());\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
En este ejemplo obtenemos un nuevo HashMap, pero también podríamos guardar la información en un ArrayList o en cualquier otro tipo de estructura.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas2 = new HashMap<String, Persona>();\r
  grupoPersonas.forEach((k, v) -> {\r
    if (k.endsWith("F")) {\r
      grupoPersonas2.put(k, v);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener diferentes tipos de subcolecciones. Con API Stream podemos filtrar, hacer subconjuntos y guardar el resultado usando diferentes formas de .collect, que darán como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap de Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas3 = (HashMap<String, Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // Lista de Personas cuyo DNI acaba en "F"\r
  List<Persona> listaPersonas3 = (List<Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toList());\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenación de elementos\r
\r
::: danger HashMap no garantiza el orden de los elementos\r
Como ya hemos comentado anteriormente, un HashMap es una estructura de datos en la que el orden de los elementos no está garantizado. Es por eso que si queremos mantener una copia ordenada de los elementos, deberemos recurrir a otros tipos de colecciones que sí garantizan el orden.\r
:::\r
\r
### G.1. Ordenar por clave\r
\r
Hay un tipo especial de map, TreeMap, en el que los elementos se ordenan siguiendo el orden natural de las claves. Por lo tanto es la opción ideal si queremos tener los elementos ordenados por clave.\r
\r
\`\`\`java:no-line-numbers\r
  // Así podemos recorrer el TreeMap y mostrar los elementos ordenados por clave\r
  TreeMap<String, Persona> grupoPersonasOrdenado = new TreeMap<>(grupoPersonas);\r
 \r
  Iterator it=grupoPersonasOrdenado.keySet().iterator();\r
  while(it.hasNext())\r
  {\r
    int key=(int)itr.next();\r
    System.out.println("Key: "+key+" Element: "+hashMap.get(key));\r
  }\r
\`\`\`\r
\r
### G.2. Ordenar usando métodos de Collection\r
\r
Si lo que queremos es tener el conjunto de claves o valores ordenados por separado, la forma más fácil es obtener una lista y ordenarla usando el método sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Para las claves\r
  List<String> clavesGrupoPersonas = new ArrayList<>(grupoPersonas.keySet());\r
  Collections.sort(clavesGrupoPersonas);\r
\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas = new ArrayList<>(grupoPersonas.values());\r
  // Ordena según el método compareTo sobrescrito al implementar el interfaz Comparable\r
  Collections.sort(valoresGrupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(valoresGrupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su método \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos más adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
Si usamos una lista, no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparación que queremos hacer como parámetro del método sort\r
\r
\`\`\`java:no-line-numbers\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas2 = new ArrayList<>(grupoPersonas.values());\r
  // Indicamos la comparación que queremos hacer. Podemos usar compareTo o definir\r
  // nuestro propio comparador\r
  Collections.sort(valoresGrupoPersonas2, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(valoresGrupoPersonas2);      \r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos también el método sorted para indicar qué comparación se debe realizar. Tenemos varias opciones en función del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el más flexible es aquel en el que indicamos, mediante una expresión lambda qué comparación realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en un LinkedHashMap que sí garantiza el orden\r
  Map<String, Persona> sortedMap = grupoPersonas.entrySet().stream()\r
      // En este caso ordenamos por apellido, ascendente.\r
      .sorted((e1, e2) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
      //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\r
\`\`\`\r
\r
::: info Encadenar métodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolección con los resultados.\r
\r
Es lo más parecido que vamos a encontrar a una consulta SQL para los datos de una colección cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantáneas, sin lugar a bugs, con muy poco código.\r
:::\r
`]},{title:"3 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit3/",pathLocale:"/en/",extraFields:[`---\r
title: 3 Introduction\r
---\r
\r
# Unit 3. Multithread programming\r
\r
After leaning the basics of concurrent programming and learn how processes can be used to do multitasking, in this unit we are going to look into a single process.\r
\r
We are gonna make use of threads and the eay they are programmed to do concurrent task into a process.\r
\r
key differences between processes and threads are:\r
\r
- Threads share process memory space\r
- Threads share file descriptors\r
- Threads share program code.\r
\r
As they run into the context of a process, the TCB (Tread Control Block) is smaller than the PCB (Process Control Block) because they share part of PCB. That's why sometimes threads are so called \`lightweight processes\`.\r
\r
All previous features simplify threads communication, thus coordination and synchronization becomes harder to program and manage.\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know thread characteristics in Java\r
- To Learn how to create and manage threads\r
- To debug multithread applications\r
- To use synchronization methods for processes and sub-processes\r
- To share information between threads on a process\r
- To learn about shared memory problems\r
- To use different programming approaches to synchronize threads execution\r
`]},{title:"3.3 Producer-Consumer model",headers:[{level:2,title:"3.3.1. Communication & synchronization template",slug:"_3-3-1-communication-synchronization-template",link:"#_3-3-1-communication-synchronization-template",children:[]},{level:2,title:"3.3.2 Main class",slug:"_3-3-2-main-class",link:"#_3-3-2-main-class",children:[]},{level:2,title:"3.3.3 Producer & Consumer classes",slug:"_3-3-3-producer-consumer-classes",link:"#_3-3-3-producer-consumer-classes",children:[]},{level:2,title:"3.3.4 Shared class. Threads synchronization",slug:"_3-3-4-shared-class-threads-synchronization",link:"#_3-3-4-shared-class-threads-synchronization",children:[]}],path:"/en/unit3/producer-consumer.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.3 Producer-Consumer model\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.3 Producer-Consumer model" />\r
\r
# 3.3 Producer-Consumer model\r
\r
[[toc]]\r
\r
## 3.3.1. Communication & synchronization template\r
\r
Threads synchronization means having tools to avoid \`starvation\` (threads lock), \`deadlocks\` (when a condition can never be satisfied) and to ensure shared resources are well managed by concurrent threads access.\r
\r
The Producer-Consumer problem is a classic example of a multi-threaded synchronization problem. Let's go into the usage of the shared resources by using this famous algorithm. [Wikipedia](https://es.wikipedia.org/wiki/Problema_productor-consumidor).\r
\r
Without thread control mechanism we already know that problems will rise up randomly:\r
\r
- Consumer can get elements more than once, exceeding the stock (banc account balance under 0, reader reading a book before it is finished).\r
- Producers can be quicker than Consumer and produce more information than the system can get, making data loose.- Consumer can be quicker than the Producer and can get more than once the same value, having inconsistent systems.\r
\r
That's all we know as \`race conditions\`.\r
\r
The following code template repeats over and over again for almos all activities we are going to work on. That's what we call the Producer-Consumer model.\r
\r
![Producer-Consumer](./../../media/unit3/ProducerConsumer.png)\r
\r
This model is based on three classes, but depending on the problem we can have only producers or just consumers.\r
\r
::: info Model as a design pattern\r
It's very important to fit our code into the model schema\r
\r
This is like a puzzle where we have to adjust the problem solution. Sometimes we won't have a producer, other there will be no consumer. Maybe we will use the wait condition only in one of them.\r
\r
We shouldn't add or modify the way the schema is presented, all parts must fit into the given model.\r
:::\r
\r
## 3.3.2 Main class\r
\r
> Main class will always have the same estructure. Following code can be used as a a template.\r
\r
Here we instantiate the shared object to be used by producers&consumers. This is the object that will hold communication, synchronization and information exchange between threads.\r
\r
In this example it is an object, but we can use a Collection or any other data structure useful for thread to share information and synchronize.\r
\r
\`\`\` java {4,5,6}\r
public class ClasePrincipal { \r
\r
    public static void main(String[] args) {    \r
        ClaseCompartida objetoCompartido = new ClaseCompartida();\r
        Productor productor  = new Productor(objetoCompartido);\r
        Consumidor consumidor  = new Consumidor(objetoCompartido);\r
        productor.start();\r
        consumidor.start();\r
\r
        // No es obligatorio, pero en ocasiones puede interesar que la ClasePrincipal\r
        // espere a que acaben los hilos\r
        productor.join();\r
        consumidor.join();\r
\r
        // Acciones a realizar una vez hayan acabado el productor y el consumidor\r
    }\r
    \r
}\r
\`\`\`\r
\r
::: warning Number of producer & consumer threads\r
In the previous code we have created and launched one of each, but it has not to be like that.\r
\r
Each problem to solve will need a different number of *Producers* and *Consumers*, that will be instantiated and launched in the main method or in any other complementary method in the class in charge of thread management.\r
\r
In the same way, it's on the problem if the main thread has to wait for the others to finish or not.\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.3 Producer & Consumer classes\r
\r
> Both **Producer** and **Consumer** classes will call methods in the shared object.\r
\r
In both classes, the application logic will be developed inside **run** method. This will be done basically accessing the shared object, calling its synchronized methods, modifying its properties and updating the object state to control its functionality.\r
\r
\`\`\` java {2,5,15}\r
public class Consumidor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Consumidor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecución del método run estará normalmente gestionada por un bucle\r
        // que controlará el ciclo de vida del hilo y se adaptará al problema.\r
        // En el caso de simulaciones se harán esperas proporcionales.\r
        try {\r
            // Código que hace el hilo consumidor\r
            objetoCompartido.accionDeConsumir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
}    \r
\`\`\`\r
\r
\`\`\` java {2,5,15}\r
public class Productor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Productor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecución del método run estará normalmente gestionada por un bucle\r
        // que controlará el ciclo de vida del hilo y se adaptará al problema.\r
        // En el caso de simulaciones se harán esperas proporcionales.\r
        try {\r
            // Código que hace el hilo productor\r
            objetoCompartido.accionDeProducir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
} \r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.4 Shared class. Threads synchronization\r
\r
 This model is completed with the shared object class. Here we provide methods to be used by both Producers and Consumers. Furthermore, this class must be thread-safe to avoid \`race conditions\`.\r
\r
\`\`\` java {2,9,11,14,21,25,28,30,33,40,44}\r
public class ClaseCompartida {\r
    int valorAccedidoSimultaneamente;\r
    \r
    ClaseCompartida() {\r
        // Se inicializa el valor\r
        this.valorAccedidoSimultaneamente = 0;\r
    }\r
\r
    public synchronized void accionDeConsumir() {\r
        // Si no se cumple la condición para poder consumir, el consumidor debe esperar\r
        while (valorAccedidoSimultaneamente == 0) {\r
            try {\r
                System.out.println("Consumidor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizará la gestión de la Interrupción\r
            }\r
        }\r
                \r
        // Cuando se ha cumplido la condición para consumir, el consumidor consume\r
        valorAccedidoSimultaneamente--;\r
        System.out.printf("Se ha consumido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
    \r
    public synchronized void accionDeProducir () {\r
        // Si no se cumple la condición para poder producir, el productor debe esperar\r
        while (valorAccedidoSimultaneamente > 10) {\r
            try {\r
                System.out.println("Productor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizará la gestión de la Interrupción                \r
            }\r
        }\r
        \r
        // Cuando se ha cumplido la condición para producir, el productor produce\r
        valorAccedidoSimultaneamente++;\r
        System.out.printf("Se ha producido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
}\r
\`\`\`\r
\r
What's interesting from above code is the pair  \`wait / notifyAll\` together with the \`synchronized\` modifier.\r
\r
- A call to a **synchronized** method makes it be run if and only if there is no other thread running another **synchronized** method \`for the same object instance\`. If that happens the thread trying to access the synchronized block will be locked until another thread leaves the synchronized block. Then one random thread is chosen from the threads waiting for the monitor and then it owns the monitor and runs the synchronized block.\r
- Simply put, calling **wait()** forces the current thread to wait until some other thread invokes **notify()** or **notifyAll()** on the same object. For this, the current thread must own the object's monitor, because the monitor will be released after the wait call. \r
- We use the **notify/notifyAll** methods for waking up threads that have previously made a wait() call for this monitos. All awaken threads are automatically sent onto the monitor queue together with all threads already waiting to own the monitor. All threads, once the monitor is owned by them, will start running the synchronized code o will continue running the next sentence after the wait call.\r
\r
> With **wait**, **notifyAll** methods and **synchronized** code blocks we can avoid concurrent threads to modify a shared variable. *(lines 21 and 40 from previous code)*.\r
\r
::: info Producer-Consumer model summary\r
Original Producer-Consumer works with a buffer where the Producer puts information and the Consumer gets it from the buffer. The buffer can never be overflown and it cannot be read if it is empty.\r
\r
Our example has been simplified by using a int variable that has to be always in the range [0.10]\r
\r
This variables can be of any type and the class code will be different depending on it. It must be valid for the problem and the data type control.\r
\r
Finally, conditions or states added for waiting and updates will be what us, as programmers, must code in order to make it work as specified by problems requirements.\r
:::\r
`]},{title:"3.1 Java classes for threads",headers:[{level:2,title:"3.1.1. Runnable Interface",slug:"_3-1-1-runnable-interface",link:"#_3-1-1-runnable-interface",children:[{level:3,title:"Java Class Implements Runnable",slug:"java-class-implements-runnable",link:"#java-class-implements-runnable",children:[]},{level:3,title:"Anonymous Implementation of Runnable",slug:"anonymous-implementation-of-runnable",link:"#anonymous-implementation-of-runnable",children:[]},{level:3,title:"Java Lambda Implementation of Runnable",slug:"java-lambda-implementation-of-runnable",link:"#java-lambda-implementation-of-runnable",children:[]},{level:3,title:"Calling the run method on a Runnable class",slug:"calling-the-run-method-on-a-runnable-class",link:"#calling-the-run-method-on-a-runnable-class",children:[]}]},{level:2,title:"3.1.2 Thread subclass",slug:"_3-1-2-thread-subclass",link:"#_3-1-2-thread-subclass",children:[]},{level:2,title:"3.1.3 Starting a Thread from a Runnable",slug:"_3-1-3-starting-a-thread-from-a-runnable",link:"#_3-1-3-starting-a-thread-from-a-runnable",children:[{level:3,title:"Subclass or Runnable?",slug:"subclass-or-runnable",link:"#subclass-or-runnable",children:[]}]},{level:2,title:"3.1.4 Thread class methods",slug:"_3-1-4-thread-class-methods",link:"#_3-1-4-thread-class-methods",children:[{level:3,title:"Pause a thread",slug:"pause-a-thread",link:"#pause-a-thread",children:[]},{level:3,title:"Threads priority management",slug:"threads-priority-management",link:"#threads-priority-management",children:[]}]}],path:"/en/unit3/runnable.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.1 Java classes for threads\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.1. Java classes for threads" />\r
\r
# 3.1. Java classes for threads\r
\r
[[toc]]\r
\r
## 3.1.1. Runnable Interface\r
\r
A Java Thread can execute your Java code inside your Java application.\r
\r
When a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application. From inside your application you can create and start more threads which can execute parts of your application code in parallel with the main thread.\r
\r
Java threads are objects like any other Java objects. Threads are instances of class java.lang.Thread, or instances of subclasses of this class. In addition to being objects, java threads can also execute code.\r
\r
The first way to specify what code a thread should run is by creating a class that implements the \`java.lang.Runnable\` interface.\r
\r
The Runnable interface is a standard Java Interface that comes with the Java platform. The Runnable interface only has a single method run().\r
\r
> [java.lang.Runnable specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html)\r
\r
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method. There are three ways to implement the Runnable interface:\r
\r
- Create a Java class that implements the Runnable interface.\r
- Create an anonymous class that implements the Runnable interface.\r
- Create a Java Lambda that implements the Runnable interface.\r
\r
All three options are explained in the following sections.\r
\r
### Java Class Implements Runnable\r
\r
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface. Here is an example of a custom Java class that implements the Runnable interface:\r
\r
\`\`\`java\r
public class MyRunnable implements Runnable {\r
\r
  public void run(){\r
      System.out.println("MyRunnable running");\r
  }\r
}\r
\`\`\`\r
\r
All this Runnable implementation does is to print out the text MyRunnable running. After printing that text, the run() method exits, and the thread running the run() method will stop.\r
\r
### Anonymous Implementation of Runnable\r
\r
You can also create an anonymous implementation of Runnable. Here is an example of an anonymous Java class that implements the Runnable interface:\r
\r
\`\`\`java\r
Runnable myRunnable =\r
    new Runnable(){\r
        public void run(){\r
            System.out.println("Runnable running");\r
        }\r
    }\r
\`\`\`\r
\r
Apart from being an anonymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.\r
\r
### Java Lambda Implementation of Runnable\r
\r
The third way to implement the Runnable interface is by creating a Java Lambda implementation of the Runnable interface. This is possible because the Runnable interface only has a single unimplemented method, and is therefore practically (although possibly unintentionally) a functional Java interface.\r
\r
Here is an example of a Java lambda expression that implements the Runnable interface:\r
\r
\`\`\`java\r
Runnable runnable =\r
        () -> { System.out.println("Lambda Runnable running"); };\r
\`\`\`\r
\r
### Calling the run method on a Runnable class\r
\r
Look at this sample code of Runnable implementation\r
\r
\`\`\`java{1,13,23}\r
public class LiftOff implements Runnable {\r
    private int countDown = 10;\r
    private static int taskCount = 0;\r
    private final int id = taskCount;\r
    \r
    public LiftOff() {}\r
    \r
    public LiftOff(int countDown) {\r
        this.countDown = countDown;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        while (countDown > 0) {\r
            System.out.println("#" + id + " (" + countDown + ")" );\r
            countDown--;\r
        }\r
        System.out.println("LiftOff (" + id + ")");\r
    }\r
    \r
    public static void main(String[] args) {\r
        LiftOff launch = new LiftOff();\r
        launch.run();\r
        System.out.println("Waiting for LiftOff!");\r
    }    \r
}\r
\`\`\`\r
\r
Copy the code above and run it in your IDE. What do you see in the output?\r
\r
::: question What's wrong with previous execution\r
Is the "Waiting for LiftOff!" placed in the right place?\r
\r
Try to create more instances of LiftOff and run them all?\r
\r
Is the application doing something different to a single threaded application?\r
What can you notice from the program output?\r
:::\r
\r
## 3.1.2 Thread subclass\r
\r
The second way to specify what code a thread is to run, is to create a subclass of \`java.lang.Thread\` and override the run() method. The run() method is what is executed by the thread after you call \`start()\`.\r
\r
> [java.lang.Thread specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html)\r
\r
Here is an example of creating a Java Thread subclass:\r
\r
\`\`\`java\r
public class MyThread extends Thread {\r
  public void run(){\r
      System.out.println("MyThread running");\r
  }\r
}\r
\`\`\`\r
\r
To create and start the above thread you can do like this:\r
\r
\`\`\`java\r
MyThread myThread = new MyThread();\r
myTread.start();\r
\`\`\`\r
\r
The start() call will return as soon as the thread is started. **It will not wait until the run() method is done**. The run() method will execute as if executed by a different CPU. When the run() method executes it will print out the text "MyThread running".\r
\r
You can also create an anonymous subclass of Thread like this:\r
\r
\`\`\`java\r
Thread thread = new Thread(){\r
  public void run(){\r
    System.out.println("Thread Running");\r
  }\r
}\r
\r
thread.start();\r
\`\`\`\r
\r
This example will print out the text "Thread running" once the run() method is executed by the new thread.\r
\r
::: question LiftOff example\r
Copy the original LiftOff example and now make it extends Thread class.\r
\r
Is the "Waiting for LiftOff!" placed in the right place? Is it working as it's supposed to?\r
\r
Try to create more instances of LiftOff and run them all\r
is the application doing something different to a single threaded application?\r
What can you notice from the program output?\r
:::\r
\r
## 3.1.3 Starting a Thread from a Runnable\r
\r
To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor. Here is how that is done:\r
\r
\`\`\`java\r
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...\r
\r
Thread thread = new Thread(runnable);\r
thread.start();\r
\`\`\`\r
\r
When the thread is started it will call the run() method of the MyRunnable instance (see previous examples) instead of executing it's own run() method. The above example would print out the text "MyRunnable running".\r
\r
::: info\r
Hence, there are two ways to specify what code the thread should execute.\r
\r
- The first is to create a subclass of Thread and override the run() method.\r
- The second method is to pass an object that implements Runnable to the Thread constructor.\r
:::\r
\r
<CodeGroup>\r
<CodeGroupItem title="Extends Thread" active>\r
\r
\`\`\`java{1,7}\r
public class EjemploThread extends Thread {\r
  public void run() {\r
    // Código del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    EjemploThread hilo = new EjemploThread();\r
    hilo.start();\r
  }\r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Runnable">\r
\r
\`\`\`java{1,7}\r
public class EjemploRunnable implements Runnable {\r
  public void run() {\r
    // Código del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    Thread hilo = new Thread(new EjemploRunnable());\r
    hilo.start();\r
  }    \r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
</CodeGroup>\r
\r
### Subclass or Runnable?\r
\r
There are no rules about which of the two methods is the best. Both methods works. **The preferred method is implementing Runnable**, and handing an instance of the implementation to a Thread instance.\r
\r
A few reasons against extending Thread\r
\r
- When extending the Thread class, we're not overriding any of its methods. Instead, we override the method of Runnable (which Thread happens to implement). This is a clear violation of IS-A Thread principle.\r
- Creating an implementation of Runnable and passing it to the Thread class utilizes composition and not inheritance – which is more flexible\r
- After extending the Thread class, we can't extend any other class\r
From Java 8 onwards, Runnables can be represented as lambda expressions\r
\r
::: danger Common Pitfall: Calling run() Instead of start()\r
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:\r
\r
> Thread newThread = new Thread(MyRunnable());\r
> newThread.run();  //should be start();\r
\r
or\r
\r
> MyRunnable runnable = new MyRunnable();\r
> runnable.run();  \r
\r
At first you may not notice anything because the Runnable's run() method is executed like you expected. However, it is **NOT executed by the new thread** you just created. Instead the run() method is executed by the thread that created the thread. In other words, the thread that executed the above two lines of code. To have the run() method of the MyRunnable instance called by the new created thread, newThread, **you MUST call the newThread.start() method**.\r
:::\r
\r
## 3.1.4 Thread class methods\r
\r
If we take a look at the Thread class definition, we will find many methods. We must be careful because some of those methods like stop(), suspend(), resume() and destroy() are \`deprecated\`.\r
\r
Next we can see the most commonly used methods of Thread class:\r
\r
| Method                      | Description                                                                                                                                           |\r
| :-------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| start()                     | Makes a thread execute the code in the run method()                                                                                                   |\r
| boolean isAlive()           | Checks if the thread is alive or not                                                                                                                  |\r
| sleep(long ms)              | Changes the thread state to blocked for the ms specified                                                                                              |\r
| run()                       | Is the thread code to be run. It is called by the start method. It represents the lifecycle of a thread.                                              |\r
| String toString()           | Returns a readable representation a thread [threadName, priority, threadGroupName]                                                                    |\r
| long getId()                | Returns the thread id                                                                                                                                 |\r
| void yield()                | Makes the thread stop running at the moment going back to the queue and allowing other threads to be executed.                                        |\r
| void join()                 | Called from another thread, waits for this thread to die                                                                                              |\r
| String getName()            | Gets the thread name                                                                                                                                  |\r
| String setName(String name) | Sets a name for the thread                                                                                                                            |\r
| int getPriority()           | Gets the thread priority                                                                                                                              |\r
| setPriority(int p)          | Sets the thread priority                                                                                                                              |\r
| void interrupt()            | Interrupts the thread executions causing a InterruptedException                                                                                       |\r
| boolean interrupted()       | Checks if a thread has been interrupted                                                                                                               |\r
| Thread.currentThread()      | STATIC method returns a reference to the thread that is running this code                                                                             |\r
| boolean isDaemon()          | Checks if thread is a daemon. A low-level process running independently from its process. A process can finish while a daemon thread is still running |\r
| setDaemon(boolean on)       | Makes a thread turn into a daemon. By default all threads are user-threads when they are created.                                                     |\r
| int activeCount()           | Returns the number of active threads in the thread group where the thread belongs to.                                                                 |\r
| Thread.State getState()     | Returns the thread state, one of NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.                                                        |\r
\r
Thread also has up to 9 constructors, most of them getting a Runnable object as parameter along with the thread name and the tread group.\r
\r
| Thread constructors                                                                                   |\r
| :---------------------------------------------------------------------------------------------------- |\r
| Thread()                                                                                              |\r
| Thread​(Runnable target)                                                                              |\r
| Thread​(String name)                                                                                  |\r
| Thread​(Runnable target, String name)                                                                 |\r
| Thread​(ThreadGroup group, Runnable target)                                                           |\r
| Thread​(ThreadGroup group, String name)                                                               |\r
| Thread​(ThreadGroup group, Runnable target, String name)                                              |\r
| Thread​(ThreadGroup group, Runnable target, String name, long stackSize)                              |\r
| Thread​(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) |\r
\r
Here we can see an example of some of these methods in use\r
\r
\`\`\`java\r
public class ThreadMethodsExample extends Thread {\r
    \r
    ThreadMethodsExample (ThreadGroup group, String name) {\r
        // Call to parent class constructor with group and thread name\r
        super(group, name);\r
    }\r
    \r
    @Override\r
    public void run() {\r
        String threadName = Thread.currentThread().getName();\r
        System.out.println("["+threadName+"] " + "Inside the thread");\r
        System.out.println("["+threadName+"] " + "Priority: " \r
          + Thread.currentThread().getPriority());\r
        Thread.yield();\r
        System.out.println("["+threadName+"] " + "Id: " \r
          + Thread.currentThread().getId());\r
        System.out.println("["+threadName+"] " + "ThreadGroup: " \r
          + Thread.currentThread().getThreadGroup().getName());\r
        System.out.println("["+threadName+"] " + "ThreadGroup count: " \r
          + Thread.currentThread().getThreadGroup().activeCount());\r
    } \r
    \r
    public static void main(String[] args) {\r
        // main thread \r
        Thread.currentThread().setName("Main");\r
        System.out.println(Thread.currentThread().getName());\r
        System.out.println(Thread.currentThread().toString());\r
        \r
        ThreadGroup even = new ThreadGroup("Even threads");\r
        ThreadGroup odd = new ThreadGroup("Odd threads");\r
        \r
        Thread localThread = null;\r
        for (int i=0; i<10; i++) {\r
            localThread = new ThreadMethodsExample((i%2==0)?even:odd, "Thread"+i);\r
            localThread.setPriority(i+1);\r
            localThread.start();\r
        }\r
              \r
        try {\r
            localThread.join(); // --> Will wait until last thread ends \r
                                // like a waitFor() for processes\r
        } catch (InterruptedException ex) {\r
            ex.printStackTrace();\r
            System.err.println("The main thread was interrupted while waiting for " \r
              + localThread.toString() + "to finish");\r
        }\r
        System.out.println("Main thread ending");\r
    }    \r
}\r
\`\`\`\r
\r
As you can see in the code above, the static method Thread.currentThread() should be called in order to get the instance of the current thread running each statement, as there are many threads running the same code at the same time.\r
\r
In the previous example we have used just one class for the new threads and for the main thread. And that's not the usual way to run threads. It's a better practice to split the code in separate classes.\r
\r
Also note that the Thread (or Runnable) class can have it's own constructor to set its local properties or call the superclass constructors.\r
\r
:::question Split the code in two classes\r
Copy the code from the ThreadMethodsExample and split in in two classes. One containing the thread class and the other just having the main method and the calls to create and launch the processes.\r
\r
Next, change the ThreadMethodsExample to implement the Runnable interface and make the appropriate changes in the other class to make it work again.\r
:::\r
\r
Pay attention to  even if the threads are started in sequence (1, 2, 3 etc.) they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out. This is because the threads are in principle executing in parallel and not sequentially. The JVM and/or operating system determines the order in which the threads are executed. This order does not have to be the same order in which they were started nor each time the are run.\r
\r
### Pause a thread\r
\r
A thread can pause itself by calling the static method **Thread.sleep()**. The sleep() takes a number of milliseconds as parameter. The sleep() method will attempt to sleep that number of milliseconds before resuming execution. The Thread sleep() is not 100% precise, but it is pretty good still. Here is an example of pausing a Java thread for 3 seconds (3.000 milliseconds) by calling the Thread sleep() method:\r
\r
\`\`\`java:no-line-numbers\r
try {\r
    Thread.sleep(3000L);\r
} catch (InterruptedException e) {\r
    e.printStackTrace();\r
}\r
\`\`\`\r
\r
::: info Real systems simulation\r
This method is going to be used in activities to simulate time lapses and speed up the real systems simulation. For instance, we can set that each *real* hour is just a second in the simulation, so one day will be reduced to 24 seconds.\r
\r
Also it's interesting when we need to set random time lapses for each thread, in order to get a realistic simulation of events in the real system.\r
:::\r
\r
Random numbers within a specific range of type integer, float, double, long, and boolean can be generated in Java.\r
\r
There are three methods to generate random numbers in Java.\r
\r
#### Method 1: Using random class\r
\r
We can use the \`java.util.Random\` class to generate random numbers, following the steps below:\r
\r
- Import the class java.util.Random\r
- Make the instance of the class Random, i.e., Random rand = new Random()\r
- Invoke one of the following methods of rand object:\r
  - nextInt(upperbound) generates random numbers in the range 0 to upperbound-1.\r
  - nextFloat() generates a float between 0.0 and 1.0.\r
  - nextDouble() generates a double between 0.0 and 1.0.\r
  \r
if we use the netxInt invocation with the bound parameter, we'll get numbers within a range\r
\r
> int randomIntWithinARange = random.nextInt(max)\r
\r
This will give us a number between *0 (inclusive)* and *max* (exclusive). The bound parameter must be greater than 0. Otherwise, we'll get a java.lang.IllegalArgumentException.\r
\r
#### Method 2: Using Math.random\r
\r
For generating random numbers within a range using Math.random(), follow the steps below:\r
\r
- Declare the minimum value of the range\r
- Declare the maximum value of the range\r
- Use the formula Math.random()*(max-min)+min to generate values with the min and the max value inclusive.\r
\r
The value returned by Math.random() is in the range 0 to 1 inclusive.\r
\r
To generate a random value between 0 and an upper limit (50)\r
\r
> Math.random()*50\r
\r
To generate a random value between 1 and an upper limit (50)\r
\r
> Math.random()*49+1\r
\r
To generate a random bounded value, let's say between 200 and 500\r
\r
> Math.random()*300+200\r
\r
#### Method 3: Use ThreadLocalRandom\r
\r
The \`java.util.Random\` class doesn't perform well in a multi-threaded environment.\r
\r
In a simplified way, the reason for the poor performance of Random in a multi-threaded environment is due to contention – given that multiple threads share the same Random instance.\r
\r
To address that limitation, Java introduced the \`java.util.concurrent.ThreadLocalRandom\` for generating random numbers in a multi-threaded environment.\r
\r
We just need to call \`ThreadLocalRandom.current()\` method, and it will return the instance of ThreadLocalRandom for the current thread. We can then generate random values by invoking available instance methods of the class.\r
\r
To generate a random int value without any bounds:\r
\r
> int unboundedRandomValue = ThreadLocalRandom.current().nextInt());\r
\r
To generate a random bounded int value, meaning a value between a given lower and upper limit.\r
\r
> int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);\r
\r
Please note, 0 is the inclusive lower limit and 100 is the exclusive upper limit.\r
\r
We can generate random values for long and double by invoking \`nextLong()\` and \`nextDouble()\` methods in a similar way as shown in the examples above.\r
  \r
### Threads priority management\r
\r
In Java, a thread's priority is an integer in the range 1 to 10. *The larger the integer, the higher the priority*. The thread scheduler uses this integer from each thread to determine which one should be allowed to execute. The Thread class defines three types of priorities:\r
\r
- Minimum priority\r
- Normal priority\r
- Maximum priority\r
  \r
The Thread class defines these priority types as constants \`MIN_PRIORITY\`, \`NORM_PRIORITY\`, and \`MAX_PRIORITY\`, with values 1, 5, and 10, respectively. **NORM_PRIORITY is the default priority for a new Thread**.\r
\r
Java's Thread class provides methods for checking the thread’s priority and for modifying it.\r
\r
The \`getPriority()\` instance method returns the integer that represents its priority.\r
\r
The \`setPriority()\` instance method takes an integer between 1 and 10 for changing the thread's priority. If we pass a value outside the 1-10 range, the method will throw an error.\r
\r
When we create a Thread, it inherits its default priority. When multiple threads are ready to execute, the JVM selects and executes the Runnable thread that has the highest priority. If this thread stops or becomes not runnable, the lower-priority threads will execute. In case two threads have the same priority, the JVM will execute them in FIFO order.\r
\r
There are two scenarios that can cause a different thread to run:\r
\r
- A thread with higher priority than the current thread becomes runnable\r
- The current thread exits the runnable state or yields (temporarily pause and allow other threads)\r
\r
In general, at any time, the highest priority thread is running. But sometimes, the thread scheduler might choose low-priority threads for execution to avoid starvation.\r
\r
\`\`\`java\r
class U3S3_HiloPrioridad1 extends Thread {\r
  private long c = 0;\r
  private boolean stopHilo = false;\r
  public long getContador () {\r
    return c;\r
  }\r
  public void pararHilo() {\r
    stopHilo = true;\r
  }\r
  @Override\r
  public void run() {\r
    while (!stopHilo) c++;\r
  }\r
}\r
\r
public class U3S3_EjemploHiloPrioridad1 {\r
  public static void main(String args[]) {\r
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();\r
\r
    h1.setPriority(Thread.NORM_PRIORITY);\r
    h2.setPriority(Thread.MAX_PRIORITY);\r
    h3.setPriority(Thread.MIN_PRIORITY);\r
\r
    h1.start();\r
    h2.start();\r
    h3.start();\r
\r
    try {\r
      Thread.sleep(10000);\r
        } catch (InterruptedException e) {}\r
\r
    h1.pararHilo();\r
    h2.pararHilo();\r
    h3.pararHilo();\r
\r
    System.out.println("h2 (Prio. Máx: "+h2.getContador());\r
    System.out.println("h1 (Prio. Normal: "+h1.getContador());\r
    System.out.println("h3 (Prio. Mínima: "+h3.getContador());\r
  }\r
}\r
\`\`\`\r
`]},{title:"3.2 Threads synchronization and communication",headers:[{level:2,title:"3.2.1. Shared memory",slug:"_3-2-1-shared-memory",link:"#_3-2-1-shared-memory",children:[]},{level:2,title:"3.2.2. Synchronization",slug:"_3-2-2-synchronization",link:"#_3-2-2-synchronization",children:[{level:3,title:"Monitors and locks",slug:"monitors-and-locks",link:"#monitors-and-locks",children:[]},{level:3,title:"Critical sections",slug:"critical-sections",link:"#critical-sections",children:[]},{level:3,title:"Synchronized and Data Visibility",slug:"synchronized-and-data-visibility",link:"#synchronized-and-data-visibility",children:[]}]},{level:2,title:"3.2.3 Inter-Thread synchronization",slug:"_3-2-3-inter-thread-synchronization",link:"#_3-2-3-inter-thread-synchronization",children:[]}],path:"/en/unit3/synchronization.html",pathLocale:"/en/",extraFields:[`---\r
title: 3.2 Threads synchronization and communication\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.2 Threads synchronization and communication" />\r
\r
# 3.2 Threads synchronization and communication\r
\r
[[toc]]\r
\r
::: info Multithread Vocabulary\r
\r
- **Race condition**: A race condition occurs when two or more threads can access shared data and they try to change it at the same time. Because the thread scheduling algorithm can swap between threads at any time, you don't know the order in which the threads will attempt to access the shared data. Therefore, the result of the change in data is dependent on the thread scheduling algorithm, i.e. both threads are "racing" to access/change the data.\r
- **Deadlock**: Deadlock describes a situation where two or more threads are blocked forever, waiting for each other. Deadlock occurs when multiple threads need the same locks but obtain them in different order.\r
- **Critical section**: A critical section is a section of code that is executed by multiple threads and where the sequence of execution for the threads makes a difference in the result of the concurrent execution of the critical section. It needs to be executed without outside interference - i.e. without another thread potentially affecting/being affected by "intermediate" states within the section.\r
- **Thread-safe**: A class (or chunk of code) is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and **with no additional synchronization or other coordination on the part of the calling code**.\r
\r
:::\r
\r
## 3.2.1. Shared memory\r
\r
Usually threads need to communicate with each other. The most common way of communication is sharing a common object.\r
\r
Let's code an example where two threads share the same Contador instance.\r
\r
![alt_text](../../media/unit3/SumadorRestador_uml.jpg)\r
\r
<!--\r
\`\`\`puml\r
class Contador {\r
  - int c = 0\r
  + Contador(int c)\r
  +void incrementa()\r
  +void decrementa()\r
  + int valor()\r
}\r
class Sumador extends Thread {\r
  - Contador c\r
  + Sumador(String name, Contador c)\r
  + void run()\r
\r
}\r
class Restador implements Runnable{\r
  - Contador c\r
  + Restador(String name, Contador c)\r
  + void run()\r
\r
}\r
Restador o-- Contador\r
Sumador o-- Contador\r
\`\`\`\r
-->\r
\r
To test the shared object, there must be just another class - containing the main method - to create the shared object (with init value of 100) and to launch the Sumador and Restador threads. In Sumador class we call the Contador.incrementa method in order to add 1 the Contador c property, and similarly Restador calls the decrementa method to substract 1 on Contador c property. Each thread will repeat the same action 300 times, waiting a random time between 50ms and 150ms.\r
It is very relevant to use the same Contador object as parameter for Sumador and Restador, to make sure they are sharing the same Contador instance.\r
\r
::: question Expected behaviour\r
Write the four classes attending to the Class diagram. Make sure to have Sumador extending Thread and Restador implementing Runnable to test differences in how a thread is obtained from each approach.\r
\r
What should happen after running the code?\r
\r
Check what it really happens. Try to run the program many times.\r
:::\r
\r
:::details Code for the example\r
\r
\`\`\`java{4,7,9}\r
public class U3S3_SharedMemory {\r
  public static void main(String[] args) throws InterruptedException {\r
    // Inicializar el objeto Contador\r
    Contador c = new Contador(100);\r
    \r
    // Crear y lanzar 2 hilos (Sumador + Restador)\r
    Sumador s1 = new Sumador("Sumador1", c);\r
    Restador r1 = new Restador("Restador1", c);\r
    Thread h1 = new Thread(r1);\r
    \r
    s1.start();\r
    h1.start();\r
    \r
    // El hilo principal espera a que los hilos s1 y r1 terminen\r
    s1.join();\r
    h1.join();\r
    \r
    System.out.println("El valor final de c es " + c.valor());\r
    \r
  }\r
\`\`\`\r
\r
\`\`\`java\r
public class Contador {\r
  private int c = 0;\r
  \r
  public Contador(int c) {\r
    this.c = c;\r
  }\r
  \r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
  \r
  public int valor() {\r
    return c;\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,5,14}\r
public class Sumador extends Thread {\r
  private Contador c;\r
  public Sumador(String name, Contador c) {\r
    // To set the thread name we can access the Thread class constructor\r
    super(name);\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.incrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());\r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }\r
    }\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,3,13,17}\r
public class Restador implements Runnable {\r
  private Contador c;\r
  private String name;\r
  public Restador(String name, Contador c) {\r
    // Restador doesn't extend Thread, so it cannot call the Thread constructor\r
    // super(name);\r
    this.name = name;\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    Thread.currentThread().setName(this.name);\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.decrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());              \r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }      \r
    }    \r
  }\r
}\r
\`\`\`\r
\r
If we run the code, sometimes it will end by showing a final value of 100 for c, what it should be expected. But if you run the code many times you'll find that sometimes the value can be 99, 101 or any other value.\r
\r
To avoid this synchronization problems (random problems really hard to detect), we need the threads to be synchronized.\r
:::\r
\r
if we check the above problem, we'll find that we are trying to run this code in parallel, from different threads, on the same object instance (shared instance):\r
\r
\`\`\`java\r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
\`\`\`\r
\r
If we apply Bernstein conditions, we well get that none of the three conditions are met, so this code cannot be run concurrently, at least not without having concurrency problems.\r
\r
So, we have to set a special configuration in our code in order to avoid this code to be run simultaneously.\r
\r
## 3.2.2. Synchronization\r
\r
As we have previously seen, threads communicate primarily by sharing access to objects and their properties. This form of communication is extremely efficient but makes two kinds of errors possible:\r
\r
- thread interference\r
- memory consistency errors.\r
\r
The tool needed to prevent these errors is synchronization.\r
\r
When one thread is able to observe the effects of other threads and may be able to detect that variable accesses become visible to other threads in a different order than executed or specified in the program, we talk about reorderings, usually happening with incorrectly synchronized multithread programs. Most of the time, one thread doesn’t care what the other is doing. But when it does, that’s what synchronization is for.\r
\r
### Monitors and locks\r
\r
To synchronize threads, Java uses \`monitors\`, which are a high-level mechanism for allowing only one thread at a time to execute a region of code protected by the monitor. The behavior of monitors is explained in terms of locks; **there is a lock associated with each object**.\r
\r
Synchronization has several aspects. The most well-understood is \`mutual exclusion\` — **only one thread can hold a monitor at once**, so synchronizing on a monitor means that once one thread enters a synchronized block protected by a monitor, no other thread can enter a block protected by that monitor until the first thread exits the synchronized block.\r
\r
But there is more to synchronization than mutual exclusion. Synchronization ensures that memory writes by a thread before or during a synchronized block are made visible in a predictable manner to other threads that synchronize on the same monitor.\r
\r
::: info Volatile-like behaviour\r
After we exit a synchronized block, we release the monitor, which has the effect of flushing the cache to main memory, so that writes made by this thread can be visible to other threads. Before we can enter a synchronized block, we acquire the monitor, which has the effect of invalidating the local processor cache so that variables will be reloaded from the main memory.\r
:::\r
\r
### Critical sections\r
\r
Synchronized blocks in Java are marked with the \`synchronized\` keyword. A synchronized block in Java is synchronized with some objects. All synchronized blocks synchronized on the same object can only have one thread executing inside them at the same time. All other threads attempting to enter the synchronized block are blocked until the thread inside the synchronized block exits the block.\r
\r
The synchronized keyword can be used to mark four different types of blocks:\r
\r
- Instance methods\r
- Static methods\r
- Code blocks inside instance methods\r
- Code blocks inside static methods\r
\r
Here is a synchronized instance method:\r
\r
\`\`\`java{3}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
}\r
\`\`\`\r
\r
Notice the use of the synchronized keyword in the add() method declaration. This tells Java that the method is synchronized.\r
\r
A synchronized instance method in Java is synchronized on the instance (object) owning the method. Thus, each instance has its synchronized methods synchronized on a different object: the owning instance.\r
\r
Only one thread per instance can execute inside a synchronized instance method. If more than one instance exists, then one thread at a time can execute inside a synchronized instance method per instance. One thread per instance.\r
\r
This is true across all synchronized instance methods for the same object (instance). Thus, in the following example, only one thread can execute inside either of the two synchronized methods. One thread in total per instance:\r
\r
\`\`\`java{3,6}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
 public synchronized void sub(int value){\r
   this.count -= value;\r
 }\r
}\r
\`\`\`\r
\r
::: info Synchronized with static methods\r
Synchronized static methods are synchronized on the **class object** of the class the synchronized static method belongs to. Since **only one class object exists in the Java VM per class**, only one thread can execute inside a static synchronized method in the same class.\r
:::\r
\r
You do not have to synchronize a whole method. Sometimes it is preferable to synchronize only part of a method. Java synchronized blocks inside methods make this possible.\r
Here is a synchronized block of Java code inside an unsynchronized Java method:\r
\r
\`\`\`java{2}\r
public void add(int value){\r
  synchronized(this){\r
    this.count += value;  \r
  }\r
 }\r
\`\`\`\r
\r
This example uses the Java synchronized block construct to mark a block of code as synchronized. This code will now execute as if it was a synchronized method.\r
\r
Notice how the Java synchronized block construct takes an object in parentheses. In the example “this” is used, which is the instance the add method is called on. The object taken in the parentheses by the synchronized construct is called a monitor object. The code is said to be synchronized on the monitor object. **A synchronized instance method uses the object it belongs to as a monitor object**.\r
\r
Only one thread can execute inside a Java code block synchronized on the same monitor object.\r
\r
The following two examples are both synchronized on the instance they are called on. **They are therefore equivalent with respect to synchronization**:\r
\r
\`\`\`java{2,8}\r
public class MyClass { \r
  public synchronized void log1(String msg1, String msg2){\r
    log.writeln(msg1);\r
    log.writeln(msg2);\r
  }\r
 \r
  public void log2(String msg1, String msg2){\r
    synchronized(this){\r
     log.writeln(msg1);\r
     log.writeln(msg2);\r
    }\r
  }\r
 }\r
\`\`\`\r
\r
Thus only a single thread can execute inside either of the two synchronized blocks in this example.\r
\r
::: warning What Objects to Synchronize On\r
The synchronized block must be synchronized on some object. You can actually choose any object to synchronize on, but **it is recommended that you do not synchronize on String objects, or any primitive type wrapper objects** (Integer, Double, Boolean, ...).\r
\r
To be on the safe side, synchronize on this - or on a new Object() . Those are not cached or reused internally by the Java compiler, Java VM, or Java libraries.\r
:::\r
\r
### Synchronized and Data Visibility\r
\r
Without the use of the synchronized keyword (or the Java \`volatile\` keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g. via an object all threads have access to), that the other threads can see the changed value. There are no guarantees about when a variable kept in a CPU register by one thread is "committed" to main memory, and there is no guarantee about when other threads "refresh" a variable kept in a CPU register from main memory.\r
\r
The synchronized keyword changes that.\r
\r
- When a thread enters a synchronized block it will refresh the values of all variables visible to the thread.\r
- When a thread exits a synchronized block all changes to variables visible to the thread will be committed to the main memory.\r
\r
This is similar to how the volatile keyword works.\r
\r
## 3.2.3 Inter-Thread synchronization\r
\r
We can avoid several threads run the same code at the same time by using the \`synchronized\` keyword in order to get \`mutual exclusion\` in the form of \`critical sections\`.\r
Sometimes it can be enough, but others we need the threads to keep certain order in their execution, probably related to other threads previous actions or results.\r
\r
To do so, we need to use three new methods from the object class, directly related to synchronized.\r
\r
- **wait()**: When you call wait method on the object then it tell threads to \`give up the lock\` and go to sleep state unless and until some other thread enters in same monitor and calls notify or notifyAll methods on it.\r
- **notify()**: When you call notify method on the object, it \`wakes one of thread waiting for that object\`. So if multiple threads are waiting for an object, it will wake of one of them. Now you must be wondering which one it will wake up. It actually depends on OS implementation.\r
- **notifyAll()**: notifyAll will \`wake up all threads waiting on that object\` unlike notify which wakes up only one of them. Which one will wake up first depends on thread priority and OS implementation.\r
\r
wait , notify and notifyAll method are used to allow threads to communicate to each other via accessing common object. This common object can be considered a medium for \`inter thread communication\`via these methods. **These methods need to be called from synchronized context**,otherwise it will throw java.lang.IllegalMonitorStateException.\r
\r
When **wait()** method is called, the thread is running inside the synchronized block so it will own the monitor (lock) for the object. That monitor is released by the thread and the thread is locked into another **queue (from the lock object) of threads waiting to be notified**, different than the queue of threads waiting for the object monitor (lock).\r
\r
When a thread is unlocked because another thread has called **notify()/notifyAll()** on the same object, the thread goes back to the point where the wait was made, so the thread is still into a synchronized block. To keep on running, the thread goes back to the **queue of threads waiting for the object monitor (lock)** and it has to wait until it gets the lock to run the sentences after the wait().\r
\r
![Monitor queues](../../media/unit3/Monitor_queues.png)\r
\r
Let's learn how these methods work by looking at the following example\r
\r
\`\`\`java\r
// It is the common java class on which thread will act and call wait and notify method.\r
public class Book {\r
 String title;\r
 boolean isCompleted;\r
 \r
 public Book(String title) {\r
 super();\r
 this.title = title;\r
 }\r
 \r
 public String getTitle() {\r
 return title;\r
 }\r
 public void setTitle(String title) {\r
 this.title = title;\r
 }\r
 public boolean isCompleted() {\r
 return isCompleted;\r
 }\r
 public void setCompleted(boolean isCompleted) {\r
 this.isCompleted = isCompleted;\r
 } \r
}\r
\`\`\`\r
\r
\`\`\`java{14,17}\r
// It will first take a lock on book object \r
// Then, the thread will wait until other thread call notify method, then after it will complete its processing. \r
// So in this example, it will wait for BookWriter to complete the book.\r
public class BookReader implements Runnable{\r
 Book book;\r
 \r
 public BookReader(Book book) {\r
 super();\r
 this.book = book;\r
 }\r
 \r
 @Override\r
 public void run() {\r
 synchronized (book) {\r
  System.out.println(Thread.currentThread().getName()+" is waiting for the book to be completed: "+book.getTitle());\r
  try {\r
  book.wait();\r
  } catch (InterruptedException e) {  \r
  e.printStackTrace();\r
  }\r
  System.out.println(Thread.currentThread().getName()+": Book has been completed now!! you can read it");\r
 }\r
 } \r
}\r
\`\`\`\r
\r
\`\`\`java{15,22,25}\r
// This class will notify thread(in case of notify) which is waiting on book object. \r
// It will not give away lock as soon as notify is called, it first complete its synchronized block. \r
// So in this example, BookWriter will complete the book and notify it to BookReaders. \r
public class BookWriter implements Runnable{\r
\r
 Book book;\r
 \r
 public BookWriter(Book book) {\r
 super();\r
 this.book = book;\r
 }\r
 \r
 @Override\r
 public void run() {\r
 synchronized (book) {\r
  System.out.println("Author is Starting book : " +book.getTitle() );\r
  try {\r
  Thread.sleep(1000);\r
  } catch (InterruptedException e) {\r
  e.printStackTrace();\r
  }\r
  book.setCompleted(true);\r
  System.out.println("Book has been completed now");\r
 \r
  book.notify();\r
  System.out.println("notify one reader");\r
 } \r
 }\r
}\r
\`\`\`\r
\r
\`\`\`java{8,9,26}\r
// This is our main class which will create object of above classes and run it.\r
public class U3S5_Books {\r
 \r
 public static void main(String args[])\r
 {\r
 // Book object on which wait and notify method will be called\r
 Book book=new Book("The Alchemist");\r
 BookReader johnReader=new BookReader(book);\r
 BookReader arpitReader=new BookReader(book);\r
 \r
 // BookReader threads which will wait for completion of book\r
 Thread johnThread=new Thread(johnReader,"John");\r
 Thread arpitThread=new Thread(arpitReader,"Arpit");\r
 \r
 arpitThread.start();\r
 johnThread.start();\r
 \r
 // To ensure both readers started waiting for the book\r
 try {\r
  Thread.sleep(3000);\r
 } catch (InterruptedException e) {\r
 \r
  e.printStackTrace();\r
 }\r
\r
 // BookWriter thread which will notify once book get completed\r
 BookWriter bookWriter=new BookWriter(book);\r
 Thread bookWriterThread=new Thread(bookWriter);\r
 bookWriterThread.start();\r
 }\r
}\r
\`\`\`\r
\r
There must be a notify call for every wait to ensure we have no deadlocks in our app.\r
\r
::: question Does order matter?\r
If we run the previous code, we have to ask ourselves:\r
\r
- a) How many wait() are done? And how many notify()?\r
\r
Just by looking at the code, we can see that there are 2 wait() and 1 notify(). Something doesn't fit.\r
\r
One of the readers is not notified, so a thread is waiting in a wait(). As that thread doesn't finish, the process doesn't either. We have to remember that a process doesn't finish until the last of its threads does. In Netbeans, this means the program doesn't end and we have to stop it.\r
\r
**Solution**: In this case we have two alternatives. The first one is to use notifyAll() instead of notify(). This way, both BookReaders are activated and they wait to take the monitor lock. One will do it first and the other one later, but both will end up reading the book.\r
The other option is, following with notify(), that each reader, when finishing reading the book, notifies other possible readers waiting so that one wakes up and reads the book.\r
\r
- b) What will happen to the above code if we change the order for the Readers and Writer in the main method? That is, first we make sure the Book is finished and then we call the Readers. What if we start all threads at the same time and we don't know in which order they will run? What if we start the Readers first and then the Writer?\r
\r
If the BookWriter is launched first, it finishes the book and notifies... nobody, because the BookReaders are not waiting yet. Then the BookReaders arrive and both get stuck, as no other thread will notify them.\r
\r
**Solution**: Threads are now blocking indiscriminately, but they should only block if the book they want to read is not finished. Therefore, we have to control the blocking of the BookReader with a condition. As we have commented, the conditions must be in the shared object, in this case book, shared by BookWriter and the two BookReader. The condition that allows us to discriminate if a BookReader can continue or not is the isCompleted property that we consult through the book.isCompleted() method.\r
\r
\`\`\`java\r
try {\r
  if (!book.isCompleted())\r
    book.wait();\r
} catch (InterruptedException e) { \r
\`\`\`\r
\r
With these two changes, the application should work with any number of BookReaders and BookWriters, regardless of the order or the amount.\r
:::\r
\r
::: info ¿notify() o notifyAll()?\r
All will depend on the system we are programming, but as a general rule, if we want only one thread to continue after modifying the system state, we will call notify().\r
\r
Otherwise, notifyAll() should be used. If everything is well programmed, the thread will check if it can continue and, if not, it will wait() again and continue waiting, so it is not a problem that more than one thread is activated.\r
\r
The use of notify() poses a greater risk of indefinite blocking of threads waiting for notifications that will never arrive, this blocking being different from a deadlock. We must be very careful with the programming of synchronization mechanisms.\r
\r
It should also be noted that there should be at least one notify() call for each wait() that has been made, although that does not ensure that some thread will not be blocked.\r
:::\r
\r
::: question Modifify previous Sumador-Restador\r
Make the necessary changes in the classes of the U3S3_SharedMemory project (save it as U3S3_SharedMemory_v2) so that:\r
\r
- The first thread that performs an operation on the counter is a Sumador\r
- After a Sumador, a Restador is always executed and after a Restador, a Sumador is always executed, making a sequence Sumador-Restador-Sumador-Restador-...\r
:::\r
\r
::: details U3S3_SharedMemory_v2\r
\r
\`\`\`java\r
public class Contador {\r
\r
    private int c = 0;\r
    boolean ahoraSumador = true;\r
\r
    public Contador(int c) {\r
        this.c = c;\r
        ahoraSumador = true;\r
    }\r
\r
    public synchronized void incrementa() {\r
        while (!ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) {\r
            }\r
        }\r
\r
        // El hilo hace su tarea\r
        c++;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = false;\r
        notifyAll();\r
\r
    }\r
\r
    public synchronized void decrementa() {\r
        while (ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) { }\r
        }\r
\r
        // El hilo hace su tarea\r
        c--;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = true;\r
        notifyAll();\r
    }\r
\r
    public int valor() {\r
        return c;\r
    }\r
}\r
\`\`\`\r
\r
In Contador class a new state variable has been added to control the threads order, which one has to wait and which one can run its code.\r
\r
Furthermore, output from the threads run method has been moved into the synchronized methods in this class.\r
\r
\`\`\`java\r
public class Restador  implements Runnable {\r
    private Contador c;\r
    private String name;\r
    public Restador(String name, Contador c) {\r
        // super(name);\r
        this.name = name;\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        Thread.currentThread().setName(this.name);\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.decrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }        \r
    }\r
}\r
\`\`\`\r
\r
Restador and Sumador have few changes.\r
\r
\`\`\`java\r
public class Sumador  extends Thread {\r
    private Contador c;\r
    public Sumador(String name, Contador c) {\r
        super(name);\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.incrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }\r
    }\r
}\r
\`\`\`\r
\r
Main class remains equal.\r
\r
::: danger Synchronized output\r
As you can see from the previous code, the output originally in the threads' run methods now is into Contador class methods, more specifically into the \`synchronized\` methods.\r
\r
Careful with console output. All threads are in a \`race condition\` to use the System.out stream. The concequence is that what we see on the console doesn't match the order in which the output has been sent to the stream. That's why is so important to move the console output into the synchronized methods, when possible.\r
\r
If we don't control the console output we can have well coded and solved problems but in the console we will see wrong results.\r
:::\r
\r
`]},{title:"4 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit4/",pathLocale:"/en/",extraFields:[`---\r
title: 4 Introduction\r
---\r
\r
# Unit 4. Network programming\r
\r
---\r
\r
We have already studied how independent applications can collaborate to do a task (\`multiprocess\`) or just how to divide a program in many execution threads to be run simultaneously and even concurrently (\`multithread\`). But all this happens inside one computer, it can be **monoprocessor** or **multiprocessor**, under the same OS and sharing memory and I/O.\r
\r
In this unit we are going one step forward, we are going to code applications working on distributed environments. Once again we will have multiple processes running, but instead having a parent-child (launcher-launched) relationship, now the processes will be run on independent systems, and what's more interesting, the will communicate through the network by using \`communication protocols\`.\r
\r
Basically we can classify distributed systems in two groups::\r
\r
- **Client / Server**: where one process, called the \`server\`, offers services to one or more processes, called \`clients\`.\r
- **Peer to peer (P2P)**: where all the processes collaborate in a similar way without any particular specialization or difference among them.\r
\r
::: warning Processes and Threads\r
To make a distributed application, with processes and network communication, we are not starting form the scratch.\r
\r
Network programming is strongly linked with multiprocess programming. We will see how communication between process is exactly the same as through the network.\r
\r
On the other side, the specialization and service offered by a server, simultaneously to many clients, is based on the multithread approach..\r
\r
All the above, all concepts and knowledge acquired from unit 1 to unit 3, will be the scaffold to start creating distributed applications.\r
:::\r
\r
## Goals\r
\r
The goals for this unit are:\r
\r
- To know about TCP/IP protocol, addresses used in each protocol layer and associated protocols.\r
- To know Java classes tp work with Internet addresses and server names.\r
- To learn about basic TPC and UPD protocols features.\r
- To code applications that use TCP protocol for communication purposes.\r
- To code applications that use UDP protocol for communication purposes.\r
- To design and code protocols for distributed applications.\r
- to coordinate multiple client access to servers by using multithread programming.\r
`]},{title:"4.2 TCP Sockets",headers:[{level:2,title:"4.2.1. Comunicación cliente/servidor con sockets TCP",slug:"_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",link:"#_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",children:[{level:3,title:"Programación de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.2.2. Cliente TCP",slug:"_4-2-2-cliente-tcp",link:"#_4-2-2-cliente-tcp",children:[{level:3,title:"Streams para E/S en los sockets",slug:"streams-para-e-s-en-los-sockets",link:"#streams-para-e-s-en-los-sockets",children:[]}]},{level:2,title:"4.2.3 Servidor TCP",slug:"_4-2-3-servidor-tcp",link:"#_4-2-3-servidor-tcp",children:[]},{level:2,title:"4.2.4 Servidor multihilo",slug:"_4-2-4-servidor-multihilo",link:"#_4-2-4-servidor-multihilo",children:[]}],path:"/en/unit4/sockets-tcp.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.2 TCP Sockets\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 TCP Sockets" />\r
\r
# 4.2 TCP Sockets\r
\r
[[toc]]\r
\r
## 4.2.1. Comunicación cliente/servidor con sockets TCP\r
\r
Oracle ha resumido el uso de los sockets en un breve tutorial. Todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)\r
\r
La interfaz Java que da soporte a sockets TCP está constituida por las clases **ServerSocket** y **Socket**.\r
\r
- ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexión de los clientes. Su método \`accept\` toma una petición de conexión de la cola, o si la cola está vacía, se bloquea hasta que llega una petición.\r
  \r
  El resultado de ejecutar accept es una instancia de Socket, a través del cual el servidor tiene acceso a los datos enviados por el cliente.\r
\r
- Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, así se crea el socket local y además se conecta con el servicio.\r
  \r
  Esta clase proporciona los métodos \`getInputStream\` y \`getOutputStream\` para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir \`BufferedReader\` y \`PrintWriter\`, respectivamente, para poder procesar los datos de forma más sencilla.\r
\r
### Programación de aplicaciones Cliente y/o Servidor\r
\r
Al crear aplicaciones cliente y servidor puede que nos encontremos con varios escenarios, a saber:\r
\r
- Si tenemos que programar solo el servidor **deberemos definir un protocolo** de comunicación para usar ese servidor.\r
- Si tenemos que programar solo el cliente **necesitaremos conocer el protocolo** de comunicación para conectar con ese servidor.\r
- Si tenemos que programar el cliente y el servidor, tendremos que empezar por **definir el protocolo** de comunicación entre ambos.\r
\r
::: info Herramientas para definir los protocolos\r
Dentro de todos los diagramas que ofrece UML, el diagrama de secuencia es el que mejor se adapta para definir los protocolos de comunicación entre clases y las interacciones que se producen.\r
\r
Para crear estos diagramas existen multitud de herramientas, tanto de escritorio como online. De todas ellas cabe destacar:\r
\r
- [Mermaid Live editor](https://mermaid.live/) que usa una [sintaxis en modo texto](https://mermaid-js.github.io/mermaid/#/sequenceDiagram) para definir los diagramas.\r
- [WebSequenceDiagrams](https://www.websequencediagrams.com/): Más visual y también con una definición textual de los diagramas.\r
- [Visual Paradigm Online](https://online.visual-paradigm.com/drive/#diagramlist:proj=0&dashboard): Herramienta totalmente visual y con unos resultados más espectaculares.\r
\r
Estas herramientas son las que tenéis que usar en las actividades en las que se os pida definir un protocolo de comunicación cliente / servidor.\r
:::\r
\r
## 4.2.2. Cliente TCP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente será:\r
\r
1. Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.\r
2. Obtener las referencias al stream de entrada y al de salida al socket.\r
3. Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar el socket.\r
\r
\`\`\`java{12,14,17,36,38,51,52,54}\r
public class BasicClient {\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que está en la misma máquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket("localhost", 4444);\r
            // Obtenemos el canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexión");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenvía al servidor hasta que este\r
        // se despide con "Adios"\r
        try {\r
            while (true) {\r
                // Leo la entrada del usuario\r
                linea = stdIn.nextLine();\r
                // La envia al servidor por el OutputStream\r
                salida.println(linea);\r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Envía a la salida estándar la respuesta del servidor\r
                System.out.println("Respuesta servidor: " + linea);\r
                // Si es "Adios" es que finaliza la comunicación\r
                if (linea.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
\r
        // Libera recursos\r
        salida.close();\r
        entrada.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\r
\`\`\`\r
\r
::: info Herramientas para simular clientes genéricos\r
Si sólo tenemos que desarrollar un servidor y no tenemos o no queremos hacer un cliente para las pruebas, tenemos varias herramientas que nos ayudan a hacer de clientes genéricos, útiles para una gran variedad de servidores, incluso para servidores estándar como FTP, HTTP, etc.\r
\r
La primera herramienta es una aplicación y un protocolo de nivel de aplicación de TCP/IP, es la herramienta \`Telnet\`.\r
\r
Esta herramienta suele venir instalada en los sistemas GNU/Linux y OS X. Sin embargo en los sistemas Windows viene deshabilitada por defecto.\r
\r
Os dejo un enlace al artículo de Xataka [Telnet: qué es y cómo activarlo en Windows 10](https://www.xataka.com/basics/telnet-que-como-activarlo-windows-10).\r
\r
Es importante que lo activéis tanto en clase como en el aula.\r
\r
La segunda herramienta es NetCat. Es una herramienta muy versátil y potente, ya que no sólo puede hacernos de cliente, sino que también puede servir como servidor.\r
\r
Como muchas otras herramientas, esta también viene instalada de serie en GNU/Linux y OS X, pero no en Windows. Su uso en los sistemas de Microsoft es algo más controvertido ya que el sistema la detecta como un malware y tenemos que habilitar su uso en el *Guardian* del SO.\r
\r
Os dejo también un enlace a este artículo de IONOS [¿Qué es Netcat y cómo funciona?](https://www.ionos.es/digitalguide/servidores/herramientas/netcat/)\r
:::\r
\r
### Streams para E/S en los sockets\r
\r
Si vemos ejemplos en Internet o en tutoriales, podemos observar que hay dos formas mayoritarias de enviar y recibir la información a través de los streams que proporciona un socket.\r
\r
![Basic Stream IO](../../media/unit4/basicIOStreams.png)\r
\r
En cualquier caso, a través de los streams enviamos bytes, que es la forma más básica de generar información, bien sea a través de la red o entre procesos.\r
\r
Como es complicado gestionar a nivel de bytes toda la información que queremos enviar o recibir, usamos \`Decorators\` o \`Wrappers\` para enviar tipos de datos de un nivel de abstracción mayor.\r
\r
En los temas anteriores, cuando hemos tenido que intercambiar información entre procesos, hemos estado usando BufferedReader y PrintWriter. Estas clases trabajan a nivel de Strings, y son muy útiles cuando lo que queremos intercambiar a través de los streams son cadenas de texto.\r
\r
> En los protocolos de comunicaciones, más del 90% de la información que se intercambia, a nivel de protocolo, es en formato texto.\r
\r
Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos. \r
\r
\`DataInputStream\` y \`DataOutputStream\` proporcionan métodos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo números y valores booleanos. \r
\r
![Basic Stream IO](../../media/unit4/streamWrappers.png)\r
\r
DataOutputStream codifica esos valores de forma independiente de la máquina y los envía al stream de más bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.\r
\r
Así, podemos trabajar con DataInputStream y DataOutputStream a partir de los streams que nos proporcionan los sockets\r
\r
\`\`\`java\r
// Código en el cliente\r
DataInputStream dis = new DataInputStream(socket.getInputStream());\r
dis.readDouble();\r
\r
// Código en el servidor\r
DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\r
dis.writeDouble(number);\r
\`\`\`\r
\r
Los métodos \`readUTF()\` and \`writeUTF()\` de DataInputStream y DataOutputStream leen y escriben un String de caracteres Unicode usando la codificación UTF-8.\r
\r
::: warning Elige un método y usa siempre el mismo\r
Es muy importante no mezclar diferentes wrappers en el mismo sistema. Aunque todos acaban utilizando el InputStream y el OutputStream, las codificaciones y la forma de enviar la información no es la misma.\r
\r
Por lo que, si usas DataInputStream en el cliente para leer, debes usar DataOutputStream en el servidor para enviar. Además de usar los métodos complementarios para la lectura y escritura, por ejemplo readInt / writeInt.\r
:::\r
\r
Información extraída de [Learning Java, 4th Edition - O'Reilly](https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch12s01.html)\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.3 Servidor TCP\r
\r
La forma de implementar un servidor será:\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_states.png)\r
\r
1. Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.\r
2. Esperar solicitudes de clientes\r
3. Cuando se produce una solicitud:\r
    - Aceptar la conexión obteniendo un objeto de la clase Socket\r
    - Obtener las referencias al stream de entrada y al de salida al socket anterior.\r
    - Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket.Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar los sockets.\r
\r
\`\`\`java{9,23,26,29,36,40,50,51,52,53}\r
public class BasicServer {\r
\r
    public static final int PORT = 4444;\r
\r
    public static void main(String[] args) throws IOException {\r
        // Establece el puerto en el que escucha peticiones\r
        ServerSocket socketServidor = null;\r
        try {\r
            socketServidor = new ServerSocket(PORT);\r
        } catch (IOException e) {\r
            System.out.println("No puede escuchar en el puerto: " + PORT);\r
            System.exit(-1);\r
        }\r
\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        System.out.println("Escuchando: " + socketServidor);\r
        try {\r
            // Se bloquea hasta que recibe alguna petición de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexión aceptada: " + socketCliente);\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Hace eco de lo que le proporciona el cliente, hasta que recibe "Adios"\r
            while (true) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
                // Envía a la salida estándar el mensaje del cliente\r
                System.out.println("Cliente: " + str);\r
                // Le envía la respuesta al cliente por el OutputStream                \r
                salida.println(str);\r
                // Si es "Adios" es que finaliza la comunicación\r
                if (str.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
        salida.close();\r
        entrada.close();\r
        socketCliente.close();\r
        socketServidor.close();\r
    }\r
\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_sequence.png)\r
\r
El servidor monohilo se encarga de realizar las operaciones de E/S con el cliente. Hasta que no acaba no puede hacer otro \`accept\` y atender a otro cliente.\r
\r
::: warning Local Name Resolver (hosts file)\r
You should know that DNS translates domain names like into IP addresses. But did you know that there’s a file on your system that can override that?\r
\r
It’s called your \`hosts\` file and lets you map specific domain names to an IP address of your choosing. Your HOSTS file only affects your computer, so you can use it to create custom URLs for IP addresses on your network, or you can use it to redirect certain websites.\r
\r
As you can imagine, editing the HOSTS file can easily break your internet if it’s modified incorrectly or maliciously. So, it’s not particularly easy for a normal user to edit. This is a good thing.\r
\r
- Windows\r
\r
The HOSTS file is normally stored in a plain text file in the Windows System folder.\r
\r
Hit the start menu or press the Windows key and start typing Notepad.\r
\r
Right-click Notepad and choose Run as administrator.\r
\r
In Notepad, click File then Open… In the File name field, paste the following path in:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Now you’ll be able to edit and save changes to your HOSTS file.\r
\r
To map a domain, add a line based on the examples in the HOSTS file.\r
\r
- OS X & GNU/Linux\r
\r
The file is in /etc/hosts and you should edit it with administrator privileges.\r
\r
\`\`\`bash\r
# Add the following lines to the hosts file\r
## At school\r
##  - use your computer IP for the 'cliente' and 'servidor' entries.\r
##  - use the teacher's computer IP as the 'profesor' entry\r
## At home (IP address can change and probably will be something like 192.168.X.X)\r
##  - use your computer IP for the 'cliente', 'servidor' and 'profesor' entries.\r
\r
# In all the activities, we will always use these domain names \r
# making our apps work at home and at school without having to change any IP address.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.4 Servidor multihilo\r
\r
Si queremos que un servidor pueda atender varias peticiones de forma simultanea, debemos usar hilos para dotarle de esa capacidad.\r
\r
El flujo básico ahora cambiaría para adaptarse a este formato\r
\r
\`\`\`\r
while (true) {\r
\r
    Aceptar la conexión obteniendo un objeto de la clase Socket;\r
\r
    Crear un thread para que se encargue de la comunicación con ese cliente, es decir, \r
    para que gestione el socket obtenido en el accept.;\r
}\r
\`\`\`\r
![Estados de un servidor multihilo](../../media/unit4/multithread_server_states.png)\r
\r
El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexión de nuevos clientes con los que volverá a hacer lo mismo.\r
\r
El servidor multihilo se ayuda de una clase \`Worker\` que hereda de Thread, pudiendo así ejecutarse concurrentemente con el hilo principal.\r
\r
Esta clase \`Worker\` es la encargada de realizar toda la comunicación con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe  la conexión de un cliente \`ServerSocket.accept()\`.\r
\r
\`\`\`java {6,20,24}\r
public static final int PORT = 4444;\r
public static void main(String[] args)  {\r
    // Establece el puerto en el que escucha peticiones\r
    ServerSocket socketServidor = null;\r
    try {\r
        socketServidor = new ServerSocket(PORT);\r
    } catch (IOException e) {\r
        System.out.println("No puede escuchar en el puerto: " + PORT);\r
        System.exit(-1);\r
    }\r
\r
    Socket socketCliente = null;\r
\r
    System.out.println("Escuchando: " + socketServidor);\r
    try {\r
        \r
        while (true) {\r
            // Se bloquea hasta que recibe alguna petición de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexión aceptada: " + socketCliente);\r
            // Para seguir aceptando peticiones de otros clientes\r
            // se crea un nuevo hilo que se encargará de la comunicación con el cliente\r
            new Worker(socketCliente).start();\r
        }\r
                        \r
    ...\r
}    \r
\`\`\`\r
\r
Y esta sería una implementación estándar de un worker\r
\r
\`\`\`java{13,15,22,26}\r
public class Worker extends Thread {\r
\r
    private Socket socketCliente;\r
    private BufferedReader entrada = null;\r
    private PrintWriter salida = null;\r
\r
    ....\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Realizamos la comunicación entre servidor y cliente\r
            // **** ES LO QUE CAMBIA EN CADA EJERCICIO ****\r
\r
            // Hacemos una recepción de información desde el cliente\r
            String mensajeRecibido = entrada.readLine();\r
            System.out.println("<-- Cliente: " + mensajeRecibido);\r
            \r
            // Hacemos un envío al cliente\r
            String mensajeEnviado = "Mensaje enviado desde el servidor al cliente";\r
            salida.println(mensajeEnviado);\r
            System.out.println("--> Cliente: " + mensajeEnviado);\r
        }\r
        ....\r
}        \r
\`\`\`\r
\r
Quedando ahora la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/multithread_server_sequence.png)\r
\r
<div class="pagebreak"> </div>\r
\r
::: info Ejecución de múltiples clientes desde línea de comandos\r
Para poder lanzar varias aplicaciones java a la vez, la forma más correcta de hacerlo es desde una terminal de comandos. Esto nos permite poder pasarle argumentos a todas las clases, no sólo a la que está marcada como *principal* en el proyecto.\r
\r
Aquí tenemos dos posibilidades, **ejecutar las clases individualmente**, tal y como hacemos desde el IDE o bien **lanzar las clases desde un archivo JAR**.\r
\r
En ambos casos, necesitamos haber compilado y construido el proyecto (*F11 ó Shift+F11 en Netbeans*).\r
\r
Ejecución de clases individuales\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener las clases compiladas.\r
- A continuación, al igual que hacíamos con los procesos, debemos ubicarnos en la carpeta \`build/classes\` del proyecto.\r
- Desde ahí, ejecutaremos\r
    > build/classes$ java psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuación del nombre de la clase son los parámetros que la clase recibirá en el args[] de su método main.\r
\r
    y para la clase o clases que no sean las principales\r
    > build/classes$ java psp.actividades.U4AX_ClaseSCliente localhost 5566\r
\r
    Si queremos lanzar más de un cliente, repetiremos el comando desde otra ventana de comandos.\r
\r
Lanzar las clases desde un archivo JAR\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener el proyecto construido\r
- A continuación, y a diferencia del caso anterior, debemos ubicarnos en el directorio donde esté el archivo JAR. Si no lo hemos movido, estará en la carpeta \`dist\` del proyecto.\r
- Desde ahí, ejecutaremos, **para la clase principal del proyecto**\r
    > dist$ java -jar U4AX_ProyectoClienteServidor.jar 5566\r
\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuación del nombre de la clase son los parámetros que la clase recibirá en el args[] de su método main.\r
\r
    y para la clase o clases que no sean las principales\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseCliente localhost 5566\r
\r
    Si queremos lanzar más de un cliente, repetiremos el comando desde otra ventana de comandos.\r
:::\r
`]},{title:"4.3 UDP Sockets",headers:[{level:2,title:"4.3.1. Client/Server communication using UDP sockets",slug:"_4-3-1-client-server-communication-using-udp-sockets",link:"#_4-3-1-client-server-communication-using-udp-sockets",children:[{level:3,title:"DatagramSocket",slug:"datagramsocket",link:"#datagramsocket",children:[]},{level:3,title:"DatagramPacket",slug:"datagrampacket",link:"#datagrampacket",children:[]},{level:3,title:"Programación de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.3.2. Cliente UDP",slug:"_4-3-2-cliente-udp",link:"#_4-3-2-cliente-udp",children:[]},{level:2,title:"4.3.3 Servidor UDP",slug:"_4-3-3-servidor-udp",link:"#_4-3-3-servidor-udp",children:[]},{level:2,title:"4.3.4 Multicast socket",slug:"_4-3-4-multicast-socket",link:"#_4-3-4-multicast-socket",children:[]}],path:"/en/unit4/sockets-udp.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.3 UDP Sockets\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.3 UDP Sockets" />\r
\r
# 4.3 UDP Sockets\r
\r
[[toc]]\r
\r
## 4.3.1. Client/Server communication using UDP sockets\r
\r
Igual que en el apartado anterior, Oracle proporciona una guía son información básica sobre el uso de los Sockets UDP. De nuevo, todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about datagrams](https://docs.oracle.com/javase/tutorial/networking/datagrams/index.html)\r
\r
::: info UDP - Protocolo sin conexión\r
El protocolo de comunicaciones con \`datagramas\` UDP, es un protocolo sin conexión, es decir, cada vez que se envíen datagramas es necesario enviar el descriptor del socket local y la dirección del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicación.\r
\r
Se trata de un servicio de transporte sin conexión. Son más eficientes que TCP, pero no está garantizada la fiabilidad: los datos se envían y reciben en paquetes, cuya entrega no está garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envió.\r
:::\r
\r
La interfaz Java que da soporte a sockets TCP está constituida por las clases **DatagramPacket** y **DatagramSocket**.\r
\r
- DatagramSocket: es la clase utilizada para realizar el envío y la recepción de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexión, sólo se encarga de transportar los datos del origen al destino.\r
\r
    Lo único que se hace es enviar los datos, mediante la creación de un socket y utilizando los métodos de envío y recepción apropiados.\r
\r
    Esta clase proporciona los métodos \`send\` y \`receive\`.\r
\r
- DatagramPackets: esta clase es la encargada de incluir la información que se quiere enviar/recibir y la información de direccionamiento, es decir, la dirección a la que se quiere enviar l información que contiene.\r
  \r
   DatagramPacket contiene la información relevante. Cuando se desea recibir un datagrama, éste deberá almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no sólo debe tener la información, sino que además debe tener la dirección IP y el puerto de destino.\r
\r
::: warning Puertos duplicados UDP / TCP\r
Dado que la gestión de los puertos y el protocolo que se utiliza es diferente, podemos usar el mismo número de puerto para un servicio que use el protocolo TCP y otro servicio, en el mismo puerto, que use UDP.\r
\r
En realidad, un socket además de IP_origen, Puerto_origen, IP_destino, Puerto_destino, también incluye el protocolo usado, por eso un socket con el mismo origen y destino, es diferente y puede ser usado a al vez por UDP y TCP\r
\r
**Socket = [Protocolo (TCP/UDP) + IP_origen + Puerto_origen + IP_destino + Puerto_destino]**\r
:::\r
\r
### DatagramSocket\r
\r
Esta clase proporciona los siguiente métodos\r
\r
| Método | Descripción |\r
| --- | ----------- |\r
| public DatagramSocket () throws SocketException | Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible. |\r
| public DatagramSocket (int port) throws SocketException | Ídem, pero con la salvedad de que permite especificar el número de puerto asociado. |\r
| public DatagramSocket (int port, InetAddress ip) throws SocketException | Permite especificar, además del puerto, la dirección local a la que se va a asociar el socket. |\r
| public int getLocalPort() | Retorna el número de puerto en el host local al que está conectado el socket. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Envía un DatagramPacket a través del socket. |\r
| **public setSoTimeout(int timeout)** | Permite establecer un tiempo de espera límite para que el método receive se quede bloqueado esperando a recibir una respuesta por parte del otro extremo. Si no reciben datos en el tiempo fijado se lanza la excepción \`InterruptedIOException\` |\r
\r
El DatagramSocket, cuando se utiliza en la parte receptora (la que vamos a llamar servidora) que ofrece el servicio para que los clientes se conecten, sólo va a indicar el puerto al que esos clientes deben enviar sus solicitudes. En el caso de los procesos que actúen como clientes, se usará el constructor sin parámetros para que sea el SO el que asigne un puerto libre.\r
\r
Por lo tanto, un mismo DatagramSocket al no incluir ninguna información de direccionamiento puede ser reutilizado para enviar y/o recibir datagramas a/desde diferentes destinos.\r
\r
### DatagramPacket\r
\r
La clase \`DatagramPacket\` como se ha indicado anteriormente, es un contenedor del mensaje y del destino de ese mensaje.\r
\r
![Datagram Packet](../../media/unit4/datagrampacket.svg)\r
\r
Esta clase proporciona los siguiente métodos\r
\r
| Método | Descripción |\r
| --- | ----------- |\r
| public DatagramPacket(byte ibuf[], int  ilength)  | Implementa un DatagramPacket para la **recepción** de paquetes de longitud ilength, siendo el valor de este parámetro menor o igual que ibuf.length. |\r
| public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)  | Implementa un DatagramPacket para el **envío** de paquetes de longitud ilength al número de puerto especificado en el parámetro iport, del host especificado en la dirección de destino que se le pasa por medio del parámetro iaddr. |\r
| public InetAddress getAddress () | Retorna la dirección IP del host al cual se le envía el datagrama o del que el datagrama se recibió. |\r
| public byte[] getData() | Retorna los **datos a recibir** o a enviar. |\r
| public int getLength() | Retorna la longitud de los datos a enviar o a recibir. |\r
| public int getPort() | Retorna el número de puerto de la máquina remota a la que se le va a enviar el datagrama o del que se recibió. |\r
\r
Como se intuye de la descripción de los métodos, la forma de crear el datagrama va a depender de si queremos enviar o recibir la información, ya que en cada uno de estas acciones tendremos que indicar dónde van dirigidos esos datos (envío) o bien esa información ya vendrá incluida en el datagrama (recepción) y podremos acceder a ella a través de los métodos getter de la clase.\r
\r
Es importante hacer ver que la información debe enviarse como un array de bytes y que se recibe de la misma forma, por lo que tendremos que usar los métodos de String o de cualquiera de los otros tipos primitivos de Java para convertirlos a bytes.\r
\r
### Programación de aplicaciones Cliente y/o Servidor\r
\r
En el caso de aplicaciones UDP, el protocolo de comunicación no tiene sentido a nivel de capa de transporte, ya que sólo se envían y reciben mensajes y hablamos de un \`protocolo no orientado a conexión\`, por lo tanto no sirve para realizar confirmaciones o diálogos entre la parte servidora y cliente.\r
\r
La parte del protocolo se delega en una capa superior, que será la encargada de gestionar la comunicación a un nivel de abstracción mayor.\r
\r
De todas formas, la comunicación entre ambas partes debe seguir estando sincronizada en los que a envíos / respuestas se refiere para no dejar a la otra parte bloqueada en las lecturas.\r
\r
::: info Bloqueo de lecturas con timeout\r
Esta característica, también disponible para los sockets TCP, permite evitar un bloqueo infinito de un hilo a la espera de recibir datos del otro extremo del socket.\r
\r
Es de especial importancia en la gestión de las comunicaciones UDP ya que, como hemos dicho, no tienen porqué seguir un protocolo preestablecido a nivel de transporte.\r
\r
Con el método \`setSoTimeout\` de DatagramSocket podemos fijar un tiempo de espera máximo para la recepción de datos a través del socket.\r
:::\r
\r
## 4.3.2. Cliente UDP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente será:\r
\r
1. El cliente creará un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.\r
2. Utilizará el método send() del socket para enviar la petición en forma de datagrama.\r
    - La información se envia en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
3. Permanece a la espera de recibir respuesta\r
4. El cliente recibe la respuesta del servidor mediante el método receive() del socket.\r
    - La información se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
5. Cerrar y liberar los recursos.\r
\r
\`\`\`java{10,14,17,20,28,31}\r
public class BasicUDP_Client {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // IP y puerto al que se envía el Datagrama\r
        InetAddress destino = InetAddress.getLocalHost();\r
        int port = 12345; \r
        \r
        // Buffer para recibir el datagrama\r
        byte[] buffer = new byte[1024];\r
        \r
        // El mensaje a enviar en el Datagrama se convierte a bytes\r
        String mensajeEnviado = "Enviando Saludos !!";\r
        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\r
\r
        // Se preparara el DatagramPacket que se va a enviar\r
        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\r
        // En este caso, especificamos un puerto, aunque podríamos dejarlo para\r
        // que el SO asigne uno libre\r
        DatagramSocket socket = new DatagramSocket(34567);\r
        \r
        System.out.println("Host destino : " + destino.getHostName());\r
        System.out.println("IP Destino : " + destino.getHostAddress());\r
        System.out.println("Puerto local del socket: " + socket.getLocalPort());\r
        System.out.println("Puerto al que envio: " + datagramaEnviado.getPort());\r
\r
        // Envío del Datagrama\r
        socket.send(datagramaEnviado);\r
        \r
        // Cierre y liberación de recursos       \r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.3 Servidor UDP\r
\r
En los sockets UDP no se establece conexión. A pesar de que cuando los programamos sí existen diferencias entre el servidor y el cliente, estas no son tan claras como con los sockets TCP. La funcionalidad y el código que diferencia a un servidor de un cliente está más diluido.\r
\r
> Podemos considerar servidor al que espera un mensaje y responde; y cliente al que inicia la comunicación.\r
\r
Tanto uno como otro si desean ponerse en contacto necesitan saber en qué ordenador y en qué puerto está escuchando el otro.\r
\r
1. El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.\r
2. Permanece a la espera de recibir peticiones.\r
3. El servidor recibe las peticiones mediante el método receive() del socket.\r
    - La información se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
4. En el datagrama recibido va incluido además del mensaje, el puerto y la IP del cliente emisor de la petición; lo que le permite al servidor conocer la dirección del emisor del datagrama. Utilizando el método send() del socket puede enviar la respuesta al cliente emisor.\r
5. El servidor permanece a la espera de recibir más peticiones.\r
6. Cerrar y liberar los recursos.\r
\r
\`\`\`java{6,10,18,20,21,33}\r
public class BasicUDP_Server {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // Buffer para recibir el datagrama\r
        byte[] bufer = new byte[1024];\r
\r
        // El Socket del servidor se asocia a un puerto para que los clientes\r
        // puedan enviar peticiones.\r
        DatagramSocket socket = new DatagramSocket(12345);\r
\r
        // Se espera la llegada de un DATAGRAMA\r
        // Al igual que con TCP, esta llamada a receive es bloqueante\r
        // y es la que tiene que marcar la sincronización entre lecturas y \r
        // escrituras de las app cliente / servidor\r
        System.out.println("Esperando Datagrama ................");\r
        // Se crea el objeto que almacenará el mensaje enviado por el cliente\r
        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\r
        // Se espera el mensaje y se le pasa el datagrama para que lo almacene ahí\r
        socket.receive(datagramaRecibido);\r
        String mensajeRecibido = new String(datagramaRecibido.getData());\r
\r
        //Información recibida\r
        System.out.println("Número de Bytes recibidos: " + datagramaRecibido.getLength());\r
        System.out.println("Contenido del Paquete    : " + mensajeRecibido.trim());\r
\r
        System.out.println("Puerto origen del mensaje: " + datagramaRecibido.getPort());\r
\r
        System.out.println("IP de origen             : " + datagramaRecibido.getAddress().getHostAddress());\r
        System.out.println("Puerto destino del mensaje:" + socket.getLocalPort());\r
\r
        // Liberamos los recursos\r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor UDP](../../media/unit4/udp_process.png)\r
\r
Veamos ahora un ejemplo completo de C/S UDP\r
\r
\`\`\`java\r
public class BasicUDP_Client2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // FLUJO PARA ENTRADA ESTANDAR\r
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r
\r
        DatagramSocket clientSocket = new DatagramSocket();\r
        byte[] enviados = new byte[1024];\r
        byte[] recibidos = new byte[1024];\r
\r
        // DATOS DEL SERVIDOR al que enviar mensaje\r
        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\r
        int puerto = 9876; // puerto por el que escucha\r
\r
        // INTRODUCIR DATOS POR TECLADO\r
        System.out.print("Introduce mensaje: ");\r
        String cadena = in.readLine();\r
        enviados = cadena.getBytes();\r
\r
        // ENVIANDO DATAGRAMA AL SERVIDOR\r
        System.out.println("Enviando " + enviados.length + " bytes al servidor.");\r
        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\r
        clientSocket.send(envio);\r
\r
        // RECIBIENDO DATAGRAMA DEL SERVIDOR\r
        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\r
        System.out.println("Esperando datagrama....");\r
        clientSocket.receive(recibo);\r
        String mayuscula = new String(recibo.getData());\r
\r
        // OBTENIENDO INFORMACIÓN DEL DATAGRAMA\r
        InetAddress IPOrigen = recibo.getAddress();\r
        int puertoOrigen = recibo.getPort();\r
        System.out.println("\\tProcedente de: " + IPOrigen + ":" + puertoOrigen);\r
        System.out.println("\\tDatos: " + mayuscula.trim());\r
\r
        //cerrar socket\r
        clientSocket.close();\r
\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class BasicUDP_Server2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Puerto por el que escucha el servidor: 9876\r
        DatagramSocket serverSocket = new DatagramSocket(9876);\r
        byte[] recibidos = new byte[1024];\r
        byte[] enviados = new byte[1024];\r
        String cadena;\r
\r
        while (true) {\r
            System.out.println("Esperando datagrama.....");\r
\r
            //RECIBO DATAGRAMA\r
            recibidos = new byte[1024];\r
            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\r
            serverSocket.receive(paqRecibido);\r
            cadena = new String(paqRecibido.getData());\r
\r
            //DIRECCION ORIGEN\r
            InetAddress IPOrigen = paqRecibido.getAddress();\r
            int puerto = paqRecibido.getPort();\r
            System.out.println("\\tOrigen: " + IPOrigen + ":" + puerto);\r
            System.out.println("\\tMensaje recibido: " + cadena.trim());\r
\r
            //CONVERTIR CADENA A MAYÚSCULA\r
            String mayuscula = cadena.trim().toUpperCase();\r
            enviados = mayuscula.getBytes();\r
\r
            //ENVIO DATAGRAMA AL CLIENTE\r
            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\r
            serverSocket.send(paqEnviado);\r
\r
            // Condición de finalización\r
            if (cadena.trim().equals("*")) {\r
                break;\r
            }\r
\r
        }//Fin de while\r
\r
        serverSocket.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.4 Multicast socket\r
\r
La clase MulticastSocket es útil para enviar paquetes a múltiples destinos simultáneamente.\r
\r
Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo número de puerto.\r
\r
Cuando se envía un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibirán el mensaje.\r
\r
La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el número de miembros del grupo ni sus direcciones IP.\r
\r
::: info Grupo multicast\r
\r
Un grupo multicast se especifica mediante una dirección IP de clase D y un número de puerto UDP estándar.\r
\r
Las direcciones desde la 224.0.0.0 a la 239.255.255.255 están destinadas para ser direcciones de multicast.\r
\r
La dirección 224.0.0.0 está reservada y no debe ser utilizada.\r
:::\r
\r
Los métodos que proporciona la clase MulticastSocket son\r
\r
| Método | Descripción |\r
| --- | ----------- |\r
|  MulticastSocket() throws IOException  | Construye un socket multicast dejando al SO que asigne un puerto libre. |\r
|  MulticastSocket(int port) throws IOException  | Construye un socket multicast y lo conecta al puerto local especificado. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Envía un DatagramPacket a través del socket. |\r
| joinGroup( InetAddress multicastAddress) | Permite al socket unirse al grupo de multicast. A partir de ese momento podrá recibir los mensajes que se envían a esa dirección. Un MulticastSocket puede estar unido a más de un grupo multicast. |\r
| leaveGroup( InetAddress multicastAddress) | Permite al socket abandonar el grupo de multicast |\r
\r
Y a continuación presentamos el esquema de llamadas seguido por un **servidor multicast**\r
\r
1. Se crea el socket multicast. No hace falta especificar puerto\r
    > MulticastSocket ms = new MulticastSocket();\r
\r
2. Se define el puerto multicast\r
    > int Puerto = 12345;\r
\r
3. Se crea el grupo multicast\r
    > InetAddress grupo = InetAddress.getByName(“225.0.0.1”);\r
\r
4. Se crea el datagrama\r
    > DatagramPacket paquete = new DatagramPacket(msg.getBytes(), msg.length(), grupo, Puerto);\r
\r
5. Se envía el paquete al grupo\r
    > ms.send(paquete);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
y el esquema de llamadas seguido por un **cliente multicast**\r
\r
1. Se crea un socket multicast en el puerto establecido\r
    > MulticastSocket ms = new MulticastSocket(12345);\r
\r
2. Se configura la IP del grupo al que nos conectaremos\r
    > InetAddress grupo = InetAddress.getByName(“225.0.0.1”);\r
\r
3. Se une al grupo\r
    > ms.joinGroup(grupo);\r
\r
4. Recibe el paquete del servidor multicast\r
\r
    > byte[] buf = new byte[1000];\r
DatagramPacket recibido = new DatagramPacket(buf, buf.length);\r
ms.receive(recibido);\r
\r
5. Salimos del grupo multicast:\r
    > ms.leaveGroup(grupo);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
Y ahora lo vemos todo junto con un ejemplo\r
\r
\`\`\`java\r
public class U4_BasicMulticastServer {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // Enviamos la información introducida por teclado hasta que se envíe un *        \r
        Scanner in = new Scanner(System.in);\r
\r
        //Se crea el socket multicast.\r
        MulticastSocket ms = new MulticastSocket();\r
        // Se escoge un puerto para el server\r
        int puerto = 12345;\r
        // Se escoge una dirección para el grupo\r
        InetAddress grupoMulticast = InetAddress.getByName("225.0.0.1");\r
\r
        String cadena = "";\r
        while (!cadena.trim().equals("*")) {\r
\r
            System.out.print("Datos a enviar al grupo: ");\r
            cadena = in.nextLine();\r
\r
            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\r
            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\r
            ms.send(paquete);\r
        }\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class U4_BasicMulticastClient {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Se crea el socket multicast\r
        // El puerto debe ser el mismo en todos los clientes, ya que el \r
        // servidor multicast envía la información a la IP multicast y a un puerto\r
        int puerto = 12345;//Puerto multicast\r
        MulticastSocket ms = new MulticastSocket(puerto);\r
\r
        //Nos unimos al grupo multicast\r
        InetAddress grupo = InetAddress.getByName("225.0.0.1");\r
        ms.joinGroup(grupo);\r
        String msg = "";\r
\r
        while (!msg.trim().equals("*")) {\r
            // El buffer se crea dentro del bucle para que se sobrescriba \r
            // con cada nuevo mensaje\r
            byte[] buf = new byte[1000];\r
            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\r
            //Recibe el paquete del servidor multicast\r
            ms.receive(paquete);\r
            msg = new String(paquete.getData());\r
            System.out.println("Recibo: " + msg.trim());\r
        }\r
\r
        // Abandonamos grupo\r
        ms.leaveGroup(grupo);\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
::: info mezcla de sockets en una app\r
Ya hemos visto todo el abanico de posibilidades que tenemos para comunicar dos procesos en red.\r
\r
A partir de este momento, en nuestras aplicaciones no sólo tenemos que elegir uno de ellos, sino que podemos tener varios sockets, de diferente tipo, para comunicar los clientes y los servidores.\r
\r
Se trata ahora de analizar en qué situación es más conveniente un tipo que otro y usarlo. Podemos ayudarnos de la creación de hilos que estén "especializados" en el envío y/o recepción de información de un socket, permitiendo que se intercambien varios mensajes a la vez.\r
:::\r
`]},{title:"4.4 Stateful protocols",headers:[{level:2,title:"4.4.1. Stateful and stateless protocols",slug:"_4-4-1-stateful-and-stateless-protocols",link:"#_4-4-1-stateful-and-stateless-protocols",children:[{level:3,title:"Stateless protocols",slug:"stateless-protocols",link:"#stateless-protocols",children:[]},{level:3,title:"Stateful protocols",slug:"stateful-protocols",link:"#stateful-protocols",children:[]}]},{level:2,title:"4.4.2 Programación de servidores basados en estados",slug:"_4-4-2-programacion-de-servidores-basados-en-estados",link:"#_4-4-2-programacion-de-servidores-basados-en-estados",children:[{level:3,title:"Programación de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.4.3. Ejemplo de servidor con estados",slug:"_4-4-3-ejemplo-de-servidor-con-estados",link:"#_4-4-3-ejemplo-de-servidor-con-estados",children:[{level:3,title:"Ejemplo del Worker que implementa el protocolo",slug:"ejemplo-del-worker-que-implementa-el-protocolo",link:"#ejemplo-del-worker-que-implementa-el-protocolo",children:[]}]},{level:2,title:"4.4.4. Ejemplo de cliente con estados",slug:"_4-4-4-ejemplo-de-cliente-con-estados",link:"#_4-4-4-ejemplo-de-cliente-con-estados",children:[{level:3,title:'Ejemplo de cliente "genérico" que implementa el protocolo',slug:"ejemplo-de-cliente-generico-que-implementa-el-protocolo",link:"#ejemplo-de-cliente-generico-que-implementa-el-protocolo",children:[]}]}],path:"/en/unit4/stateful-protocols.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.4 Stateful protocols\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.4 Stateful protocols" />\r
\r
# 4.4 Stateful protocols\r
\r
[[toc]]\r
\r
## 4.4.1. Stateful and stateless protocols\r
\r
Como ya hemos comentado anteriormente, un protocolo, aplicado al mundo de las comunicaciones informáticas, es un conjunto de reglas que especifican la manera en la que se realiza la comunicación entre dos interlocutores.\r
\r
Este conjunto de reglas establece el formato de los mensajes que se intercambian \`(texto, binario, JSON, XML, CSV, ...)\`, las acciones que cada uno de los extremos de la comunicación deben realizar en cada momento \`(envío o recepción)\` y, lo que nos ocupa en este apartado del tema, si las acciones dependen de acciones anteriores o no.\r
\r
### Stateless protocols\r
\r
En informática, un protocolo sin estado es un protocolo de comunicaciones que trata cada petición como una transacción independiente que no tiene relación con cualquier solicitud anterior, de modo que la comunicación se compone de pares independientes de solicitud y respuesta.\r
[Wikipedia: Protocolo sin estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)\r
\r
El ejemplo más conocido de protocolo sin estado es HTTP.1​ El protocolo no proporciona medio alguno de almacenamiento de datos de un usuario entre las peticiones, dejando esta tarea a niveles superiores y haciendo necesario el reenvío de información de manera continua para simular un funcionamiento con estado (cookies, cabeceras, etc.).\r
\r
### Stateful protocols\r
\r
Un protocolo sin estado no requiere que el servidor retenga información de la sesión o de estado acerca de los intercambios de información durante la realización de múltiples peticiones. En contraste, un protocolo que requiere el mantenimiento del **estado interno en el servidor** se conoce como un **protocolo con estado**.\r
\r
Por lo tanto, un estado es una configuración en un programa o máquina que depende de los estados anteriores y que determina el funcionamiento del sistema, en función de la entrada recibida y del estado actual en el que se encuentre el sistema.\r
\r
Poniendo una analogía, podemos tomar una solicitud a la administración, donde debemos realizar varios pasos hasta resolver la solicitud.\r
\r
1. En primer lugar se rellena una instancia con los datos y se envía al departamento correspondiente.\r
2. Ese departamento comprobará la instancia recibida y contestará solicitando información adicional o confirmando que la solicitud se ha recibido correctamente.\r
3. En un proceso posterior, se solicita un pago de tasas al usuario.\r
4. El usuario tiene que realizar el pago de tasas y enviar el justificante.\r
5. Tras cotejar toda la información, se le solicita al usuario que aporte los documentos originales.\r
6. El usuario se persona para mostrar la documentación original\r
7. Finalmente se resuelve la solicitud informando al usuario el resultado de la misma.\r
\r
Esto, que puede ser un procedimiento normal, refleja claramente un proceso en el que se siguen una serie de pasos y cuyo orden no se puede cambiar.\r
\r
Por ejemplo, no tendría sentido hacer el pago de las tasas (paso 4) sin antes haber presentado la solicitud (paso 1) o sin haber recibido la confirmación de que la solicitud está completa.\r
\r
Esto mismo pasa con algunos protocolos de comunicación.\r
\r
## 4.4.2 Programación de servidores basados en estados\r
\r
Hay toda una teoría matemática, \`la teoría de grafos\`, desarrollada en torno a esto, junto con un modelo computacional, \`los autómatas finitos\`, que estudian y optimizan el desarrollo de aplicaciones basadas en estados.\r
\r
La teoría de grafos es una rama de las matemáticas y las ciencias de la computación que estudia las propiedades de los grafos\r
\r
La teoría de grafos tiene sus fundamentos en las \`matemáticas discretas\` y de las \`matemáticas aplicadas\`. Esta teoría requiere de diferentes conceptos de diversas áreas como **combinatoria, álgebra, probabilidad, geometría de polígonos, aritmética y topología**. Actualmente ha tenido mayor influencia en el campo de la informática, las ciencias de la computación y telecomunicaciones. Debido a la gran cantidad de aplicaciones en la optimización de recorridos, procesos, flujos y algoritmos de búsquedas, entre otros\r
\r
Un autómata finito o máquina de estado finito es un modelo computacional que toma decisiones de computación de forma automática sobre una entrada para producir una salida.\r
\r
Este modelo está conformado por un alfabeto, un conjunto de estados finito, una función de transición, un estado inicial y un conjunto de estados finales.\r
\r
La finalidad de los autómatas finitos, entre otras, es la de reconocer lenguajes regulares, que corresponden a los lenguajes formales más simples según la Jerarquía de Chomsky.\r
\r
### Programación de aplicaciones Cliente y/o Servidor\r
\r
Como en todos los casos que hemos estudiado con anterioridad, el protocolo es la pieza común entre los clientes y los servidores.\r
\r
Nuestros clientes podrán estar bien o mal programados, de hecho muchos de nuestros clientes son interactivos, por lo que podemos alterar el orden de los comandos a nuestro antojo, no siendo esto ningún problema.\r
\r
Debe ser el servidor el que tenga el control del proceso, el que asegure la integridad del sistema y de los datos, por lo tanto va a ser en la parte del servidor donde tengamos que realizar las modificaciones para adaptarlo al control y gestión de los estados.\r
\r
Esto no quita que los clientes deban seguir \`sincronizados\` con el servidor para evitar situaciones de interbloqueo, ya que de una forma u otra el cliente siempre debe seguir el protocolo, aunque no los estados tal y como hemos dicho.\r
\r
## 4.4.3. Ejemplo de servidor con estados\r
\r
Vamos a ver qué pasos debemos seguir para controlar los estados en el servidor y cómo adaptar un cliente.\r
\r
El ejemplo que vamos a utilizar es el de la actividad  \`U4A03_ProtocoloSaludo\`. Primero vamos a aclarar cómo debe funcionar este protocolo.\r
\r
Si el cliente está bien programado, el intercambio de información entre Cliente y Servidor se realiza en tres pasos\r
\r
1. Cliente envía "Hi Server!"\r
2. Servidor responde "Hi Client!"\r
3. Cliente responde "By Server!"\r
\r
Ante un funcionamiento normal, este protocolo es bastante fácil de implementar. Sin embargo,\r
\r
- ¿Qué pasa si el cliente envía "By Server!" como primer mensaje?\r
- ¿Qué debe responder el servidor si no recibe el mensaje que está esperando?\r
- ¿Qué debe hacer el cliente si no recibe el mensaje que está esperando?\r
\r
Estas son las circunstancias a las que debemos responder con los estados del protocolo, indicando en cada caso qué debe hacer cada una de las partes. Todo dependerá de la funcionalidad que esté implementando el protocolo.\r
\r
Cada caso es diferente, por ejemplo, si es importante hacer los tres pasos en orden, ante cualquier fallo se debe volver a empezar (un borrado en una BD, una autenticación de tres vías). Si por el contrario, los dos primeros pasos se tienen que realizar de forma conjunta, pero el tercero es independiente, si el incumplimiento del protocolo se produce en ese momento, no es necesario que se repitan los dos primeros pasos, sino que sólo será necesario repetir el último.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Estado Hi\\nEsperando al saludo\r
    Bye: Estado Bye\\nEsperando la despedida\r
    [*] -> Hi\r
    Hi -> Hi : Mensaje incorrecto\\nSe envía error al cliente\r
    Hi -> Bye : Se ha recibido el mensaje correcto\\nSe envía respuesta al cliente\r
    note left of Hi : Permanecemos en este estado\\nhasta que se reciba el mensaje correcto\r
    Bye -> Hi : Mensaje incorrecto\\nSe envía error al cliente\r
    Bye -> [*] : Se ha recibido el mensaje correcto\\nSe cierra la conexión con el cliente\r
-->\r
\r
### Ejemplo del Worker que implementa el protocolo\r
\r
\`\`\`java{12,17,34,50,61,71}\r
public class U4A03_SaludoWorker extends Thread {\r
\r
    Socket socketCliente;\r
    BufferedReader entrada;\r
    PrintWriter salida;\r
\r
    private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\r
    U4A03_SaludoWorker(Socket socketCliente) {\r
        this.socketCliente = socketCliente;\r
        // Inicializamos el valor del estado al estado inicial\r
        estado = Estados.HI;\r
    }\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Recibe lo que envía el cliente hasta que el mensaje sea\r
            // END OF TRANSMISSION\r
            while (estado != Estados.END) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
\r
                // Comprobamos si se ha cerrado el extremo cliente del socket\r
                // Y damos por concluida la comunicación.\r
                if (str == null) {\r
                    estado = Estados.END;\r
                } else {\r
                    // Mostramos la información recibida por consola\r
                    System.out.println("CLIENTE > " + str);\r
                }\r
\r
                // Controlamos la respuesta en función del mensaje recibido y \r
                // el estado actual\r
                switch (estado) {\r
                    case HI:\r
                        if (messages[0].equals(str)) {\r
                            // Enviamos respuesta al cliente\r
                            salida.println(messages[1]);\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.BYE;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                        }\r
                        break;\r
                    case BYE:\r
                        if (messages[2].equals(str)) {\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.END;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                            estado = Estados.HI;\r
                        }\r
                        break;\r
                    case END:\r
                        // No sería necesario contemplarlo en este caso\r
                        // Pero sí en otros en los que se tenga que enviar \r
                        // algún mensaje antes de salir.\r
                        break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("Error de comunicación con el cliente");\r
        } catch (Exception e) {\r
            System.out.println(e.getLocalizedMessage());\r
            e.printStackTrace();\r
        } finally {\r
            try {\r
                entrada.close();\r
                System.out.println("Conexión cerrada: " + socketCliente);\r
                socketCliente.close();\r
            } catch (IOException e) {\r
                System.out.println("Error inesperado cerrando los recursos");\r
            }\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El código corresponde al worker de un servidor multihilo. Analicemos ahora el código por partes\r
\r
Es recomendable usar propiedades para guardar los mensajes que queramos comparar y tener un ENuM para definir los estados. Los \`enum\` en Java permiten ser usados en los bloques switch-case.\r
\r
La propiedad **estado** va a ser el punto central que controle el flujo de ejecución del servidor.\r
\r
\`\`\`java:no-line-numbers {6}\r
private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\`\`\`\r
\r
En el constructor, además de todas las propiedades, inicializamos el estado, asignándole el valor del estado inicial.\r
\r
\`\`\`java:no-line-numbers{4}\r
U4A03_SaludoWorker(Socket socketCliente) {\r
    this.socketCliente = socketCliente;\r
    // Inicializamos el valor del estado al estado inicial\r
    estado = Estados.HI;\r
}\r
\`\`\`\r
\r
El servidor estará ejecutándose hasta que se alcance el estado final\r
\r
\`\`\`java:no-line-numbers\r
// Recibe lo que envía el cliente hasta que el mensaje sea\r
// END OF TRANSMISSION\r
while (estado != Estados.END) {\r
\`\`\`\r
\r
En este ejemplo, el intercambio de información con el cliente se hace uno a uno, es decir se recibe un mensaje y se envía una respuesta, pero no tiene porqué ser así, se pueden recibir varios mensajes y no enviar respuesta, o cualquier combinación de envío respuesta que nos imaginemos.\r
\r
El código que sigue e un control para saber si el cliente ha cerrado el socket, así evitamos tener excepciones de tipo NullPointerException o dejar al servidor en un bucle infinito. Forzamos la salida cambiando el estado del protocolo.\r
\r
\`\`\`java:no-line-numbers{4}\r
// Comprobamos si se ha cerrado el extremo cliente del socket\r
// Y damos por concluida la comunicación.\r
if (str == null) {\r
    estado = Estados.END;\r
} else {\r
    // Mostramos la información recibida por consola\r
    System.out.println("CLIENTE > " + str);\r
}\r
\`\`\`\r
\r
Este es el código que implementa el diagrama de estados que he diseñado para esta actividad.\r
Fijaos que el servidor tiene que realizar una comprobación para cada línea que sale de un estado. En este caso al ser sólo dos líneas, sirve con un if-else, pero puede ser un número mayor de opciones.\r
\r
Además, una de las opciones tiene un comportamiento totalmente diferente al resto, ya que **cuando se recibe el mensaje final, el protocolo no dice que enviemos una respuesta al cliente**.\r
\r
Esto \`debemos controlarlo en el cliente\`, porque si lo programamos de forma que envíe un mensaje y espere una respuesta, puede quedarse bloqueado en la lectura. Aprovechando que este es el último mensaje, más adelante veremos cómo se ha solventado en el cliente.y las opciones que tenemos para evitar posibles bloqueos como este.\r
\r
\`\`\`java:no-line-numbers{16}\r
// Controlamos la respuesta en función del mensaje recibido y \r
// el estado actual\r
switch (estado) {\r
    case HI:\r
        if (messages[0].equals(str)) {\r
            // Enviamos respuesta al cliente\r
            salida.println(messages[1]);\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.BYE;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
        }\r
        break;\r
    case BYE:\r
        if (messages[2].equals(str)) {\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.END;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
            estado = Estados.HI;\r
        }\r
        break;\r
    case END:\r
        // No sería necesario contemplarlo en este caso\r
        // Pero sí en otros en los que se tenga que enviar \r
        // algún mensaje antes de salir.\r
        break;\r
}\r
\`\`\`\r
\r
## 4.4.4. Ejemplo de cliente con estados\r
\r
Aunque un cliente interactivo como los que usamos para las pruebas no deberían cambiar su funcionalidad, sí hay que hacer pequeños ajustes para adaptar su funcionamiento a las posibles respuestas y errores que envía el servidor.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/client_sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Envío mensaje\r
    Bye: Recibo mensaje\r
    [*] -> Hi\r
    Hi -> Bye : Se envía un mensaje\\nSe espera la respuesta del servidor\r
    Bye -> Hi : Se muestra la respuesta del servidor\r
    note left of Hi : Se envían mensajes\\nmientras el servidor mantenga\\nla conexión abierta   \r
    Hi -> [*] : Se ha detectado el cierre\\nde la conexión con el servidor\r
-->\r
\r
Como ya hemos dicho en el código del servidor, si implementamos el protocolo como un cliente de envío-respuesta, hay un caso en el que no debemos esperar una respuesta. Este es el caso de la salida, en la que se envía un mensaje pero no esperamos respuesta por parte del servidor.\r
\r
Se puede pensar en poner una condición de salida para cuando el cliente envía el último mensaje, pero no podemos asegurar que ese mensaje cerrará la comunicación, porque dependerá del estado en el que se encuentre el servidor.\r
\r
### Ejemplo de cliente "genérico" que implementa el protocolo\r
\r
\`\`\`java{39,41}\r
public class U4A03_SaludoClient {\r
\r
    private static final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que está en la misma máquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket(args[0], Integer.parseInt(args[1]));\r
\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexión");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenvía al servidor hasta que se envía \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
            // Recibe la respuesta del servidor por el InputStream\r
            linea = entrada.readLine();\r
            if (linea == null) {\r
                // Comprobamos si se ha cerrado el extremo servidor del socket\r
                // Y damos por concluida la comunicación.\r
                break;\r
            } else {\r
                // Envía a la salida estándar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            }\r
        } while (true);\r
\r
        // Libera recursos\r
        salida.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\`\`\`\r
\r
El código corresponde a un cliente interactivo genérico, que va enviando mensajes y esperando la respuesta de los mismos sin hacer ningún tipo de control sobre lo que se envía o lo que recibe.\r
\r
Analicemos algunos aspectos del código del cliente\r
\r
La parte que sigue es equivalente a la que hemos usado en el servidor. No modificamos el flujo envío-recepción, pero sí que comprobamos si el lado del servidor ha cerrado el socket (ha realizado todo el protocolo correctamente) para decidir que el cliente finalice su ejecución.\r
\r
\`\`\`java:no-line-numbers{3}\r
// Recibe la respuesta del servidor por el InputStream\r
linea = entrada.readLine();\r
if (linea == null) {\r
    // Comprobamos si se ha cerrado el extremo servidor del socket\r
    // Y damos por concluida la comunicación.\r
    break;\r
} else {\r
    // Envía a la salida estándar la respuesta del servidor\r
    System.out.println("SERVIDOR > " + linea);\r
}\r
} while (true);\r
\`\`\`\r
\r
::: warning Lectura con timeout\r
Otra manera distinta de hacer lo mismo es usando lecturas con timeout.\r
\r
En este ejemplo podríamos haber comprobado si el mensaje enviado es el mensaje de finalización. Es ese caso, si todo ha ido bien, no deberíamos esperar una respuesta por parte del server, pero si ha habido algún error, sí debemos realizar una lectura del socket.\r
\r
Usando este código\r
\r
\`\`\`java\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenvía al servidor hasta que se envía \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
\r
            // Si enviamos el mensaje de salida, no hacemos una lectura indefinida\r
            if (linea.equals(messages[2])) {\r
                socketCliente.setSoTimeout(100);\r
            } else {\r
                socketCliente.setSoTimeout(0);\r
            }\r
\r
            try { \r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Envía a la salida estándar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            } catch (SocketTimeoutException ste) {\r
                // Pasado el timeout no se ha recibido una respuesta\r
                // Podemos suponer que el server no envía respuesta\r
                // Eso indica que el protocolo se ha completado\r
                // Damos por concluida la comunicación.\r
                break;\r
            }            \r
        } while (true);\r
\`\`\`\r
\r
fijamos un tiempo de espera pasado el cual se producirá una \`SocketTimeoutException\` indicando que no se ha leído nada del socket. Si por el contrario se lee información del socket, esta se muestra por la consola.\r
\r
En este caso en concreto, esta solución no funciona porque el servidor ya ha cerrado el socket. Esto sería útil cuando tengamos que hacer una \`lectura opcional\` en mitad de un protocolo, y serviría tanto para un cliente como para un servidor.\r
:::\r
`]},{title:"4.1 TCP IP protocol stack",headers:[{level:2,title:"4.1.1. TCP/IP Layers",slug:"_4-1-1-tcp-ip-layers",link:"#_4-1-1-tcp-ip-layers",children:[]},{level:2,title:"4.1.2. Addresses and ports - Sockets",slug:"_4-1-2-addresses-and-ports-sockets",link:"#_4-1-2-addresses-and-ports-sockets",children:[{level:3,title:"IP Addresses",slug:"ip-addresses",link:"#ip-addresses",children:[]},{level:3,title:"Ports",slug:"ports",link:"#ports",children:[]},{level:3,title:"Sockets",slug:"sockets",link:"#sockets",children:[]}]},{level:2,title:"4.1.3 TCP vs UDP",slug:"_4-1-3-tcp-vs-udp",link:"#_4-1-3-tcp-vs-udp",children:[]}],path:"/en/unit4/tcp-ip.html",pathLocale:"/en/",extraFields:[`---\r
title: 4.1 TCP IP protocol stack\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.1 TCP IP protocol stack" />\r
\r
# 4.1 TCP IP protocol stack\r
\r
[[toc]]\r
\r
## 4.1.1. TCP/IP Layers\r
\r
The TCP/IP Stack, or the internet protocol suite, is a set of communication protocols used by the Internet or similar networks.\r
\r
TCP/IP is the world's most widely-used non-proprietary protocol suite because it enables computers using diverse hardware and software platforms, on different types of networks, to communicate. The protocols work equally well in both LANs and WANs.\r
\r
TCP/IP is a collection of protocols named after its two best-known and most important protocols, the \`Transmission Control Protocol (TCP)\` and the \`Internet Protocol (IP)\`. As well as these relatively low-level protocols, TCP/IP includes several higher level protocols that facilitate common applications such as electronic mail, terminal emulation, and file transfer.\r
\r
::: info Protocol RFC\r
Each Internet protocol, together with any subsequent amendments, is described in a document known as a Request For Comments (RFC).\r
\r
A list of RFCs is available at: [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).\r
:::\r
\r
It is called a **stack** because it is typically designed as a hierarchy of layers, each supporting the one above it and using those below it. Each layer solves a specific set of problems involving the transmission of data and provides well-defined services to the layers above it.\r
\r
The TCP/IP model has four layers. From lowest to highest, these are the link layer, the internet layer, the transport layer, and the application layer, as shown below.\r
\r
![TCP/IP real communication flow](../../media/unit4/1-ip-real-communication-flow.gif)\r
\r
- The **link layer** provides the interface with the underlying network hardware and physical wired or wireless connection media.\r
- The **internetwork layer** provides addressing and routing functions that ensures messages are delivered to their destination. Internet Protocol (IP) is the most important protocol in this layer and probably on the whole stack.\r
- The **transport layer** oversees the end-to-end transfer of data, and can handle a number of data streams simultaneously. The main transport layer protocol is \`Transmission Control Protocol (TCP)\`, which provides a reliable, connection-oriented service. \`User Datagram Protocol (UDP)\` provides an unreliable, connectionless service.\r
- An **application layer** protocol is specific to a particular type of application (e.g. file transfer, electronic mail, network management etc.) and is sometimes embodied within the application's client software, although it could also be implemented within the operating system software. The interface between an application layer protocol and a transport layer protocol is defined with reference to \`port numbers\` and \`sockets\`.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.1-ip-protocols.png)\r
\r
## 4.1.2. Addresses and ports - Sockets\r
\r
### IP Addresses\r
\r
Each host on a TCP/IP network is assigned a unique IP address consisting of a network number and a host number. The network number identifies a specific network. The host number identifies a host on a network and is assigned by the network administrator.\r
\r
Ipv4 IP address are 32-bit addresses. The IP address is grouped into four binary octets (an octet is a group of eight bits) and is represented using dotted decimal notation. The minimum value for an octet is 0, and the maximum value is 255.\r
\r
> 192.168.0.100\r
>\r
> 127.0.0.1\r
>\r
> 10.1.100.1\r
\r
IPv6 addresses are typically composed of a 64-bit network prefix, and a 64-bit host part. IPv6 addresses are normally written as eight groups of four hexadecimal numbers. A group consisting solely of zeros can be omitted. Leading zeros in a group can also be omitted.\r
\r
So the addresses below are all valid and equivalent to each other\r
\r
> 2001:0db8:0000:0000:0000:0000:1428:57ab\r
>\r
> 2001:0db8:0000:0000:0000::1428:57ab\r
>\r
> 2001:0db8:0:0:0:0:1428:57ab\r
>\r
> 2001:0db8:0:0::1428:57ab\r
>\r
> 2001:0db8::1428:57ab\r
>\r
> 2001:db8::1428:57ab\r
\r
![Routing](../../media/unit4/data_transfer.gif)\r
\r
### Ports\r
\r
An application process running on one computer that wants to communicate with an application process running on another computer identifies itself using a 16-bit port number, which is subsequently used by the transport layer protocol (TCP or UDP) to deliver incoming messages.\r
\r
Port numbers go from 0 to 65535, and they are grouped in three ranges\r
\r
| Port group                      | Port range    | Description                                                    |\r
| ------------------------------- | ------------- | -------------------------------------------------------------- |\r
| Well know ports or system ports | 0 - 1023      | Used by standard protocols and services                        |\r
| Registered ports                | 1024- 49151   | Reserved by companies and organizations for their own services |\r
| Ephemeral ports                 | 49152 - 65535 | For free use by clients and servers                            |\r
\r
Common server applications such as Telnet and FTP use one or more of the well known port numbers (these range between 1 and 1023). Most server applications only use one port, although some (like FTP) use two. The use of a specific port number by server applications allows the client process to send a request to a server without having to first find out which port is being used by the server application.\r
\r
> HTTP requests, for example, are addressed by default to port 80 on the server.\r
\r
The clients themselves do not need to use a well known port, since they are initiating the communication. A client process is dynamically allocated a port number (in the range 1024 to 65535) by the client operating system. This number is subsequently included in all datagrams sent to the server.\r
\r
### Sockets\r
\r
A \`socket\` is essentially an addressable end point in a communication between two processes, and consists of a **unique combination of IP address, port number and transport layer protocol (usually TCP)**.\r
\r
When a client application wishes to communicate with a server application, the operating system creates a socket which is then used by the client application to receive incoming data from the server. The unique combination of transport protocol, IP address and port number allows the communication end point to be addressed by a process running on a remote server, and ensures that data is delivered to the process for which it is intended.\r
\r
The server application will have its own socket for communicating with the client, and a connection is established between client and server using the two socket addresses. The applications exchange information by writing to, or reading from, the sockets they have created.\r
\r
The connection used by a client process consists of two sockets, one at each end of the connection. The connection can thus be identified by a unique combination of four numbers - the source and destination IP addresses, together with the source and destination port numbers.\r
\r
It is possible for several client applications running on different computers to connect to the same destination socket on a server. So there is no confusion as to which computer a datagram is destined for, even if the source and destination ports are the same in each case.\r
\r
Using sockets, it is even possible for several client applications running on the same computer to connect to the same destination socket on a server. Datagrams sent to the client by the server contain the socket address for each client process, which includes the client process's individual port number, so there is no confusion as to which process a datagram is bound for.\r
\r
![TCP/IP logical communication flow](../../media/unit4/2-ip-logical-communication-flow.gif)\r
\r
As the real communication flow goes from one layer to the next or previous one, applications on each layer are abstracted from the underlying layers, so their communications flows to the same layer on the other side. In the TCP/IP stack different pieces of information are managed at each level as shown in the previous diagram.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.0-The-TCP-IP-UDP-IP-Stack_Q640.jpg)\r
\r
As stated before, sockets are the bridge between application layer and transport layer. That's the point where our applications are going to be developed and run, giving service to higher level protocols.\r
\r
## 4.1.3 TCP vs UDP\r
\r
The \`Transmission Control Protocol (TCP)\` is a widely used connection-oriented transport layer protocol that provides reliable transfer of data between two end points, and includes mechanisms to handle flow-control, segmentation, error recovery, and multiplexing.\r
\r
The TCP transport service offers the following features:\r
\r
- Full duplex communication: both ends of a connection can transmit simultaneously\r
- Timing: timers are used to ensure that data is transmitted in a timely fashion\r
- Sequencing: message blocks are given sequence numbers to enable messages to be reassembled in the correct order before being passed to the application layer protocols on the destination computer\r
- Flow control: the flow of data is regulated using buffers and windows\r
- Error handling: checksums are provided to enable transmission errors to be detected and dealt with\r
\r
![TCP/IP logical communication flow](../../media/unit4/5-Graphic-UDP-Vs-TCP.png)\r
\r
The \`User Datagram Protocol (UDP)\` is an unreliable, connectionless protocol that works at the transport layer of TCP/IP, and provides a datagram delivery service to applications with a minimum of overhead. UDP provides a very simple interface between the application layer and the internetwork layer.\r
\r
UDP does not provide any guarantee of delivery, nor does it provide error recovery or flow control. No connection is established, and hence no handshaking procedure is required. Packets may arrive out of order, not arrive at all, or be duplicated.\r
\r
UDP is the transport protocol for a variety of application-layer protocols, including Simple Network Management Protocol (SNMP), Dynamic Host Configuration Protocol (DHCP), Routing Information Protocol (RIP), and the Domain Name System (DNS), as well as streaming media applications such as Voice over IP (VoIP).\r
\r
![TCP/IP logical communication flow](../../media/unit4/7-TCP-vs-UDP-differences.png)\r
`]},{title:"5.2 FTP Client",headers:[{level:2,title:"5.2.1 Apache Common Net FTP",slug:"_5-2-1-apache-common-net-ftp",link:"#_5-2-1-apache-common-net-ftp",children:[]},{level:2,title:"5.2.2 FTP Server",slug:"_5-2-2-ftp-server",link:"#_5-2-2-ftp-server",children:[]},{level:2,title:"5.2.3 FTP Client",slug:"_5-2-3-ftp-client",link:"#_5-2-3-ftp-client",children:[{level:3,title:"5.2.3.1 Connect and login",slug:"_5-2-3-1-connect-and-login",link:"#_5-2-3-1-connect-and-login",children:[]},{level:3,title:"5.2.3.2 Change directories",slug:"_5-2-3-2-change-directories",link:"#_5-2-3-2-change-directories",children:[]},{level:3,title:"5.2.3.3 Upload files",slug:"_5-2-3-3-upload-files",link:"#_5-2-3-3-upload-files",children:[]},{level:3,title:"5.2.3.4 Download files",slug:"_5-2-3-4-download-files",link:"#_5-2-3-4-download-files",children:[]},{level:3,title:"5.2.3.5 Other operations",slug:"_5-2-3-5-other-operations",link:"#_5-2-3-5-other-operations",children:[]}]}],path:"/en/unit5/ftp.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.2 FTP Client\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.2 FTP Client" />\r
\r
# 5.2 FTP Client\r
\r
[[toc]]\r
\r
## 5.2.1 Apache Common Net FTP\r
\r
Apache Commons Net™ library implements the client side of many basic Internet protocols.\r
\r
The purpose of the library is to provide fundamental protocol access, not higher-level abstractions. Therefore, some of the design violates object-oriented design principles.\r
\r
Our philosophy is to make the global functionality of a protocol accessible (e.g., TFTP send file and receive file) when possible, but also provide access to the fundamental protocols where applicable so that the programmer may construct his own custom implementations (e.g, the TFTP packet classes and the TFTP packet send and receive methods are exposed).\r
\r
::: tip Apache Commons NET™ library\r
Supported protocols include:\r
\r
- FTP/FTPS\r
- FTP over HTTP (experimental)\r
- NNTP\r
- SMTP(S)\r
- POP3(S)\r
- IMAP(S)\r
- Telnet\r
- TFTP\r
- Finger\r
- Whois\r
- rexec/rcmd/rlogin\r
- Time (rdate) and Daytime\r
- Echo\r
- Discard\r
- NTP/SNTP\r
:::\r
\r
In Java, natively, it is possible to carry out file transfers using this protocol, but it is extremely hard to do so. The Apache Commons Net library provides classes and utilities to perform any operation on an FTP or FTPS server from a Java client.\r
\r
This library can be downloaded from the apache.org website through the following link: https://commo\r
ns.apache.org/proper/commons-net/\r
\r
## 5.2.2 FTP Server\r
\r
The FTP server is a program that runs on a computer and allows other computers to connect to it and transfer files using the FTP protocol.\r
\r
To make tests we are going to use the FileZilla FTP server, which can be downloaded from the [Filezilla site](https://filezilla-project.org/download.php?type=server).\r
\r
The installation is very simple, just follow the steps of the installation wizard. Once installed, we will have to configure the server, for this we will have to open the FileZilla Server Interface program, which will be in the Windows start menu.\r
\r
![FileZilla Server Interface](../../media/unit5/FileZilla-Server-Interface.png)\r
\r
Once you have installed the server, you will have to configure it. To do this, you will have to open the FileZilla Server Interface program, which will be in the Windows start menu and open the Server menu and select the option "Configure".\r
\r
Then, in the Users section, we will have to create a user, for this we will have to click on the "Add" button and fill in the fields with the data of the user that we want to create. Then change the Authentication type to "Require a password to login" and enter the password that we want to assign to the user.\r
\r
Then, in the Mounting Points section, we will have to add a new mounting point, for this we will have to click on the "Add" button and fill in the fields with the data of the mounting point that we want to create. In the "Native path" field we will have to select the directory that we want to share.\r
\r
::: tip Virtual Paths vs Native Paths\r
Virtual paths are used to map a directory on the server to a virtual directory. This allows you to create a virtual directory structure that is different from the actual directory structure on the server. For example, you can map the directory "C:\\My Documents" to the virtual directory "/Documents". When a client connects to the server and changes to the "/Documents" directory, the client will actually be in the "C:\\My Documents" directory on the server.\r
:::\r
\r
Once we have created the user and the mounting point, we will have to click on the "OK" button to save the changes.\r
\r
## 5.2.3 FTP Client\r
\r
The main classes and methods in the org.apache.commons.net.ftp package are shown below.\r
\r
### 5.2.3.1 Connect and login\r
\r
\`\`\`java\r
public class ApacheFTPClient {\r
\r
    private String server;\r
    private int port;\r
    private String user;\r
    private String password;\r
    private FTPClient ftp;\r
\r
    public ApacheFTPClient(String server, int port, String user, String password) {\r
        this.server = server;\r
        this.port = port;\r
        this.user = user;\r
        this.password = password;\r
    }\r
\r
    void open() throws IOException {\r
        ftp = new FTPClient();\r
\r
        ftp.connect(server, port);\r
        int reply = ftp.getReplyCode();\r
        if (!FTPReply.isPositiveCompletion(reply)) {\r
            ftp.disconnect();\r
            throw new IOException("Exception in connecting to FTP Server");\r
        }\r
\r
        ftp.login(user, password);\r
    }\r
\r
    void close() throws IOException {\r
        ftp.disconnect();\r
    }\r
\r
    public static void main(String[] args) throws IOException {\r
        ApacheFTPClient client = new ApacheFTPClient("localhost", 21, "alumnodam", "psp");\r
        client.open();\r
        client.close();\r
    }\r
}\r
\`\`\`\r
\r
In the previous example we can see how to connect to an FTP server using the Apache Commons Net library.\r
\r
1. To do this, we will have to create an instance of the **FTPClient** class and call the connect method, passing as parameters the server and the port to which we want to connect.\r
1. Then we will have to check that the connection has been established correctly, for this we will have to call the *getReplyCode* method and check that the value returned by this method is positive.\r
1. Finally, we will have to call the login method, passing as parameters the user and the password with which we want to log in.\r
\r
### 5.2.3.2 Change directories\r
\r
In the FTP protocol, the local directory is the directory on the client's computer and the remote directory is the directory on the server. Both the local and remote directories are called working directories and both can be changed with the **changeWorkingDirectory** method for the remote files and the **File** methods to set the origin for the local files.\r
\r
To show the current working directory, we can use the **printWorkingDirectory** method and to show the contents of the current working directory, we can use the **listFiles** method or the **listNames** method.\r
\r
\`\`\`java\r
    // Get the current remote working directory\r
    String workingDirectory = ftp.printWorkingDirectory();\r
    \r
    // Show contents of current remote working directory\r
    for (String name : ftp.listNames()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Change the current remote working directory\r
    ftp.changeWorkingDirectory(fileName)\r
\`\`\`\r
\r
To show the current local working directory, we have to manage it with the File class and its methods. We can also rely on the System class and its methods as we studied in the process management unit.\r
\r
\`\`\`java\r
    // Get the current local working directory\r
    String workingDirectory = System.getProperty("user.dir");\r
    \r
    // Show contents of current local working directory\r
    File file = new File(workingDirectory);\r
    for (String name : file.list()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Change the current local working directory\r
    System.setProperty("user.dir", fileName);\r
\`\`\`\r
\r
### 5.2.3.3 Upload files\r
\r
In FTP files can be upload in two different ways:\r
\r
ASCII mode: The file is uploaded as text, with the line endings converted to the network standard.\r
\r
\`\`\`java\r
    public boolean sendTextFile(String fileName) throws FileNotFoundException, IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        InputStream input = new FileInputStream(file);\r
        boolean upload = ftp.storeFile(fileRemote, input);\r
        input.close();\r
        return upload;\r
    }\r
\`\`\`\r
\r
Binary mode: The file is uploaded as is, without any conversion.\r
\r
\`\`\`java\r
public boolean sendBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        InputStream input = new FileInputStream(file);\r
        OutputStream output = ftp.storeFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        input.close();\r
        output.close();\r
        boolean upload = ftp.completePendingCommand();\r
\r
        return upload;\r
    }\r
\`\`\`\r
\r
### 5.2.3.4 Download files\r
\r
As with the upload, files can be downloaded in two different ways:\r
\r
ASCII mode: The file is downloaded as text, with the line endings converted to the local standard.\r
\r
\`\`\`java\r
    public boolean getTextFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        OutputStream output = new FileOutputStream(file);\r
        boolean download = ftp.retrieveFile(fileRemote, output);\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
Binary mode: The file is downloaded as is, without any conversion.\r
\r
\`\`\`java\r
    public boolean getBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        OutputStream output = new FileOutputStream(file);\r
        InputStream input = ftp.retrieveFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        boolean download = ftp.completePendingCommand();\r
        input.close();\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
### 5.2.3.5 Other operations\r
\r
Other operations that can be performed on the FTP server are:\r
\r
Show file information and file properties\r
\r
\`\`\`java\r
    public void showFileInfo(String fileName) throws IOException {\r
        FTPFile[] files = ftp.listFiles(fileName);\r
        for (FTPFile file : files) {\r
            System.out.println(file.getName());\r
            System.out.println(file.getTimestamp().getTime());\r
            System.out.println(file.getSize());\r
            if (f.getType() == FTPFile.FILE_TYPE) {\r
                tipo = "File";\r
            }\r
            if (f.getType() == FTPFile.DIRECTORY_TYPE) {\r
                tipo = "Folder";\r
            }\r
        }\r
    }    \r
\`\`\`\r
\r
Add and remove remote FTP directories\r
\r
\`\`\`java\r
    public void addRemoteDirectory(String directory) throws IOException {\r
        ftp.makeDirectory(directory);\r
    }\r
\r
    public void removeRemoteDirectory(String directory) throws IOException {\r
        ftp.removeDirectory(directory);\r
    }\r
\`\`\`\r
\r
Create and remove remote FTP files\r
\r
\`\`\`java\r
    public void addRemoteFile(String fileName) throws IOException {\r
        ftp.storeFile(fileName, new ByteArrayInputStream(new byte[0]));\r
    }\r
\r
    public void removeRemoteFile(String fileName) throws IOException {\r
        ftp.deleteFile(fileName);\r
    }\r
\`\`\`\r
\r
Rename remote FTP files and directories\r
\r
\`\`\`java\r
    public void renameRemoteFile(String oldName, String newName) throws IOException {\r
        ftp.rename(oldName, newName);\r
    }\r
\`\`\`\r
`]},{title:"5.4 Annex I - GMail configurations",headers:[{level:2,title:"5.4.1 Common Exceptions when using Gmail SMTP",slug:"_5-4-1-common-exceptions-when-using-gmail-smtp",link:"#_5-4-1-common-exceptions-when-using-gmail-smtp",children:[{level:3,title:"5.4.1.1 Two-way authentication",slug:"_5-4-1-1-two-way-authentication",link:"#_5-4-1-1-two-way-authentication",children:[]},{level:3,title:"5.4.1.2 Less secure apps",slug:"_5-4-1-2-less-secure-apps",link:"#_5-4-1-2-less-secure-apps",children:[]}]}],path:"/en/unit5/gmail_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.4 Annex I - GMail configurations\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.4 Annex I - GMail configurations" />\r
\r
# 5.4 Annex I - GMail configurations\r
\r
[[toc]]\r
\r
## 5.4.1 Common Exceptions when using Gmail SMTP\r
\r
While sending an email with any of the above methods, you might get the following exceptions, even your Gmail credentials are correct.\r
\r
:::danger Google security\r
It's important to check your account security. Change the following settings only if you are absolutely sure of what you are doing.\r
\r
Do not share any of the password because your account can be used without your permission.\r
:::\r
\r
### 5.4.1.1 Two-way authentication\r
\r
\`\`\`java\r
Error while trying to send mail: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
The exception (jakarta.mail.AuthenticationFailedException) talks about the Application-specific password required. This is because your Gmail account is configured for 2-step verification so your direct Gmail password won’t work here due to security reasons. To rectify this, you need to follow the below steps.\r
\r
1. Sign in with your Google account\r
2. Go to your Google account or just click on the link [Google account security settings](https://myaccount.google.com/?pli=1)\r
![Google settings](../../media/unit5/Google-Settings-1.1.png)\r
3. Click on Security from the left menu.\r
4. Scroll a bit down to reach the “Signing in to Google” section – most probably 3rd section from the top.\r
5. Here you can see 2-Step Verification is turned On.\r
![Google settings](../../media/unit5/Google-Settings-1.2.png)\r
6. Click on App Password just below it. Google will ask you to re-enter the password.\r
7. On the next screen, you need to select the App and Device.\r
8. From the “Select app” dropdown, just select Other (Custom name).\r
9. Give an appropriate name like “Web” and press Generate button.\r
![Google settings](../../media/unit5/Google-Settings-1.3.png)\r
10. You will a generated password on the screen with a popup.\r
11. Save and use this password for all your Java mail code.\r
\r
### 5.4.1.2 Less secure apps\r
\r
\`\`\`java\r
Error while trying to send mail: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
1. Sign in with your Google account\r
1. Go to your Google account or just click on the link [Google less secure apps settings](https://www.google.com/settings/security/) to advance until step 5.\r
![Google settings](../../media/unit5/Google-Settings-1.1.png)\r
1. Click on Security from the left menu.\r
1. Scroll a bit down to reach the “Less secure applications".\r
1. You will find it disabled. Enter the section to turn it On.\r
![Google settings](../../media/unit5/Google-Settings-2.3.png)\r
1. Save and use your account password for all your Java mail code.\r
\r
<!-- References\r
Jakarta Mail Tutorials\r
https://mailtrap.io/blog/jakarta-mail-tutorial/\r
https://mailtrap.io/blog/sending-email-using-java/\r
https://www.opensource-techblog.com/use-java-mail-api-to-send-email-with-gmail-smtp-example.html\r
\r
Modify pom.xml to make dependencies be copied along with the jar file\r
https://www.baeldung.com/executable-jar-with-maven\r
-->\r
`]},{title:"5 Introduction",headers:[{level:2,title:"Goals",slug:"goals",link:"#goals",children:[]}],path:"/en/unit5/",pathLocale:"/en/",extraFields:[`---\r
title: 5 Introduction\r
---\r
\r
# Unit 5. Network Services\r
\r
Services are helpers used in a system to manage a collection of resources and provide their functionality to users and applications.\r
\r
Access to services consists of the set of operations offered, for example, a file service offers read, write, and delete file operations.\r
\r
All Internet services implement a client-server relationship. There are many libraries to work with the most common services. In this unit we are going to focus on the FTP (file transfer), SMTP service (mail sending) and POP3/IMAP (mail reading).\r
\r
In addition, there are other approaches, also based on the client-server architecture that allow access to systems. Among the most used, is what is called \`Rest API\`, which is still a service over *HTTP* that allows you to interact with  the backend of the  systems, no matter the architecture and languages used in the frontend.\r
\r
We are going to analyze in this unit other approaches such as queue systems, based on the MQ protocol, or \`serverless systems\`  offered by the main cloud computing platforms (Azure Functions, AWS Lambda and Google Cloud Functions).\r
\r
## Goals\r
\r
Goals of this unit:\r
\r
- Use Java libraries to use the most important TCP/IP application protocols.\r
- Test network communication services.\r
- Allow cloud operations easily.\r
- Create applications that allow asynchronous communication between clients and between clients and servers.\r
`]},{title:"5.1 Mail",headers:[{level:2,title:"5.1.1 Jakarta Mail",slug:"_5-1-1-jakarta-mail",link:"#_5-1-1-jakarta-mail",children:[{level:3,title:"Library usage",slug:"library-usage",link:"#library-usage",children:[]}]},{level:2,title:"5.1.2 Jakarta Mail API Core Classes",slug:"_5-1-2-jakarta-mail-api-core-classes",link:"#_5-1-2-jakarta-mail-api-core-classes",children:[{level:3,title:"jakarta.mail.Session",slug:"jakarta-mail-session",link:"#jakarta-mail-session",children:[]},{level:3,title:"jakarta.mail.Message",slug:"jakarta-mail-message",link:"#jakarta-mail-message",children:[]},{level:3,title:"jakarta.mail.Address",slug:"jakarta-mail-address",link:"#jakarta-mail-address",children:[]},{level:3,title:"jakarta.mail.Authenticator",slug:"jakarta-mail-authenticator",link:"#jakarta-mail-authenticator",children:[]},{level:3,title:"jakarta.mail.Transport",slug:"jakarta-mail-transport",link:"#jakarta-mail-transport",children:[]}]},{level:2,title:"5.1.3 Send basic emails in Jakarta Mail",slug:"_5-1-3-send-basic-emails-in-jakarta-mail",link:"#_5-1-3-send-basic-emails-in-jakarta-mail",children:[{level:3,title:"Preparing session",slug:"preparing-session",link:"#preparing-session",children:[]},{level:3,title:"Message composition (plain text)",slug:"message-composition-plain-text",link:"#message-composition-plain-text",children:[]},{level:3,title:"Send message",slug:"send-message",link:"#send-message",children:[]}]},{level:2,title:"5.1.4 Send HTML messages",slug:"_5-1-4-send-html-messages",link:"#_5-1-4-send-html-messages",children:[]},{level:2,title:"5.1.5 Send Email with Attachments",slug:"_5-1-5-send-email-with-attachments",link:"#_5-1-5-send-email-with-attachments",children:[]},{level:2,title:"5.1.6 Send HTML emails with images",slug:"_5-1-6-send-html-emails-with-images",link:"#_5-1-6-send-html-emails-with-images",children:[{level:3,title:"CID (Content-ID) image embedding",slug:"cid-content-id-image-embedding",link:"#cid-content-id-image-embedding",children:[]},{level:3,title:"Inline embedding (Base64 encoding)",slug:"inline-embedding-base64-encoding",link:"#inline-embedding-base64-encoding",children:[]},{level:3,title:"Linked images",slug:"linked-images",link:"#linked-images",children:[]}]},{level:2,title:"5.1.7 Read emails in Jakarta Mail",slug:"_5-1-7-read-emails-in-jakarta-mail",link:"#_5-1-7-read-emails-in-jakarta-mail",children:[]}],path:"/en/unit5/mail.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.1 Mail\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.1 Mail" />\r
\r
# 5.1 Mail\r
\r
[[toc]]\r
\r
## 5.1.1 Jakarta Mail\r
\r
When scouring the Internet for tutorials on sending emails using Java, there is a high chance every single one will mention something called \`Jakarta Mail\` or \`Java Mail\`.\r
\r
For a long time, the Java Enterprise Edition (commonly known as Java EE), has been the de facto platform for developing mission-critical applications.\r
\r
Recently, in order to stir the creation of cloud-native applications, several prominent software vendors joined hands to transfer Java EE technologies to the Eclipse Foundation, which is a not-for-profit organization tasked with stewarding the activities of the Eclipse open source software community.\r
\r
>**Consequently, the Java EE has been rebranded to Jakarta EE.**\r
\r
In spite of the name change, all the main classes and properties definitions still remain the same for both Jakarta Mail and JavaMail.\r
\r
::: tip Jakarta vs Java Mail\r
To avoid confusion, it’s important to note that JavaMail is only the former name of Jakarta Mail and the two represent the same software.\r
:::\r
\r
So, Jakarta Mail, or JavaMail as some still like to call it, is an API for sending and receiving emails via **SMTP**, **POP3**, as well as **IMAP** and is the most popular option that also supports both TLS and SSL authentication. It is platform-independent, protocol-independent, and built into the Jakarta EE platform.\r
\r
You can also find Jakarta Mail as an optional package for use with the Java SE platform.\r
\r
### Library usage\r
\r
>[JakartaMail API](https://jakarta.ee/specifications/mail/2.1/jakarta-mail-spec-2.1) is the Jakarta Mail API specification. The reference implementation of this specification can be found in the GitHub repository [Jakarta Mail Specification](https://jakartaee.github.io/mail-api/).\r
\r
::: danger JavaMail API\r
As the name suggests, JavaMail API is an API, not an implementation. So you can’t use it directly in your project. Instead, you need to use an implementation of the Jakarta Mail API, such as the reference implementation of the Jakarta Mail API specification. \r
:::\r
\r
You can also find the jakarta.mail-api-X.Y.Z.jar file in the Maven repository and add it with \`Maven\` dependencies:\r
\r
\`\`\`xml:no-line-numbers\r
    <dependencies>\r
        <dependency>\r
            <groupId>org.eclipse.angus</groupId>\r
            <artifactId>angus-mail</artifactId>\r
            <version>2.0.2</version>\r
            <type>jar</type>\r
        </dependency>        \r
        <dependency>\r
            <groupId>jakarta.mail</groupId>\r
            <artifactId>jakarta.mail-api</artifactId>\r
            <version>2.1.2</version>\r
            <type>jar</type>\r
        </dependency>\r
    </dependencies>\r
\`\`\`\r
\r
::: info Implementaciones de Jakarta Mail\r
In the previous example we have used the Jakarta AngusMail implementation, but you can use others like the Oracle one, just changing the dependency.\r
\r
\`\`\`xml:no-line-numbers\r
        <dependency>\r
            <groupId>com.sun.mail</groupId>\r
            <artifactId>jakarta.mail</artifactId>\r
            <version>2.0.1</version>\r
        </dependency>      \r
\`\`\`\r
\r
As it is an implementation of the API proposed by Jakarta, the code should work without changes.\r
:::\r
\r
## 5.1.2 Jakarta Mail API Core Classes\r
\r
The Jakarta Mail API has a wide range of classes and interfaces that can be used for sending, reading, and performing other actions with email messages—just like in a typical mailing system.\r
\r
Although there are several packages in the Jakarta Mail Project, two of the most frequently used ones are \`jakarta.mail\` and \`jakarta.mail.internet\`.\r
\r
The **jakarta.mail** package provides classes that model a mail system and the **jakarta.mail.internet** package provides classes that that are focused to Internet mail systems.\r
\r
Here is a description of the core classes in each of the packages:\r
\r
### jakarta.mail.Session\r
\r
The Session class, which is not subclassed, is the *top-level class of the Jakarta Mail API*. It’s a multi-threaded object that acts as the connection factory for the Jakarta Mail API. apart from collecting the mail API’s properties and defaults, **it is responsible for configuration settings and authentication**.\r
\r
To get the Session object, you can call either of the following two methods:\r
\r
- getDefaultInstance(), which returns the default session\r
- getInstance(), which returns a new session\r
  \r
### jakarta.mail.Message\r
\r
The Message class is an *abstract class* that models an email message; its subclasses support the actual implementations. Usually, its \`MimeMessage subclass\` *(jakarta.mail.internet.MimeMessage)* is used for actually crafting the details of the email message to be sent. **A MimeMessage is an email message that uses the MIME (Multipurpose Internet Mail Extension) formatting style** defined in the RFC822.\r
\r
Here are some of the commonly used methods of the MimeMessage class:\r
|Method |Description |\r
|:---|:---|\r
|setFrom(Address addresses) | It’s used to set the “From” header field.|\r
|setRecipients(Message.RecipientType type, String addresses) | It’s used to set the stated recipient type to the provided addresses. The possible defined address types are “TO” (Message.RecipientType.TO), “CC” (Message.RecipientType.CC), and “BCC” (Message.RecipientType.BCC).|\r
|setSubject(String subject) | It’s used to set the email’s subject header field.|\r
|setText(String text) | It’s used to set the provided String as the email’s content, using MIME type of “text/plain”. |\r
|setContent(Object message, String contentType) | It’s used to set the email’s content, and can be used with a MIME type other than “text/html”.|\r
\r
### jakarta.mail.Address\r
\r
The Address class is an *abstract class* that models the addresses (To and From addresses) in an email message; its subclasses support the actual implementations. Usually, its \`InternetAddress subclass\`, which denotes an Internet email address, is commonly used.\r
\r
### jakarta.mail.Authenticator\r
\r
The Authenticator class is an *abstract class* that is used to get authentication to access the mail server resources—often by requiring the user’s information. Usually, its \`PasswordAuthentication subclass\` is commonly used.\r
\r
### jakarta.mail.Transport\r
\r
The Transport class is an *abstract class* that uses the \`SMTP protocol\` for submitting and transporting email messages.\r
\r
## 5.1.3 Send basic emails in Jakarta Mail\r
\r
Essentially, here are the steps for sending an email message using the Jakarta Mail API:\r
\r
1. Configure the SMTP server details using a **Java Properties object**. You can get SMTP server details from your email service provider.\r
1. Create a Session object by calling the getInstance() method. Then, pass the \`account’s username and password\` to PasswordAuthentication. When creating the session object, you should always register the Authenticator with the Session.\r
1. Once the Session object is created, the next step is to create the email message to be sent. To do this, start by passing the created session object in the MimeMessage class constructor.\r
1. Next, after creating the message object, set the From, To, and Subject fields for the email message.\r
1. Use the setText() method to set the content of the email message.\r
1. Use the Transport object to send the email message.\r
1. Add Exceptions to retrieve the details of any possible errors when sending the message.\r
\r
### Preparing session\r
\r
The very first step is to get the mail session object. The Session class is a singleton class. So you can’t directly create an instance of it. You need to call one of the overloaded static methods, usually \`getInstance()\`.\r
\r
::: info Properties Files/Objects\r
A property file is a text file containing key-value pairs for the configuration settings of a project.\r
\r
It can be created on-the-fly as in the next examples, but it can also be read from a file in the project (this is the preferred way).\r
\r
Here you can find some links to take a look on how to use and access these files\r
\r
- [Java Properties Files y como usarlos - Arquitectura Java](https://www.arquitecturajava.com/java-properties-files-y-como-usarlos/)\r
- [Getting started with Java properties - Baeldung](https://www.baeldung.com/java-properties)\r
- [Properties class in Java - javaTpoint](https://www.javatpoint.com/properties-class-in-java)\r
\r
![http://www.instanceofjava.com/2018/01/how-to-read-values-from-properties-file.html](../../media/unit5/propertiesfile.png)\r
\r
In the previous image you can see where to place the properties file in a \`Maven\` project.\r
:::\r
\r
\`\`\` java\r
// Prepare SMTP configuration into a Property object\r
final Properties prop = new Properties();\r
prop.put("mail.smtp.username", "usuario@gmail.com");\r
prop.put("mail.smtp.password", "passwordEmail");\r
prop.put("mail.smtp.host", "smtp.gmail.com");\r
prop.put("mail.smtp.port", "587");\r
prop.put("mail.smtp.auth", "true");\r
prop.put("mail.smtp.starttls.enable", "true"); // TLS\r
\r
// Create the Session with the user credentials\r
Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
    @Override\r
    protected PasswordAuthentication getPasswordAuthentication() {\r
        return new PasswordAuthentication(prop.getProperty("mail.smtp.username"), \r
                    prop.getProperty("mail.smtp.password"));\r
    }\r
});\r
\`\`\`\r
\r
In the above code, we have just created the Session object with properties and the Authenticator object.\r
\r
The properties are as follows.\r
\r
- mail.smtp.username – Username of SMTP server\r
- mail.smtp.password – Password of SMTP server\r
- mail.smtp.host – Host of SMTP server\r
- mail.smtp.port – Port\r
- mail.smtp.auth – Is Authentication is required.\r
- mail.smtp.starttls.enable – TLS enable or not.\r
\r
The Authenticator is an abstract class. Its object is created by providing an anonymous implementation of getPasswordAuthentication() method. The PasswordAuthentication class is used as a placeholder for storing user credentials.\r
\r
Here you can find a sample code to read the properties from a file in the project.\r
\r
\`\`\`java\r
    private void loadSMTPConfiguration() {\r
        try ( InputStream input = this.getClass().getResourceAsStream("/" + propertiesFile)) {\r
\r
            smtpConfiguration = new Properties();\r
            // load a properties file\r
            smtpConfiguration.load(input);\r
\r
            // get the property value and print it out\r
            smtpConfiguration.forEach((key, value) -> System.out.println("Key : " + key + ", Value : " + value));\r
\r
        } catch (IOException ex) {\r
            System.err.println("Cant open properties file: " + ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }\r
    }    \r
\`\`\`\r
\r
The content of the properties file could be something like this\r
\r
\`\`\`txt\r
# Data to send emails from a GMAIL account\r
mail.from=cuenta@iesdoctorbalmis.com ó cuenta@gmail.com\r
mail.smtp.username=cuenta@iesdoctorbalmis.com\r
mail.smtp.password=***contraseña de la cuenta habilitando apps poco seguras o contraseña de app con 2FA***\r
\r
\r
mail.smtp.host=smtp.gmail.com\r
mail.smtp.port=587\r
mail.smtp.auth=true\r
mail.smtp.starttls.enable=true\r
\`\`\`\r
\r
### Message composition (plain text)\r
\r
Next, we will compose the email message. The jakarta.mail.Message class represents a message in Java mail API. Since it’s an abstract class, we will use its concrete implementation \`jakarta.mail.internet.MimeMessage\` class. Java Mail API allows sending mail either in plain text or in HTML content. Let’s start by sending a plain text message.\r
\r
\`\`\`java{8}\r
// Prepare the MimeMessage\r
Message message = new MimeMessage(mailSession);\r
// Set From and subject email properties\r
message.setFrom(new InternetAddress("no-reply@gmail.com"));\r
message.setSubject("Sending Mail with pure Java Mail API ");\r
\r
// Set to, cc & bcc recipients        \r
InternetAddress[] toEmailAddresses = \r
        InternetAddress.parse("user1@gmail.com, user2@gmail.com");\r
InternetAddress[] ccEmailAddresses = \r
        InternetAddress.parse("user21@gmail.com, user22@gmail.com");\r
InternetAddress[] bccEmailAddresses = \r
        InternetAddress.parse("user31@gmail.com");\r
            \r
message.setRecipients(Message.RecipientType.TO,toEmailAddresses);\r
message.setRecipients(Message.RecipientType.CC,ccEmailAddresses);\r
message.setRecipients(Message.RecipientType.BCC,bccEmailAddresses);\r
\r
/* Mail body with plain Text */\r
message.setText("Hello User," \r
        + "\\n\\n If you read this, means mail sent with Java Mail API is successful");\r
\r
\`\`\`\r
\r
> **To send an email in plain text, just pass the text in the message.setText() method.**\r
\r
### Send message\r
\r
So far, we created a session and compose the message. Now it’s time to send the message to the recipients. We will use jakarta.mail.Transport class for the same. It provides overloaded \`send()\` methods.\r
\r
\`\`\`java\r
    // Send the configured message in the session\r
    Transport.send(message);\r
\`\`\`\r
\r
## 5.1.4 Send HTML messages\r
\r
In terms of usability, HTML content is far superior to plain text. So, most of the time, we send emails in HTML content. Java Mail API supports sending emails in HTML content. To send an email with HTML content, you need to replace the message.setText() method with below code.\r
\r
\`\`\`java\r
...\r
message.setContent("Just discovered that Jakarta Mail is fun and easy to use", \r
"text/html");\r
...\r
\`\`\`\r
\r
> we’ll be using the **setContent()** method to set content and specify \`"text/html”\` in the second argument, indicating the message has HTML content.\r
\r
## 5.1.5 Send Email with Attachments\r
\r
Apart from the previously mentioned steps, here are the differing steps involved in using the Jakarta Mail API for sending email attachments:\r
\r
1. Create an instance of the \`MimeMultipart\` object that will be used for wrapping the MimeBodyPart body parts. **A Multipart acts like a container that keeps multiple body parts**, and it comes with methods for getting and setting its various subparts.\r
1. Then, set the first part of the multipart object by passing the actual message to it.\r
1. Next, set the second and next parts of the multipart object by adding the attachment.\r
1. Include the multipart in the message to be sent.\r
1. Send the message\r
\r
![Multipart MIME Message structure](../../media/unit5/e-mail_multipart_structure.png)\r
\r
\`\`\`java{2,5,9,12,16,19}\r
 // create an instance of multipart object\r
Multipart multipart = new MimeMultipart();\r
\r
// create the 1st message body part\r
MimeBodyPart messageBodyPart = new MimeBodyPart();\r
// Add a plain message (HTML can also be added with setContent)\r
messageBodyPart.setText("Please find the attachment sent using Jakarta Mail");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// 2nd. bodyPart with an attached file\r
messageBodyPart = new MimeBodyPart();\r
String filename = "C:/temp/file1.pdf";\r
messageBodyPart.attachFile(filename);\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
::: info Test emails\r
You can use [YopMail](http://www.yopmail.com/en/) to test your email sending code. It’s a free service that provides disposable email addresses. You can use any email address of your choice to receive emails. The service is free and can be used to receive emails anonymously.\r
:::\r
\r
## 5.1.6 Send HTML emails with images\r
\r
To add an image to your HTML email in Jakarta Mail, you can choose any of the three common options:\r
\r
- CID image embedding\r
- inline embedding or Base64 encoding\r
- linked images.\r
  \r
### CID (Content-ID) image embedding\r
\r
To do CID image embedding, you need to create a MIME \`multipart/related\` message using the following code:\r
\r
\`\`\`java{2,5,17}\r
// 1st part of the message. An HTML code with a CID referenced image\r
Multipart multipart = new MimeMultipart("related");\r
MimeBodyPart htmlPart = new MimeBodyPart();\r
//add reference to your image to the HTML body <img src="cid:some-image-cid" alt="img" />\r
String messageBody = "<p></p><img src=\\"cid:my-test-image-cid\\" alt=\\"embedded img\\" /></p>";\r
htmlPart.setText(messageBody, "utf-8", "html");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(htmlPart);\r
\r
// 2nd part of the message. The image with special CID header markers\r
MimeBodyPart imgPart = new MimeBodyPart();\r
// imageFile is the file containing the image\r
imgPart.attachFile(imageFile);\r
// or, if the image is in a byte array in memory, use\r
// imgPart.setDataHandler(new DataHandler(\r
//      new ByteArrayDataSource(bytes, "image/whatever")));\r
imgPart.setContentID("<my-test-image-cid>");\r
// Add the multipart object to the message\r
multipart.addBodyPart(imgPart);\r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
### Inline embedding (Base64 encoding)\r
\r
For inline embedding or Base64 encoding, you should include the encoded image data in the HTML body similar to this:\r
\r
\`\`\`html\r
<img src="data:image/jpeg;base64,base64-encoded-data-here" />\r
\`\`\`\r
\r
::: warning HTML size\r
Each Base64 digit represents 6 bits of data, so your actual image code will be pretty long.\r
\r
As this affects the overall size of the HTML message, it’s better not to use inline large images.\r
:::\r
\r
To Base 64 encode/decode a stream we can use the \`java.util.Base64\` class.\r
\r
 \`\`\`java\r
byte[] fileContent = new FileInputStream(imageFile).readAllBytes();\r
String base64EncodedData = Base64.getEncoder().encodeToString(fileContent);\r
 \`\`\`\r
\r
:::tip Base64 encoding\r
Base64 is such a good option to send binary data over text protocols like HTTP without data loose.\r
\r
This operation could be applied for any binary files or binary arrays. It's useful when we need to transfer binary content in JSON format such as from mobile app to REST endpoint.\r
\r
[Image to Base64 String Conversion - Baeldung](https://www.baeldung.com/java-base64-image-string)\r
:::\r
\r
### Linked images\r
\r
Lastly, we have linked images that are essentially images hosted on some external server that you then create a link to.\r
You can do that using the img tag in the HTML body like so\r
\r
\`\`\`html\r
<img src="/wp-content/uploads/2018/11/blog/-illustration-email-embedding-images.png" alt="img" />\r
\`\`\`\r
\r
::: warning Debug Jakarta Mail\r
Debugging plays a critical role in testing of email sending.\r
\r
In Jakarta Mail, it’s pretty straightforward. Set debug to true in the properties of your email code:\r
\r
> props.put("mail.debug", "true");\r
\r
As a result, you will get a step by step description of how your code is executed. If any problem with sending your message appears, you will instantly understand what happened and at which stage.\r
:::\r
\r
## 5.1.7 Read emails in Jakarta Mail\r
\r
The Jakarta Mail API also provides support for reading emails. To read emails, you need to use the \`javax.mail.Store\` class. The Store class is an abstract class that models a message store and its access protocol, and it’s subclassed by the \`POP3Store\` and \`IMAPStore\` classes.\r
\r
Reading emails stored on an IMAP server consists of the following steps:\r
\r
- Creation of the IMAP session (Session), indicating the protocol, the host name, the port, if it uses\r
SSL and the associated trusted server.\r
- Configuration and obtaining of the warehouse (Store).\r
- Obtaining the connection through the store, indicating the account identifier and password.\r
- Obtaining the folder to be read.\r
- Opening of the folder.\r
- Getting the messages\r
- Message processing\r
- Closing of the folder and the store.\r
- Closing of the session and the connection.\r
\r
\`\`\`java\r
    // Prepare IMAP configuration into a Property object\r
    final Properties prop = new Properties();\r
    prop.put("mail.imap.host", "imap.gmail.com");\r
    prop.put("mail.imap.port", "993");\r
    prop.put("mail.imap.ssl.enable", "true");\r
    prop.put("mail.imap.auth", "true");\r
\r
    // Create the Session with the user credentials\r
    Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
        @Override\r
        protected PasswordAuthentication getPasswordAuthentication() {\r
            return new PasswordAuthentication(prop.getProperty("mail.imap.username"), \r
                        prop.getProperty("mail.imap.password"));\r
        }\r
    });\r
\r
    // Get the Store object and connect to the current host using the specified username and password.\r
    Store store = mailSession.getStore("imap");\r
    store.connect(prop.getProperty("mail.imap.host"), \r
            prop.getProperty("mail.imap.username"), \r
            prop.getProperty("mail.imap.password"));\r
\r
    // Get the folder and open it\r
    Folder folder = store.getFolder("INBOX");\r
    folder.open(Folder.READ_ONLY);\r
\r
    // Get the messages\r
    Message[] messages = folder.getMessages();\r
\r
    // Process the messages\r
    for (int i = 0; i < messages.length; i++) {\r
        Message message = messages[i];\r
        System.out.println("Message " + (i + 1));\r
        System.out.println("From: " + message.getFrom()[0]);\r
        System.out.println("Subject: " + message.getSubject());\r
        System.out.println("Sent Date: " + message.getSentDate());\r
        System.out.println("Text: " + message.getContent().toString());\r
    }\r
\r
    // Close the folder and store objects\r
    folder.close(false);\r
    store.close();\r
\`\`\`\r
`]},{title:"5.3 Auxiliary classes for networking",headers:[{level:2,title:"5.3.1 java.net.NetworkInterface",slug:"_5-3-1-java-net-networkinterface",link:"#_5-3-1-java-net-networkinterface",children:[]},{level:2,title:"4.2.2 java.net.InterfaceAddress",slug:"_4-2-2-java-net-interfaceaddress",link:"#_4-2-2-java-net-interfaceaddress",children:[]},{level:2,title:"4.2.3. java.net.InetAddress",slug:"_4-2-3-java-net-inetaddress",link:"#_4-2-3-java-net-inetaddress",children:[]},{level:2,title:"4.2.4 java.net.URL",slug:"_4-2-4-java-net-url",link:"#_4-2-4-java-net-url",children:[]},{level:2,title:"4.2.5 java.net.URLConnection",slug:"_4-2-5-java-net-urlconnection",link:"#_4-2-5-java-net-urlconnection",children:[]}],path:"/en/unit5/urls.html",pathLocale:"/en/",extraFields:[`---\r
title: 5.3 Auxiliary classes for networking\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.3 Auxiliary classes for networking" />\r
\r
# 5.3 Auxiliary classes for networking\r
\r
[[toc]]\r
\r
## 5.3.1 java.net.NetworkInterface\r
\r
This class represents network interface, both software as well as hardware, its name, list of IP addresses assigned to it and all related information. It can be used in cases when we want to specifically use a particular interface for transmitting our packet on a system with multiple NICs.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html)\r
\r
::: info What is a Network Interface?\r
A network interface can be thought of as a point at which your computer connects to the network. It is not necessarily a piece of hardware but can also be implemented in a software. For example a loopback interface which is used for testing purposes.\r
:::\r
\r
| Method                                                            | Description                                                                                                                                                                                         |\r
| ----------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public static Enumeration getNetworkInterfaces()                  | Returns all the network interfaces on the system.                                                                                                                                                   |\r
| public List getInterfaceAddresses()                               | Returns a list of all interface addresses on this interface.                                                                                                                                        |\r
| public Enumeration getInetAddresses()                             | Returns an enumeration of all InetAddresses bound to this network interface, if security manager allows it.                                                                                         |\r
| public String getName()                                           | Returns the name of this network interface.                                                                                                                                                         |\r
| public int getIndex()                                             | Returns the index assigned to this network interface by the system. Indexes can be used in place of long names to refer to any interface on the device.                                             |\r
| public String getDisplayName()                                    | This method returns the name of network interface in a readable string format.                                                                                                                      |\r
| public static NetworkInterface getByName(String name)             | Finds and returns the network interface with the specified name, or null if none exists.                                                                                                            |\r
| public static NetworkInterface getByIndex(int index)              | Performs similar function as the previous function with index used as search parameter instead of name.                                                                                             |\r
| public static NetworkInterface getByInetAddress(InetAddress addr) | This method is widely used as it returns the network interface the specified inetaddress is bound to. If an InetAddress is bound to multiple interfaces, any one of the interfaces may be returned. |\r
| public boolean isUp()                                             | Returns a boolean value indicating if this network interface is up and running.                                                                                                                     |\r
\r
\`\`\`java\r
// Java program to illustrate various java.net.NetworkInterface class methods.\r
\r
public class NetworkInterfaceExample\r
{\r
    public static void main(String[] args) throws SocketException,\r
                                                UnknownHostException\r
    {\r
\r
        // getNetworkInterfaces() returns a list of all interfaces\r
        // present in the system.\r
        ArrayList<NetworkInterface> interfaces = Collections.list(\r
                                            NetworkInterface.getNetworkInterfaces());\r
\r
        System.out.println("Information about present Network Interfaces...\\n");\r
        for (NetworkInterface iface : interfaces)\r
        {\r
            // isUp() method used for checking whether the interface in process\r
            // is up and running or not.\r
            if (iface.isUp())\r
            {\r
                // getName() method\r
                System.out.println("Interface Name: " + iface.getName());\r
\r
                // getDisplayName() method\r
                System.out.println("Interface display name: " + iface.getDisplayName());\r
\r
                // getHardwareAddress() method\r
                System.out.println("Hardware Address: " +\r
                                Arrays.toString(iface.getHardwareAddress()));\r
\r
                // getParent() method\r
                System.out.println("Parent: " + iface.getParent());\r
\r
                // getIndex() method\r
                System.out.println("Index: " + iface.getIndex());\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInterface addresses: ");\r
\r
                // getInterfaceAddresses() method\r
                for (InterfaceAddress addr : iface.getInterfaceAddresses())\r
                {\r
                    System.out.println("\\t\\t" + addr.getAddress().toString());\r
                }\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInetAddresses associated with this interface: ");\r
\r
                // getInetAddresses() method returns list of all\r
                // addresses currently bound to this interface\r
                Enumeration<InetAddress> en = iface.getInetAddresses();\r
                while (en.hasMoreElements())\r
                {\r
                    System.out.println("\\t\\t" + en.nextElement().toString());\r
                }\r
\r
                // getMTU() method\r
                System.out.println("\\tMTU: " + iface.getMTU());\r
\r
                // getSubInterfaces() method\r
                System.out.println("\\tSubinterfaces: " +\r
                                Collections.list(iface.getSubInterfaces()));\r
\r
                // isLoopback() method\r
                System.out.println("\\tis loopback: " + iface.isLoopback());\r
\r
                // isVirtual() method\r
                System.out.println("\\tis virtual: " + iface.isVirtual());\r
\r
                // isPointToPoint() method\r
                System.out.println("\\tis point to point: " + iface.isPointToPoint());\r
\r
                // supportsMulticast() method\r
                System.out.println("Supports Multicast: " + iface.supportsMulticast());\r
\r
            }\r
        }\r
\r
        // getByIndex() method returns network interface\r
        // with the specified index\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
\r
        // toString() method is used to display textual\r
        // information about this network interface\r
        System.out.println("Network interface 1: " + nif.toString());\r
\r
        // getByName() method returns network interface\r
        // with the specified name\r
        NetworkInterface nif2 = NetworkInterface.getByName("eth0");\r
        InetAddress ip = InetAddress.getByName("localhost");\r
\r
        // getbyInetAddress() method\r
        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\r
        System.out.println("\\nlocalhost associated with: " + nif3);\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.2 java.net.InterfaceAddress\r
\r
This class represents a network interface address. Every device that has an IP address has an IP address on the network interface.\r
\r
In short it's an IP address, a subnet mask and a broadcast address when the address is an IPv4 one. An IP address and a network prefix length in the case of IPv6 address.\r
\r
> [java.net.InterfaceAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html)\r
\r
| Method                                | Description                                                                                                                                                                     |\r
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public InetAddress getAddress()       | Returns an InetAddress for this address.                                                                                                                                        |\r
| public InetAddress getBroadcast()     | Returns the InetAddress for the broadcast address for this interface address. As only IPv4 addresses have broadcast addresses, null would be returned on using an IPv6 address. |\r
| public short getNetworkPrefixLength() | Returns the prefix length for this interface address, i.e. subnet mask for this address.                                                                                        |\r
\r
\`\`\`java\r
// Java program to illustrate methods of java.net.InterfaceAddress class\r
\r
public class InterfaceaddressExample\r
{\r
    public static void main(String[] args) throws SocketException\r
    {\r
        // Modify according to your system\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
        List<InterfaceAddress> list = nif.getInterfaceAddresses();\r
\r
        for (InterfaceAddress iaddr : list)\r
        {\r
            // getAddress() method\r
            System.out.println("getAddress() : " + iaddr.getAddress());\r
\r
            // getBroadcast() method\r
            System.out.println("getBroadcast() : " + iaddr.getBroadcast());\r
\r
            // getNetworkPrefixLength() method\r
            System.out.println("PrefixLength : " + iaddr.getNetworkPrefixLength());\r
\r
            // hashCode() method\r
            System.out.println("Hashcode : " + iaddr.hashCode());\r
\r
            // toString() method\r
            System.out.println("toString() : " + iaddr.toString());\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.3. java.net.InetAddress\r
\r
Java InetAddress class represents an IP address. The java.net.InetAddress class provides methods to get the IP of any host name for example www.google.com, www.facebook.com, etc.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)\r
\r
An instance of InetAddress represents the IP address with its corresponding host name. There are two types of addresses: Unicast and Multicast. The Unicast is an identifier for a single interface whereas Multicast is an identifier for a set of interfaces.\r
\r
::: warning Local Name Resolver (hosts file)\r
You should know that DNS translates domain names like into IP addresses. But did you know that there’s a file on your system that can override that?\r
It’s called your hosts file and lets you map specific domain names to an IP address of your choosing. Your HOSTS file only affects your computer, so you can use it to create custom URLs for IP addresses on your network, or you can use it to redirect certain websites.\r
\r
As you can imagine, editing the HOSTS file can easily break your internet if it’s modified incorrectly or maliciously. So, it’s not particularly easy for a normal user to edit. This is a good thing.\r
\r
- Windows\r
\r
The HOSTS file is normally stored in a plain text file in the Windows System folder.\r
\r
Hit the start menu or press the Windows key and start typing Notepad.\r
\r
Right-click Notepad and choose Run as administrator.\r
\r
In Notepad, click File then Open… In the File name field, paste the following path in:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Now you’ll be able to edit and save changes to your HOSTS file.\r
\r
To map a domain, add a line based on the examples in the HOSTS file.\r
\r
- OS X & GNU/Linux\r
\r
The file is in /etc/hosts and you should edit it with administrator privileges.\r
\r
\`\`\`bash\r
# Add the following lines to the hosts file\r
## At school\r
##  - use your computer IP for the 'cliente' and 'servidor' entries.\r
##  - use the teacher's computer IP as the 'profesor' entry\r
## At home\r
##  - use your computer IP for the 'cliente', 'servidor' and 'profesor' entries.\r
\r
# In all the activities, we will always use these domain names \r
# making our apps work at home and at school without having to change any IP address.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
| Method                                                                       | Description                                                                      |\r
| ---------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |\r
| public static InetAddress getByName(String host) throws UnknownHostException | It returns the instance of  InetAddress containing LocalHost IP and name.        |\r
| public static InetAddress getLocalHost() throws UnknownHostException         | It returns the instance of InetAdddress  containing local host name and address. |\r
| public String getHostName()                                                  | It returns the host name of the IP address.                                      |\r
| public String getHostAddress()                                               | It returns the IP address in string format.                                      |\r
| public boolean isReachable(int timeout)                                      | This method tests whether that address is reachable.                             |\r
\r
\`\`\`java\r
\r
class InetAddressExample {\r
    public static void main(String[] args)\r
        throws UnknownHostException\r
    {\r
        // To get and print InetAddress of Local Host\r
        InetAddress address1 = InetAddress.getLocalHost();\r
        System.out.println("InetAddress of Local Host : "\r
                        + address1);\r
\r
        // To get and print InetAddress of Named Host\r
        InetAddress address2\r
            = InetAddress.getByName("45.22.30.39");\r
        System.out.println("InetAddress of Named Host : "\r
                        + address2);\r
\r
        // To get and print ALL InetAddresses of Named Host\r
        InetAddress address3[]\r
            = InetAddress.getAllByName("172.19.25.29");\r
        for (int i = 0; i < address3.length; i++) {\r
            System.out.println(\r
                "ALL InetAddresses of Named Host : "\r
                + address3[i]);\r
        }\r
\r
        // To get and print InetAddresses of\r
        // Host with specified IP Address\r
        byte IPAddress[] = { 125, 0, 0, 1 };\r
        InetAddress address4\r
            = InetAddress.getByAddress(IPAddress);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address : "\r
            + address4);\r
\r
        // To get and print InetAddresses of Host\r
        // with specified IP Address and hostname\r
        byte[] IPAddress2\r
            = { 105, 22, (byte)223, (byte)186 };\r
        InetAddress address5 = InetAddress.getByAddress(\r
            "gfg.com", IPAddress2);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address and hostname : "\r
            + address5);\r
    }\r
}\r
\r
\`\`\`\r
\r
::: question Host seeker (U4S4_HostSeeker)\r
Your computer is connected to a LAN (Local Area Network) and probably it is using private IP addresses.\r
\r
Addresses can be one of class C (192.168.X.Y), class B (172.17.X.Y) or class A (10.X.Y.Z). That depends on the network mask or network prefix used for the network interface configuration.\r
\r
You can also check it using Linux **ifconfig** command or Windows **ipconfig** command.\r
\r
Write a program to know which hosts are up and running in your network, that is, which hosts are reachable from you computer by using one of the interfaces.\r
\r
First, you can write specific code to test your network.\r
Once your app is working, try to make it generic and reusable by making it work in any network, detecting the network prefix and checking all the possible IPs in a network.\r
\r
The app will get a Network interface card name as argument and will check only the IPv4 addresses attached to that interface. We can know if an IP is IPv4 or IPv6 using the operator \`ìnstanceof\` with Inet4Address and  Inet6Address subclasses of InetAddress\r
:::\r
\r
::: details Code for the example\r
\r
\`\`\`java\r
public class U4S4_HostSeeker {\r
\r
    private final int timeout = 10;\r
    private String interfaceName;\r
    private String ipAddress;\r
    private String networkMask;\r
\r
    private ArrayList<String> reachableIps = new ArrayList<>();\r
\r
    public static void main(String[] args)\r
            throws UnknownHostException, IOException {\r
\r
        U4S4_HostSeeker seeker = new U4S4_HostSeeker(args);\r
        System.out.println("Scanning...");\r
        seeker.processNetwork();\r
        seeker.listResults();\r
    }\r
\r
    public U4S4_HostSeeker(String[] args) throws SocketException, UnknownHostException {\r
        NetworkInterface networkCard = null;\r
\r
        switch (args.length) {\r
            case 1 -> {\r
                // Get the interface from the name\r
                interfaceName = args[0];\r
                                \r
                networkCard = NetworkInterface.getByName(interfaceName);\r
\r
                // Get the IP and the mask from the NetworkInterface\r
                List<InterfaceAddress> cardAddresses = networkCard.getInterfaceAddresses();\r
                for (InterfaceAddress ifAddr : cardAddresses) {\r
                    if (ifAddr.getAddress() instanceof Inet4Address) {\r
                        ipAddress = ifAddr.getAddress().getHostAddress();\r
                        networkMask = Integer.toString(ifAddr.getNetworkPrefixLength());\r
                    }\r
                }\r
\r
            }\r
            case 2 -> {\r
                // Get the IP and mask\r
                ipAddress = args[0];\r
                networkMask = args[1];\r
\r
                // Get the interface name from the assigned IP\r
                networkCard = NetworkInterface.getByInetAddress(InetAddress.getByName(ipAddress));\r
                interfaceName = networkCard.getName();\r
            }\r
            default -> {\r
                // In order to find the right interface name... run the app with no args\r
                NetworkInterface.networkInterfaces().forEach((t) -> {\r
                    try {\r
                        if (t.isUp())\r
                            System.out.println(t.getName() + " --> " + t.getDisplayName() + " : " + t.inetAddresses().findFirst().toString());\r
                    } catch (SocketException ex) {\r
                        Logger.getLogger(U4S4_HostSeeker.class.getName()).log(Level.SEVERE, null, ex);\r
                    }\r
                });\r
                \r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker IP maskLength");\r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker interfaceName");\r
                throw new AssertionError();\r
            }\r
        }\r
\r
    }\r
\r
    private void processNetwork() throws IOException {\r
        String baseAddress;\r
        String[] addressParts = ipAddress.split("\\\\.");\r
        switch (networkMask) {\r
            case "24" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + "." + addressParts[2] + ".";\r
                checkClassCNetwork(baseAddress);\r
\r
            }\r
            case "16" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + ".";\r
                checkClassBNetwork(baseAddress);\r
            }\r
            case "8" -> {\r
                baseAddress = addressParts[0] + ".";\r
                checkClassANetwork(baseAddress);\r
\r
            }\r
            default ->\r
                throw new AssertionError();\r
        }\r
    }\r
\r
    // Check for /24 networks \r
    private void checkClassCNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        System.out.println("Checking network " + baseAddress + "0...");\r
        for (int i = 1; i < 255; i++) {\r
            InetAddress tempIP = InetAddress.getByName(baseAddress + i);\r
            if (tempIP.isReachable(timeout)) {\r
                addReachableIp(tempIP.getHostAddress());\r
            }\r
        }\r
    }\r
\r
    // Check for /16 networks \r
    private void checkClassBNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class C adresses: " + baseAddress + i + ".xxx");\r
            checkClassCNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    // Check for /8 networks \r
    private void checkClassANetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class B adresses: " + baseAddress + i + ".xxx");\r
            checkClassBNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    private /*synchronized*/ void addReachableIp(String ip) {\r
        reachableIps.add(ip);\r
    }\r
\r
    private void listResults() {\r
        System.out.println("Reachable IPs:");\r
        for (String ip : reachableIps) {\r
            System.out.println("--> " + ip);\r
        }\r
    }\r
}\r
   \r
\`\`\`\r
\r
:::\r
\r
## 4.2.4 java.net.URL\r
\r
The Java URL class represents an URL. URL is an acronym for Uniform Resource Locator.\r
\r
> [java.net.URL specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html)\r
\r
It points to a resource on the World Wide Web. For example:\r
\r
> http://psp2dam.github.io/psp_pages/\r
\r
A URL contains many information:\r
\r
- **Protocol**: In this case, \`http\` is the protocol.\r
- **Server name or IP Address**: In this case, \`psp2dam.github.io\` is the server name.\r
- **Port Number**: It is an optional attribute. Many times it is derived from the protocol, by chosing its standard default port. In the example the port is missing but it is set to \`80\`.\r
- **File Name or directory name**: In this case, only the path (directory) is specified in the URL. Depending on the server configuration the file name can take a default value. In the example \`index.html\` is the file name.\r
\r
| Constructor                                                                        | Description                                                                                               |\r
| ---------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\r
| URL(String spec)                                                                   | Creates an instance of a URL from the String representation.                                              |\r
| URL(String protocol, String host, int port, String file)                           | Creates an instance of a URL from the given protocol, host, port number, and file.                        |\r
| URL(String protocol, String host, int port, String file, URLStreamHandler handler) | Creates an instance of a URL from the given protocol, host, port number, file, and handler.               |\r
| URL(String protocol, String host, String file)                                     | Creates an instance of a URL from the given protocol name, host name, and file name.                      |\r
| URL(URL context, String spec)                                                      | Creates an instance of a URL by parsing the given spec within a specified context.                        |\r
| URL(URL context, String spec, URLStreamHandler handler)                            | Creates an instance of a URL by parsing the given spec with the specified handler within a given context. |\r
\r
The java.net.URL class provides many methods. The important methods of URL class are given below.\r
\r
| Method                                | Description                                                                                    |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------- |\r
| public String getProtocol()           | it returns the protocol of the URL.                                                            |\r
| public String getHost()               | it returns the host name of the URL.                                                           |\r
| public String getPort()               | it returns the Port Number of the URL.                                                         |\r
| public String getFile()               | it returns the file name of the URL.                                                           |\r
| public String getAuthority()          | it returns the authority of the URL.                                                           |\r
| public String toString()              | it returns the string representation of the URL.                                               |\r
| public String getQuery()              | it returns the query string of the URL.                                                        |\r
| public String getDefaultPort()        | it returns the default port of the URL.                                                        |\r
| public URLConnection openConnection() | it returns the instance of URLConnection i.e. associated with this URL.                        |\r
| public InputStream openStream()       | it opens a connection to this URL and returns an InputStream for reading from that connection. |\r
| public boolean equals(Object obj)     | it compares the URL with the given object.                                                     |\r
| public Object getContent()            | it returns the content of the URL.                                                             |\r
| public String getRef()                | it returns the anchor or reference of the URL.                                                 |\r
| public URI toURI()                    | it returns a URI of the URL.                                                                   |\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args) throws MalformedURLException{  \r
\r
    URL url=new URL("http://psp2dam.github.io/psp_pages");  \r
  \r
    System.out.println("Protocol: "+url.getProtocol());  \r
    System.out.println("Host Name: "+url.getHost());  \r
    System.out.println("Port Number: "+url.getPort());  \r
    System.out.println("File Name: "+url.getFile());  \r
}   \r
\`\`\`\r
\r
Let us see another example URL class in Java.\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args){    \r
    URL url=new URL("https://www.google.com/search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8");    \r
        \r
    System.out.println("Protocol: "+url.getProtocol());    \r
    System.out.println("Host Name: "+url.getHost());    \r
    System.out.println("Port Number: "+url.getPort());    \r
    System.out.println("Default Port Number: "+url.getDefaultPort());    \r
    System.out.println("Query String: "+url.getQuery());    \r
    System.out.println("Path: "+url.getPath());    \r
    System.out.println("File: "+url.getFile());      \r
}    \r
\`\`\`\r
\r
\`\`\`bash:no-line-numbers{3}\r
Protocol: https\r
Host Name: www.google.com\r
Port Number: -1\r
Default Port Number: 443\r
Query String: q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
Path: /search\r
File: /search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
\`\`\`\r
\r
## 4.2.5 java.net.URLConnection\r
\r
The Java URLConnection class represents a communication link between the URL and the application. It can be used to read and write data to the specified resource referred by the URL.\r
\r
> [java.net.URLConnection specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html)\r
\r
URLConnection is an abstract class. The two subclasses \`HttpURLConnection\` and \`JarURLConnection\` makes the connection between the client Java program and URL resource on the internet.\r
\r
With the help of URLConnection class, a user can read and write to and from any resource referenced by an URL object. Once a connection is established and the Java program has an URLConnection object, we can use it to read or write or get further information like content length, etc.\r
\r
The URLConnection class provides many methods. We can display all the data of a webpage by using the getInputStream() method. It returns all the data of the specified URL in the stream that can be read and displayed.\r
\r
| Method                                | Description                                                                                    |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------- |\r
| void connect() | It opens a communications link to the resource referenced by this URL, if such a connection has not already been established. |\r
| Object getContent() | It retrieves the contents of the URL connection. |\r
| String getContentEncoding() | It returns the value of the content-encoding header field. |\r
| int getContentLength() | It returns the value of the content-length header field. |\r
| long getContentLengthLong() | It returns the value of the content-length header field as long. |\r
| String getContentType() | It returns the value of the date header field. |\r
| long getDate() | It returns the value of the date header field. |\r
| boolean getDoInput() | It returns the value of the URLConnection's doInput flag.|\r
| boolean getDoInput() | It returns the value of the URLConnection's doOutput flag.|\r
| String getHeaderField(int n) | It returns the value of nth header field|\r
| String getHeaderField(String name) | It returns the value of the named header field.|\r
| String getHeaderFieldKey(int n) | It returns the key for the nth header field.|\r
| Map<String, List&lt;String&gt;> getHeaderFields() | It returns the unmodifiable Map of the header field.|\r
| long getIfModifiedSince() | It returns the value of the object's ifModifiedSince field.|\r
| InputStream getInputStream() | It returns an input stream that reads from the open condition.|\r
| long getLastModified() | It returns the value of the last-modified header field.|\r
| OutputStream getOutputStream() | It returns an output stream that writes to the connection.|\r
| URL getURL() | It returns the value of the URLConnection's URL field.|\r
| void setDoInput(boolean doinput) | It sets the value of the doInput field for this URLConnection to the specified value.|\r
|void setDoOutput(boolean dooutput) | It sets the value of the doOutput field for the URLConnection to the specified value.|\r
\r
::: info How to get the object of URLConnection Class\r
The openConnection() method of the URL class returns the object of URLConnection class.\r
:::\r
\r
\`\`\`java{11}\r
// URLConnectionExample\r
public static void main(String[] args) throws MalformedURLException, IOException{\r
\r
    // Creating an object of URL class\r
\r
    // Custom input URL is passed as an argument\r
    URL u = new URL("www.google.com");\r
\r
    // Creating an object of URLConnection class to\r
    // communicate between application and URL\r
    URLConnection urlconnect = u.openConnection();\r
\r
    // Creating an object of InputStream class\r
    // for our application streams to be read\r
    InputStream stream\r
        = urlconnect.getInputStream();\r
\r
    BufferedReader in =  \r
        new BufferedReader(\r
            new InputStreamReader(stream));\r
    // Till the time URL is being read\r
    String line;\r
    while ((line = in.readLine()) != null) {\r
\r
        // Continue printing the stream\r
        System.out.println(line);\r
    }\r
}\r
\`\`\`\r
\r
::: warning MalformedURLException\r
If you test the previous code, you will get a \`MalformedURLException\` exception.\r
What should you change to make it work?\r
:::\r
\r
::: question Images downloader (U4S7_ImagesDownloader)\r
Create an application to download images from a URL.\r
The image URL must be given as an application argument and the image has to be saved in a images folder on the root of your project.\r
:::\r
\r
::: details Code for the example\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
`]},{title:"6.4 Encriptación asimétrica",headers:[{level:2,title:"6.4.1. Clave pública y clave privada",slug:"_6-4-1-clave-publica-y-clave-privada",link:"#_6-4-1-clave-publica-y-clave-privada",children:[]},{level:2,title:"6.4.2. Firma digital",slug:"_6-4-2-firma-digital",link:"#_6-4-2-firma-digital",children:[{level:3,title:"Integridad",slug:"integridad",link:"#integridad",children:[]},{level:3,title:"Autenticación y no repudio",slug:"autenticacion-y-no-repudio",link:"#autenticacion-y-no-repudio",children:[]}]},{level:2,title:"6.4.3 Certificados digitales",slug:"_6-4-3-certificados-digitales",link:"#_6-4-3-certificados-digitales",children:[{level:3,title:"Claves digitales",slug:"claves-digitales",link:"#claves-digitales",children:[]},{level:3,title:"Infraestructura de clave pública (PKI)",slug:"infraestructura-de-clave-publica-pki",link:"#infraestructura-de-clave-publica-pki",children:[]}]},{level:2,title:"6.4.4. Generación de pares de claves",slug:"_6-4-4-generacion-de-pares-de-claves",link:"#_6-4-4-generacion-de-pares-de-claves",children:[{level:3,title:"Tipos de ficheros para certificados digitales",slug:"tipos-de-ficheros-para-certificados-digitales",link:"#tipos-de-ficheros-para-certificados-digitales",children:[]},{level:3,title:"Generación de claves desde Java",slug:"generacion-de-claves-desde-java",link:"#generacion-de-claves-desde-java",children:[]}]},{level:2,title:"6.4.5. Cifrado y descifrado usando un par de claves",slug:"_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",link:"#_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",children:[]},{level:2,title:"6.2.3. Cifrado asimétrico con GnuPG",slug:"_6-2-3-cifrado-asimetrico-con-gnupg",link:"#_6-2-3-cifrado-asimetrico-con-gnupg",children:[]}],path:"/en/unit6/asymmetric-keys.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.4 Encriptación asimétrica\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.4 Encriptación asimétrica" />\r
\r
# 6.4 Encriptación asimétrica\r
\r
[[toc]]\r
\r
## 6.4.1. Clave pública y clave privada\r
\r
La criptografía asimétrica o **criptografía de clave pública** supuso una auténtica revolución en su momento. Permitía el intercambio seguro de información (confidencialidad, autenticación y no repudio) entre interlocutores que no compartían ningún secreto.\r
\r
Se creó en los años 70 a partir del trabajo de *Diffie y Hellman* por una parte y de *Rivest, Shamir y Adleman* por otra.\r
\r
Se basa en la existencia de un par de claves, una pública y otra privada, entre las cuales existe una relación matemática, de manera que es muy difícil obtener la clave privada a partir de la pública. Sin embargo, es muy sencillo obtener la clave pública a partir de la privada.\r
\r
::: info Algoritmo RSA\r
En la familia de algoritmos RSA (Rivest, Shamir y Adleman) la clave pública consiste en un número que es el producto de dos factores primos muy grandes (mayores que 10^100) y la clave privada se deriva de la factorización de dicho número, es decir, los dos factores primos.\r
\r
Requiere poco procesamiento multiplicar dos números primos tan grandes, pero requiere una cantidad enorme de cálculos encontrar la factorización del número.\r
:::\r
\r
A diferencia del cifrado simétrico, el el cifrado asimétrico se usan funciones diferentes para cifrar y descifrar los mensajes.\r
\r
- Para **encriptación** se usa la **clave pública**. Cualquiera puede tener acceso a la clave pública, mediante la cual, usando la función de cifrado, se encripta la información dirigida a un destinatario concreto (el propietario de la clave privada asociada).\r
- Para **desencriptación** se usa la **clave privada**, que debe mantenerse a buen recaudo ya que sólo con esa clave y la función de descifrado se puede desencriptar un mensaje cifrado con la clave pública correspondiente.\r
\r
Entre los algoritmos de cifrado asimétrico más utilizados se encuentran\r
\r
- Rivest Shamir Adleman (RSA). Basado en la factorización de números primos grandes.\r
- Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).\r
- Elliptical Curve Cryptography (ECC). Está basado en las matemáticas de las curvas elípticas\r
- the Diffie-Hellman exchange method.\r
- TLS/SSL protocol.\r
\r
![cifrado asimétrico](../../media/unit6/asymmetric-encryption-primitive.png)\r
\r
## 6.4.2. Firma digital\r
\r
Con la firma digital Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
![cifrado asimétrico](../../media/unit6/proceso-firma-digital.png)\r
\r
El proceso básico que se sigue para la firma electrónica es el siguiente:\r
\r
1. El usuario dispone de un documento electrónico (una hoja de cálculo, un pdf, una imagen, incluso un formulario en una página web) y de un **certificado** (clave pública y clave privada) que le pertenece y le identifica.\r
2. La aplicación o dispositivo digital utilizados para la firma realiza un **resumen del documento**. El resumen de un documento de gran tamaño puede llegar a ser tan solo de unas líneas. Este resumen es único y cualquier modificación del documento implica también una modificación del resumen.\r
3. La aplicación utiliza la clave privada para codificar el resumen.\r
4. La aplicación crea otro documento electrónico que contiene ese resumen codificado. Este nuevo documento es la firma electrónica.\r
\r
El resultado de todo este proceso es un documento electrónico obtenido a partir del documento original y de las claves del firmante. La firma electrónica, por tanto, es el mismo documento electrónico resultante.\r
\r
![verificación de firma digital](../../media/unit6/digital-signature-sign-verify.png)\r
\r
### Integridad\r
\r
Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificación respecto al momento en el que se firmó, garantizando de esta forma la integridad de la información firmada.\r
\r
### Autenticación y no repudio\r
\r
Por las características de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave pública, que el mensaje recibido lo generó el propietario de la clave privada.\r
\r
Con esta característica se puede probar y demostrar que el mensaje lo firmó el emisor y no cualquier otra persona, garantizando por un lado la autoría y por otro evitando que el emisor niegue haber generado esa información.\r
\r
## 6.4.3 Certificados digitales\r
\r
Un certificado digital es un documento electrónico expedido por una **Autoridad de Certificación** e identifica a una persona (física o jurídica) con un par de claves.Tiene como misión validar y certificar que una firma electrónica se corresponde con una persona o entidad concreta.\r
\r
Contiene la información necesaria para firmar electrónicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiración y organismo que lo expide.\r
\r
La Autoridad de Certificación da fe de que la firma electrónica se corresponde con un usuario concreto. Esa es la razón por la que los certificados están firmados, a su vez, por la Autoridad de Certificación.\r
\r
### Claves digitales\r
\r
En un certificado, las claves digitales son los elementos esenciales para la firma e identificación del firmante. Existen dos claves, la **clave privada** y **clave pública**, y trabajan de forma complementaria. *Lo que cifra o codifica una clave sólo lo puede descifrar o decodificar la otra*.\r
\r
La diferencia entre ellas es que la clave privada está pensada para que nunca salga del certificado y esté siempre bajo el control del firmante. En cambio, la clave pública se puede repartir o enviar a otros usuarios.\r
\r
En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la pública y del Certificado Público para referirse al certificado que sólo contiene la clave pública.\r
\r
::: info Creación de Certificados digitales\r
Obtener el Certificado Digital depende de si el certificado está contenido en una tarjeta, como el DNIe, o de si el certificado se guarda en un fichero software.\r
\r
En ambos procesos hay un paso que es la identificación del responsable o usuario del certificado, lo cual requiere que éste **se persone en las oficinas de una Autoridad de Registro**. Estas oficinas corroboran la identidad.\r
:::\r
\r
### Infraestructura de clave pública (PKI)\r
\r
Una infraestructura de clave pública (PKI) es una combinación de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecución con garantías de operaciones criptográficas, cumpliendo los requisitos de integridad, confidencialidad, autenticación y no repudio.\r
\r
Una PKI permite establecer y gestionar asociaciones entre claves públicas e identidades de personas y organizaciones.\r
\r
La cuestión entonces es determinar si un certificado es válido o de confianza, ol o que es lo mismo, si representa a la persona u organización que aparece como titular y propietario  del certificado.\r
\r
Para dar por válido un certificado digital su firma digital debe ser válida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qué emisores son de confianza.\r
\r
::: warning Autenticidad de los certificados\r
Los certificados deben estar firmados por una AC por dos motivos\r
\r
1. Garantizar su integridad, de forma que cualquier intento de modificación del certificado lo invalide.\r
2. Identificar al creador del certificado digital. Todo el sistema está basado en una relación de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones públicas o privadas de reconocido prestigio\r
:::\r
\r
En nuestro sistema podemos ver y modificar qué entidades de certificación consideramos como seguras, es decir, que los certificados que éstas hayan firmado los tomaremos como válidos.\r
\r
[Autoridades de confianza para apps de Azure](https://docs.microsoft.com/es-es/exchange/trusted-root-certification-authorities-for-federation-trusts-exchange-2013-help)\r
\r
En Windows, si ejecutamos \`certmgr.msc\` podemos acceder a la configuración de certificados del sistema. En OSX lo podemos hacer con la aplicación \`Llavero\`.\r
\r
Para nuestra navegación, la información de qué certificados considera el navegador como seguros, depende de en qué AC confiemos (por defecto en la instalación vienen configurados los más comunes)\r
\r
[Ver certificados y AC en Chrome](https://www.adminfacil.es/como-ver-los-certificados-instalados-en-google-chrome/)\r
\r
::: danger Certificados autofirmados\r
**Hemos de tener en cuenta que, con herramientas como las que proporciona Java, SSH o GnuPG cualquiera puede generar un certificado digital con la información que quiera**\r
\r
Para las pruebas vamos a firmar nuestros propios certificados. Incluso dentro de una compañía podemos ejercer nosotros mismos como Autoridad de Certificación de Confianza, firmando nuestros certificados.\r
\r
Debemos preparar la configuración de nuestros sistemas para que **confíen** en esos certificados autofirmados, asumiendo el riesgo que esto conlleva.\r
:::\r
\r
## 6.4.4. Generación de pares de claves\r
\r
La generación y gestión de pares de claves implica dos aspectos fundamentales.\r
\r
Por un lado, tenemos la creación de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuación, se pueden generar desde una aplicación, igual que hacemos con las claves simétricas.\r
\r
Por otro lado, tenemos la gestión del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados \`keyrings\` a los que puede acceder una aplicación y desde los que gestionamos las relaciones de confianza.\r
\r
El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generación de números aleatorios para satisfacer unos requisitos mínimos de seguridad.\r
\r
::: info SecureRandom\r
La generación de números aleatorios juega un papel fundamental en la criptografía, siendo uno de los **Engine** que proporciona el JCA junto con un amplio grupo de algoritmos.\r
\r
La clase **SecureRandom** genera número aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto simétricas como asimétricas\r
:::\r
\r
### Tipos de ficheros para certificados digitales\r
\r
Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el estándar X.509. Generalmente uncertificado no contiene sólo la clave, sino que tiene información adicional.\r
\r
Esxiten dos posibles codificaciones para almacenar certificados X.509\r
\r
- der: Es una codificación binaria\r
- dem: Es una codificación en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado\r
\r
Veamos un ejemplo de certificado con codificación dem\r
\r
\`\`\`sh\r
-----BEGIN CERTIFICATE----- \r
MIIDijCCAvOgAwIBAgIJAKRvtQxONVZoMA0GCSqGSIb3DQEBBAUAMIGLMQswCQYD \r
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxl \r
MSAwHgYDVQQKExdBcnViYSBXaXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFD \r
MSMwIQYDVQQDExpteXNlcnZlci5hcnViYW5ldHdvcmtzLmNvbTAeFw0wODA0MzAy \r
MzM3MDJaFw0xMDA0MzAyMzM3MDJaMIGLMQswCQYDVQQGEwJVUzETMBEGA1UECBMK \r
Q2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxlMSAwHgYDVQQKExdBcnViYSBX \r
aXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFDMSMwIQYDVQQDExpteXNlcnZl \r
ci5hcnViYW5ldHdvcmtzLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA \r
zRwqc9prVXycGhHcsAjGPzC2MKU4DhXSr86Z89Jk8/cXEJBJ0C/NgdAqqDgxneUh \r
nVyxGxODa7BNGAWSagdCsKLrbkchr479E3xLfgdc3UzAJITLGCXGiQ66NwQDyM5I \r
G/xKYm4oqgyOE/lFTTkK0M8V0NmmJynyOCYC/AwQKjMCAwEAAaOB8zCB8DAdBgNV \r
HQ4EFgQUM5btT6IlPGkLTTPvFccTVURO1p0wgcAGA1UdIwSBuDCBtYAUM5btT6Il \r
PGkLTTPvFccTVURO1p2hgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD \r
YWxpZm9ybmlhMRIwEAYDVQQHEwlTdW5ueXZhbGUxIDAeBgNVBAoTF0FydWJhIFdp \r
cmVsZXNzIE5ldHdvcmtzMQwwCgYDVQQLEwNUQUMxIzAhBgNVBAMTGm15c2VydmVy \r
LmFydWJhbmV0d29ya3MuY29tggkApG+1DE41VmgwDAYDVR0TBAUwAwEB/zANBgkq \r
hkiG9w0BAQQFAAOBgQBp71WeF6dKvqUSO1JFsVhBeUesbEgx9+tx6eP328uL0oSC \r
fQ6EaiXZVbrQt+PMqG0F80+4wxVXug9EW5Ob9M/opaCGI+cgtpLCwSf6CjsmAcUc \r
b6EjG/l4HW2BztYJfx15pk51M49TYS7okDKWYRT10y65xcyQdfUKvfDC1k5P9Q== \r
-----END CERTIFICATE-----\r
\`\`\`\r
\r
Además de la codificación, tenemos formatos de fichero estándar para guardar los certificados usando una de las codificaciones anteriores\r
\r
- cer, crt, der: Contienen certificados X.509 estándares codificados como \`der\`\r
- p12: Realmente hace referencia a toda una familia de estándares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, además de los datos del certificado, una clave privada. Si contiene la clave privada, ésta estará protegida por una contraseña que será necesaria para acceder a la clave privada. [PKCS en Wikipedia](https://es.wikipedia.org/wiki/PKCS)\r
\r
### Generación de claves desde Java\r
\r
Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde código\r
\r
1. El primer paso para obtener un par de claves es obtener un objeto *keyPairGenerator* para el algoritmo que queramos utilizar.\r
2. A continuación se inicializa el generador del par de claves llamando a alguna de las versiones del método *initialize*. En nuestro caso indicaremos el tamaño de clave para el algoritmo seleccionado y un generador de números aleatorios.\r
3. El último paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.\r
4. A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer será guardarlas en sendos archivos.\r
\r
A continuación podemos ver un ejemplo de generación de claves, almacenamiento de las claves en un fichero y visualización de la clave obtenida.\r
\r
\`\`\`java{14,15,18-20,39,52}\r
public class U6S4_1_GenerateRsaKeyPair {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            // Elijo un algoritmo de generación de números aleatorios de los denominados\r
            // altamente seguros para generar el par de claves\r
            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\r
            // Preparo el generados de claves para usar el algortimo RSA\r
            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\r
            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\r
\r
            // Creo el par de claves y lo guardo en objetos\r
            KeyPair parClaves = genParClaves.generateKeyPair();\r
            PublicKey clavePublica = parClaves.getPublic();\r
            PrivateKey clavePrivada = parClaves.getPrivate();\r
\r
            // Guardamos la clave pública en un archivo y la visualizamos\r
            // La clave se guarda con codificación DER y en formato X.509\r
            guardaClavePublicaX509(clavePublica);\r
            \r
            // Guardamos la clave privada en un archivo y la visualizamos\r
            // La clave se guarda con codificación DER y en formato PKCS#8\r
            guardaClavePrivadaPKCS8(clavePrivada);\r
            \r
\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algortimo en ningún Provider");\r
        }\r
\r
    }\r
\r
    private static void guardaClavePublicaX509(PublicKey clavePublica) {\r
        try (FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\r
            publicKeyFile.write(clavePublica.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\r
                    codificacionClavePublica.getFormat(), ficheroClavePublica);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave pública en " + ficheroClavePublica);\r
        }                \r
    }\r
\r
    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\r
        try (FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\r
            privateKeyFile.write(clavePrivada.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\r
                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave privada en " + ficheroClavePrivada);\r
        }        \r
    }\r
\r
    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\r
        System.out.println("Clave guardada en formato " + formatoClave \r
                + " en fichero " + ficheroClave);\r
        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll("(.{76})", "$1\\n"));\r
    }\r
}\r
\`\`\`\r
\r
Esta sería la salida proporcionada\r
\r
\`\`\`sh\r
Clave guardada en formato X.509 en fichero claves/clavepublica.der\r
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4UFRgEIm3lFKO75QmqTPvkDs0fM6NUm2FHQcA\r
cQHawLx9/WKXh9xkx/xYZZcc4L2YQYcwTu4jfk889iGKGLn2Kh4ywBY+g8uZ6ljM5PT6f95dU6Zd\r
xATWOn1qsizBubf7kKhBL7xDnKU5do3XYzrSjme+9uIsgS7HQ7K0MbKrpQIDAQAB\r
\r
Clave guardada en formato PKCS#8 en fichero claves/claveprivada.pkcs8\r
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALhQVGAQibeUUo7vlCapM++QOzR8\r
zo1SbYUdBwBxAdrAvH39YpeH3GTH/FhllxzgvZhBhzBO7iN+Tzz2IYoYufYqHjLAFj6Dy5nqWMzk\r
9Pp/3l1Tpl3EBNY6fWqyLMG5t/uQqEEvvEOcpTl2jddjOtKOZ7724iyBLsdDsrQxsqulAgMBAAEC\r
gYA97xBLL4N3YqnTSgIYc6b2Cxs56e5mYppWrohZx5996GHuXCSzEn4mh2TuN0Tt+T78WJiazQsM\r
djceHv7qLqDd2kWn3IR0gX207KxwjG0I/sAP2z/i9NZ7DPL+FUv8lmeYUfDj8h3wkyhmBqn+tan1\r
0xIOcZUrr/yRhrjZLI1SCQJBAPEc4uWSbyBLHVC6SNga7XWNmwi8Mq4PZJdhW9RJWDxg9zOlC/HV\r
rV60ddbfW/ldIqCH33DUge5U5YhD6Mla/XMCQQDDsahcwTksp2bJowMTRgFHT094sihtSlQ7sgdI\r
uAemuMvBmVTHleFBWMqz1rAN6A/76yef3WK4I+nsmeCGa+yHAkEA7BR1kYT8q+kATi/n7TkIcoZx\r
W28yTD2kJ5jbWhNqgswKn5WmCWdH9qfJjddrbdEke3wuaoKYqeyURgUAJE+kQwJADhEsQBanrH0Q\r
F3h/VRhYKS8bUFrGKy0Hpw7iFSkda6+m/fCutnYgrhja4ViSaT2AQKSjwYsheIkkXJynFiKV6wJA\r
PUHXqlvfgPr4w2U+Ddq7h/gp59kO0uojGrEBO0B2wt3PuuSQlZlMN97Ly9QmB6LYRtw6woCZZZOD\r
ePqA7rf8IA==\r
\`\`\`\r
\r
En el ejemplo anterior en lugar de utilizar clases estándar para volcar el contenido binario de las claves a un archivo en formato raw, se utilizan clases codificadoras para generar ficheros binarios en formatos estándares, tanto para la clave pública como para la privada.\r
\r
Esto tiene la enorme ventaja de que se pueden utilizar las claves generadas con herramientas estándar como openssl. Además, facilita la tarea ya que las claves pública y privada para criptografía asimétrica son objetos compuestos.\r
\r
::: info Codificación Base64\r
Base64 es un grupo de esquemas de codificación de binario a texto que representa los datos binarios mediante una cadena.\r
\r
Los esquemas de codificación Base64 son comúnmente usados cuando se necesita codificar datos binarios para que sean almacenados y transferidos sobre un medio diseñado para tratar con datos textuales. Esto es para asegurar que los datos se mantienen intactos y sin modificaciones durante la transmisión.\r
\r
Los valores codificados en Base64 como texto se muestran en filas de 76 caracteres como máximo, para mejor legibilidad, y siguiendo convenciones habituales.\r
\r
Para verlos en pantalla se añade un salto de línea después de cada grupo de 76 caracteres usando  \`replaceAll("(.{76})", "$1\\n")\`.\r
:::\r
\r
Las claves que se han guardado con el programa tienen las siguientes características:\r
\r
- La clave pública se guarda en un fichero \`clavepublica.der\`, con el formato de la estructura *SubjectPublicKeyInfo* en formato *ASN.1* definido en el estándar *X.509*, y con codificación *DER (binaria)*. Para eso se ha utilizado la clase codificadora **X509EncodedKeySpec**.\r
- La clave privada se guarda en un fichero \`claveprivada.pkcs8\`, en formato *PKCS#8*, y con codificación *DER (binaria)*. Para eso se ha utilizado la clase codificadora **PKCS8EncodedKeySpec**.\r
\r
::: info Codificaciones por defecto\r
Las codificaciones usadas en el programa coinciden con las codificacione por defecto que usan las clases PrivateKey y PublicKey, como se puede ver en los valores proporcionados por los métodos getFormat() y getEncoded().\r
:::\r
\r
## 6.4.5. Cifrado y descifrado usando un par de claves\r
\r
Aunque ya hemos visto que las claves se pueden generar desde código, lo normal es que una vez hayamos generado un par de claves, estas se puedan reutilizar desde las aplicaciones para cifrar y descifrar información.\r
\r
Si hemos guardado las claves en archivos, el primer paso que tendremos que realizar es recuperar esas claves para poder realizar las operaciones criptográficas con ellas.\r
\r
::: question Prueba de claves online\r
Podemos probar las claves generadas con una herramienta online.\r
\r
[Online RSA tool](https://www.devglan.com/online-tools/rsa-encryption-decryption)\r
\r
Prueba a copiar el contenido (en Base64) de las claves pública y privada para hacer un cifrado y un descifrado de la información.\r
\r
También puedes probar a simular una firma digital, realizando el cifrado con la clave privada y el descifrado con la clave pública.\r
:::\r
\r
Veamos un ejemplo de cómo se hace todo este proceso en Java\r
\r
\`\`\`java{23-25,38-40,76-78,108-110}\r
public class U6S4_2_RsaKeyPairEncrypt {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            //////////////////////////////////////////////////\r
            // CIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave pública de un archivo\r
            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\r
\r
            // Preparamos la información que queremos cifrar\r
            String textoEnClaro = "Quiero cifrar este mensaje de prueba";\r
            byte[] mensajeEnClaro = textoEnClaro.getBytes("UTF-8");\r
            \r
            // Realizamos el proceso de cifrado con clave pública\r
            // Los pasos son exactamente los mismos que con el cifrado simétrico\r
            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\r
            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\r
            // Visualizamos el mensaje cifrado en modo texto\r
            MostrarMensajeBase64(mensajeCifrado);\r
            \r
            //////////////////////////////////////////////////\r
            // DESCIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave privada de un archivo\r
            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\r
\r
            // Realizamos el proceso de descifrado con clave privada\r
            // Los pasos son exactamente los mismos que con el cifrado simétrico\r
            // Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\r
            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\r
            // Visualizamos el mensaje descifrado\r
            System.out.println("Texto descifrado:\\n" + new String(mensajeDescifrado, "UTF-8"));\r
                        \r
        } catch (UnsupportedEncodingException ex) {\r
            System.out.println("Codificación de caracteres UTF-8 no soportada");\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo " + algoritmoClaveAsimetrica + " en ningún Provider");\r
        } catch (NoSuchPaddingException ex) {\r
            System.err.println("El relleno especificado para el algoritmo no está permitido");\r
        } catch (InvalidKeyException ex) {\r
            System.err.println("Especificación de clave no válida");\r
        } catch (IllegalBlockSizeException ex) {\r
            System.err.println("Tamaño de bloque no válido");\r
        } catch (BadPaddingException ex) {\r
            System.err.println("Excepción con el relleno usado por el algoritmo");\r
        }\r
    }\r
\r
    private static PublicKey leerClavePublica(String ficheroClave) {\r
        byte[] clavePublicaEncoded;\r
\r
        // Leemos la información del archivo\r
        try (FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePublicaEncoded = publicKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave pública.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave pública.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes leídos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\r
            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\r
\r
            // Devolvemos la clave pública generada\r
            return clavePublica;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo " + algoritmoClaveAsimetrica + " en ningún Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
\r
    private static PrivateKey leerClavePrivada(String ficheroClave) {\r
        byte[] clavePrivadaEncoded;\r
\r
        // Leemos la información del archivo\r
        try (FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePrivadaEncoded = privateKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave privada.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave privada.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes leídos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\r
            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\r
\r
            // Devolvemos la clave pública generada\r
            return clavePrivada;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo " + algoritmoClaveAsimetrica + " en ningún Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
    \r
    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\r
        System.out.println("Mensaje cifrado visualizado como texto en Base64:");                \r
        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll("(.{76})", "$1\\n"));\r
    }    \r
}\r
\`\`\`\r
\r
Y esta es la salida proporcionada\r
\r
\`\`\`sh\r
Mensaje cifrado visualizado como texto en Base64:\r
EV+7WrEf+4CYwckys9blk6DXnLHUm4i0k+4BIp3oNmPdo2skYY8bQsAhXToBx2gi/rMIK9wiJTH0\r
yg99jpyaLeUgtga8PxWx1plgvxohzO/lALkf5AFRUczZh8F5QvOXCi93v2ycZCZXq7QmZTopkEQh\r
ARSezD/1Al2UYPc2X68=\r
\r
Texto descifrado:\r
Quiero cifrar este mensaje de prueba\r
\`\`\`\r
\r
::: warning Cifrado siempre diferente, descifrado siempre igual\r
El resultado de cifrar un mensaje con la misma clave pública no siempre es igual, aunque al descifrar los mensajes con la clave privada siempre se obtiene el mensaje original.\r
\r
Esto es debido a que, para aumentar la variabilidad (**entropía**) del mensaje cifrado al mensaje que se cifra se le añade una parte aleatoria (**salt**) que se descarta cuando se descifra.\r
:::\r
\r
En el código podemos observar cómo los procesos para cargar la clave desde un archivo usan las mismas clases que cuando se generaron, siendo el código muy parecido.\r
\r
En cuanto al cifrado y descifrado se realiza con el *Engine Cipher* usando la misma secuencia de llamadas que con el cifrado simétrico.\r
\r
## 6.2.3. Cifrado asimétrico con GnuPG\r
\r
Con la suite GnuPG también podemos generar pares de claves y cifrar y descifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la información de los algoritmos disponibles para cada tipo de servicio. En concreto, de resúmenes, en mi versión instalada:\r
\r
Clave pública: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\r
:::\r
\r
Para generar las claves, ejecutamos los siguientes comandos.\r
Debemos tener en cuenta que las claves generadas se añaden a nuestro anillo de claves (almacén de seguridad de claves en las que confiamos).\r
\r
\`\`\`bash\r
gpg --gen-key\r
gpg --list-keys \r
# El formato corto equivalente es gpg -k\r
gpg --list-secret-keys \r
# El formato corto equivalente es gpg -K\r
\r
#Extraer las claves públicas y privadas\r
# En un archivo binario\r
gpg --output tunombre.pub --export IDdeLaClavePública\r
# En un archivo ASCII\r
gpg --armor --output tunombre.asc --export IDdeLaClavePública\r
\r
gpg --export-secret-keys -a IDdeLaClavePública > tunombre.priv\r
\r
# Importar una clave pública\r
gpg --import clavepublica.asc\r
# Importar una clave privada\r
gpg --allow-secret-key-import --import claveprivada.priv\r
\`\`\`\r
\r
Para cifrar y descifrar un archivo con las claves generadas, ejecutamos los siguientes comandos\r
\r
\`\`\`bash\r
# Cifrar\r
gpg --output archivo.cifrado --encrypt --recipient IDdeLaClavePública archivo\r
# Descifrar\r
gpg --output archivo --decrypt archivo.cifrado\r
\`\`\`\r
`]},{title:"6.2 Hash functions",headers:[{level:2,title:"6.2.1. Hash functions",slug:"_6-2-1-hash-functions",link:"#_6-2-1-hash-functions",children:[]},{level:2,title:"6.2.2. MessageDigest",slug:"_6-2-2-messagedigest",link:"#_6-2-2-messagedigest",children:[]},{level:2,title:"6.2.3. MessageDigest with GnuPG",slug:"_6-2-3-messagedigest-with-gnupg",link:"#_6-2-3-messagedigest-with-gnupg",children:[]}],path:"/en/unit6/hash-functions.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.2 Hash functions\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.2 Hash functions" />\r
\r
# 6.2 Hash functions\r
\r
[[toc]]\r
\r
## 6.2.1. Hash functions\r
\r
A **message digest**, better known as **hash functions**, is a digital mark of a block of data. There are a large number of algorithms designed to process these summaries, the two best known are SHA-1 and MD5.\r
\r
From a digest we can highlight the following characteristics:\r
\r
- For the same algorithm, the digest always has the same size, regardless of the size of the data used to generate it.\r
- It is impossible to recover the original information from a digest.\r
- The digest should not reveal anything about the data used to generate it.\r
- It is computationally unfeasible to find two messages that have the same digest value. Mathematically it is highly unlikely, but not impossible.\r
- A small change in the summarized data generates a completely different digest.\r
\r
Digests are used to generate unique and reliable identifiers. Sometimes they are called *checksum*, since they are used to check if a download has been done correctly, generating its summary and comparing it with the one generated by the original file.\r
\r
::: warning A hash is not used to encrypt\r
It is important to note that, because it is impossible to obtain the data that generated a digest from the digest itself, the digest cannot be used to encrypt information.\r
\r
On the other side, it is a mechanism that is used to compare. Its most widespread use is with passwords, since in the databases a summary is saved instead of the password in clear. In this way, when a password is received, its digest is generated and compared with the stored value.\r
:::\r
\r
## 6.2.2. MessageDigest\r
\r
The *MessageDigest* class allows applications to implement cryptographically secure summary algorithms such as SHA-256 or SHA-512\r
\r
To generate a hash with JCA, proceed as follows:\r
\r
1. An object of the *MesageDigest* class is created with the static method *getInstance()* of the same class, specifying the name of the algorithm. Optionally, the name of the provider can be specified.\r
2. Data is added with the *update()* method. A byte or byte array can be added. This method can be invoked several times to add new data.\r
3. The hash value is obtained with the *digest()* method.\r
4. If you wanted to calculate a new hash, the *reset()* method would be invoked to start the process again.\r
\r
Next we can see an example\r
\r
\`\`\`java\r
public class U6S2_MessageDigest {\r
\r
    public static void main(String[] args) {\r
        String plaintext = "Esto es un texto plano.";\r
        try {\r
            // Obtenemos un ENGINE que implementa el algoritmo especificado\r
            // Se puede indicar cualquier algoritmo disponible en el sistema\r
            // SHA-224, SHA-512, SHA-256, SHA3-224, ...\r
            MessageDigest m = MessageDigest.getInstance("SHA-256");\r
\r
            // Opcional - Reinicia el objeto para un nuevo uso \r
            // Por si queremos poner este código en un bucle y procesar más\r
            // de un mensaje\r
            m.reset();\r
\r
            // Realiza el resumen de los datos pasados por parámetro\r
            // Si queremos procesar la información poco a poco, \r
            // debemos ir llamando al método update para cada bloque de datos\r
            m.update(plaintext.getBytes());\r
\r
            // Completa el cálculo del valor del hash y devuelve el resumen\r
            byte[] digest = m.digest();\r
\r
            // Mensaje de resumen\r
            System.out.println("Resumen (raw data): " + new String(digest));\r
\r
            // Mensaje en formato hexadecimal\r
            System.out.println("Resumen (hex data): " + toHexadecimal(digest));\r
            \r
            \r
            // Información del proceso\r
            System.out.println("=> Algoritmo: " + m.getAlgorithm() + ", Provider: " + m.getProvider().getName() + " " + m.getProvider().getVersionStr());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo MD5 en ningún Provider");\r
        }\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
}\r
\`\`\`\r
\r
and this would be the output provided\r
\r
\`\`\`sh\r
Resumen (raw data): �Y�"�3\x1B��\`b����bs?;������~E\r
Resumen (hex data): FB59D31122913314111B92CD60628ED7E7DE62733F3B10DEDAF303AAABE57E45\r
=> Algoritmo: SHA-256, Provider: SUN 11\r
\`\`\`\r
\r
## 6.2.3. MessageDigest with GnuPG\r
\r
With the GnuPG suite we can generate summaries of files using the algorithms provided by the suite.\r
\r
::: info Algorithms available for GnuPG\r
To see the list of available algorithms we have to show the help of the command\r
\r
> gpg --help\r
\r
and at the top we see the information of the algorithms available for each type of service. Specifically, of summaries, in my installed version:\r
\r
Summary: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\r
:::\r
\r
To generate a summary of a file, we run the command as follows\r
\r
\`\`\`sh\r
gpg --print-md SHA256 filename.ext\r
\`\`\`\r
\r
`]},{title:"6 Introduction",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/en/unit6/",pathLocale:"/en/",extraFields:[`---\r
title: 6 Introduction\r
---\r
\r
# Unit 6. Secure programming techniques\r
\r
Cryptography is a term derived from the Greek word *kryptos* which means hidden and *grafos* which means writing. The objective of cryptography is to hide the meaning of a message by encrypting or encoding the message.\r
\r
Cryptographic techniques are used to protect the confidentiality, integrity and authenticity of information. Cryptography is used to protect information in transit or stored in a computer system. Cryptography is also used to protect the identity of users and to protect the integrity of programs and data.\r
\r
Of all the techniques of secure programming, we are going to study in this topic\r
\r
- Hash functions\r
- **Symmetric encryption** or hidden key\r
- **Asymmetric encryption** or private key\r
\r
We will also study how to use secure communication channels for our applications, using secure sockets using SSL/TLS.\r
\r
In addition, we will see a security tool that incorporates Java, security policies.\r
\r
## Objetivos\r
\r
Goals of this unit:\r
\r
- Identify principles and practices of secure programming.\r
- Analyze cryptographic techniques and practices.\r
- Define security policies.\r
- Use cryptographic algorithms.\r
- Use secure sockets for transmitting information.\r
- Study the operation of TLS/SSL over the TCP protocol\r
- Know generic tools in cryptography\r
`]},{title:"6.5 Comunicaciones seguras en Java",headers:[{level:2,title:"6.5.1. Protocolo SSL (Secure Sockets Layer)",slug:"_6-5-1-protocolo-ssl-secure-sockets-layer",link:"#_6-5-1-protocolo-ssl-secure-sockets-layer",children:[]},{level:2,title:"6.5.2. JSSE",slug:"_6-5-2-jsse",link:"#_6-5-2-jsse",children:[{level:3,title:"SSLSocket y SSLServerSocket",slug:"sslsocket-y-sslserversocket",link:"#sslsocket-y-sslserversocket",children:[]},{level:3,title:"keytool: certificados, confianza y almacenes de claves",slug:"keytool-certificados-confianza-y-almacenes-de-claves",link:"#keytool-certificados-confianza-y-almacenes-de-claves",children:[]}]},{level:2,title:"6.5.3. Servidor y Cliente SSL",slug:"_6-5-3-servidor-y-cliente-ssl",link:"#_6-5-3-servidor-y-cliente-ssl",children:[]}],path:"/en/unit6/jsse.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.5 Comunicaciones seguras en Java\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.5 Comunicaciones seguras en Java" />\r
\r
# 6.5 Comunicaciones seguras en Java\r
\r
[[toc]]\r
\r
## 6.5.1. Protocolo SSL (Secure Sockets Layer)\r
\r
SSL es el protocolo habitualmente usado para encriptar la comunicación cliente-servidor. Casi todo el tráfico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.\r
\r
La implementación de SSL es una extensión de los sockets que permite establecer un canal (stream) de comunicación. Dicha comunicación se inicia con un **handshake** durante el cual, el cliente y el servidor construyen una session-key (clave simétrica encriptada con par de claves asimétricas) compartida para verificar su identidad mutua.\r
\r
## 6.5.2. JSSE\r
\r
JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementación para Java de los protocolos SSL y TSL e incluye funcionalidad de\r
\r
- encriptación de datos\r
- autenticación de servidores\r
- integridad de mensajes\r
- autenticación de clientes\r
\r
Con JSSE, los programadores  pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicación, tales como HTTP, Telnet o FTP, a través de TCP/IP.\r
\r
Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.\r
\r
### SSLSocket y SSLServerSocket\r
\r
Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente.\r
\r
JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creación de sockets seguros. No tienen constructor, se obtienen a través del método estático getDefault().\r
\r
Para obtener un socket servidor seguro o *SSLServerSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
SSLServerSocket servidorSSL = (SSLServerSocket) = sfact.createServerSocket(puerto);\r
\`\`\`\r
\r
El método **createServerSocket(int puerto)** devuelve un socket de servidor enlazado al puerto especificado.\r
\r
Para crear un *SSLSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
SSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\r
\`\`\`\r
\r
El método createSocket (String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.\r
\r
### keytool: certificados, confianza y almacenes de claves\r
\r
Cuando dos socket SSL, uno cliente y otro servidor, intentan establecer conexión, tienen que "presentarse" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno confía en el otro, la conexión se establece, en caso contrario, no se establece.\r
\r
Para establecer esa confianza se debe crear un certificado en el servidor y añadirlo a los certificados de confianza del cliente.\r
\r
- El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta **keytool**, que viene incluida en el JDK de Java. La herramienta guardará la pareja de claves en un almacén (el cual tiene su propia clave).\r
- Después generaremos un certificado a partir de esa pareja.\r
- El código del servidor necesitará indicar el fichero donde se almacenan las claves y la clave para acceder a ese almacén.\r
- El cliente necesitará indicar que confía en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almacén de claves del cliente.\r
\r
::: info Seguridad mutua\r
Aunque no suele hacerse también podría hacerse a la inversa y obligar al cliente a tener un certificado que el servidor pudiera importar, lo que aumentaría la seguridad.\r
:::\r
\r
Vamos a ver cómo realizar estas operaciones previas con la herramienta **keytool**\r
\r
Primero las acciones a realizar en el servidor\r
\r
\`\`\`sh:no-line-numbers\r
# El servidor genera una pareja de claves que se almacena en un\r
# fichero llamado "clavesservidor". Dentro del fichero se indica\r
# un alias para poder referirnos a esa clave fácilmente\r
# keytool -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
What is your first and last name?\r
  [Unknown]:  Vicente Martinez\r
What is the name of your organizational unit?\r
  [Unknown]:  Dpto. Informatica\r
What is the name of your organization?\r
  [Unknown]:  IES Doctor Balmis\r
What is the name of your City or Locality?\r
  [Unknown]:  Alicante\r
What is the name of your State or Province?\r
  [Unknown]:  Alicante\r
What is the two-letter country code for this unit?\r
  [Unknown]:  ES\r
Is CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES correct?\r
  [no]: yes\r
\r
# El servidor genera su "certificado", es decir un fichero que\r
# de alguna forma indica quien es él. El certificado se almacena\r
# en un fichero llamado clavesservidor y a partir de él queremos\r
# generar el certificado de un alias creado previamente con nombre servidor\r
# keytool -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
Enter keystore password:\r
Certificate stored in file <servidor.cer>\r
\`\`\`\r
\r
En la carpeta donde hemos ejecutado el comando keytool, se ha creado el almacén de claves en un fichero llamado **ClavesServidor** y el certificado exportado en el archivo **servidor.cer**\r
\r
y a continuación las que habría que realizar en el cliente para generar el almacén de confianza que, en nuestro caso contenga el mismo certificado que hemos exportado del servidor.\r
\r
\`\`\`sh:no-line-numbers\r
# Se importa el certificado del servidor indicando que pertenece a\r
# la lista de certificados confiables.\r
# keytool -importcert -trustcacerts -alias servidor -file servidor.cer -keystore clavescliente  -storepass 87654321\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -importcert -trustcacerts -alias servidor -file servidor.cer -keystore CertificadosConfianzaCliente -storepass 87654321\r
Owner: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Issuer: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Serial number: 4eb6f2a5\r
Valid from: Mon Jan 24 00:20:24 CET 2022 until: Sun Apr 24 01:20:24 CEST 2022\r
Certificate fingerprints:\r
         SHA1: DD:A2:75:4C:1C:BC:39:60:BE:B1:20:67:E1:5C:45:8C:48:B5:1F:54\r
         SHA256: 82:C8:56:C2:DB:DE:8C:73:A9:21:C6:7D:DE:1F:39:4F:79:CC:5F:D5:10:BC:61:DA:E3:EE:E1:1D:21:EA:D2:33\r
Signature algorithm name: SHA256withRSA\r
Subject Public Key Algorithm: 2048-bit RSA key\r
Version: 3\r
\r
Extensions:\r
\r
#1: ObjectId: 2.5.29.14 Criticality=false\r
SubjectKeyIdentifier [\r
KeyIdentifier [\r
0000: 16 AE 35 7C 58 97 B1 95   91 9B FA 6C 2A 80 D2 90  ..5.X......l*...\r
0010: 1C 50 7F C0                                        .P..\r
]\r
]\r
\r
Trust this certificate? [no]:  yes\r
Certificate was added to keystore\r
\`\`\`\r
\r
En esta ocasión también se crea, en la carpeta donde se ha ejecutado el comando keytool, un fichero **CertificadosConfianzaCliente** con el/los certificados de confianza para el cliente.\r
\r
## 6.5.3. Servidor y Cliente SSL\r
\r
En le siguiente ejemplo podemos observar como la inicialización del ServerSocket es diferente, pero a partir de que se llama al método accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del código es igual que con la clase Socket.\r
\r
\`\`\`java{5,16,17,24}\r
public class U6S5_SSLServer {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteConectado = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante código, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicación\r
        // System.setProperty("javax.net.ssl.keyStore", System.getProperty("user.dir") + "\\\\ClavesServidor");\r
        // System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
        \r
        // Inicialización del ServerSocket SSL\r
        int puerto = 6000;\r
        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\r
\r
        for (int i = 1; i < 5; i++) {\r
\r
            System.out.println("Esperando al cliente " + i);\r
\r
            // Se espera la conexión de un cliente con accept\r
            clienteConectado = (SSLSocket) servidorSSL.accept();\r
            // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
            // el código del ejemplo\r
            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\r
            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\r
\r
            // El cliente envía un mensaje\r
            System.out.println("Recibiendo del CLIENTE: " + i + " \\n\\t" + flujoEntrada.readUTF());\r
\r
            // El Servidor responde con un saludo\r
            flujoSalida.writeUTF("Saludos al cliente del servidor");\r
        }\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteConectado.close();\r
        servidorSSL.close();\r
    }\r
}\r
\`\`\`\r
\r
En el cliente el proceso es el mismo, tras la llamada al método createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.\r
\r
\`\`\`java{5,12,13,19,20}\r
public class U6S5_SSLClient {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteSSL = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante código, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicación\r
        // System.setProperty("javax.net.ssl.trustStore", System.getProperty("user.dir") + "/CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
        // Inicialización del ServerSocket SSL\r
        int puerto = 6000;\r
        String host = "localhost";\r
\r
        System.out.println("Programa Cliente iniciado....");\r
        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\r
\r
        // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
        // el código del ejemplo\r
        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\r
        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\r
\r
        // Envío un saludo al servidor\r
        flujoSalida.writeUTF("Saludos al SERVIDOR DESDE EL CLIENTE");\r
\r
        // El Servidor responde con un mensaje\r
        System.out.println("Recibiendo del SERVIDOR: \\n\\t" + flujoEntrada.readUTF());\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteSSL.close();\r
    }\r
\r
    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException {\r
\r
        //------------------------------------------------------------------------------\r
        //Ejemplo de la múltiple información sobre la sesión SSL\r
        // que se puede obtener a partir \r
        SSLSession session = ((SSLSocket) cliente).getSession();\r
        System.out.println("Host: " + session.getPeerHost());\r
        System.out.println("Cifrado: " + session.getCipherSuite());\r
        System.out.println("Protocolo: " + session.getProtocol());\r
\r
        System.out.println("IDentificador:" + new BigInteger(session.getId()));\r
\r
        System.out.println("Creación de la sesión: " + session.getCreationTime());\r
\r
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\r
        System.out.println("Propietario: " + certificate.getSubjectDN());\r
        System.out.println("Algoritmo: " + certificate.getSigAlgName());\r
        System.out.println("Tipo: " + certificate.getType());\r
        System.out.println("Emisor: " + certificate.getIssuerDN());\r
        System.out.println("Número Serie: " + certificate.getSerialNumber());\r
        //-----------------------------------------------------------------------------\r
    }\r
}\r
\`\`\`\r
\r
Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Exception in thread "main" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\r
\`\`\`\r
\r
Para ejecutar el programa servidor es necesario indicar el certificado que se utilizará.\r
\r
Lo podemos indicar a la hora de ejecutar el programa, añadiendo a la línea de comandos\r
\r
\`\`\` sh\r
 java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\r
\`\`\`\r
\r
y en el programa cliente es necesario indicar la ubicación de los certificados de confianza\r
\r
\`\`\` sh\r
java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\r
\`\`\`\r
\r
o bien, en las opciones de ejecución del IDE\r
\r
![Netbeans: Opciones de la JVM](../../media/unit6/VM_Options.png)\r
\r
::: info Parámetros de JVM vs hardcoded\r
En el código anterior hay unas líneas comentadas que especifican cómo podemos configurar el valor de las propiedades desde código mediante el uso del método System.setProperty(String propiedad, String valor), evitando así tener que indicarlas como parámetros de ejecución de cliente y servidor (mejor opción).\r
\r
En el programa servidor incluiríamos las siguientes líneas:\r
\r
System.setProperty("javax.net.ssl.keyStore", "ClavesServidor");\r
System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
\r
Y en el programa cliente serían estas:\r
\r
System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
\r
Además del nombre, podemos indicar la ruta donde se encuentran los almacenes, recordando que NO ES RECOMENDABLE el uso de barras invertidas para indicar rutas.\r
:::\r
\r
Una vez hechos los cambios, bien en las opciones de la JVM o bien en el código de las aplicaciones, la salida que obtendremos será esta\r
\r
<CodeGroup>\r
<CodeGroupItem title="Servidor" active>\r
\r
\`\`\`sh:no-line-numbers\r
Esperando al cliente 1\r
Recibiendo del CLIENTE: 1 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 2\r
Recibiendo del CLIENTE: 2 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 3\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Cliente">\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Recibiendo del SERVIDOR: \r
	Saludos al cliente del servidor\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
</CodeGroup>\r
\r
::: warning Default trusted certificates\r
Whenever Java attempts to connect to another application over SSL (e.g.: HTTPS, IMAPS, LDAPS), it will only be able to connect to that application if it can trust it. The way trust is handled in the Java world is that you have a keystore (typically $JAVA_HOME/lib/security/cacerts), also known as the truststore. This contains a list of all known Certificate Authority (CA) certificates, and Java will only trust certificates that are signed by one of those CAs or public certificates that exist within that keystore.\r
\r
If -Djavax.net.ssl.trustStore has been configured, it will override the location of the default truststore, which will need to be checked.\r
:::`]},{title:"6.6 Anexo I - Logs library Log4Java2",headers:[{level:2,title:"6.6.1 Registros o logs",slug:"_6-6-1-registros-o-logs",link:"#_6-6-1-registros-o-logs",children:[]},{level:2,title:"6.6.2. Configuración automática de Log4j2",slug:"_6-6-2-configuracion-automatica-de-log4j2",link:"#_6-6-2-configuracion-automatica-de-log4j2",children:[]},{level:2,title:"6.6.3. Niveles de registro",slug:"_6-6-3-niveles-de-registro",link:"#_6-6-3-niveles-de-registro",children:[]},{level:2,title:"6.6.4. Ejemplo de uso de Log4j2",slug:"_6-6-4-ejemplo-de-uso-de-log4j2",link:"#_6-6-4-ejemplo-de-uso-de-log4j2",children:[]},{level:2,title:"6.6.5. Configuración de Log4j2",slug:"_6-6-5-configuracion-de-log4j2",link:"#_6-6-5-configuracion-de-log4j2",children:[]},{level:2,title:"6.6.6 Appenders",slug:"_6-6-6-appenders",link:"#_6-6-6-appenders",children:[]},{level:2,title:"6.6.7. Loggers",slug:"_6-6-7-loggers",link:"#_6-6-7-loggers",children:[]},{level:2,title:"6.6.8. Layouts",slug:"_6-6-8-layouts",link:"#_6-6-8-layouts",children:[]},{level:2,title:"6.6.9. Actividades",slug:"_6-6-9-actividades",link:"#_6-6-9-actividades",children:[]},{level:2,title:"6.6.10. Bibliografía",slug:"_6-6-10-bibliografia",link:"#_6-6-10-bibliografia",children:[]}],path:"/en/unit6/log4j_annex.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.6 Anexo I - Logs library Log4Java2\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.6 Annex I - Logs library Log4Java2" />\r
\r
# 6.6 Anexo I - Log4Java2 - Gestor de logs\r
\r
[[toc]]\r
\r
## 6.6.1 Registros o logs\r
\r
El registro es el proceso de escribir mensajes de registro en cualquier archivo, base de datos, consola, etc. para mantener un registro de eventos que ocurren en un sistema. El registro es una parte esencial de cualquier aplicación para depurar y monitorear el sistema.\r
\r
El software con suficiente registro y monitorización le permitirá detectar posibles incidentes cuando su código se despliegue en un entorno de producción. \`Log4j\` se utiliza para gestionar el registro de información en una aplicación.\r
\r
Además, en términos de seguridad, el registro es una parte esencial de cualquier aplicación. Si su aplicación se ve comprometida, el registro le ayudará a rastrear el origen de un ataque, accesos indebidos, accesos no autorizados y a tomar medidas para evitar que vuelva a ocurrir.\r
\r
Hasta ahora hemos usado la instrucción SOP \`System.out.println()\` para imprimir mensaje de registro. Este sistema tiene algunas desventajas:\r
\r
- Podemos imprimir mensajes de registro solo en la consola. Por lo tanto, cuando se cierre la consola, perderemos -dos los registros.\r
- No podemos almacenar mensajes de registro en ningún lugar permanente. Estos mensajes se imprimirán uno por uno en la consola porque es un entorno de un solo hilo.\r
- No podemos configurar diferentes niveles de registro como INFO, DEBUG, ERROR, etc.\r
- No podemos configurar el formato de registro, como la fecha, la hora, el nombre de la clase, el nombre del método y que se aplique a todos los mensajes de registro.\r
- No podemos configurar el destino de registro, como la consola, el archivo, la base de datos, etc.\r
\r
Para solventar estos problemas, se utiliza el framework Log4j. Log4j es un framework de código abierto proporcionado por Apache solo para proyectos de Java.\r
\r
!!! note Versiones Log4j2\r
    Log4j es un sistema de registro donde la API (llamada Log4j API) y su implementación (llamada Log4j Core) están separadas claramente la una de la otra.\r
\r
    Esto permite que la API de Log4j proporcione una interfaz que sea fácil de usar de una manera correcta y a prueba de futuro. Consulta las páginas de [API de Java](https://logging.apache.org/log4j/2.x/manual/api.html), [API de Kotlin](https://logging.apache.org/log4j/kotlin/index.html) y [API de Scala](https://logging.apache.org/log4j/scala/latest/) para obtener más información.\r
\r
    \r
Para usar Log4j2 en nuestro código solo necesitamos agregar las siguientes [librerías / dependencias](https://logging.apache.org/log4j/2.x/download.html) en nuestro proyecto:\r
\r
\`\`\`bash\r
log4j-api-<version>.jar\r
log4j-core-<version>.jar\r
\`\`\`\r
\r
## 6.6.2. Configuración automática de Log4j2\r
\r
Podemos configurar Log4j2 con nuestra aplicación utilizando un archivo de configuración escrito en formato XML, JSON, YAML o propiedades. También podemos hacerlo mediante código pero, por ahora, nos vamos a centrar en la configuración utilizando archivos de configuración.\r
\r
Log4j tiene la capacidad de configurarse automáticamente durante la inicialización. Tiene un orden para buscar el archivo de configuración en la aplicación. Log4j proporcionará una configuración predeterminada si no puede localizar un archivo de configuración.\r
\r
## 6.6.3. Niveles de registro\r
\r
Los niveles de registro son un mecanismo para categorizar los registros. Los niveles se utilizan para identificar la gravedad de un evento. Podemos configurar fácilmente los niveles para especificar qué detalles de registro queremos ver. Log4j proporciona los siguientes niveles:\r
\r
1. ALL: Para registrar todos los eventos.\r
2. TRACE: Un mensaje de depuración detallado, que captura típicamente el flujo a través de la aplicación.\r
3. DEBUG: Un evento de depuración general.\r
4. INFO: Un evento con fines informativos.\r
5. WARN: Un evento que podría posiblemente llevar a un error.\r
6. ERROR: Un error en la aplicación, posiblemente recuperable.\r
7. FATAL: Un error grave que impedirá que la aplicación continúe.\r
8. OFF: No se registrarán eventos.\r
\r
Log4j sigue el siguiente orden:\r
\r
> ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL\r
\r
Si especificamos el nivel de registro como INFO, se registrarán todos los eventos INFO, WARN, ERROR y FATAL. Si especificamos el nivel de registro como WARN, se registrarán todos los eventos WARN, ERROR y FATAL. En términos simples, se considerarán todos los niveles por debajo del nivel especificado, incluido el nivel especificado.\r
\r
## 6.6.4. Ejemplo de uso de Log4j2\r
\r
\`\`\`java\r
package psp.examples.u06.log4j2;\r
\r
import org.apache.logging.log4j.LogManager;\r
import org.apache.logging.log4j.Logger;\r
\r
public class ModuleA {\r
\r
    private static final Logger logger = LogManager.getLogger();\r
    \r
    // Log messages\r
    public static void main(String[] args) {\r
        logger.debug("It is a debug logger.");\r
        logger.error("It is an error logger.");\r
        logger.fatal("It is a fatal logger.");\r
        logger.info("It is a info logger.");\r
        logger.trace("It is a trace logger.");\r
        logger.warn("It is a warn logger.");\r
    }\r
}\r
\`\`\`\r
\r
La salida obtenida será la siguiente:\r
\r
\`\`\`bash\r
11:14:47.469 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\r
11:14:47.471 [main] FATAL psp.examples.u06.log4j2.ModuleA - It is a fatal logger.\r
\`\`\`\r
\r
Aunque hemos usado todos los niveles, en la consola solo vemos dos niveles. En realidad, cuando no proporcionamos ningún archivo de configuración, por defecto Log4j utiliza una configuración predeterminada. La configuración predeterminada, proporcionada en la clase DefaultConfiguration, configurará:\r
\r
- Un **\`ConsoleAppender\`** para el logger por defecto, es decir, los registros se imprimirán en la consola.\r
- Un **\`PatternLayout\`** configurado con el patrón:\r
  " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n " asociado al ConsoleAppender\r
\r
!!! tip Nivel de registro por defecto\r
    Por defecto, Log4j asigna el logger raíz al nivel Level.ERROR y esos logs se imprimirán en la consola estándar.\r
\r
!!! info Patrón por defecto\r
    Vamos a entender el formato de patrón en el que se imprimen los logs. Dado que no hemos pasado ningún archivo de configuración, utiliza el formato por defecto que se muestra a continuación.\r
\r
    > " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n "\r
\r
    - \`%d{HH:mm:ss.SSS}\` is execution timestamp i.e. 18:07:15.984\r
    - \`[%t]\` is thread name i.e. [main] \r
    - \`%-5level\` is level name i.e. ERROR\r
    - \`%logger{36}\` is logger name which we are creating as first step i.e. psp.examples.u06.log4j2\r
    - \`%msg%n\` is message i.e. “ It is an error logger ” followed by a new line character.\r
\r
## 6.6.5. Configuración de Log4j2\r
\r
Para configurar Log4j2, necesitamos un archivo de configuración. Log4j2 admite la configuración en formato XML, JSON, YAML y propiedades.\r
\r
Log4j2 tiene una arquitectura de registro bastante compleja, sin embargo la mayoría de los usuarios solo requieren estos elementos:\r
\r
- **Loggers**: Son el punto de entrada del pipeline de registro, que se utiliza directamente en el código. Su configuración debe especificar qué nivel de mensajes registran y a qué \`*appenders*\` envían los mensajes. Los cubriremos mientras configuramos los \`*loggers*\`.\r
- **Appenders**: Son el punto de salida del pipeline de registro. Deciden a qué recurso (consola, archivo, base de datos o similar) se envía el evento de registro. Los más comunes son el \`*console appender*\` y el \`*file appender*\`.\r
- **Layouts**: Indican a los \`*appenders*\` cómo formatear el evento de registro: texto, JSON, XML o similar. Los más comunes son \`*Pattern Layout*\` y \`*JSON Template Layout*\`.\r
\r
A continuación se muestra un ejemplo de configuración en formato XML.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuración, hemos configurado un \`ConsoleAppender\` que imprimirá los mensajes de registro en la consola. Hemos configurado el nivel de registro raíz como \`error\`, por lo que solo se imprimirán los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscará los archivos de configuración en el siguiente orden:\r
\r
1. Primero comprobará si se ha especificado un archivo de configuración en la propiedad del sistema \`log4j.configurationFile\`. Si no se ha especificado, buscará los archivos de configuración en el siguiente orden:\r
2. Si no encuentra la propiedad del sistema buscará los archivos de configuración en el \`classpath\` en el siguiente orden:\r
\r
   - \`log4j2-test.xml\`\r
   - \`log4j2-test.json\`\r
   - \`log4j2-test.yaml\`\r
   - \`log4j2-test.yml\`\r
   - \`log4j2-test.properties\`\r
   - \`log4j2.xml\`\r
   - \`log4j2.json\`\r
   - \`log4j2.yaml\`\r
   - \`log4j2.yml\`\r
   - \`log4j2.properties\`\r
\r
Se puede ampliar la información en la [documentación oficial de Log4j2](https://logging.apache.org/log4j/2.x/manual/configuration.html).\r
\r
## 6.6.6 Appenders\r
\r
> [Documentación Appenders](https://logging.apache.org/log4j/2.x/manual/appenders.html)\r
\r
Podemos especificar destinos para mantener los registros de eventos. Podemos querer imprimir esos registros en la consola o en cualquier archivo externo. Los \`appenders\` suelen ser responsables de escribir los datos de eventos en el destino objetivo. Podemos usar varios *appenders* en una misma configuración.\r
\r
Los \`appenders\` más comunes son:\r
\r
- **ConsoleAppender**: Imprime los mensajes de registro en la consola.\r
- **FileAppender**: Imprime los mensajes de registro en un archivo.\r
- **RollingFileAppender**: Imprime los mensajes de registro en un archivo y crea un nuevo archivo cuando el tamaño del -chivo alcanza un límite.\r
- **DBAppender**: Imprime los mensajes de registro en una base de datos.\r
- **SMTPAppender**: Envía los mensajes de registro por correo electrónico.\r
- **SocketAppender**: Envía los mensajes de registro a un servidor remoto.\r
- **SyslogAppender**: Envía los mensajes de registro a un servidor Syslog.\r
- **JMSAppender**: Envía los mensajes de registro a un servidor JMS.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration xmlns="https://logging.apache.org/xml/ns"\r
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r
               xsi:schemaLocation="\r
                   https://logging.apache.org/xml/ns\r
                   https://logging.apache.org/xml/ns/log4j-config-2.xsd">\r
  <Appenders>\r
    <Console name="CONSOLE">\r
      <PatternLayout pattern="%p - %m%n"/>\r
    </Console>\r
    <File name="MAIN" fileName="logs/main.log">\r
      <JsonTemplateLayout/>\r
    </File>\r
    <File name="DEBUG_LOG" fileName="logs/debug.log">\r
      <PatternLayout pattern="%d [%t] %p %c - %m%n"/>\r
    </File>\r
  </Appenders>\r
  <Loggers>\r
    <Root level="INFO">\r
      <AppenderRef ref="CONSOLE" level="WARN"/>\r
      <AppenderRef ref="MAIN"/>\r
    </Root>\r
    <Logger name="org.example" level="DEBUG">\r
      <AppenderRef ref="DEBUG_LOG"/>\r
    </Logger>\r
  </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En el ejemplo anterior se han configurado tres \`appenders\`:\r
\r
- Un \`ConsoleAppender\` llamado CONSOLE con un \`PatternLayout\`.\r
  En este caso la salida se mostrará en la consola y se imprimirá el nivel de log y el mensaje. Por ejemplo, \`INFO - It is an info logger\`.\r
- Un \`FileAppender\` llamado MAIN con un \`JsonTemplateLayout\`.\r
  En este caso la salida se escribirá en el archivo \`logs/main.log\` en formato JSON. Por ejemplo, \`{"level":"INFO","message":"It is an info logger"}\`.\r
- Un \`FileAppender\` llamado DEBUG_LOG con un \`PatternLayout\`.\r
    En este caso la salida se escribirá en el archivo \`logs/debug.log\` con el formato de fecha, hilo, nivel de log, clase y mensaje. Por ejemplo, \`2021-09-15 11:14:47,471 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\`\r
\r
## 6.6.7. Loggers\r
\r
> [Documentación Loggers](https://logging.apache.org/log4j/2.x/manual/configuration.html#configuring-loggers)\r
\r
Los \`loggers\` se utilizan directamente en el código para registrar mensajes.\r
\r
Los \`loggers\` se configuran en el archivo de configuración de Log4j2. y se pueden configurar para enviar mensajes de registro a uno o varios \`appenders\`.\r
\r
En el ejemplo anterior, se han configurado dos \`loggers\`:\r
\r
- Un \`logger\` raíz con nivel de log INFO y dos \`appenders\` asociados: CONSOLE y MAIN.\r
  En este caso, los mensajes de log con nivel INFO o superior se enviarán al \`appender\` MAIN, es decir, al archivo \`logs/main.log\`.\r
  Los mensajes de log con nivel WARN o superior se enviarán también al \`appender\` CONSOLE, es decir, a la consola.\r
- Un \`logger\` con nombre \`org.example\` con nivel de log DEBUG y un \`appender\` asociado: DEBUG_LOG.\r
  En este caso, los mensajes de log con nivel DEBUG o superior se enviarán al \`appender\` DEBUG_LOG.\r
\r
!!! question Un mismo mensaje, diferentes salidas\r
    Fíjate en la siguiente tabla con los mensajes que se enviarían a cada \`appender\` en función del nivel de log, del \`logger\` que lo genere y de los \`appenders\`.\r
\r
    | Logger name | Log event level | Appenders |\r
    |-------------|-----------------|-----------|\r
    | org.example.foo | WARN | CONSOLE, MAIN, DEBUG_LOG |\r
    | org.example.foo | DEBUG | MAIN, DEBUG_LOG |\r
    | org.example.foo | TRACE | none |\r
    | com.example | WARN | CONSOLE, MAIN |\r
    | com.example | INFO | MAIN |\r
    | com.example | DEBUG | none |\r
\r
    Si un logger no tiene un nivel de log configurado se heredará el nivel de log del logger padre. Si no se ha configurado ningún nivel de log, se heredará el nivel de log del logger raíz.\r
\r
## 6.6.8. Layouts\r
\r
> [Documentación Layouts](https://logging.apache.org/log4j/2.x/manual/layouts.html)\r
\r
Los \`layouts\` se utilizan para dar formato a los mensajes de log. Log4j2 proporciona varios \`layouts\` predefinidos que se pueden utilizar para dar formato a los mensajes de log.\r
\r
Los \`layouts\` más comunes son:\r
\r
- **PatternLayout**: Es el \`layout\` más comúnmente utilizado. Permite configurar el formato de los mensajes de log utilizando un patrón.\r
- **JsonTemplateLayout**: Es un \`layout\` que genera mensajes de log en formato JSON.\r
- **YamlLayout**: Es un \`layout\` que genera mensajes de log en formato YAML.\r
- **HtmlLayout**: Es un \`layout\` que genera mensajes de log en formato HTML.\r
- **CsvLogLayout**: Es un \`layout\` que genera mensajes de log en formato CSV.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuración, hemos configurado un \`ConsoleAppender\` que imprimirá los mensajes de registro en la consola. Hemos configurado el nivel de registro raíz como \`error\`, por lo que solo se imprimirán los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscará los archivos de configuración en el siguiente orden:\r
\r
Un ejemplo de configuración de Log4j2 con un \`JsonTemplateLayout\` sería el siguiente:\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <JsonTemplateLayout eventTemplateUri="classpath:log4j2/templates/JsonEventLayout.json"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
Donde un posible contenido para el archivo \`JsonEventLayout.json\` podría ser el siguiente:\r
\r
\`\`\`json\r
{\r
  "timeMillis": "\${timeMillis}",\r
  "thread": "\${thread}",\r
  "level": "\${level}",\r
  "loggerName": "\${loggerName}",\r
  "message": "\${message}",\r
  "thrown": "\${thrown}"\r
}\r
\`\`\`\r
\r
## 6.6.9. Actividades\r
\r
Puedes probar a realizar las siguientes actividades para practicar con Log4j2:\r
\r
1. Escribe un programa simple utilizando Log4j2 que imprima TODOS los niveles de error en la consola.\r
2. Utilizando el programa del ejercicio 1, genera un archivo de configuración manual para imprimir los errores FATALES en SYSTEM_ERR y el resto de los niveles de error en SYSTEM_OUT. (Añade comentarios en el XML con \`<!--Tu comentario-->\`)\r
3. Utilizando el programa del ejercicio 1, genera un archivo de configuración manual en el que los errores FATALES vayan a un archivo de texto, los errores de nivel ERROR aparezcan en rojo en la consola (SYSTEM_ERR) y el resto aparezcan en la consola normal (SYSTEM_OUT).\r
4. Utilizando el archivo anterior (ejercicio 3) cambia el Patrón de Salida para que lo primero que aparezca en la línea de LOG sean tus iniciales.\r
\r
!!! tip Guardar los registros en una base de datos\r
    Log4j2 también permite guardar los registros en una base de datos.\r
    Investiga cómo se puede hacer y realiza un ejemplo de cómo guardar los registros en una base de datos MySQL.\r
\r
## 6.6.10. Bibliografía\r
\r
- [Log4j2 - Documentación oficial](https://logging.apache.org/log4j/2.x/)\r
- [Tutorial de 7 partes de MakeSeleniumEasy sobre Log4j2](http://makeseleniumeasy.com/2021/03/11/log4j2-tutorial-1-introduction-to-apache-log4j2/)\r
- [Log4j2 - Tutorialspoint](https://www.tutorialspoint.com/log4j/log4j_logging_files.htm)\r
`]},{title:"6.1 Security",headers:[{level:2,title:"6.1.1. Digital security",slug:"_6-1-1-digital-security",link:"#_6-1-1-digital-security",children:[]},{level:2,title:"6.1.2. Seguridad en Java",slug:"_6-1-2-seguridad-en-java",link:"#_6-1-2-seguridad-en-java",children:[]},{level:2,title:"6.1.2. Security in Java",slug:"_6-1-2-security-in-java",link:"#_6-1-2-security-in-java",children:[{level:3,title:"JCA: Engines, algorithms and providers",slug:"jca-engines-algorithms-and-providers",link:"#jca-engines-algorithms-and-providers",children:[]}]},{level:2,title:"6.1.3. Providers",slug:"_6-1-3-providers",link:"#_6-1-3-providers",children:[{level:3,title:"6.1.4. Engines",slug:"_6-1-4-engines",link:"#_6-1-4-engines",children:[]},{level:3,title:"6.1.5 Algorithms",slug:"_6-1-5-algorithms",link:"#_6-1-5-algorithms",children:[]}]}],path:"/en/unit6/security.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.1 Security\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.1 Security" />\r
\r
# 6.1 Security\r
\r
[[toc]]\r
\r
## 6.1.1. Digital security\r
\r
Fundamental aspects of security in digital communications are:\r
\r
- **Integrity**: It allows to ensure that the data received by a receiver are identical to those sent by the sender. That is, it has not been modified at any intermediate point in **the channel, which as we know, is a shared and therefore, insecure channel**. Modifications can be caused by failures in transmission through the channel or by an intentional action of a third party.\r
- **Confidentiality**: It ensures that the transmitted data is intelligible only to the recipient of the message. Due to the characteristics of the medium, we cannot prevent the message from reaching other recipients, but what we can prevent is that they can see the original content of the message. This is achieved by encrypting the message.\r
- **Authentication**: It allows to ensure to the receiver of a message that the sender of the message is who he says he is and not any other. This is achieved with certificates and digital signature.\r
- **Non-repudiation**: It is a consequence of the previous characteristic, since a receiver can demonstrate that the message was sent by a sender unequivocally.\r
\r
## 6.1.2. Seguridad en Java\r
\r
## 6.1.2. Security in Java\r
\r
[oracle Security Developers Guide](https://docs.oracle.com/en/java/javase/11/security/java-cryptography-architecture-jca-reference-guide.html)\r
\r
From the point of view of security, the set of security classes distributed with the Java 2 SDK can be divided into two subsets:\r
\r
- Classes related to access control and permission management.\r
- Classes related to Cryptography.\r
\r
Java includes APIs for accessing general-purpose cryptographic functions, known as the **Java Cryptography Architecture (JCA)** and the **Java Cryptography Extension (JCE)**.\r
\r
The JCA is made up of the basic classes related to cryptography distributed with the JDK and the support for encryption is provided by the JCE extension package.\r
\r
Java also includes a set of packages for secure Internet communication, known as the **Java Secure Socket Extension (JSSE)**. It implements a Java version of the SSL and TLS protocols, and also includes features such as data encryption, server authentication, message integrity, and client authentication.\r
\r
Finally, Java includes an interface that allows Java applications to access authentication and access control services, the **Java Authentication and Authorization Service (JAAS)**. It can be used for two purposes: user authentication to know who is running Java code; and user authorization to ensure that whoever runs it has the necessary permissions to do so.\r
\r
### JCA: Engines, algorithms and providers\r
\r
Java has a Provider Architecture, which allows multiple implementations of cryptographic algorithms to coexist (i.e. multiple implementations of the JCE). The Java 2 platform substantially extends the JCA, among other things the certificate management infrastructure has been improved to support X.509 V3 certificates.\r
\r
To understand how the JCA works we have to define some basic terms:\r
\r
#### Engine\r
\r
In the context of the JCA we use the term engine to refer to an abstract representation of a cryptographic service that does not have a concrete implementation. A cryptographic service is always associated with an algorithm or type of algorithm and can have any of the following functions:\r
\r
- Provide cryptographic operations (such as those used in signing and digesting messages)\r
- Generate or provide the cryptographic material (keys or parameters) necessary to perform the operations.\r
- Generate objects (key stores or certificates) that group cryptographic keys in a secure manner.\r
\r
#### Algorithm\r
\r
An algorithm is an implementation of an engine. For example, the MD5 algorithm is an implementation of the message digest engine. The internal implementation may vary depending on the code provided by the MD5 class.\r
\r
#### Provider\r
\r
A provider is responsible for providing the implementation of one or more algorithms to the programmer (i.e. giving him access to a specific internal implementation of the algorithms).\r
\r
## 6.1.3. Providers\r
\r
The JCA defines the concept of provider through the Provider class of the java.security package. It is an abstract class that must be redefined by specific provider classes.\r
\r
The constructor of a provider class adjusts the values of several properties that the Java security API needs to locate the algorithms or other facilities implemented by the provider.\r
\r
The Provider class has methods to access the name of the provider, the version number and other information about the implementations of the algorithms for key generation, conversion and management and the generation of signatures and digests.\r
\r
If a programmer wants to know the available providers, he can use the methods\r
\r
- getProvider("name") to know if a specific provider is installed\r
- getProviders() that returns a vector of strings with the names of the providers\r
\r
::: info java.security file\r
%JAVA_HOME%/conf/security/java.security is the file that contains the security configuration information used by the JCA classes.\r
\r
All the providers and algorithms that are available are declared there, as well as the order in which the classes will look for them.\r
:::\r
\r
To understand how providers work we will give an example. Suppose a program needs an implementation of the MD5 algorithm. To obtain it the programmer needs to create an instance of it and will do so by writing the following line of code:\r
\r
\`\`\`java\r
MessageDigest m = MessageDigest.getInstance("MD5");\r
\`\`\`\r
\r
Internally, the getInstance() method requests the java.security.Security class to provide it with the requested object. Since no provider has been specified, the Security class queries all the available providers, requesting an implementation of the "MD5" algorithm, until it finds one or runs out of providers. The query is made according to the list of providers in the java.security file, which by default only contains the entry:\r
\r
Security.provider.1=sun.security.provider.Sun\r
\r
### 6.1.4. Engines\r
\r
In the JDK the JCA defines the following Engine classes\r
\r
| JCA Class | Function |\r
|---|---|\r
|java.security.MessageDigest | Calculation of message summary (hash).|\r
|java.security.Signature| Data signing and signature verification.|\r
|java.security.KeyPairGenerator | Generate key pairs (public and private) for an algorithm.|\r
|java.security.KeyFactory| Convert cryptographic key formats, key specifications and vice versa|\r
|java.security.certificate.CertificateFactory| Create public key certificates and revocation lists (CRLs).|\r
|java.security.KeyStore | Create and manage a key store (keystore).|\r
|java.security.AlgorithmParameters | Manage the parameters of an algorithm, including encoding and decoding.|\r
|java.security.AlgorithmParameterGenerator | Generate a set of parameters for an algorithm.|\r
|java.security.SecureRandom | Generate random or pseudo-random numbers.|\r
\r
To instantiate an engine class you must invoke the static method *getInstance()*, if you pass an algorithm name it will try to obtain an implementation of some provider.\r
\r
### 6.1.5 Algorithms\r
\r
As with command line tools, we need to know which algorithms are available for use by applications on our virtual machine.\r
\r
The following program allows us to know which providers and algorithms we have installed on our system.\r
\r
In addition, if we invoke it with the -l option it will tell us which algorithms they implement (reading the provider's properties)\r
\r
All the information shown is extracted from the *java.security* file\r
\r
\`\`\`java\r
class U6_S1_1_InfoProveedoresJCA {\r
\r
    public static void main(String[] args) {\r
        boolean listarProps = false;\r
        if (args.length > 0 && args[0].equals("-l")) {\r
            listarProps = true;\r
        }\r
        System.out.println("------------------------------------");\r
        System.out.println("Proveedores instalados en su sistema");\r
        System.out.println("------------------------------------");\r
        int i = 0;\r
        for (Provider proveedor: Security.getProviders()) {\r
            System.out.println("Núm. proveedor : " + (i + 1));\r
            System.out.println("Nombre         : " + proveedor.getName());\r
            System.out.println("Versión        : " + proveedor.getVersion());\r
            System.out.println("Información    :\\n  " + proveedor.getInfo());\r
            System.out.println("Propiedades    :");\r
            if (listarProps) {\r
                Enumeration propiedades = proveedor.propertyNames();\r
                while (propiedades.hasMoreElements()) {\r
                    String clave = (String) propiedades.nextElement();\r
                    String valor = proveedor.getProperty(clave);\r
                    System.out.println("  " + clave + " = " + valor);\r
                }\r
            }\r
            System.out.println("------------------------------------");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
The following program allows us to check the properties of algorithms available in our system.\r
\r
\`\`\`java\r
class U6_S1_2_ProbarAlgoritmosJCA {\r
\r
    public static void main(String[] args) {\r
        if (args.length != 1) {\r
            System.out.println("Uso: java ProbarAlgoritmosJCA <algoritmo>");\r
            System.exit(1);\r
        }\r
        try {\r
            MessageDigest md = MessageDigest.getInstance(args[0]);\r
            System.out.println("Algoritmo: " + md.getAlgorithm());\r
            System.out.println("Proveedor: " + md.getProvider().getName());\r
            System.out.println("Info     : " + md.toString());\r
            System.out.println("Tamaño   : " + md.getDigestLength());\r
            System.out.println("Bloque   : " + md.getBlockSize());\r
            System.out.println("Entrada  : " + md.getInputSize());\r
            System.out.println("Salida   : " + md.getOutputSize());\r
            System.out.println("Implement: " + md.getClass().getName());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.out.println("Algoritmo no disponible");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
\r
`]},{title:"6.3 Encriptación simétrica",headers:[{level:2,title:"6.3.1. Clave secreta",slug:"_6-3-1-clave-secreta",link:"#_6-3-1-clave-secreta",children:[]},{level:2,title:"6.3.2. Cipher",slug:"_6-3-2-cipher",link:"#_6-3-2-cipher",children:[{level:3,title:"Transformaciones básicas en Java",slug:"transformaciones-basicas-en-java",link:"#transformaciones-basicas-en-java",children:[]}]},{level:2,title:"6.3.3. Clases stream para cifrado y descifrado simétrico",slug:"_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",link:"#_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",children:[]},{level:2,title:"6.3.4. Cifrado simétrico con GnuPG",slug:"_6-3-4-cifrado-simetrico-con-gnupg",link:"#_6-3-4-cifrado-simetrico-con-gnupg",children:[]}],path:"/en/unit6/symmetric-key.html",pathLocale:"/en/",extraFields:[`---\r
title: 6.3 Encriptación simétrica\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.3 Encriptación simétrica" />\r
\r
# 6.3 Encriptación simétrica\r
\r
[[toc]]\r
\r
## 6.3.1. Clave secreta\r
\r
Ahora nos interesa no sólo verificar la integridad de la información intercambiada, sino también mantener su privacidad, es decir, que no sea "comprensible" durante la transmisión, intercambio o almacenamiento. \r
\r
Tenemos un conjunto de algoritmos denominados de **clave simétrica** (también conocidos como de clave secreta) en los que, mediante la aplicación de una clave conocida tanto por el emisos como por el receptor, la información se **encripta o cifra** de forma que sólo pueda ser **desencriptada o descifrada** utilizando el mismo algoritmo y la misma clave.\r
\r
::: info El código Enigma\r
Como ejemplo de sistema simétrico está Enigma. Este fue un sistema empleado por Alemania durante la Segunda Guerra Mundial, en el que las claves se distribuían a diario en forma de libros de códigos. \r
\r
Cada día, un operador de radio, receptor o transmisor, consultaba su copia del libro de códigos para encontrar la clave del día. Todo el tráfico enviado por ondas de radio durante aquel día era cifrado y descifrado usando las claves del día.\r
\r
Inglaterra usó máquinas para descifrar las claves durante aquella guerra y aunque el citado sistema alemán, Enigma, estaba provisto de un amplio abanico de claves, los ingleses diseñaron máquinas de cómputo especializado, los Bombes, para comprobar las claves de modo mecánico hasta que la clave del día era encontrada. \r
\r
Esto significaba que algunas veces encontraban la clave del día pocas horas después de que ésta fuera puesta en uso, pero también que otros días no podían encontrar la clave correcta. \r
\r
Los Bombes no fueron máquinas de cómputo general, sino las precursoras de los ordenadores (computadoras) actuales.\r
:::\r
\r
Entre los algoritmos de cifrado simétrico más utilizados se encuentran\r
\r
- DES\r
- 3DES o Tiple DES\r
- RC5\r
- AES\r
- Blowfish\r
- IDEA\r
\r
![cifrado simétrico](../../media/unit6/symmetric-encryption-primitive.png)\r
\r
## 6.3.2. Cipher\r
\r
Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *SecretKey* a partir de un KeyGenerator obtenido con el método estático *getInstance()*, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. Así podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave será diferente.\r
3. Se crea un objeto de tipo Cipher indicando qué algoritmo vamos a usar. Y después, con el método *init()* se indica qué vamos a hacer (cifrar/descifrar) y con qué clave.\r
4. Se añaden datos con el método *update()*. Se puede añadir un byte o un array de bytes. Este método se puede invocar varias veces para ir añadiendo nuevos datos.\r
5. Se obtiene el valor cifrado con el método *doFinal()*.\r
6. Si se quisiera descifrar, sólo hay que volver a invocar al método *init()* indicando en este caso que queremos descifrar.\r
\r
A continuación podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S3_1_SecretKeyEncrypt {\r
\r
    public static void main(String[] args) {\r
        SecretKey claveSecreta = null;\r
        \r
        try {\r
\r
            //Generamos clave secreta\r
            // Podemos crear una nueva clave\r
            claveSecreta = getNewKey();\r
            // O bien usar una clave guardada en algún almacén, fichero, etc.\r
            claveSecreta = getKeyFromData();\r
\r
            System.out.println("Clave usada: " + claveSecreta.getFormat());\r
            //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
            Cipher c = Cipher.getInstance("DESede"); // AES/ECB/PKCS5Padding\r
            // Configuramos el modo de CIFRADO\r
            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\r
\r
            // Aquí leemos la información que queremos cifrar\r
            // Puede ser una cadena o leerla de un archivo\r
            byte[] textoPlano = "Texto que queremos cifrar para la prueba".getBytes();\r
            \r
            // Si queremos ir cifrando poco a poco, vamos haciendo llamadas\r
            // al método update\r
            // c.update(textoPlano);\r
            // Se realiza el proceso final de cifrado de la información\r
            byte[] textoCifrado = c.doFinal(textoPlano);\r
            System.out.println("Texto cifrado con clave secreta (raw):\\n" + new String(textoCifrado));\r
            System.out.println("Texto cifrado con clave secreta (hex):\\n" + toHexadecimal(textoCifrado));\r
                        \r
            \r
            // El proceso de descifrado es equivalente\r
            // Cambiamos el modo de ENCRYPT a DECRYPT\r
            // Usamos la misma clave\r
            // Pasamos el texto cifrado para obtener el original\r
            c.init(Cipher.DECRYPT_MODE, claveSecreta);\r
            byte[] textoOriginal = c.doFinal(textoCifrado);\r
            //Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\r
            System.out.println("Texto descifrado:\\n" + new String(textoOriginal));\r
            \r
        } catch (Exception e) {\r
            e.printStackTrace();\r
        }\r
    }\r
\r
    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
    \r
            KeyGenerator kg = KeyGenerator.getInstance("DESede");\r
            kg.init(112);\r
            SecretKey clave = kg.generateKey();\r
            \r
            return clave;\r
    }\r
\r
    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // Clave obtenida usando un generador de número aleatorios seguro\r
        KeyGenerator genClaves = KeyGenerator.getInstance("DESede");\r
        // Utilizamos un algoritmo de generación de aleatorios        \r
        SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");\r
        genClaves.init(srand);\r
        \r
        SecretKey clave = genClaves.generateKey();\r
        System.out.println("Formato de clave: " + clave.getFormat());\r
        \r
        /*\r
        SecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance("DESede");\r
        DESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\r
        byte[] valorClave = keySpec.getKey();\r
        */\r
        \r
        return clave;\r
    }\r
    \r
    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        SecretKeySpec keySpec = new SecretKeySpec (valorClave, "DESede");\r
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");\r
        SecretKey clave = keyFactory.generateSecret(keySpec);\r
        \r
        return clave;\r
    }\r
\r
    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        Key clave = new SecretKeySpec(valorClave, "AES");\r
\r
        return clave;\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
    \r
}\r
\`\`\`\r
\r
y esta sería la salida proporcionada\r
\r
\`\`\`sh\r
Texto cifrado con clave secreta:\r
D0A61CD14B5844AD98B2C7BA795B327ACA0795B658C6F93EC6E1586A246BE71AC180B574207E8C4FFEB959B7D4642FCB\r
Texto descifrado:\r
Texto que queremos cifrar para la prueba\r
\`\`\`\r
\r
Hay que tener en cuenta que en el ejemplo la clave se está usando primero para cifrar y luego para descifrar. Si esto lo hacemos en programas separados, los programas que quieran comunicarse deberán tener acceso a la clave.\r
\r
Lo que se suele hacer es almacenar la clave en un archivo y, cuando se necesita para cifrar o descifrar, se lee con un método similar al método *getKeyFromData()* del ejemplo anterior.\r
\r
### Transformaciones básicas en Java\r
\r
En la siguiente tabla tenemos los algoritmos, modos y tipos de relleno, junto con la longitud de clave empleada, de los algoritmos de cifrado simétrico m'as comunes.\r
\r
|Transformación (algoritmo/modo/relleno)|Key Size|\r
|---|---|\r
|AES/CBC/NoPadding|128|\r
|AES/CBC/PKCS5Padding|128|\r
|AES/ECB/NoPadding|128|\r
|AES/ECB/PKCS5Padding|128|\r
|DES/CBC/NoPadding|56|\r
|DES/CBC/PKCS5Padding|56|\r
|DES/ECB/NoPadding|56|\r
|DES/ECB/PKCS5Padding|56|\r
|DESede/CBC/NoPadding|168|\r
|DESede/CBC/PKCS5Padding|168|\r
|DESede/ECB/NoPadding|168|\r
|DESede/ECB/PKCS5Padding|168|\r
|RSA/ECB/PKCS1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-1AndMGF1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-256AndMGF1Padding|1024, 2048|\r
\r
\r
## 6.3.3. Clases stream para cifrado y descifrado simétrico\r
\r
Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete *java.crypto* pero por lo demás funcionan exactamente igual que las clases Stream del paquete *java.io*, de las que además son clases descendientes y y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.\r
\r
| Clase |Ejemplo |\r
| --- | --- |\r
| CipherInputStream | CipherInputStream (InputStream is, Cipher c) |\r
| CipherOutputStream | CipherOutputStream (OutputStream os, Cipher c) |\r
\r
Por lo tanto, cuando tenemos que leer o escribir información, podemos añadir un envoltorio más al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher.\r
\r
El uso más común es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la información de forma cifrada/descifrada.\r
\r
::: warning Tamaño de bloque\r
Muchos de los algoritmos de cifrado simétrico trabajan con bloques de datos, por lo que no debemos intentar cifrar o descifrar más información de la que permite el tamaño de bloque.\r
\r
La clase Cipher tiene un método **getBlockSize()** que nos devuelve el tamaño de bloque que permite el algoritmo configurado en su método **init()**.\r
:::\r
\r
Veamos un ejemplo de cómo quedaría el wrapper\r
\r
\`\`\`java\r
public class U6S3_2_StreamCrypto {\r
\r
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\r
        File file;\r
        String filePath = "a.txt";\r
\r
        file = new File(filePath);\r
\r
        //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding"); //DESede\r
        // Configuramos el modo de CIFRADO\r
        byte[] valorClave = "12345678123456781234567812345678".getBytes();\r
\r
        // CIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.ENCRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (OutputStream outputStream = new BufferedOutputStream(\r
                new CipherOutputStream(new FileOutputStream(file), c))) {\r
            for (int i = 0; i < 10; i++) {\r
                outputStream.write(new String("Hello World\\n").getBytes());\r
            }\r
\r
        }\r
\r
        // DESCIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.DECRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (InputStream inputStream = new BufferedInputStream(\r
                new CipherInputStream(new FileInputStream(file), c))) {\r
\r
            System.out.println("Contenido del fichero (descifrado):\\n" + new String(inputStream.readAllBytes()));\r
        }\r
\r
    }\r
}\r
\`\`\`\r
\r
## 6.3.4. Cifrado simétrico con GnuPG\r
\r
Con la suite GnuPG también podemos cifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la información de los algoritmos disponibles para cada tipo de servicio. En concreto, de resúmenes, en mi versión instalada:\r
\r
Cifrado: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\r
         CAMELLIA128, CAMELLIA192, CAMELLIA256\r
:::\r
\r
Para cifrar y descifrar un archivo, ejecutamos los siguientes comandos\r
\r
\`\`\`sh\r
gpg --symmetric --cipher-algo 3DES filename.ext\r
gpg --decrypt filename.ext.gpg\r
\`\`\`\r
\r
Vemos que para el cifrado nos solicita una clave y que con el parámetro *--cipher-algo* indicamos qué algoritmo de encriptación queremos utilizar.\r
\r
El cifrado genera un archivo filename.ext.gpg.\r
\r
Para el descifrado, no hace falta indicar el algoritmo, aunque se puede volver a usar el parámetro *--cipher-algo* y la clave se queda en una cache de GnuPG durante un tiempo, por lo que no siempre la solicita.\r
`]},{title:"1.2 Concurrencia",headers:[{level:2,title:"1.2.1. Concurrencia vs Paralelismo",slug:"_1-2-1-concurrencia-vs-paralelismo",link:"#_1-2-1-concurrencia-vs-paralelismo",children:[{level:3,title:"Monoproceso",slug:"monoproceso",link:"#monoproceso",children:[]},{level:3,title:"Multiprogramación",slug:"multiprogramacion",link:"#multiprogramacion",children:[]},{level:3,title:"Paralelismo",slug:"paralelismo",link:"#paralelismo",children:[]}]},{level:2,title:"1.2.2. Sistemas distribuidos",slug:"_1-2-2-sistemas-distribuidos",link:"#_1-2-2-sistemas-distribuidos",children:[]},{level:2,title:"1.2.3. Ventajas e inconvenientes",slug:"_1-2-3-ventajas-e-inconvenientes",link:"#_1-2-3-ventajas-e-inconvenientes",children:[]},{level:2,title:"1.2.4. Condiciones de Bernstein",slug:"_1-2-4-condiciones-de-bernstein",link:"#_1-2-4-condiciones-de-bernstein",children:[]}],path:"/es/unit1/concurrency.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.2 Concurrencia\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.2. Concurrencia" />\r
\r
# 1.2. Concurrencia\r
\r
[[toc]]\r
\r
Según el diccionario de la [RAE](https://dle.rae.es/concurrencia?m=form) una de las acepciones de concurrencia es\r
> Coincidencia, concurso simultáneo de varias circunstancias.\r
\r
Si cambiamos circunstancias por \`procesos\`, ya tendríamos una definición cercana a lo que significa concurrencia en el mundo digital\r
\r
Si nos fijamos, no es la primera vez que surge la palabra \`proceso\` en este texto, y es que los procesos son una pieza fundamental del puzle, por no decir la parte más importante.\r
\r
## 1.2.1. Concurrencia vs Paralelismo\r
\r
Ahora que ya sabemos qué es un proceso, vamos a ver la relación que éstos tienen con el hardware en el que se ejecutan.\r
\r
### Monoproceso\r
\r
Por mucho que tengamos varios procesos procesos ejecutándose a la vez, si sólo tenemos un microprocesador para atenderlos a todos, estas tareas nunca van a poder ejecutarse a la vez.\r
\r
Una posibilidad sería la ejecución secuencias de las tareas en el sistema. Se empieza a ejecutar una tarea y, hasta que esta no finaliza, el sistema no empieza a ejecutar la siguiente. Esto se correspondería con sistemas que sólo son capaces de hacer una tarea a la vez, algo raro hoy en día.\r
\r
![Secuential execution of tasks (monoprocessor system)](./../../media/unit1/gantt_sequential.svg)\r
\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Secuential execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1       :done, t1, 0, 4s\r
Process 2     : active, t2, after t1, 5s\r
Process 3     : crit, t3, after t2, 2s\r
Process 4    : t4, after t3, 5s\r
\`\`\`\r
-->\r
\r
### Multiprogramación\r
\r
Para que los procesos no tengan que esperar a que todos los demás se ejecuten, los sistemas aprovechan y exprimen los recursos al máximo, permitiendo la ilusión de que varios procesos se ejecutan de forma simultánea. Esto es lo que se conoce como \`multitarea\`.\r
\r
En estos sistemas, se aprovecha el diseño de los sistemas operativos modernos, y de las operaciones que realizan los procesos que no requieren el uso del procesador (esperar a una operación de E/S, una interacción con el usuario, la recepción de información desde la red, etc.) para poder ejecutar otros procesos. La ejecución se multiplexa en el tiempo.\r
\r
![Concurrent execution of tasks (monoprocessor system)](./../../media/unit1/gantt_concurrent.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Concurrent execution of tasks (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 3  :crit, t3, after t2, 2s\r
Process 4  : t4, after t3, 1s\r
Process 1  :done, t5, after t4, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 4  : t7, after t6, 3s\r
Process 2  :active, t8, after t7, 2s\r
Process 4  : t9, after t8, 1s\r
\`\`\`\r
-->\r
\r
Como se puede observar en las dos imágenes anteriores (aunque se trata sólo de un modelo), el tiempo de uso total del procesador es igual en ambos casos, es decir, que el sistema tardará el mismo tiempo en completar todas las tareas. Sin embargo, la sensación es que todas las tareas se están realizando a la vez.\r
\r
### Paralelismo\r
\r
Con el avance de la tecnología ahora la gran mayoría de dispositivos, desde los equipos de escritorio, portátiles, dispositivos móviles, ... hasta los dispositivos IoT, tienen capacidades de multiproceso, es decir, tienen más de un procesador para poder realizar varias tareas a la vez de forma real, no simulada.\r
A este tipo de ejecución es a lo que llamamos \`paralelismo\`.\r
\r
![Parallel execution of tasks (dual processor system)](./../../media/unit1/gantt_parallel.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Parallel execution of tasks (dual processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1  :done, t1, 0, 2s\r
Process 2  :active, t2, after t1, 2s\r
Process 1  :done, t5, after t2, 2s\r
Process 2  :active, t6, after t5, 1s\r
Process 2  :active, t8, after t6, 2s\r
section Processor 2\r
Process 3  :crit, t3, 0, 2s\r
Process 4  : t4, after t3, 1s\r
Process 4  : t7, after t4, 3s\r
Process 4  : t9, after t7, 1s\r
\`\`\`\r
-->\r
\r
En este caso, a mayor número de unidades de proceso, menor tiempo tardarán las tareas en completarse y mayor será la sensación de rapidez que notará el usuario. Este es uno de los retos de los sistemas operativos, planificar adecuadamente las tareas para minimizar los tiempos de ejecución, de espera y el uso de los recursos del sistema, el procesador principalmente.\r
\r
::: question núcleos vs hilos\r
Si habéis comprado un procesador hace poco, o estáis al día en cuanto al hardware, sabréis que una de las características de los procesadores es su **número de núcleos** (4, 8, 16).\r
\r
Pero además, al número de núcleos lo acompaña otra característica que es el número de **hilos o threads**, que suele ser el doble que el de núcleos.\r
\r
¿Qué implicación tienen los threads de un procesador con respecto a la concurrencia? ¿Si un equipo tiene 8 núcleos / 16 hilos significa eso que puede ejecutar 16 procesos a la vez?\r
:::\r
\r
## 1.2.2. Sistemas distribuidos\r
\r
> "Un sistema distribuido es una colección de computadores independientes que aparecen ante los usuarios como un único sistema coherente"\r
>\r
> "Andrew S. Tanembaum"\r
\r
Posiblemente el ejemplo más famoso y conocido de sistema distribuido sea \`Internet\`.Internet aparece ante los usuarios como un enorme repositorio de documentos, es decir, como un único sistema capaz de proveer casi cualquier tipo de información o servicio que se necesite. No obstante, sabemos que está compuesta por millones de equipos ubicados en localizaciones diferentes e interconectados entre sí.\r
\r
Nace de la necesidad de compartir recursos. Actualmente el máximo exponente de este tipo de sistemas es el \`Cloud Computing\` o servicios en la nube. Un sistema es distribuido cuando los componentes software están distribuidos en la red, se comunican y coordinan mediante el paso de mensajes.\r
\r
Las características de este tipo de sistemas son::\r
\r
- Concurrencia: ejecución de programas concurrentes.\r
- Inexistencia de un reloj global. Implica sincronizarse con el paso de mensajes.\r
- Fallos independientes: cada componente del sistema puede fallar sin que perjudique la ejecución de los demás.\r
\r
## 1.2.3. Ventajas e inconvenientes\r
\r
Ventajas del procesamiento paralelo:\r
\r
- Ejecución simultánea de tareas.\r
- Disminuye el tiempo total de ejecución\r
- Resuelve problemas complejos y de grandes dimensiones.\r
- Utilización de recursos no locales distribuidos en la red\r
- Disminución de costos, aprovechando los recursos distribuidos, no es necesario gastar en un único supercomputador, se puede alcanzar el mismo poder de computación con equipos más modestos distribuidos.\r
\r
Inconvenientes del procesamiento paralelo:\r
\r
- Los compiladores y entornos de programación para sistemas paralelos son más complicados de desarrollar.\r
- Los programas paralelos son más difíciles de escribir\r
- Hay mayor consumo de energía\r
- Mayor complejidad en el acceso a datos\r
- Complejidad a la hora de la comunicación y sincronización de las diferentes subtareas. <Badge type="danger" text="cuidado" vertical="middle" />\r
\r
Ventajas de la programación distribuida\r
\r
- Se comparten recursos y datos\r
- Crecimiento bajo demanda\r
- Mayor flexibilidad para distribuir la carga\r
- Alta disponibilidad\r
- Soporte de aplicaciones distribuidas\r
- Filosofía abierta y heterogénea\r
\r
::: question Escalado de sistemas\r
Con escalado nos referimos a la posibilidad de incrementar las capacidades de un sistema.\r
\r
Investiga las diferencias, ventajas e inconvenientes del \`escalado horizontal\` y el \`escalado vertical\`.\r
:::\r
\r
Inconvenientes de la programación distribuida\r
\r
- Aumenta la complejidad\r
- Se necesita software nuevo especializado\r
- Problemas derivados de las comunicaciones (perdidas, saturaciones, etc.)\r
- Problemas de seguridad, ataques DDoS\r
\r
Ejemplos de utilización de la programación paralela y distribuida\r
\r
- Estudios meteorológicos\r
- Estudios del genoma humano\r
- Modelado de la biosfera\r
- Predicciones sísmicas\r
- Simulación de moléculas\r
\r
::: info Ejemplo de programación paralela y distribuida\r
[Búsqueda de inteligencia extraterrestre - Proyecto SETI](https://setiathome.berkeley.edu/sah_about.php)\r
:::\r
\r
## 1.2.4. Condiciones de Bernstein\r
\r
Una vez que sabemos qué es un programa concurrente y las distintas arquitecturas hardware que pueden soportarlo, vamos a ver qué partes de un programa se pueden ejecutar de forma concurrente y cuáles no.\r
\r
Si observamos el siguiente código, queda claro que la primera instrucción se debe ejecutar antes que la segunda para que el resultado sea siempre el mismo (para los mismos datos de entrada).\r
\r
\`\`\`java\r
x = x + 1;\r
y = x + 1;\r
\`\`\`\r
\r
Sin embargo, en un código como el siguiente el orden en el que se ejecuten las instrucciones no influye en el resultado final (valor de las variables). En este caso se pueden ejecutar las tres sentencias a la vez incrementando la velocidad de procesamiento.\r
\r
\`\`\`java\r
x = 1;\r
y = 2;\r
z = 3;\r
\`\`\`\r
\r
A.J. Bernstein definió unas condiciones para determinar si dos conjuntos de instrucciones S<sub>i</sub> y S<sub>j</sub> se pueden ejecutar concurrentemente.\r
\r
Para poder determinar si dos conjuntos de instrucciones se pueden ejecutar concurrentemente, se definen en primer lugar los siguientes conjuntos\r
\r
- L(S<sub>k</sub>) = {a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ...} como el conjunto de lectura formado por todas las variables cuyos valores se leen durante la ejecución de las instrucciones del conjunto k.\r
- E(S<sub>k</sub>) = {b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub>, ...} como el conjunto de escritura formado por todas las variables cuyos valores se actualizan durante la ejecución de las instrucciones del conjunto k.\r
\r
Para que dos conjuntos de instrucciones S<sub>i</sub> y S<sub>j</sub> se puedan ejecutar concurrentemente, se deben cumplir estas tres condiciones de forma simultánea.\r
\r
- L(S<sub>i</sub>) ∩ E(S<sub>j</sub>)\r
- E(S<sub>i</sub>) ∩ L(S<sub>j</sub>)\r
- E(S<sub>i</sub>) ∩ E(S<sub>j</sub>)\r
  \r
::: question Cuales de estas instrucciones se pueden ejecutar de forma concurrente\r
\r
\`\`\`java\r
a = x + y;\r
b = z - 1;\r
c = a - b;\r
w = c + 1;\r
\`\`\`\r
\r
:::\r
\r
Primero deberíamos obtener los conjuntos L y E para cada sentencia\r
\r
> L(S<sub>1</sub>) = {x, y}\r
>\r
> E(S<sub>1</sub>) = {a}\r
\r
> L(S<sub>2</sub>) = {z}\r
>\r
> E(S<sub>2</sub>) = {b}\r
\r
> L(S<sub>3</sub>) = {a, b}\r
>\r
> E(S<sub>3</sub>) = {c}\r
\r
>L(S<sub>4</sub>) = {c}\r
>\r
> E(S<sub>4</sub>) = {w}\r
\r
Y ahora aplicarlas entre cada par de sentencias\r
\r
> L(S<sub>1</sub>) ∩ E(S<sub>2</sub>) = ∅\r
> E(S<sub>1</sub>) ∩ L(S<sub>2</sub>) = ∅\r
> E(S<sub>1</sub>) ∩ E(S<sub>2</sub>) = ∅         // Sí se pueden ejecutar concurrentemente\r
\r
> L(S<sub>1</sub>) ∩ E(S<sub>3</sub>) = ∅\r
> E(S<sub>1</sub>) ∩ L(S<sub>3</sub>) = {a} ≠ ∅\r
> E(S<sub>1</sub>) ∩ E(S<sub>3</sub>) = ∅         // NO se pueden ejecutar concurrentemente\r
\r
> L(S<sub>1</sub>) ∩ E(S<sub>4</sub>) = ∅\r
> E(S<sub>1</sub>) ∩ L(S<sub>4</sub>) = ∅\r
> E(S<sub>1</sub>) ∩ E(S<sub>4</sub>) = ∅         // Sí se pueden ejecutar concurrentemente\r
\r
> L(S<sub>2</sub>) ∩ E(S<sub>3</sub>) = ∅\r
> E(S<sub>2</sub>) ∩ L(S<sub>3</sub>) = {b] ≠\r
> E(S<sub>2</sub>) ∩ E(S<sub>3</sub>) = ∅         // NO se pueden ejecutar concurrentemente\r
\r
> L(S<sub>2</sub>) ∩ E(S<sub>4</sub>) = ∅\r
> E(S<sub>2</sub>) ∩ L(S<sub>4</sub>) = ∅\r
> E(S<sub>2</sub>) ∩ E(S<sub>4</sub>) = ∅         // Sí se pueden ejecutar concurrentemente\r
\r
> L(S<sub>3</sub>) ∩ E(S<sub>4</sub>) = ∅\r
> E(S<sub>3</sub>) ∩ L(S<sub>4</sub>) = {c} ≠ ∅\r
> E(S<sub>3</sub>) ∩ E(S<sub>4</sub>) = ∅         // NO se pueden ejecutar concurrentemente\r
`]},{title:"1 Introducción",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit1/",pathLocale:"/es/",extraFields:[`---\r
title: 1 Introducción\r
---\r
# Tema 1. Programación concurrente\r
\r
En este primer tema vamos a conocer los conceptos básicos relacionados con la programación concurrente, así como la mayoría de la terminología que vamos a trabajar y utilizar durante todo el curso.\r
\r
En un mundo en el que cada vez los dispositivos electrónicos son cada vez más potentes, y veloces, el software debe ser capaz de aprovechar las características que le ofrecen tanto el hardware como los sistemas operativos.\r
\r
Son muchas las tareas que requieren de un procesamiento rápido de cantidades ingentes de datos. Un par de ejemplos los tenemos en las aplicaciones \`Big Data\` e \`Inteligencia artificial\`. Estos dos campos son unos de los máximos exponentes en cuanto a programación concurrente.\r
\r
::: details ¿Qué es para ti concurrencia?\r
Vamos a discutirlo en clase.\r
Iremos desgranando y definiendo el concepto a lo largo del tema\r
:::\r
\r
## Objetivos\r
\r
Los objetivos que alcanzaremos tras esta unidad son:\r
\r
- Diferenciar entre programa y proceso\r
- Comprender qué es la concurrencia\r
- Conocer el concepto, diferencias y relación existente entre las dos unidades básicas de ejecución: procesos e hilos.\r
- Tener nociones sobre programación concurrente\r
- Entender el funcionamiento concurrente del SO y del hardware\r
`]},{title:"1.3 Procesos en el SO",headers:[{level:2,title:"1.3.1. El kernel del SO",slug:"_1-3-1-el-kernel-del-so",link:"#_1-3-1-el-kernel-del-so",children:[]},{level:2,title:"1.3.2. Control de procesos en GNU/Linux",slug:"_1-3-2-control-de-procesos-en-gnu-linux",link:"#_1-3-2-control-de-procesos-en-gnu-linux",children:[{level:3,title:"Comandos para saber el pid de los procesos",slug:"comandos-para-saber-el-pid-de-los-procesos",link:"#comandos-para-saber-el-pid-de-los-procesos",children:[]},{level:3,title:"Comandos para ver los procesos activos",slug:"comandos-para-ver-los-procesos-activos",link:"#comandos-para-ver-los-procesos-activos",children:[]},{level:3,title:"Control de procesos",slug:"control-de-procesos",link:"#control-de-procesos",children:[]}]},{level:2,title:"1.3.3. Estados de un proceso",slug:"_1-3-3-estados-de-un-proceso",link:"#_1-3-3-estados-de-un-proceso",children:[]},{level:2,title:"1.3.4 Planificación de procesos",slug:"_1-3-4-planificacion-de-procesos",link:"#_1-3-4-planificacion-de-procesos",children:[]},{level:2,title:"1.3.5. Algoritmos de planificación de procesos",slug:"_1-3-5-algoritmos-de-planificacion-de-procesos",link:"#_1-3-5-algoritmos-de-planificacion-de-procesos",children:[{level:3,title:"FCFS - First Come First Served",slug:"fcfs-first-come-first-served",link:"#fcfs-first-come-first-served",children:[]},{level:3,title:"SJF - Shortest Job First",slug:"sjf-shortest-job-first",link:"#sjf-shortest-job-first",children:[]},{level:3,title:"Planificación por prioridad",slug:"planificacion-por-prioridad",link:"#planificacion-por-prioridad",children:[]},{level:3,title:"Round Robin",slug:"round-robin",link:"#round-robin",children:[]},{level:3,title:"Procesos con operaciones de E/S o bloqueos",slug:"procesos-con-operaciones-de-e-s-o-bloqueos",link:"#procesos-con-operaciones-de-e-s-o-bloqueos",children:[]}]}],path:"/es/unit1/operatingsystem.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.3 Procesos en el SO\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.3. Procesos en el SO" />\r
\r
# 1.3. Procesos en el Sistema Operativo\r
\r
[[toc]]\r
\r
## 1.3.1. El kernel del SO\r
\r
El \`kernel o núcleo de un SO\` se encarga de la funcionalidad básica del sistema, el responsable de la gestión de los recursos del ordenador, se accede al núcleo a través de las llamadas al sistema, es la parte más pequeña del sistema en comparación con la interfaz. El resto del sistema operativo se le denomina como programas del sistema.\r
\r
Todos los programas que se ejecutan en el ordenador se organizan como un conjunto de procesos. Es el sistema operativo el que decide parar la ejecución , por ejemplo, porque lleva mucho tiempo en la CPu, y decide cuál será el siguiente proceso que pasará a ejecutarse.\r
\r
Cuando se suspende la ejecución de un proceso, luego deberá reiniciarse en el mismo estado en el que se encontraba antes de ser suspendido. Esto implica que debemos almacenar en algún sitio la información referente a ese proceso para poder luego restaurarla tal como estaba antes. Esta información se almacena en el \`PCB\` (Bloque de control de procesos).\r
\r
Estos \`cambios de contexto\`, que es como se conoce al reemplazo de un proceso por otro, son bastante costosos (en tiempo y recursos) por toda la información que hay que guardar. Ya veremos más adelante que existe otra unidad de ejecución, los \`hilos\`, que solucionan en parte este problema.\r
\r
![Process Control Block](./../../media/unit1/process_control_blocks.gif)\r
\r
## 1.3.2. Control de procesos en GNU/Linux\r
\r
Los sistemas Linux identifican a los procesos por su PID (Process ID) así como por su PPID (Parent PID). De esta forma, los procesos pueden clasificarse en:\r
\r
- Procesos padre: Son procesos que crean otros procesos durante su ejecución\r
- Procesos hijos: son procesos creados por otros procesos\r
\r
Cuando se arranca el sistema, el kernel lanza el proceso **init** que es la madre de todos los demás procesos. Al ser el primero que se lanza es el único que no tiene padre. El proceso init se encarga de gestionar todos los demás procesos que se van ejecutando en el SO.\r
\r
::: info proceso init\r
El proceso init tiene el pid 1 y, como ya hemos dicho no tiene padre.\r
\r
Este proceso se utiliza como padre "adoptivo" para todos aquellos procesos que se quedan huérfanos.\r
:::\r
\r
### Comandos para saber el pid de los procesos\r
\r
El comando \`pidof cmdname\` nos dice el nombre de todos los procesos asociados a ese comando. Es importante recordar que cada vez que ejecutamos un comando, se crea un nuevo proceso.\r
\r
Las variables $$ y $PPID nos indican el pid del proceso actual y su ppid respectivamente.\r
\r
\`\`\`bash\r
# pidof systemd\r
1\r
# pidof top\r
2060\r
# pidof httpd\r
2103 2102 2101 2100 2099 1076\r
# Process pid\r
echo $$\r
2109\r
# Process parent pid\r
echo $PPID\r
2106\r
\`\`\`\r
\r
### Comandos para ver los procesos activos\r
\r
El principal comando para conocer los procesos que se están ejecutando en un equipo es el comando \`ps\`. Con este comando podemos ver parte de la información asociada a un proceso.\r
\r
El comando ps tiene múltiples opciones que nos permiten ver más o menos información de los procesos, así como los procesos de nuestro usuario o del resto de usuarios, estadísticas sobre el uso de recursos de cada proceso, etc.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD\r
root         1     0  0   223   576   5 11:00 ?        00:00:00 /init\r
root         7     1  0   223    80   3 11:00 ?        00:00:00 /init\r
root         8     7  0   223    80   1 11:00 ?        00:00:00 /init\r
vicente      9     8  0  2508  5032   4 11:00 pts/0    00:00:00 -bash\r
vicente     70     9  0  2650  3224   5 11:06 pts/0    00:00:00 ps -AF\r
vicente@Desktop-Vicente:~$ ps -auxf\r
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\r
root         1  0.0  0.0    892   576 ?        Sl   11:00   0:00 /init\r
root         7  0.0  0.0    892    80 ?        Ss   11:00   0:00 /init\r
root         8  0.0  0.0    892    80 ?        S    11:00   0:00  \\_ /init\r
vicente      9  0.0  0.0  10032  5032 pts/0    Ss   11:00   0:00      \\_ -bash\r
vicente     72  0.0  0.0  10832  3408 pts/0    R+   11:09   0:00          \\_ ps -auxf\r
\`\`\`\r
\r
::: info Useful ‘ps’ examples for Linux process monitoring\r
[https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/](https://www.tecmint.com/ps-command-examples-for-linux-process-monitoring/)\r
:::\r
\r
El otro comando que nos permite ver la información, en este caso en tiempo real, de los procesos que se están ejecutando en l máquina junto con los recursos que están consumiendo, es el comando \`top\`.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ ps -AF\r
top - 11:14:52 up 14 min,  0 users,  load average: 0.00, 0.00, 0.00\r
Tasks:   5 total,   1 running,   4 sleeping,   0 stopped,   0 zombie\r
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\r
MiB Mem :  12677.3 total,  12556.4 free,     70.6 used,     50.3 buff/cache\r
MiB Swap:   4096.0 total,   4096.0 free,      0.0 used.  12433.8 avail Mem\r
\r
  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND\r
    1 root      20   0     892    576    516 S   0.0   0.0   0:00.04 init\r
    7 root      20   0     892     80     20 S   0.0   0.0   0:00.00 init\r
    8 root      20   0     892     80     20 S   0.0   0.0   0:00.01 init\r
    9 vicente   20   0   10032   5032   3324 S   0.0   0.0   0:00.11 bash\r
   73 vicente   20   0   10856   3664   3148 R   0.0   0.0   0:00.00 top\r
\`\`\`\r
\r
::: info ‘top’ examples in Linux\r
[https://www.tecmint.com/12-top-command-examples-in-linux/](https://www.tecmint.com/12-top-command-examples-in-linux/)\r
:::\r
\r
### Control de procesos\r
\r
Linux tiene varios comandos para controlar los procesos, entre los que cabe destacar el comando \`kill\`.\r
\r
La forma de controlar los procesos es enviándoles señales. Hay multitud de señales que se pueden enviar a un proceso. Sin embargo, para responder a una señal, los procesos deben estar programados para gestionarlas.\r
\r
\`\`\`bash\r
# Get Firefox PID after it freezes\r
$ pidof firefox\r
2687\r
# Send the SIGKILL (9) signal to end the process immediately\r
$ kill 9 2687\r
\`\`\`\r
\r
::: info How to control Linux process Using kill, pkill and killall\r
[https://www.tecmint.com/how-to-kill-a-process-in-linux/](https://www.tecmint.com/how-to-kill-a-process-in-linux/)\r
:::\r
\r
Otra forma de influir en la ejecución de los procesos es mediante la prioridad. En los sistemas Linux todos los procesos tienen una cierta prioridad. Esto influye a la hora de obtener tiempo de CPU por lo que podemos conseguir que un proceso se ejecute más o menos rápido que los demás.\r
\r
Un usuario con privilegios de *root* puede modificar los valores de prioridad de los procesos. Este valor lo podemos ver en la columna NI (nice) del comando top. Este valor influye en la columna PR que indica la prioridad que le da el sistema a un proceso.\r
\r
El rango de asignación de prioridad disponible es de -20 a 19 , siendo -20 la mayor prioridad y 19 la menor. Con el comando \`nice\` podemos asegurarnos que en momentos de usos elevados de CPU los procesos adecuados reciban el mayor % de la misma.\r
\r
\`\`\`bash\r
vicente@Desktop-Vicente:~$ nice\r
0\r
vicente@Desktop-Vicente:~$ nice -n 10 bash\r
vicente@Desktop-Vicente:~$ nice\r
10\r
vicente@Desktop-Vicente:~$\r
\`\`\`\r
\r
::: tip Control de procesos en Windows\r
En los sistemas operativos Windows, la mayoría de estas acciones se pueden realizar desde el administrador de tareas, aunque también tenemos los comandos **tasklist** y **taskkill** para hacerlo desde consola\r
\r
*tasklist /svc /fi “imagename eq svchost.exe”*\r
Con esta instrucción sabremos que servicios se están ejecutando bajo el proceso svchost.exe, es el nombre de proceso de host genérico para servicios que se ejecutan desde bibliotecas de vínculos dinámicos (DLL), hay tantos para evitar riesgos ya que si estuviera todo en uno, un posible fallo podría colapsar el sistema.\r
:::\r
\r
## 1.3.3. Estados de un proceso\r
\r
El siguiente diagrama muestra los tres posibles estados en los que se puede encontrar un proceso. Las líneas que conectan los estados representan las posibles transiciones que se pueden dar.\r
\r
En todo momento un procesos estará en una de los tres estados. Como ya hemos visto, en los sistemas monoprocesador, un único proceso podrá estar en estado de ejecución en un momento dado. El resto de procesos estará o bien en espera o bien bloqueados.\r
\r
Para cada uno de los estados se gestiona una lista de procesos que administra el kernel del SO. Los procesos permanecerán en la cola hasta que se produzca algún evento.\r
\r
![Estados de un proceso](./../../media/unit1/estados_proceso.png)\r
\r
- **Nuevo**. El fichero es creado a partir de un ejecutable.\r
- **Listo**. Está parado temporalmente y listo para ejecutarse cuando se le dé la oportunidad. El sistema operativo todavía no le asigno un procesador para ejecutarse. El planificador del S.O. será el responsable de seleccionar el proceso para que pase a estado de ejecución.\r
- **En ejecución**. Está usando el procesador. El sistema operativo utiliza el mecanismo de interrupciones para controlar su ejecución. Si el proceso necesitase un recurso, incluyendo la realización de operaciones de E/S, llamará a la llamada al sistema correspondiente. Si un proceso se ejecuta durante el máximo tiempo permitido por la política del sistema, salta un temporizador que lanza una interrupción. Si el sistema es de tiempo compartido, lo para y lo pasa a estado de listo.\r
- **Bloqueado**. El proceso se encuentra bloqueado esperando a a que ocurra algún suceso. Por ejemplo puede estar esperando a que termine alguna operación de E/S, o bien a sincronizarse con otro proceso. Cuando ocurre el evento que lo desbloquea, el proceso queda pendiente de ser planificado por el S.O. no pasa directamente a ejecución.\r
- **Terminado**. El proceso termina y libera su imagen de memoria. Es el propio proceso el que debe llamar al sistema para indicar que ha terminado, aunque el sistema puede finalizarlo con una excepción (que es una interrupción especial).\r
\r
Transiciones entre estados:\r
\r
- **De ejecución a bloqueado**: un proceso pasa de ejecución a bloqueado cuando espera la ocurrencia de un evento externo.\r
- **De bloqueado a listo**: cuando ocurre el evento externo que esperaba\r
- **De listo a ejecución**: cuando el sistema le otorga un tiempo de CPU.\r
- **De ejecución a listo**: cuando se le acaba el tiempo asignado por el S.O.\r
\r
## 1.3.4 Planificación de procesos\r
\r
Uno de los objetivos de los sistemas operativos es la multiprogramación, es decir, admitir varios procesos en memoria para maximizar el uso del procesador. Esto funciona ya que los procesos se irán intercambiando el uso del procesador para su ejecución de forma concurrente. Para ello, el sistema operativo organiza los procesos en varias colas pasándolos de unas colas a otras\r
\r
- Cola de procesos: contiene todos los procesos del sistema\r
- Cola de procesos preparados: todos los procesos listos esperando para ejecutarse.\r
- Varias colas de dispositivos: procesos que están esperando alguna operación de E/S.\r
\r
![Colas de procesos del planificador](./../../media/unit1/process_queues.gif)\r
\r
El planificador es el encargado de seleccionar los movimientos de los procesos entre las distintas colas. Existe una planificación a corto plazo y otra a largo plazo, veamos cada una:\r
\r
- Corto plazo: selecciona los procesos de la cola de preparados para pasarlos a ejecución, se invoca con mucha frecuencia, del orden de milisegundos, por lo que el algoritmo debe ser muy sencillo.\r
  - Planificación sin desalojo: un proceso en ejecución sólo se saca si termina o bien se queda bloqueado.\r
  - Planificación apropiativa: solo se saca un proceso de ejecución si termina, se bloquea o por último aparece un proceso con mayor prioridad.\r
  - Tiempo compartido: cada cierto tiempo (cuanto), se desaloja un proceso y se mete otro, Se considera que todos los procesos tienen la misma prioridad.\r
- Largo plazo: selecciona que procesos nuevos pasan a la cola de preparados. Hace un control del grado de multiprogramación del proceso para tomar sus decisiones.\r
\r
::: warning Cambios de contexto\r
El cambio de contexto que se hace al cambiar un proceso es tiempo perdido, ya no se hace trabajo útil. Cambiar el estado del proceso, el estado del procesador (cambio valores de registro) e información de la gestión de memoria, por muy rápido que se haga si se hace con mucha frecuencia puede provocar una ralentización del sistema, por eso tener muchos programas abiertos provoca una disminución importante en el rendimiento del sistema.\r
:::\r
\r
## 1.3.5. Algoritmos de planificación de procesos\r
\r
Los algoritmos de planificación se utilizan para intentar mejorar el rendimiento del sistema y, por ende, la experiencia de usuario.\r
\r
Para establecer parámetros objetivos que permitan comparar los diferentes resultados, vamos a tomar como referencia los siguientes criterios:\r
\r
- **Tiempo de espera**: tiempo que un proceso permanece en la cola de preparados o de bloqueados esperando a ser ejecutado.\r
- **Tiempo de retorno**: tiempo transcurrido entre la llegada de un proceso y su finalización.\r
- **Uso de CPU**: % de tiempo que la CPU está siendo utilizada\r
  \r
> En un sistema con 1 unidad de proceso  \r
> ![Uso 1 CPU](./../../media/unit1/uso1cpu.gif)\r
<!--$\\frac{\\#\\ instantes\\ de\\ tiempo\\ que \\ el\\ procesador\\ esta\\ ocupado}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ultimo\\ proceso}$\\  \\ x \\ 100-->\r
> En un sistema con N unidades de proceso  \r
> ![Uso 2 CPU](./../../media/unit1/uso2cpu.gif)\r
<!--$\\frac{\\sum_{n=1}^{N}\\#\\ instantes\\ de\\ tiempo\\ que\\ el \\ procesador_n\\ esta\\ ocupado}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ ultimo\\ proceso\\ *\\ N}$ x100-->\r
\r
- **Rendimiento/Productividad (throughput)**: número de procesos que se completan por unidad de tiempo\r
![Rendimiento](./../../media/unit1/rendimiento.gif)\r
<!-- $\\frac{número\\ de\\ procesos}{instante\\ de\\ tiempo\\ en\\ el\\ que\\ acaba\\ el\\ último\\ proceso}$-->\r
\r
| Procesos | LLegada | Tiempo uso CPU | Prioridad |\r
| :------: | :-----: | :------------: | :-------: |\r
|    P1    |    0    |       10       |     5     |\r
|    P2    |    1    |       6        |    10     |\r
|    P3    |    2    |       3        |     7     |\r
\r
Con esta información, vamos a ver cómo se comportan los diferentes algoritmos\r
\r
### FCFS - First Come First Served\r
\r
En esta política de planificación, el procesador ejecuta cada proceso hasta que termina o pasa al estado de bloqueado, por tanto, los procesos que están en la cola de procesos preparados permanecerán en el orden en que lleguen hasta que les toque su ejecución. Este método se conoce también como FIFO (Fist In, First Out).\r
\r
Se trata de una política muy simple y sencilla de llevar a la práctica, pero muy pobre en cuanto a su comportamiento.\r
\r
La cantidad de tiempo de espera de cada proceso depende del número de procesos que se encuentren en la cola en el momento de su petición de ejecución y del tiempo que cada uno de ellos tenga en uso al procesador, y es independiente de las necesidades del propio proceso.\r
\r
![FCFS monoprocessor](./../../media/unit1/fcfs-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 2     : active,t2, after t1, 6s\r
Process 3     : crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       9       |        15         |           |\r
|    P3    |      14       |        17         |           |\r
|          |\r
|  Medias  |      7,6      |        14         |   100%    |     0,15      |\r
\r
![FCFS dual processor](./../../media/unit1/fcfs-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### SJF - Shortest Job First\r
\r
Este algoritmo siempre prioriza los procesos más cortos primero independientemente de su llegada y en caso de que los procesos sean iguales utilizara el método FIFO anterior, es decir, el orden según entrada. Este sistema tiene el riesgo de poner siempre al final de la cola los procesos más largos por lo que nunca se ejecutarán, esto se conoce como \`inanición\`.\r
\r
![SJF monoprocessor](./../../media/unit1/sjf-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title SJF (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |      12       |        18         |           |\r
|    P3    |       8       |        11         |           |\r
|          |\r
|  Medias  |      6,6      |        13         |   100%    |     0,15      |\r
\r
![SJF dual processor](./../../media/unit1/sjf-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title FCFS (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### Planificación por prioridad\r
\r
Cada proceso tiene una prioridad, ejecutándose primero el que tenga mayor prioridad, independientemente de su llegada y en caso de que las prioridades sean iguales utilizará el método FIFO anterior, es decir, el orden según entrada.\r
\r
Como ocurría con SJF, con este algoritmo son los procesos de prioridad más baja los que tienen riesgo de\r
inanición.\r
\r
![Prioridad monoprocessor](./../../media/unit1/prioridad-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 10s\r
Process 3     : crit, t3, after t1, 3s\r
Process 2     : active,t2, after t3, 6s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |      12       |        18         |           |\r
|    P3    |       8       |        11         |           |\r
|          |\r
|  Medias  |      6,6      |        13         |   100%    |     0,15      |\r
\r
![Prioridad dual processor](./../../media/unit1/prioridad-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Prioridad (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1, 0, 10s\r
.     : t2, 0, 0s\r
section Processor 2\r
Process 2     :active, t2, 1, 6s\r
Process 3     :crit, t3, after t2, 3s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       0       |        10         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       5       |         8         |           |\r
|          |\r
|  Medias  |      1,6      |         6         |    95%    |      0,3      |\r
\r
### Round Robin\r
\r
Este algoritmo de planificación es uno de los más complejos y difíciles de implementar, asigna a cada proceso un tiempo equitativo tratando a todos los procesos por igual y con la misma prioridad.\r
\r
Este algoritmo es circular, volviendo siempre al primer proceso una vez terminado con el último. Para controlar que todos los procesos tienen su tiempo de CPU este método asigna a cada proceso un intervalo de tiempo llamado \`quantum\`.\r
\r
Se pueden dar dos casuísticas con este método :\r
\r
- El proceso, o lo que le queda por ejecutar, es menor que el quantum: Al terminar antes se planifica un nuevo proceso.\r
- El proceso, o lo que le queda por ejecutar, es mayor que el quantum: Al terminar el quantum se expulsa el proceso dando paso al siguiente proceso en la lista. Al terminar la iteración se volverá para terminar el primer proceso expulsado.\r
\r
![RR monoprocessor](./../../media/unit1/roundrobin-1.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1      :done, t1, 0, 2s\r
Process 2     : active,t2, after t1, 2s\r
Process 3     : crit, t3, after t2, 2s\r
Process 1      :done, t4, after t3, 2s\r
Process 2     : active,t5, after t4, 2s\r
Process 3     : crit, t6, after t5, 1s\r
Process 1      :done, t7, after t6, 2s\r
Process 2     : active,t8, after t7, 2s\r
Process 1      :done, t9, after t8, 2s\r
Process 1      :done, t10, after t9, 2s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       9       |        19         |           |\r
|    P2    |       8       |        14         |           |\r
|    P3    |       6       |         9         |           |\r
|          |\r
|  Medias  |      7,6      |        14         |   100%    |     0,15      |\r
\r
![RR dual processor](./../../media/unit1/roundrobin-2.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin (2 processor system)\r
dateFormat s\r
axisFormat %S\r
section Processor 1\r
Process 1     :done, t1_1, 0, 2s\r
Process 3     :crit, t3_1, after t1_1, 2s\r
Process 1     :done, t1_2, after t3_1, 2s\r
Process 3     :crit, t3_2, after t1_2, 1s\r
Process 1     :done, t1_3, after t3_2, 2s\r
Process 1     :done, t1_4, after t1_3, 2s\r
Process 1     :done, t1_5, after t1_4, 2s\r
section Processor 2\r
.     :active, ., 0, 0s\r
Process 2     :active, t2_1, 1, 2s\r
Process 2     :active, t2_2, after t2_1, 2s\r
Process 2     :active, t2_3, after t2_2, 2s\r
\`\`\`\r
-->\r
\r
| Procesos | Tiempo espera | Tiempo de retorno | % uso CPU | Productividad |\r
| :------: | :-----------: | :---------------: | :-------: | :-----------: |\r
|    P1    |       3       |        13         |           |\r
|    P2    |       0       |         6         |           |\r
|    P3    |       2       |         5         |           |\r
|          |\r
|  Medias  |      1,6      |       7,6         |    73%    |      0,23     |\r
\r
::: question Planificador combinado\r
En realidad, no se usa una única estrategia de planificación, sino que lo más común es que se combinen varias de ellas. De hecho en Round-Robin hemos usado también FCFS.\r
\r
¿Te atreves a ver cómo sería una planificación Round-Robin con prioridad? Ten en cuenta que funcionará con el quantum y a la hora de escoger el siguiente proceso a ejecutar, se basará en la prioridad de los que haya en la lista.\r
:::\r
\r
### Procesos con operaciones de E/S o bloqueos\r
\r
En los ejemplos anteriores hemos visto que todos los procesos pasan su tiempo en el procesador, pero esto no es un reflejo de la realidad, más bien al contrario. Los procesos en determinados momentos deben dejar el procesador para esperar una entrada de usuario, leer o almacenar información en disco, o simplemente esperar a que otro proceso termine una acción y le envíe un dato que necesita para continuar.\r
\r
En esos instantes, el proceso deja el procesador libre para que otros puedan hacer uso de él. En el momento en que ha terminado su espera o bloqueo, se vuelve a poner en cola de preparado para seguir ejecutándose.\r
\r
En el siguiente gráfico tenemos una especificación de la actividad de 2 procesos en el que, antes de realizar el último paso de ambos, debe haber acabado la operación de E/S que realiza el proceso1.\r
\r
![Procesos con E/S](./../../media/unit1/operaciones_es.svg)\r
<!--\r
\`\`\`mermaid\r
graph LR\r
\r
subgraph Process 2\r
    p2_1["run for 2"]--p2_2["E/S for 3"]--p2_3["run for 4"]--p2_5["run for 3"]\r
end\r
subgraph Process 1\r
    p1_1["run for 3"]--p1_2["E/S for 1"]--p1_3["run for 5"]--p1_4["E/S for 2"]--p1_5["run for 4"]\r
    p1_4--p2_5\r
end\r
\`\`\`\r
-->\r
\r
Veamos cómo se materializa esto en una ejecución de los procesos, suponiendo que ambos llegan a la vez a la cola.\r
\r
![RR dual processor](./../../media/unit1/roundrobin-3.svg)\r
<!--\r
\`\`\`mermaid\r
gantt\r
title Round-Robin q=2 (monoprocessor system)\r
dateFormat s\r
axisFormat %S\r
section Task 1\r
P1 runs 2 (exits because of q expiration)      :done, t1_1, 0, 2s\r
P1 runs 1 (exits and has to wait 1 for E/S)      :done, t1_2, after t2_1, 1s\r
E/S :crit, es1_1, after t1_2, 1s\r
P1 runs 2 (exits because of q expiration)      :done, t1_3, after es1_1, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_4, after t2_2, 2s\r
P1 runs 2 (exits and has to wait 1 for E/S)      :done, t1_5, after t2_3, 1s\r
E/S :crit, es1_2, after t1_5, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_6, after es1_2, 2s\r
P1 runs 2 (exits because of q expiration)      :done, t1_7, after t2_4, 2s\r
\r
section Task 2 \r
P2 runs 2 (exits and has to wait 3 for E/S) :active, t2_1, after t1_1, 2s\r
E/S :crit, es2_1, after t2_1, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_2, after t1_3, 2s\r
P2 runs 2 (exits because of q expiration)      :active, t2_3, after t1_4, 2s\r
Locked waiting :crit, es2_2, after t2_3, 3s\r
P2 runs 2 (exits because of q expiration)      :active, t2_4, after t1_6, 2s\r
P2 runs 2 (ends execution)      :active, t2_5, after t1_7, 1s\r
'''\r
-->\r
`]},{title:"1.1 Procesos, programas, hilos",headers:[{level:2,title:"1.1.1. Procesos y programas",slug:"_1-1-1-procesos-y-programas",link:"#_1-1-1-procesos-y-programas",children:[]},{level:2,title:"1.1.2. Programación concurrente",slug:"_1-1-2-programacion-concurrente",link:"#_1-1-2-programacion-concurrente",children:[{level:3,title:"¿Para qué?",slug:"¿para-que",link:"#¿para-que",children:[]},{level:3,title:"Comunicación y sincronización entre procesos",slug:"comunicacion-y-sincronizacion-entre-procesos",link:"#comunicacion-y-sincronizacion-entre-procesos",children:[]}]},{level:2,title:"1.1.3. Servicios e hilos",slug:"_1-1-3-servicios-e-hilos",link:"#_1-1-3-servicios-e-hilos",children:[{level:3,title:"Programa secuencial (Arquitectura Von Neumann)",slug:"programa-secuencial-arquitectura-von-neumann",link:"#programa-secuencial-arquitectura-von-neumann",children:[]},{level:3,title:"Programa concurrente",slug:"programa-concurrente",link:"#programa-concurrente",children:[]},{level:3,title:"Hilos vs procesos",slug:"hilos-vs-procesos",link:"#hilos-vs-procesos",children:[]}]}],path:"/es/unit1/process.html",pathLocale:"/es/",extraFields:[`---\r
title: 1.1 Procesos, programas, hilos\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
#   image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
#   markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="1.1. Procesos, programas, hilos" />\r
\r
# 1.1. Procesos, Programas, hilos\r
\r
[[toc]]\r
\r
## 1.1.1. Procesos y programas\r
\r
Un \`programa\` no es más que un conjunto de instrucciones u órdenes que le indican a un dispositivo qué acciones debe realizar con los datos recibidos.\r
\r
::: tip Caja negra\r
Según la visión de un sistema como caja negra, un programa le indica al sistema cómo obtener unos datos de salida a partir de unos datos de entrada.\r
:::\r
\r
Sin embargo, un \`proceso\` es un programa en ejecución. Esto es, un proceso es una entidad activa y un programa es una entidad pasiva.\r
\r
El proceso, por tanto, está representado por el contador del programa, el valor de los registros, la pila, el *código ejecutable*, su estado, ... todo lo necesario para la ejecución del programa por parte del SO.\r
\r
![Proceso en memoria](./../../media/unit1/proceso_memoria.png)\r
\r
Cada proceso es una entidad independiente. Cuando un programa se ejecuta, el sistema operativo crea un proceso. Si ese mismo programa se vuelve a ejecutar, se crearía un proceso distinto, teniendo en memoria dos instancias del mismo programa. Pero es importante recalcar que los dos procesos son independientes.\r
\r
## 1.1.2. Programación concurrente\r
\r
Podemos decir que dos procesos son concurrentes cuando la primera instrucción de uno de los procesos se ejecuta después de la primera y antes de la última de otro proceso.\r
\r
La planificación alternando los instantes de ejecución, \`multitarea\`, hace que los procesos se ejecuten de forma concurrente. También la disponibilidad de varias unidades de proceso, \`multiproceso\`, permite la ejecución simultánea o paralela de procesos en el sistema.\r
\r
![Concurrencia vs paralelismo](./../../media/unit1/concurrencia_vs_paralelismo.jpg)\r
\r
::: tip Concurrencia\r
A los dos escenarios descritos anteriormente es a lo que vamos a denominar, de forma general, **concurrencia**.\r
:::\r
\r
### ¿Para qué?\r
\r
Las principales razones por las que se utiliza una estructura concurrente son:\r
\r
- Optimizar la utilización de los recursos: Podremos simultanear las operaciones de E/S en los procesos. La CPU estará menos tiempo ociosa.\r
- Proporcionar interactividad a los usuarios (y animación gráfica).\r
- Mejorar la disponibilidad: Servidor que no realice tareas de forma concurrente, no podrá atender peticiones de clientes simultáneamente.\r
- Conseguir un diseño conceptualmente más comprensible y mantenible: El diseño concurrente de un programa nos llevará a una mayor modularidad y claridad.\r
- Aumentar la protección: Tener cada tarea aislada en un proceso permitirá depurar la seguridad de cada proceso y poder finalizarlo en caso de mal funcionamiento sin que suponga la caída del sistema.\r
\r
Además, los actuales avances tecnológicos hacen necesario tener en cuenta la concurrencia en el diseño de las aplicaciones para aprovechar su potencial. Los nuevos entornos hardware son:\r
\r
- Microprocesadores con múltiples núcleos que comparten la memoria principal del sistema.\r
- Entornos multiprocesador con memoria compartida.\r
- Entornos distribuidos y servicios cloud.\r
\r
### Comunicación y sincronización entre procesos\r
\r
Cuando varios procesos se ejecutan concurrentemente puede haber procesos que colaboren para un determinado fin mientras que puede haber otros que compitan por los recursos del sistema.\r
\r
En ambos casos se hace necesaria la introducción de mecanismos de comunicación y sincronización entre procesos.\r
\r
:::info Programación concurrente\r
Precisamente del estudio de esos **mecanismos de sincronización y comunicación** trata la programación concurrente y este módulo de PSP.\r
:::\r
\r
Si pensamos en la forma en la que un proceso puede comunicarse con otro, se nos plantean estas dos:\r
\r
- Intercambio de mensajes: Es la forma que se utiliza habitualmente cuando los procesos se encuentran en máquinas diferentes. Los procesos intercambian información siguiendo un protocolo previamente establecido.\r
- Recursos (o memoria) compartidos: Sólo se puede utilizar cuando los dos procesos se encuentran en la misma máquina y permite la sincronización de los procesos en función del valor o estado de un recurso compartido.\r
\r
También podemos ver el tipo de comunicación en función de la sincronía que mantengan los procesos durante la comunicación:\r
\r
- Síncrona: El emisor queda bloqueado hasta que el receptor recibe el mensaje. Ambos\r
se sincronizan en el momento de la recepción del mensaje.\r
- Asíncrona: El emisor continúa con su ejecución inmediatamente después de emitir el\r
mensaje, sin quedar bloqueado.\r
\r
## 1.1.3. Servicios e hilos\r
\r
Un programa, como ya hemos dicho, se compone de un conjunto de sentencias (operaciones y verificaciones) y un flujo de ejecución. La línea de flujo de control establece, de acuerdo con la estructura del propio programa y de los datos que maneja, el orden en que deben ejecutarse las sentencias.\r
\r
Atendiendo al número de líneas de flujo de control que tiene un programa, los procesos pueden ser:\r
\r
- Secuenciales: Poseen un único flujo de control (monohilo)\r
- Concurrentes: Poseen varios hilos de ejecución (multihilo).\r
\r
### Programa secuencial (Arquitectura Von Neumann)\r
\r
Cuando empezamos a programar, usamos el estilo de programación clásico, en el que se sigue el modelo conceptual de Von Neumann\r
\r
Los programas secuenciales presentan una línea simple de control de flujo. Las operaciones de este tipo de programas están estrictamente ordenados como una secuencia temporal lineal.\r
\r
El comportamiento del programa es solo función de la naturaleza de las operaciones individuales que constituye el programa y del orden en que se ejecutan (determinado por el conjunto de entradas que recibe).\r
\r
En los programas secuenciales, el tiempo que tarda cada operación en ejecutarse no tiene consecuencias sobre el resultado.\r
\r
![Sequential flowchart example](./../../media/unit1/sequential_flowchart.png)\r
\r
La comprobación del correcto funcionamiento (\`verificación\` o \`depuración\`) de un programa secuencial es sencilla:\r
\r
- Cada sentencia produce la respuesta correcta.\r
- Las sentencias se ejecutan en el orden esperado.\r
\r
De aquí surgen algunos de los métodos básicos de pruebas de sistemas, como el de *caja blanca*.\r
\r
### Programa concurrente\r
\r
En los programas concurrentes existen múltiples líneas de control de flujo. Las sentencias que constituyen el programa no se ejecutan siguiendo un orden que corresponda a una secuencia temporal lineal.\r
\r
En los programas concurrentes el concepto de secuencialidad entre sentencias continua siendo muy importante. Sin embargo en los programas concurrentes es de orden parcial, mientras que, tal y como hemos comentado anteriormente, en los programas secuenciales era de orden estricto.\r
\r
![Concurrent flowchat example](./../../media/unit1/concurrent_flowchart.png)\r
\r
En los programas concurrentes la *secuencialización* entre procesos concurrentes se llama **sincronización**.\r
\r
Este orden parcial implica que los programas concurrentes no tienen porqué ser deterministas, es decir, que ante el mismo conjunto de datos de entrada no siempre se va a obtener el mismo resultado.\r
\r
::: danger Indeterminismo\r
Que existan diferentes salidas para el mismo conjunto de datos de entrada no significa necesariamente que un programa concurrente sea incorrecto.\r
:::\r
\r
Si observamos el siguiente ejemplo de pseudocódigo\r
\r
\`\`\`java {16-17,25-28}\r
public class TestClass {\r
    int x;\r
\r
    public void testMethod1() {\r
        for (int i=1; i <= 5; i++) {\r
            x++;\r
        }\r
    }\r
    public void testMethod2() {\r
        for (int j=1; j <= 5; j++) {\r
            x++;\r
        }\r
    }\r
    public void sequential() {\r
        x = 0;\r
        testMethod1();\r
        testMethod2();\r
        System.out.println(x);\r
    }\r
    public void parallel() {\r
        x = 0;\r
        // cobegin-coend means that both methods are run simultaneously\r
        // These sentences doesn't exist in Java. They are used for \r
        // sample purposes\r
        cobegin\r
            testMethod1();\r
            testMethod2();\r
        coend\r
        System.out.println(x);\r
    }\r
}\r
\`\`\`\r
\r
::: question\r
¿Qué valor tendrá x tras ejecutar el método sequential?\r
\r
¿Qué valor tendrá x tras ejecutar el método parallel?\r
:::\r
\r
::: info Reseña histórica\r
La naturaleza y los modelos de interacción entre procesos de un programa concurrente fueron estudiados y descritos por **Dijkstra** (1968), Brinch **Hansen** (1973) y **Hoare** (1974).\r
\r
Estos trabajos constituyeron los principios en que se basaron los sistemas operativos multiproceso de la década de los 70 y 80.\r
:::\r
\r
El indeterminismo inherente a los programas concurrentes hace que su análisis y validación sea más complejo. No obstante, para la comprobación del correcto funcionamiento (\`verificación\` o \`depuración\`) de un programa concurrente se requiere comprobar los mismos aspectos que en los programas secuenciales, pero con los siguientes nuevos aspectos:\r
\r
- Las sentencias se pueden validar individualmente solo si no están acopladas por variables compartidas.\r
- Cuando existen variables compartidas, los efectos de interferencia entre las sentencias concurrentes pueden ser muy variados y la validación es muy difícil. <Badge type="danger" text="cuidado" vertical="middle" />\r
- Siempre que la secuencialidad entre tareas se lleve a cabo por sentencias explícitas de **sincronización**, el tiempo es un elemento que no influye sobre el resultado\r
\r
::: warning Importante\r
Estos tres aspectos que se acaban de describir forman la base de toda la programación concurrente.\r
\r
:eye: Conocerlos, entenderlos y saber aplicarlos es a lo que dedicaremos una parte importante de este curso.\r
:::\r
\r
### Hilos vs procesos\r
\r
Un hilo no es más que cada una de esas líneas de flujo que puede tener un proceso ejecutándose de forma concurrente. Un procesos es una unidad pesada de ejecución.\r
\r
Así, un proceso estará formado por, al menos, un hilo de ejecución, el hilo principal. Si el proceso tiene varios hilos, cada uno es una unidad de ejecución ligera.\r
\r
| Procesos                         | Hilos                                               |\r
| :------------------------------- | :-------------------------------------------------- |\r
| Constan de uno o más hilos       | Un hilo siempre existe dentro de un proceso         |\r
| Son independientes unos de otros | Comparten los recursos del proceso de forma directa |\r
| Son gestionados por el SO        | Son gestionados por el proceso                      |\r
| Se comunican a través del SO     | La comunicación la controla el proceso              |\r
\r
![Threads vs Processes](./../../media/unit1/threads_vs_process.jpg)\r
\r
En la imagen anterior se puede observar la relación existente entre la creación de un thread y la de su proceso asociado.\r
\r
- El proceso define un espacio de memoria en el que reside. Los hilos comparten ese espacio de memoria. Dentro de ese espacio de memoria cada hilo tiene su espacio reservado, pero todos pueden compartir la memoria global del proceso y los recursos (ficheros, sockets, etc.) que el proceso tenga abiertos.\r
- Como ya hemos visto, cada proceso tiene su PCB con información relativa al proceso.\r
- Los hilos, de forma similar, tienen su TCB (Thread Control Block) en el que guardan la información específica de cada hilo (Contador de programa, puntero a la pila, estado del thread, registros y un puntero al PCB).\r
\r
::: info Servicios\r
Un servicio es un proceso que, normalmente, es cargado durante el arranque del sistema operativo. Al no necesitar interacción con el usuario, los servicios suelen ejecutarse en forma de **demonios*, quedan su ejecución en *segundo plano*.\r
\r
Recibe el nombre de servicio ya que es un proceso que queda a la espera de que otro le pida que realice una tarea. Como deben atender las solicitudes de varios procesos, los servicios suelen ser programas multihilo.\r
:::\r
`]},{title:"2.4 Anexo I - Propiedades del sistema y programación en consola",headers:[{level:2,title:"I.1 Propiedades del sistema y comandos del sistema",slug:"i-1-propiedades-del-sistema-y-comandos-del-sistema",link:"#i-1-propiedades-del-sistema-y-comandos-del-sistema",children:[]},{level:2,title:"I.2 Formato de salida por consola",slug:"i-2-formato-de-salida-por-consola",link:"#i-2-formato-de-salida-por-consola",children:[]},{level:2,title:"I.2 Console I/O format",slug:"i-2-console-i-o-format",link:"#i-2-console-i-o-format",children:[{level:3,title:"Salida por consola",slug:"salida-por-consola",link:"#salida-por-consola",children:[]},{level:3,title:"Entrada por consola",slug:"entrada-por-consola",link:"#entrada-por-consola",children:[]},{level:3,title:"Formato de cadena",slug:"formato-de-cadena",link:"#formato-de-cadena",children:[]},{level:3,title:"Formato numérico",slug:"formato-numerico",link:"#formato-numerico",children:[]},{level:3,title:"Uso de colores en la salida por consola",slug:"uso-de-colores-en-la-salida-por-consola",link:"#uso-de-colores-en-la-salida-por-consola",children:[]}]}],path:"/es/unit2/console_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.4 Anexo I - Propiedades del sistema y programación en consola\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.4 Anexo I - Propiedades del sistema y programación en consola" />\r
\r
# 2.4 Anexo I - Propiedades del sistema y programación en consola\r
\r
[[toc]]\r
\r
## I.1 Propiedades del sistema y comandos del sistema\r
\r
Si tenemos pensado desarrollar aplicaciones que funcionen en diferentes SO tendremos que enfrentarnos a la problemática del funcionamiento diferente de los distintos SO.\r
\r
Vamos a ver algunos ejemplos que pueden servir como guía para otros problemas similares a los expuestos.\r
\r
::: danger File separator\r
Para indicar las rutas en un sistema los sistemas UNIX emplean el carácter  **/** como separador mientras que los sistemas Windows usan el carácter **\\\\** . En resumen, / en *X y \\ en Windows.\r
\r
¿Cómo podemos hacer entonces que nuestras aplicaciones sean independientes del SO en el que se ejecutan?\r
\r
Para este tipo de cuestiones vamos a utilizar de forma recurrente las propiedades del sistema mediante \`System.getProperty(String propName)\`. Estas propiedades se configuran con el propio sistema operativo, aunque las podemos modificar usando los parámetros de ejecución de la máquina virtual\r
\r
> String separator = System.getProperty("file.separator");\r
\r
o\r
\r
> -Dfile.separator\r
\r
Aunque siempre es una buena práctica usar el carácter **/** en las rutas ya que Java es capaz de convertirlas al sistema en el que se ejecuta.\r
:::\r
\r
Si lo que queremos es ejecutar un comando del SO, tenemos que hacerlo, al igual que si lo hacemos manualmente, a través del shell del sistema, donde volvemos a encontrar la dicotomía entre sistemas UNIX y sistemas Windows.\r
\r
Vamos a ver el código que, a través de las propiedades del sistema, nos permite obtener un listado de los archivos existentes en la carpeta personal del usuario.\r
\r
\`\`\`java\r
// Primero obtenemos la carpeta del usuario\r
String homeDirectory = System.getProperty("user.home");\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info Modo shell no interactivo\r
Como se puede observar, tanto para Windows como UNIX se ha usado el modificador **c** del comando. Este modificador indica que se abra un shell, se ejecute el comando recibido y se cierre el proceso del shell.\r
:::\r
\r
A continuación podemos ver un ejemplo de respuesta ante la pulsación de un botón, en una app gráfica, para abrir una página en el navegador. Tenemos cómo se haría en sistemas *X y comentado una de las formas de hacerlo en Windows.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Vamos a crear nuestro primer programa en Java, que no va a ser tan sencillo como pueda parecer\r
\r
Usando métodos de las clases System y Runtime hacer un programa que muestre\r
\r
- todas las propiedades establecidas en el sistema operativo y sus valores.\r
- memoria total, memoria libre, memoria en uso y los procesadores disponibles\r
\r
Mira los métodos que proporcionan las clases Runtime y System. Intenta obtener una lista u otra estructura de datos que te permita recorrer las propiedades para ir mostrando sus nombres y valores.\r
:::\r
\r
::: details Solución propuesta para la actividad anterior\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
\r
:::\r
\r
## I.2 Formato de salida por consola\r
\r
## I.2 Console I/O format\r
\r
::: warning Codificación de caracteres\r
One aspect to take into account when working with streams is the encoding of the information exchanged between processes, which depends on the operating system we are working on. Most systems (GNU/Linux, Mac OS, Android, iOS...) use UTF-8 encoding, based on the Unicode standard. \r
\r
For its part, MS Windows uses its own formats, incompatible with the rest, such as Windows-1252. So to correctly handle data in Java when using more advanced inter-process communication mechanisms, it will be necessary to take into account the type of encoding that the system itself uses.\r
\r
Un aspecto a tener en cuenta cuando trabajamos con flujos es la codificación de la información intercambiada entre procesos, que depende del sistema operativo en el que estemos trabajando. La mayoría de los sistemas (GNU/Linux, Mac OS, Android, iOS...) utilizan la codificación UTF-8, basada en el estándar Unicode.\r
\r
Por su parte, MS Windows utiliza sus propios formatos, incompatibles con el resto, como Windows-1252. Por lo que para manejar correctamente los datos en Java al usar mecanismos de comunicación entre procesos más avanzados, será necesario tener en cuenta el tipo de codificación que utiliza el propio sistema.\r
\r
\`\`\`java\r
// Getting the default encoding\r
System.out.println(System.getProperty("file.encoding"));\r
// Setting the encoding\r
System.setProperty("file.encoding", "UTF-8");\r
\r
// Reading with a specific encoding\r
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));\r
// Writing with a specific encoding\r
PrintWriter writer = new PrintWriter(new OutputStreamWriter(System.out, "UTF-8"));\r
\r
// Stdin with a specific encoding\r
Scanner scanner = new Scanner(System.in, "UTF-8");\r
// Stdout with a specific encoding\r
System.out.println(new String("Hello, World!".getBytes("UTF-8")));\r
\`\`\`\r
\r
:::\r
\r
### Salida por consola\r
\r
En Java, podemos usar el objeto \`System.out\` para imprimir en la consola. Podemos usar el método \`println\` para imprimir una línea en la consola.\r
\r
\`\`\`java:no-line-numbers\r
System.out.println("¡Hola, Mundo!");\r
\`\`\`\r
\r
### Entrada por consola\r
\r
En Java, podemos usar el objeto \`System.in\` para leer de la consola. Podemos usar la clase \`Scanner\` para leer de la consola.\r
\r
\`\`\`java:no-line-numbers\r
Scanner scanner = new Scanner(System.in);\r
String nombre = scanner.nextLine();\r
\`\`\`\r
\r
### Formato de cadena\r
\r
En Java, podemos usar la clase \`String\` para formatear la salida. Podemos usar el método \`format\` para formatear la salida. Este método es similar al método \`printf\` en C.\r
\r
\`\`\`java:no-line-numbers\r
String.format("El valor de PI es %.2f", Math.PI);\r
\`\`\`\r
\r
### Formato numérico\r
\r
Todos los lenguajes de programación tienen varias formas de mostrar la información al usuario. Cuando se trata de mostrar información a a través de la consola, tenemos un par de alternativas para formatear la información numérica.\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Si usamos la clase NumberFormat o cualquiera de sus descendientes podemos controlar con bastante precisión cómo se verán los números, usando patrones.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Si usamos hashes en vez de ceros permitimos que .30 se vea como 0.3\r
// (los dígitos adicionales son opcionales)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Heredado de la sintaxis de la función printf de C, podemos utilizar la sintaxis de java.util.Formatter para configurar cómo será visualizada la información.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// % rellena con hasta 10 posiciones los números\r
// para justificarlos a la derecha.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
### Uso de colores en la salida por consola\r
\r
Hay una forma sencilla de mostrar información por consola usando diferentes colores. Os dejo un ejemplo de código con la definición de algunos colores y la forma de usarlos.\r
\r
\`\`\`java:no-line-numbers\r
public class UsarColoresEnConsola {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hola" \r
                            + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Adiós" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
`]},{title:"2.5 Anexo II - Curl",headers:[{level:2,title:"I.1 Cómo obtener curl",slug:"i-1-como-obtener-curl",link:"#i-1-como-obtener-curl",children:[]},{level:2,title:"II2 Realizando una petición GET",slug:"ii2-realizando-una-peticion-get",link:"#ii2-realizando-una-peticion-get",children:[]},{level:2,title:"II.2 Puntos finales y rutas",slug:"ii-2-puntos-finales-y-rutas",link:"#ii-2-puntos-finales-y-rutas",children:[]},{level:2,title:"II.3 Métodos HTTP y cabeceras",slug:"ii-3-metodos-http-y-cabeceras",link:"#ii-3-metodos-http-y-cabeceras",children:[]},{level:2,title:"II.4 Authentication",slug:"ii-4-authentication",link:"#ii-4-authentication",children:[]},{level:2,title:"II.5 References",slug:"ii-5-references",link:"#ii-5-references",children:[]}],path:"/es/unit2/curl_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.5 Anexo II - Curl\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.5 Anexo II - Curl" />\r
\r
# 2.5 Anexo II - Curl\r
\r
 Curl está diseñado para funcionar como una forma de verificar la conectividad a las URL y como una gran herramienta para transferir datos. Tiene especial relevancia e interés cunado se trata de usar servicios basados en API REST, tanto para comprobar su funcionamiento durante la fase de pruebas o bien para cuando el sistema ya está en producción.\r
\r
Curl es una herramienta de línea de comandos que nos permite hacer peticiones HTTP desde la consola. Su principal uso es obtener una respuesta de un sitio web (pro ejemplo, para saber que no está caído) o para comprobar tiempos de respuesta.\r
\r
::: info curl means ...\r
La herramienta fué pensada para subir y descargar información usando una URL. Es una aplicación cliente (de ahí la 'c'), y a su vez es un cliente de URLs. Por lo tanto, 'c' de cliente y URL: cURL.\r
\r
En inglés "curl" se pronuncia con un sonido inicial /k/, rimando con la pronunciación de la palabra girl.\r
\r
Por el contrario, si lo deletreamos como c-URL, entonces us significado también adquiere un sentido lógico, ver-URL (see-URL), lo cual también es una buena definición de la utilidad de esta herramienta.\r
:::\r
\r
Curl funciona con protocolos que permiten la transferencia de datos en una o dos direcciones. Soporta protocolos basados en una "URI" y que estén descritos en una RFC, por lo que curl funciona principalmente con URLs (URIs en realidad) como el origen y/o destino de las transferencias e intercambios de información que realiza.\r
\r
Actualmente curl ofrece soporte para los siguiente protocolos:\r
\r
>DICT, FILE, FTP, FTPS, GOPHER, GOPHERS, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, MQTT, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET, TFTP.\r
\r
## I.1 Cómo obtener curl\r
\r
curl es una utilidad libre, abierta y disponible en varios formatos. Podemos descargarla y configurarla en la mayoría de los sistemas operativos y arquitecturas hardware. Algunos SO ya la incluyen en sus distribuciones.\r
\r
La fuente principal de información y descarga siempre debería ser el [sitio oficial de CURL](http://curl.se) donde podemos descargar, entre otros, los instaladores para nuestros sistemas.\r
\r
- Linux (Ubuntu / Debian). curl viene instalado por defecto. De todas formas, podemos actualizarlo e instalarlo usando el gesto de paquetes APT\r
  > apt install curl\r
- Windows 10 viene con la herramienta curl instalada en sus sistemas desde la versión 1804\r
    > podemos descargar e instalar la última versión oficial de curl para windows desde [curl windows binaries](http://curl.se/windows)\r
- MacOS también trae de serie la herramienta curl desde hace ya bastantes años. Si necesitamos actualizar la versión que tenemos en el sistema, se recomienda instalar homebrew (un gesto de paquetes para macOS)\r
    > brew install curl\r
\r
## II2 Realizando una petición GET\r
\r
La sintaxis básica de Curl se ve así:\r
\r
curl [OPTIONS] [URL]\r
El uso más simple de Curl es mostrar el contenido de una página. El siguiente comando mostrará la página de inicio de testdomain.com.\r
\r
> curl testdomain.com\r
\r
Esto generará el código fuente completo de la página de inicio del dominio. Si no se especifica ningún protocolo, curl lo interpretará a HTTP.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl http://www.net.net\r
<head><title>Document Moved</title></head>\r
<body><h1>Object Moved</h1>This document may be found <a HREF="http://net.net">here</a></body>\r
\r
\`\`\`\r
\r
Si no se indica lo contrario, curl realiza una solicitud HTTP con el método GET a la URL indicada. La salida del programa para el comando enviado será el cuerpo de la respuesta HTTP, en el caos anterior, el código HTML de la URL solicitada.\r
\r
Si en vez de mostrar la salida recibida por pantalla nos interesa guardar la información en un archivo, podemos usar el parámetro \`-o (--output)\`:\r
\r
> curl -o output.html www.net.net\r
>\r
> // Es equivalente a hacer esto en el SO\r
>\r
> curl www.net.net > output.html\r
\r
Como hemos visto en la sintaxis, por norma general la URL debe ponerse al final del comando. Opcionalmente podemos especificar la URL en cualquier lugar del comando si usamos el modificador \`-s (--silent)\`, pudiendo así alterar el orden de los argumentos de curl.\r
\r
curl -s http://www.net.net -o output.html\r
\r
En los ejemplos anteriores, el resultado que estamos obteniendo no es el deseado ya que el recurso se ha cambiado de ubicación o bien el sitio nos está redirigiendo a otra URI. Si usamos el parámetro \`-L (--location)\`  podemos hacer que curl siga las redirecciones y obtenga el contenido final que buscamos.\r
\r
\`\`\`bash:no-line-numbers{1,3,5}\r
$> curl http://www.dataden.tech\r
Redirecting\r
$> curl -L http://www.dataden.tech\r
<html><head><title>Loading...</title></head><body><script type='text/javascript'>window.location.replace('http://www.dataden.tech/?js=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJKb2tlbiIsImV4cCI6MTYzMzM4OTE3OSwiaWF0IjoxNjMzMzgxOTc5LCJpc3MiOiJKb2tlbiIsImpzIjoxLCJqdGkiOiIycWxmMGdkZmg2YWlzaHMxdjgwdWx0aTQiLCJuYmYiOjE2MzMzODE5NzksInRzIjoxNjMzMzgxOTc5NzgzNzQ1fQ.y5LwDoSoZCpe2tzro_FbX7cSGIw4nx1XweNBqjpLXoo&sid=da601018-2557-11ec-a001-58f389072b17');<\/script></body></html>\r
$> curl -L http://www.net.net\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        <body>\r
                <!-- Begin: Google Analytics -->\r
                <script>\r
                  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r
                  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r
                  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r
                  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r
                  ga('create', 'UA-32196-28', 'auto');\r
                  ga('send', 'pageview');\r
                <\/script>\r
                <!-- End: Google Analytics -->\r
                <center>\r
                        <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />\r
                        <font face="impact, Arial, Helvetica, sans-serif" size="14">\r
                                NET.NET\r
                        </font>\r
                        <br /><br /><br /><br />\r
                        <font face="Arial, Helvetica, sans-serif" size="1">\r
                                <a href="http://who.godaddy.com/whoischeck.aspx?domain=NET.NET" target="_blank">NET.NET</a> is the first and the best domain name on the Internet!\r
                                <br />\r
                                Coming Soon...\r
                        </font>\r
                </center>\r
        </body>\r
</html>\r
\`\`\`\r
\r
De momento sólo hemos obtenido el HTML del recurso solicitado. Si queremos ver las cabeceras HTTP de nuestra solicitud y de la respuesta recibida podemos usar el parámetro \`-v (--verbose)\` que mostrará toda la información que intercambia el protocolo HTTP..\r
\r
\`\`\`bash:no-line-numbers{1}\r
$> curl -v  http://www.net.net\r
*   Trying 34.250.90.28:80...\r
* TCP_NODELAY set\r
* Connected to net.net (34.250.90.28) port 80 (#0)\r
> GET / HTTP/1.1\r
> Host: net.net\r
> User-Agent: curl/7.68.0\r
> Accept: */*\r
>\r
* Mark bundle as not supporting multiuse\r
< HTTP/1.1 200 OK\r
< Cache-Control: private\r
< Content-Type: text/html\r
< Server: Microsoft-IIS/10.0\r
< Set-Cookie: ASPSESSIONIDASRSRRAR=IMFFLMBBBIFJNLNDHLOACDAI; path=/\r
< X-Powered-By: ASP.NET\r
< Date: Mon, 04 Oct 2021 21:40:49 GMT\r
< Content-Length: 1080\r
<\r
<html>\r
        <head>\r
                <title>NET.NET [The first domain name on the Internet!]</title>\r
        </head>\r
        ...\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver las cabeceras de nuestra solicitud (REQUEST) precedidas del caracter \`>\` mientras que las cabeceras de la respuesta (RESPONSE) se muestran precedidas dek caracter \`<\`.\r
\r
::: info formato corto y largo de los parámetros\r
Como ya hemos visto, los parámetros sirven para modificar el comportamiento por defecto de curl en función de las necesidades.\r
\r
Los parámetros de una sola letra son rápidos de usar y recordar, pero tenemos un número limitado de parámetros de este tipo por lo que no podemos tener uno para cada opción.\r
Los parámetros que usan palabras están para solucionar la falta de opciones con formato corto. Por otro lado, su uso hace que los comandos sean más legibles, por este motivo la mayoría de parámetros cortos tienen su equivalente largo.\r
\r
En el formato corto, los parámetros están formados por un guión seguido de la letra correspondiente a la opción. Se puede usar un guión para cada opción, o incluir varias opciones detrás de un único guión.\r
\r
> $> curl -v -L http://example.com\r
> $> curl -vL http://example.com\r
\r
En el formato largo, los parámetros se preceden de dos guiones y la palabra o palabras que forman la opción. Tras cada doble guión sólo se puede indicar una opción.\r
\r
> $> curl --verbose --location http://example.com\r
\r
:::\r
\r
Por último, aunque ya hemos visto como obtener la información de las cabeceras, podemos visualizar la información de la respuesta de forma completa usando la opción \`-i (--include)\` or obtener sólo las cabeceras de la respuesta con el uso de la opción \`-I (--head)\`. Esto sólo afecta al información de la respuesta (HTTP RESPONSE) y en el primer caso veremos  la respuesta completa (headers & data) o sólo los headers con la segunda opción.\r
\r
\`\`\`bash:no-line-numbers{1}\r
$>  curl -I https://jsonplaceholder.typicode.com/todos/1\r
HTTP/2 200\r
date: Mon, 04 Oct 2021 21:57:55 GMT\r
content-type: application/json; charset=utf-8\r
content-length: 83\r
x-powered-by: Express\r
x-ratelimit-limit: 1000\r
x-ratelimit-remaining: 999\r
x-ratelimit-reset: 1631546224\r
vary: Origin, Accept-Encoding\r
access-control-allow-credentials: true\r
cache-control: max-age=43200\r
pragma: no-cache\r
expires: -1\r
x-content-type-options: nosniff\r
etag: W/"53-hfEnumeNh6YirfjyjaujcOPPT+s"\r
via: 1.1 vegur\r
cf-cache-status: HIT\r
age: 10926\r
accept-ranges: bytes\r
expect-ct: max-age=604800, report-uri="https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct"\r
report-to: {"endpoints":[{"url":"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=LxJlkSosQdWmBFBOx1fB6zrbjSbU0iStl7jjtlVL27CtOEPxem%2Ffl9y%2BCajMUopcZINOEsaufiU8A2glOLEmNpO5a40%2FyWb%2B4dBuspS8VGWnCRW4jxBBmh%2F3FbupAEaxy66TUPariKJLqe3PL5iq"}],"group":"cf-nel","max_age":604800}\r
nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}\r
server: cloudflare\r
cf-ray: 6991ab2c1a5037c7-MAD\r
alt-svc: h3=":443"; ma=86400, h3-29=":443"; ma=86400, h3-28=":443"; ma=86400, h3-27=":443"; ma=86400\r
\`\`\`\r
\r
Para acabar, y como curiosidad, añadiendo la opción \`-w "%{time_total}\\n"\` podremos ver el tiempo total que se ha tardado en recibir la respuesta del servidor.\r
\r
## II.2 Puntos finales y rutas\r
\r
El término técnico \`endpoint\` hace referencia la la URL que se utiliza URL para hacer una petición. Para un mismo servicio, esta URL suele ser siempre la misma y es una de las características de las API REST.\r
\r
Para un API, los *puntos finales* son URLs y se describen en la documentación de la APU de forma que los programadores sepan cómo usarla y acceder a los recursos y servicios que proporciona.\r
\r
En el siguiente ejemplo tenemos una API con el siguiente endpoint.\r
\r
> GET https://my-api.com/Library/Books\r
\r
Esto devolvería una lista completa de los libros que hay en la biblioteca.\r
\r
Una ruta ("route") no es más que la parte de la URL que completa al endpoint y que se utiliza para seleccionar y/o acceder a diferentes componentes del servicio o API.\r
\r
> GET https://my-api.com/Library/Books/341\r
\r
El ejemplo anterior devolvería el libro con identificador 341 de los que hay en la biblioteca.\r
\r
Como ejemplo en [SWAPI (Star Wars API)](https://swapi.dev/) el endpoint es \`https://swapi.dev/api/\`. Este es el punto de entrada para todas las peticiones.\r
\r
Además, hay muchas rutas dependiendo de la información que queramos recuperar/añadir/modificar/borrar..\r
\r
\`\`\`java:no-line-numbers\r
$> curl https://swapi.dev/api/people/1\r
$> curl https://swapi.dev/api/planet/3\r
$> curl https://swapi.dev/api/vehicles\r
\`\`\`\r
\r
## II.3 Métodos HTTP y cabeceras\r
\r
Todas las peticiones HTTP tienen un método asociado, también llamado verbo. Por defecto ya hemos visto que se usa GET, pero también tenemos POST, HEAD y PUT que se utilizan bastante.\r
\r
POST es el método HTTP que se ideó para enviar y recibir información de una aplicación web y es el que utilizan, entre otros, los formularios web.\r
\r
Cuando los datos de un formulario se envían desde un navegador se mandan \`URL encoded\`, como una serie de pares nombre=valor separados con símbolos ampersand (&).\r
\r
Para enviar datos con curl lo indicamos con la opción \`-d (--data)\` con el siguiente formato:\r
\r
> curl -d 'name=admin&shoesize=12' http://example.com/\r
\r
Curl es capaz de seleccionar el método HTTP que debe utilizar en función de las opciones que recibe. Si utilizamos \`-d\` curl hará un POST, con \`-I\` hará un HEAD, etc. Con la opción \`-X (--request)\` podemos indicar qué método queremos que use curl.\r
\r
> curl -X POST -d 'imageSize=big&imageType=jpg' http://example.org/\r
\r
Si usamos la opción POSTing with curl's \`-d\` ya hemos visto que por defecto se hace POST. Además de eso, se incluye una cabecera para indicar el formato de los datos enviados \`Content-Type: application/x-www-form-urlencoded\`. Esto es lo que hace un navegador cuando enviamos un formulario.\r
\r
Puede ocurrir que los datos que estamos enviando no tengan ese formato, bien porque estemos subiendo algún archivo, enviando información binaria, usando JSON, XML, ... en estos casos podemos, a través de la misma cabecera Content-Type, indicar el formato de la información que estamos enviando.\r
\r
Por ejemplo si queremos enviar información en formato jSON:\r
\r
> curl -X "POST" -d '{"imageSize":"big","imageType":"jpg","scale":"false"}' -H 'Content-Type: application/json' https://example.com\r
\r
## II.4 Authentication\r
\r
Cada solicitud HTTP puede ser autenticada. Un servidor o proxy puede necesitar que el usuario confirme su identidad o que tiene los permisos necesarios para acceder a una URL para realizar una acción. En ese caso se le enviará al cliente una respuesta en la que se le indique que debe proporcionar información de autenticación en la cabecera HTTP para que se le permita completar esa solicitud.\r
\r
En curl, la forma de realizar una petición HTTP autenticadaes con la opción \`-u (--user)\` y proporcionando un usuario y contraseña (separados por \`:\`).\r
\r
> curl --user daniel:secret http://example.com/\r
\r
Esto hará que curl utilice el método de autenticación HTTP por defecto, denominado "Basic"\r
\r
Otras aplicaciones hacen uso de una clave secreta \`secret key\` o testigos de autorización \`Authorization token\`. Esta información nos la proporciona del servicio cuando lo creamos y configuramos.\r
\r
[Trello API Introduction](https://developer.atlassian.com/cloud/trello/guides/rest-api/api-introduction/)\r
\r
[Azure Translator API Reference](https://docs.microsoft.com/es-es/azure/cognitive-services/translator/reference/v3-0-translate)\r
\r
Por ejemplo, si queremos usar el servicio \`translate\` de Azure tendremos que obtener una *secret key* y utilizarla en la cabecera de cada solicitud que realicemos\r
\r
\`\`\`java:no-line-numbers\r
$> curl -X POST "https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" -H "Ocp-Apim-Subscription-Key: <here goes your susbcription key>" -H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
Otras veces, para no enviar siempre la secret key, solicitamos una autorización temporal, obteniendo un \`Authorization token\` que podemos usar para acceder al servicio durante un breve período de tiempo. Una vez que el token expire, debemos solicitar otro.\r
Para el envío de tokens se utiliza la cabecera \`Authorization: Bearer <token>\`.\r
\r
\`\`\`java:no-line-numbers{1,3,5}\r
$> curl -X POST "https://api.cognitive.microsoft.com/sts/v1.0/issueToken" \r
        -H "Ocp-Apim-Subscription-Key: <here goes the secret key>" -d {}\r
eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE\r
$> curl -X POST \r
"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" \r
-H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzMwMTUxNywiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.0hyyBNr22E2sIO_ZBlTiBePXM_KE_5hQOCeHxz3US44" \r
-H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
{"error":{"code":401000,"message":"The request is not authorized because credentials are missing or invalid."}}\r
$> curl -X POST \r
"https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=en&to=it" \r
-H "Authorization: Bearer eyJhbGciOiJodHRwOi8vd3d3LnczLm9yZy8yMDAxLzA0L3htbGRzaWctbW9yZSNobWFjLXNoYTI1NiIsInR5cCI6IkpXVCJ9.eyJyZWdpb24iOiJnbG9iYWwiLCJzdWJzY3JpcHRpb24taWQiOiJjOTM1ZjNhNjIwMjM0ZTVhYTIyNzUzMmI4ZGQ2ZmRkYyIsInByb2R1Y3QtaWQiOiJUZXh0VHJhbnNsYXRvci5GMCIsImNvZ25pdGl2ZS1zZXJ2aWNlcy1lbmRwb2ludCI6Imh0dHBzOi8vYXBpLmNvZ25pdGl2ZS5taWNyb3NvZnQuY29tL2ludGVybmFsL3YxLjAvIiwiYXp1cmUtcmVzb3VyY2UtaWQiOiIvc3Vic2NyaXB0aW9ucy9iMTFlODUwMS1kNjg2LTRmNjctODg4NC0wMjkzYmNkYTQ5NGEvcmVzb3VyY2VHcm91cHMvVGVzdFBTUC9wcm92aWRlcnMvTWljcm9zb2Z0LkNvZ25pdGl2ZVNlcnZpY2VzL2FjY291bnRzL3RyYW5zbGF0b3JQU1AtVk1NIiwic2NvcGUiOiJodHRwczovL2FwaS5taWNyb3NvZnR0cmFuc2xhdG9yLmNvbS8iLCJhdWQiOiJ1cm46bXMubWljcm9zb2Z0dHJhbnNsYXRvciIsImV4cCI6MTYzMzM4OTcxMCwiaXNzIjoidXJuOm1zLmNvZ25pdGl2ZXNlcnZpY2VzIn0.MFr7ka5azMv-2ZakpdJc6GIWAsp4SJKN6Hfe1LzmNJE" \r
-H "Content-Type: application/json; charset=UTF-8" -d "[{'Text':'Hola, com esteu?'}]"\r
[{"detectedLanguage":{"language":"ca","score":1.0},"translations":[{"text":"Hello, how are you?","to":"en"},{"text":"Ciao come stai?","to":"it"}]}]\r
\`\`\`\r
\r
## II.5 References\r
\r
[Everything curl](https://everything.curl.dev/) es un libro gratuito que cubre con detalle prácticamente todo lo que hay que saber sobre curl.\r
\r
[freecodecamp.org](https://www.freecodecamp.org/news/how-to-start-using-curl-and-why-a-hands-on-introduction-ea1c913caaaa/)\r
\r
[Sitio oficial de curl](https://curl.se/)\r
`]},{title:"2 Introducción",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit2/",pathLocale:"/es/",extraFields:[`---\r
title: 2 Introducción\r
---\r
\r
# Tema 2. Programación de procesos\r
\r
Una vez hemos aprendido a diferenciar entre programas, procesos e hilos, en este segundo tema vamos a aprender cómo desde un programa creado por nosotros podemos lanzar otros programas, es decir, desde un proceso en ejecución, podemos crear otro proceso.\r
\r
Además de lanzarlos, al establecerse una relación padre-hijo estos procesos pueden comunicarse entre sí intercambiando información. De esta forma nuestros programas podrán lanzar otras aplicaciones, comandos del SO e incluso otras aplicaciones nuestras, permitiendo cierto grado de sincronización y comunicación entre ellas.\r
\r
## Objetivos\r
\r
Los objetivos que alcanzaremos tras esta unidad son:\r
\r
- Conocer las clases de Java para la creación de procesos\r
- Monitorizar y controlar el ciclo de vida de un proceso\r
- Controlar la comunicación entre procesos padre/hijo\r
- Usar métodos para la sincronización entre procesos y subprocesos\r
- Entender el mecanismo de comunicación mediante tuberías (pipes)\r
- Aprender la sintaxis y uso del comando curl para probar API REST desde un programa\r
- Crear programas que ejecuten tareas en paralelo.\r
`]},{title:"2.3 Gestión de la E-S de un proceso",headers:[{level:2,title:"2.3.1  Redirección de la E/S estándar",slug:"_2-3-1-redireccion-de-la-e-s-estandar",link:"#_2-3-1-redireccion-de-la-e-s-estandar",children:[{level:3,title:"getInputStream()",slug:"getinputstream",link:"#getinputstream",children:[]},{level:3,title:"getErrorStream()",slug:"geterrorstream",link:"#geterrorstream",children:[]},{level:3,title:"getOutputStream()",slug:"getoutputstream",link:"#getoutputstream",children:[]},{level:3,title:"Heredar la E/S del proceso padre",slug:"heredar-la-e-s-del-proceso-padre",link:"#heredar-la-e-s-del-proceso-padre",children:[]}]},{level:2,title:"2.3.2 Redirección de las Entradas y Salidas Estándar",slug:"_2-3-2-redireccion-de-las-entradas-y-salidas-estandar",link:"#_2-3-2-redireccion-de-las-entradas-y-salidas-estandar",children:[]}],path:"/es/unit2/iostreams.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.3 Gestión de la E-S de un proceso\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.3 Gestión de la E-S de un proceso" />\r
\r
# 2.3 Gestión de la E-S de un proceso\r
\r
[[toc]]\r
\r
## 2.3.1  Redirección de la E/S estándar\r
\r
Ya hemos comentado que un subproceso no tiene terminal o consola en el que poder mostrar su información. Toda la E/S por defecto *(stdin -> teclado, stdout y stderr -> pantalla)* por defecto se redirige al proceso padre. Es el proceso padre el que puede usar estos streams para recoger o enviar información al proceso hijo.\r
\r
::: danger Código del proceso hijo\r
En ningún momento, cuando estamos programando un proceso, debemos pensar si va a ser lanzado como padre o como hijo.\r
\r
Es más, todos los programas que hacemos son lanzados como hijos por el IDE (Netbeans) y eso no hace que cambiemos nuestra forma de programarlos.\r
\r
Un proceso que vayamos a lanzar como hijo debería funcionar perfectamente como proceso independiente y puede ser ejecutado directamente sin tener que hacerle ningún tipo de cambio.\r
:::\r
\r
Este intercambio de información nos da mucha flexibilidad y proporciona una forma de control y comunicación sobre el proceso hijo.\r
\r
En la relación padre-hijo que se crea entre procesos los descriptores también se redirigen desde el hijo hacia el padre, usando 3 tuberías (pipes), una por cada stream de E/S por defecto. Esas tuberías pueden usarse de forma similar a cómo se hace en los sistemas Linux.\r
\r
<!--![alt_text](./../../media/unit2/pipe_with_two.jpg)-->\r
\r
![alt_text](./../../media/unit2/ProcessIO.png)\r
\r
### getInputStream()\r
\r
No sólo es importante recoger el valor de retorno de un comando, sino que muchas veces nos va a ser de mucha utilidad el poder obtener la información que el proceso genera por la salida estándar o por la salida de error.\r
\r
Para esto vamos a utilizar el método \`public abstract InputStream getInputStream()\` de la clase \`Process\` para leer el stream de salida del proceso, es decir, para leer lo que el comando ejecutado (proceso hijo) ha enviado a la consola.\r
\r
\`\`\`java{3}\r
Process p = pbuilder.start();\r
BufferedReader processOutput = \r
    new BufferedReader(new InputStreamReader(p.getInputStream()));\r
\r
String linea;    \r
while ((linea = processOutput.readLine()) != null) {\r
    System.out.println("> " + linea);        \r
}            \r
processOutput.close();    \r
\`\`\`\r
\r
![alt_text](./../../media/unit2/Java_Stream_Readers_BufferedReaders.jpg)\r
\r
::: warning Charsets y encodings\r
Desde el inicio de la informática los juegos de caracteres y las codificaciones han supuesto un auténtico quebradero de cabeza para los programadores, especialmente cuando trabajamos con juegos de caracteres no anglosajones. Pues bien, la consola de Windows no iba a ser una excepción.\r
\r
La consola de windows, conocida como *"DOS prompt"* o *cmd*, es la forma de ejecutar programas y comandos DOS en Windows, por lo tanto esos programas mantienen la codificación de DOS. A Microsoft no le gustan hacer cambios que pierdan la compatibilidad hacia atrás, es decir, que sean compatibles con versiones anteriores, así que cuando hagamos una aplicación que trabaje con la consola debemos tener en cuenta esta circunstancia.\r
\r
En Wikipedia comentan que la codificación  **CP850** teóricamente ha sido ampliamente reemplazada por **Windows-1252** y posteriormente Unicode, pero aún así **CP850** sigue presente en la consola de comandos.\r
\r
Por lo tanto, si queremos mostrar información de la consola en nuestras aplicaciones, debemos trabajar con el charset adecuado, a saber, CP-850.\r
\r
Para usar un encoding concreto, la clase InputStreamReader, que pasa de gestionar bytes a caracteres, tiene un constructor que permite especificar el tipo de codificación usado en el stream de bytes que recibimos, así que que debemos usar este constructor cuando trabajemos con aplicaciones de consola.\r
\r
\`\`\`java:no-line-numbers\r
new InputStreamReader(p.getInputStream(), "CP850");\r
\`\`\`\r
\r
> Además, para usar una codificación universal, podemos forzar que Netbeans, o mejor dicho la máquina virtual que usa Netbeans, utilice **por defecto el charset \`UTF-8\`**. Para hacerlo, debemos modificar el archivo de configuración de Netbeans \`C:/Program Files/Netbeans-xx.x/netbeans/etc/netbeans.conf\`, y modificar la directiva \`netbeans_default_option\` añadiendo al final **-J-Dfile.encoding=UTF-8**.\r
\r
:::\r
\r
### getErrorStream()\r
\r
Curiosamente, o no tanto, además de la salida estándar, también podemos obtener la salida de error (stderr) que genera el proceso hijo para procesarla desde el padre.\r
\r
Si la salida de error ha sido previamente redirigida usando el método \`ProcessBuilder.redirectErrorStream(true)\` entonces la salida de error y la salida estándar llegan juntas con getInputStream() y no es necesario hacer un tratamiento adicional.\r
\r
Si por el contrario queremos hacer un tratamiento diferenciado de los dos tipos de salida, podemos usar un esquema similar al usado anteriormente, con la salvedad de que ahora en vez de llamar a \`getInputStream()\` lo hacemos con \`getErrorStream()\`.\r
\r
\`\`\`java{3}\r
Process p = pbuilder.start();\r
BufferedReader processError = \r
    new BufferedReader(new InputStreamReader(p.getErrorStream()));\r
// En este ejemplo, por ver una forma diferente de recoger la información,\r
// en vez de leer todas las líneas que llegan, recogemos la primera línea\r
// y suponemos que nos han enviado un entero.    \r
int value = Integer.parseInt(processError.readLine());\r
processError.close();\r
\`\`\`\r
\r
::: info Patrón de diseño Decorator o Wrapper\r
En ambos tipos de streams de entrada (input y error) estamos recogiendo la información de un objeto de tipo BufferedReader. Podríamos usar directamente el InputStream que nos devuelven los métodos de Process, pero tendríamos que encargarnos nosotros de convertir los bytes a caracteres, de leer el stream carácter a carácter y de controlar el flujo al no disponer de un buffer.\r
\r
Todo esto nos lo podemos ahorrar usando clases que gestionan el flujo a un nivel de concreción más alto, usando sin llegar a ser conscientes otro patrón de diseño bastante común, **Patrón de diseño Decorator** también llamado **wrapper o envoltorio**.\r
\r
> Decorator es un patrón de diseño estructural que te permite añadir funcionalidades a objetos colocando estos objetos dentro de objetos encapsuladores especiales que contienen estas funcionalidades.\r
\r
[Refactoring.Guru patrones de diseño](https://refactoring.guru/design-patterns/java)\r
:::\r
\r
Vamos a ver un ejemplo completo de uso de todas las funcionalidad anteriores\r
\r
\`\`\`java{5,8,10,14,17}\r
import java.io.*;\r
public class Ejercicio2 {\r
    public static void main(String[] args) {\r
        String comando = "notepad";\r
        ProcessBuilder pbuilder = new ProcessBuilder (comando);\r
        Process p = null;\r
        try {\r
            p = pbuilder.start();\r
            // 1- Procedemos a leer lo que devuelve el proceso hijo\r
            InputStream is = p.getInputStream();\r
            // 2- Lo convertimos en un InputStreamReader\r
            // De esta forma podemos leer caracteres en vez de bytes\r
            // El InputStreamReader nos permite gestionar diferentes codificaciones\r
            InputStreamReader isr = new InputStreamReader(is);\r
            // 2- Para mejorar el rendimiento hacemos un wrapper sobre un BufferedReader\r
            // De esta forma podemos leer enteros, cadenas o incluso líneas.\r
            BufferedReader br = new BufferedReader(isr);\r
\r
            // A Continuación leemos todo como una cadena, línea a línea\r
            String linea;\r
            while ((linea = br.readLine()) != null) \r
                System.out.println(linea);\r
        } catch (Exception e) {\r
            System.out.println("Error en: "+comando);\r
            e.printStackTrace();\r
        } finally {\r
            // Para finalizar, cerramos los recursos abiertos\r
            br.close();\r
            isr.close();\r
            is.close();\r
        }    \r
    }\r
}\r
\`\`\`\r
\r
### getOutputStream()\r
\r
No sólo podemos recoger la información que envía el proceso hijo sino que, además, también podemos enviar información desde el proceso padre al proceso hijo, usando el último de los tres streams que nos queda, el \`stdin\`.\r
\r
Igual que con las entradas que llegan desde el proceso hijo, podemos enviar la información usando directamente el OutputStream del proceso, pero lo haremos de nuevo con un Decorator.\r
\r
En este caso, el *wrapper* de mayor nivel nivel para usar un OutputStream es la clase PrintWriter que nos ofrece métodos similares a los de \`System.out.printxxxxx\` para gestionar el flujo de comunicación con el proceso hijo.\r
\r
\`\`\`java{4}\r
PrintWriter toProcess = new PrintWriter(\r
    new BufferedWriter(\r
        new OutputStreamWriter(\r
            p.getOutputStream(), "UTF-8")), true);\r
toProcess.println("sent to child");\r
\`\`\`\r
\r
### Heredar la E/S del proceso padre\r
\r
Con el método \`inheritIO()\` podemos redireccionar todos los flujos de E/S del proceso hijo a la E/S estándar del proceso padre.\r
\r
\`\`\`java{3}\r
ProcessBuilder processBuilder = new ProcessBuilder("/bin/sh", "-c", "echo hello");\r
\r
processBuilder.inheritIO();\r
Process process = processBuilder.start();\r
\r
int exitCode = process.waitFor();\r
\`\`\`\r
\r
En el ejemplo anterior, tras invocar al método inheritIO() podemos ver la salida del comando ejecutado en la consola del proceso padre dentro del IDE Netbeans.\r
\r
::: warning Úsalo para depurar la comunicación/sincronización padre-hijo\r
Este método es útil para depurar, pero no se recomienda para código de producción. Es mejor usar los métodos getInputStream() y getErrorStream() para leer las salidas y errores del subproceso, y el método getOutputStream() para escribir en el subproceso.\r
:::\r
\r
\r
<!--\r
### Pipelines\r
\r
Java 9 introdujo el concepto de \`pipelines\` en el API de ProcessBuilder:\r
\r
\`\`\`java:no-line-numbers\r
public static List<Process> startPipeline​(List<ProcessBuilder> builders)\r
\`\`\`\r
\r
El método \`startPipeline\` usa un lista de objetos ProcessBuilder. Este método estático se encarga de lanzar un proceso para cada uno de los ProcessBuilder recibidos. Y lo que automatiza es la creación de tuberías encadenadas (pipeline) haciendo que la salida de cada proceso esté enlazada con la entrada del siguiente..\r
\r
Por ejemplo, si queremos realizar este tipo de operaciones tan comunes en shellscript:\r
\r
> find . -name *.java -type f | wc -l\r
\r
Lo que haremos será crear un ProcessBuilder para cada uno de los comandos, y  pasárselos todos al método startPipeline para que los ejecute y los encadene.\r
\r
\`\`\`java\r
List builders = Arrays.asList(\r
    new ProcessBuilder("find", "src", "-name", "*.java", "-type", "f"), \r
    new ProcessBuilder("wc", "-l"));\r
\r
List processes = ProcessBuilder.startPipeline(builders);\r
Process last = processes.get(processes.size() - 1);\r
\r
// Desde el proceso padre podemos recoger la salida del último proceso para \r
// el resultado final del pipeline\r
\`\`\`\r
\r
El ejemplo anterior busca todos los archivos .java  dentro del directorio src, encadena la salida hacia el comando wc para contar cuantos ficheros ha encontrado, siendo este el resultado final del pipeline.\r
-->\r
\r
## 2.3.2 Redirección de las Entradas y Salidas Estándar\r
\r
En un sistema real, probablemente necesitemos guardar los resultados de un proceso en un archivo de log o de errores para su posterior análisis. Afortunadamente lo podemos hacer sin modificar el código de nuestras aplicaciones usando los métodos que proporciona el API de ProcessBuilder para hacer exactamente eso.\r
\r
Por defecto, tal y como ya hemos visto, los procesos hijos reciben la entrada a través de una tubería a la que podemos acceder usando el OutputStream que nos devuelve \`Process.getOutputStream()\`.\r
\r
Sin embargo, tal y como veremos a continuación, esa entrada estándar se puede cambiar y redirigirse a otros destinos como un fichero usando el método \`redirectOutput(File)\`. Si modificamos la salida estándar, el método getOutputStream() devolverá *ProcessBuilder.NullOutputStream*.\r
\r
::: info Redirección antes de ejecutar\r
Es importante fijarse en qué momento se realiza cada acción sobre un proceso.\r
\r
Antes hemos visto que los flujos de E/S se consultan y gestionan una vez que el proceso está en ejecución, por lo tanto los métodos que nos dan acceso a esos *streams* son métodos de la clase \`Process\`.\r
\r
Si lo que queremos es redirigir la E/S, como vamos a ver a continuación, lo haremos mientras preparamos el proceso para ser ejecutado. De forma que cuando se lance sus streams de E/S se modifiquen. Por eso en esta ocasión los métodos que nos permiten redireccionar la E/S de los procesos son métodos de la clase \`ProcessBuilder\`.\r
::::\r
\r
Vamos a ver con un ejemplo cómo hacer un programa que muestre la versión de Java. Ahora bien, en esta ocasión la salida se va a guardar en un archivo de log en vez de enviarla al padre por la tubería de salida estándar:\r
\r
\`\`\`java{7}\r
ProcessBuilder processBuilder = new ProcessBuilder("java", "-version");\r
\r
// La salida de error se enviará al mismo sitio que la estándar\r
processBuilder.redirectErrorStream(true);\r
\r
File log = folder.newFile("java-version.log");\r
processBuilder.redirectOutput(log);\r
\r
Process process = processBuilder.start();\r
\`\`\`\r
\r
En el ejemplo anterior podemos observar como se crea un archivo temporal llamado *java-version.log* e indicamos a ProcessBuilder que la salida la redirija a este archivo.\r
\r
Es lo mismo que si llamásemos a nuestra aplicación usando el operador de redirección de salida:\r
\r
> java ejemplo-java-version > java-version.log\r
\r
::: tip Código del proceso hijo\r
Si el proceso hijo que lanzamos, en vez de ser un comando del sistema, es otra clase java, en ningún momento tenemos que modificar el código de este proceso para que funcione como hijo.\r
\r
Por lo tanto, el proceso hijo seguirá haciendo\r
\r
> System.out.println("Versión de Java: " + System.getProperty("java.version"));\r
\r
y será el sistema operativo el que se encargue de redirigir las salidas o entradas al fichero, o donde se haya configurado con los métodos de redirección de la clase \`ProcessBuilder\`.\r
:::\r
\r
Ahora vamos a fijarnos en una variación del ejemplo anterior. Lo que queremos hacer ahora es añadir (\`append to\`) información al archivo de log file en vez de sobrescribir el archivo cada vez que se ejecuta el proceso. Con sobrescribir nos referimos a crear el archivo vacío si no existe, o bien borrar el contenido del archivo si éste ya existe.\r
\r
\`\`\`java{3}\r
File log = tempFolder.newFile("java-version-append.log");\r
processBuilder.redirectErrorStream(true);\r
processBuilder.redirectOutput(Redirect.appendTo(log));\r
\`\`\`\r
\r
Otra vez más, es importante hacer notar la llamada a  \`redirectErrorStream(true)\`. En el caso de que se produzca algún error, se mezclarán con los mensajes de salida en el fichero..\r
\r
En el APi de ProcessBuilder encontramos métodos para redireccionar también la salida de error estándar y la entrada estándar de los procesos.\r
\r
- redirectError(File)\r
- redirectInput(File)\r
\r
Para hacer las redirecciones también podemos utilizar la clase \`ProcessBuilder.Redirect\` como parámetro para las versiones sobrecargadas de los métodos anteriores, utilizando uno de los siguientes valores\r
\r
| Valor                   | Significado                                                              |\r
| ----------------------- | ------------------------------------------------------------------------ |\r
| Redirect.DISCARD        | La información se descarta                                               |\r
| Redirect.to(File)       | La información se guardará en el fichero indicado. Si existe, se vacía.  |\r
| Redirect.from(File)     | La información se leerá del fichero indicado                             |\r
| Redirect.appendTo(File) | La información se añadirá en el fichero indicado. Si existe, no se vacía |\r
\r
Estos valores son campos estáticos de la clase Redirect y pueden ser usados como parámetros para los métodos sobrecargados redirectOutput, redirectError y redirectInput.\r
\r
\`\`\`java\r
File log = folder.newFile("sampleInputData.csv");\r
processBuilder.redirectInput(Redirect.from(log));\r
\`\`\`\r
`]},{title:"2.1 Comunicación entre procesos",headers:[{level:2,title:"2.1.1. Comunicación mediante E/S",slug:"_2-1-1-comunicacion-mediante-e-s",link:"#_2-1-1-comunicacion-mediante-e-s",children:[{level:3,title:"Redirección de la entrada estándar",slug:"redireccion-de-la-entrada-estandar",link:"#redireccion-de-la-entrada-estandar",children:[]},{level:3,title:"Redirección de la salida estándar",slug:"redireccion-de-la-salida-estandar",link:"#redireccion-de-la-salida-estandar",children:[]},{level:3,title:"Redirección de la salida de error estándar",slug:"redireccion-de-la-salida-de-error-estandar",link:"#redireccion-de-la-salida-de-error-estandar",children:[]}]},{level:2,title:"2.1.2. Redirección de la salida de un proceso a la entrada de otro proceso",slug:"_2-1-2-redireccion-de-la-salida-de-un-proceso-a-la-entrada-de-otro-proceso",link:"#_2-1-2-redireccion-de-la-salida-de-un-proceso-a-la-entrada-de-otro-proceso",children:[]},{level:2,title:"2.1.3. Comunicación mediante señales",slug:"_2-1-3-comunicacion-mediante-senales",link:"#_2-1-3-comunicacion-mediante-senales",children:[]},{level:2,title:"2.1.4. Comunicación mediante sockets",slug:"_2-1-4-comunicacion-mediante-sockets",link:"#_2-1-4-comunicacion-mediante-sockets",children:[]}],path:"/es/unit2/ipc.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.1 Comunicación entre procesos\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Comunicación entre procesos" />\r
\r
# 2.1. Comunicación entre procesos\r
\r
[[toc]]\r
\r
La comunicación entre procesos, IPC (Inter Process Communication), es una de las características principales de los sistemas operativos. En este apartado nos vamos a centrar en la comunicación de procesos que estén en el mismo dispositivo.\r
\r
## 2.1.1. Comunicación mediante E/S\r
\r
La comunicación entre procesos se puede realizar de muchas formas, pero una de las más sencillas y comunes es la comunicación mediante la entrada y salida estándar.\r
\r
::: info E/S en Java\r
En Java, la comunicación mediante la entrada y salida estándar se realiza mediante los flujos de entrada y salida estándar, \`System.in\` y \`System.out\` respectivamente.\r
:::\r
\r
Todo proceso tiene tres flujos de entrada y salida estándar que se pueden usar para la comunicación con otros procesos. Estos flujos son:\r
\r
- **stdin** (entrada estándar): por donde el proceso recibe datos. Por defecto se corresponde con el teclado y el identificador del fichero asociado es 0.\r
- **stdout** (salida estándar): por donde el proceso envía datos. Por defecto se corresponde con la consola y el identificador del fichero asociado es 1.\r
- **stderr** (salida de error estándar): por donde el proceso envía mensajes de error. Por defecto se corresponde con la consola y el identificador del fichero asociado es 2.\r
\r
Un mecanismo IPC, relativamente sencillo, es la comunicación de procesos mediante la redirección de las salidas y entradas estándar a/desde otras fuentes.\r
\r
::: warning Redirección de E/S\r
La redirección de la entrada y salida estándar se puede hacer en la línea de comandos de los sistemas UNIX y Windows. En Java, se puede hacer mediante la clase \`ProcessBuilder\` que veremos en la siguiente sección de la unidad\r
:::\r
\r
### Redirección de la entrada estándar\r
\r
La redirección de la entrada estándar se puede hacer mediante el operador \`<\` en sistemas UNIX y Windows.\r
\r
\`\`\`bash\r
$> java MiClase < entrada.txt\r
\`\`\`\r
\r
En el ejemplo anterior, el programa \`MiClase\` recibe la entrada estándar desde el fichero \`entrada.txt\` en vez de desde el teclado.\r
\r
> Cuando se redirige la entrada estándar, el programa no tiene que hacer nada especial para leer de un fichero en vez de del teclado. El sistema operativo se encarga de redirigir la entrada estándar del programa al fichero que se le indica.\r
\r
### Redirección de la salida estándar\r
\r
La redirección de la salida estándar se puede hacer mediante los operadores \`>\` y \`>>\` en sistemas UNIX y Windows.\r
\r
\`\`\`bash\r
$>  java MiClase > salida.txt\r
$>  java MiClase >> salida2.txt\r
\`\`\`\r
\r
En el ejemplo anterior, la salida estándar del programa \`MiClase\` se redirige al fichero \`salida.txt\` en vez de a la consola. Si el fichero \`salida.txt\` no existe, lo crea, y si el fichero ya existe, sobrescribe su valor.\r
\r
Si el operador es \`>>\`, la salida se añade al final del fichero en vez de sobrescribirlo.\r
\r
> Cuando se redirige la salida estándar, el programa no tiene que hacer nada especial para escribir en un fichero en vez de en la consola. El sistema operativo se encarga de redirigir la salida estándar del programa al fichero que se le indica.\r
\r
### Redirección de la salida de error estándar\r
\r
La redirección de la salida de error estándar se puede hacer mediante el operador \`2>\` en sistemas UNIX y Windows.\r
\r
\`\`\`bash\r
$> java MiClase 2> error.txt\r
$> java MiClase 2>> error2.txt\r
\`\`\`\r
\r
En el ejemplo anterior, la salida de error estándar del programa \`MiClase\` se redirige al fichero \`error.txt\` en vez de a la consola.\r
\r
Si el operador es \`2>>\`, la salida de error se añade al final del fichero en vez de sobrescribirlo.\r
\r
> Cuando se redirige la salida de error, el programa no tiene que hacer nada especial para escribir en un fichero en vez de en la consola. El sistema operativo se encarga de redirigir la salida de error del programa al fichero que se le indica.\r
\r
## 2.1.2. Redirección de la salida de un proceso a la entrada de otro proceso\r
\r
La redirección de la salida estándar a la entrada estándar de otro proceso se puede hacer mediante el operador \`|\` en sistemas UNIX y Windows.\r
\r
Las tuberías (pipes) permiten conectar la salida estándar de un proceso con la entrada estándar de otro, estableciendo así una relación de productor-consumidor.\r
El uso de tuberías sigue la siguiente sintaxis:\r
\r
\`\`\`bash\r
$> java MiClase | java MiClase2\r
\`\`\`\r
\r
En el ejemplo anterior, la salida estándar del programa \`MiClase\` se redirige a la entrada estándar del programa \`MiClase2\`.\r
\r
> Cuando se redirige la salida estándar de un proceso a la entrada estándar de otro, el sistema operativo se encarga de conectar los flujos de salida y entrada de los procesos.\r
\r
## 2.1.3. Comunicación mediante señales\r
\r
Las señales son una forma de comunicación entre procesos que se basa en la interrupción de la ejecución de un proceso para que realice una acción determinada.\r
\r
Las señales son eventos asíncronos que se envían a un proceso para notificarle de un evento. Las señales pueden ser enviadas por el propio proceso, por otro proceso o por el sistema operativo.\r
\r
Las señales se pueden enviar a un proceso mediante la línea de comandos o mediante un programa. En sistemas UNIX, se pueden enviar señales a un proceso mediante el comando \`kill\`.\r
\r
\`\`\`bash\r
$> kill -s SIGUSR1 1234\r
\`\`\`\r
\r
En el ejemplo anterior, se envía la señal \`SIGUSR1\` al proceso con PID \`1234\`.\r
\r
Las señales en el shell de Windows se pueden enviar mediante el comando \`taskkill\`.\r
\r
\`\`\`bash\r
$> taskkill /pid 1234 /f\r
\`\`\`\r
\r
En el ejemplo anterior, se envía la señal de finalización forzada al proceso con PID \`1234\`.\r
\r
::: tip Señales\r
Os dejo un enlace a la [lista de señales de UNIX](https://en.wikipedia.org/wiki/Signal_(IPC)).\r
\r
Y un artículo de ampliación sobre [Gestión de procesos en Windows](https://openwebinars.net/blog/gestion-de-procesos-y-servicios-desde-shell-script-en-windows/).\r
:::\r
\r
## 2.1.4. Comunicación mediante sockets\r
\r
Los sockets se pueden usar para la comunicación entre procesos en el mismo dispositivo o en dispositivos diferentes.\r
\r
Los sockets los estudiaremos en la Unidad 4, donde veremos cómo se pueden usar para la comunicación entre procesos en dispositivos diferentes.\r
`]},{title:"2.2 Gestión de procesos en Java - ProcessBuilder y Process",headers:[{level:2,title:"2.2.1 Preparación y configuración de un proceso",slug:"_2-2-1-preparacion-y-configuracion-de-un-proceso",link:"#_2-2-1-preparacion-y-configuracion-de-un-proceso",children:[{level:3,title:"Modificar el comando en tiempo de ejecución",slug:"modificar-el-comando-en-tiempo-de-ejecucion",link:"#modificar-el-comando-en-tiempo-de-ejecucion",children:[]},{level:3,title:"Configuraciones adicionales de un proceso",slug:"configuraciones-adicionales-de-un-proceso",link:"#configuraciones-adicionales-de-un-proceso",children:[]}]},{level:2,title:"2.2.2 Acceso al proceso una vez en ejecución",slug:"_2-2-2-acceso-al-proceso-una-vez-en-ejecucion",link:"#_2-2-2-acceso-al-proceso-una-vez-en-ejecucion",children:[]},{level:2,title:"2.2.3 Lanzar una clase Java como proceso desde otra clase java en el mismo proyecto",slug:"_2-2-3-lanzar-una-clase-java-como-proceso-desde-otra-clase-java-en-el-mismo-proyecto",link:"#_2-2-3-lanzar-una-clase-java-como-proceso-desde-otra-clase-java-en-el-mismo-proyecto",children:[]},{level:2,title:"2.2.4 Información de los procesos en Java",slug:"_2-2-4-informacion-de-los-procesos-en-java",link:"#_2-2-4-informacion-de-los-procesos-en-java",children:[{level:3,title:"Obtener información desde el propio proceso",slug:"obtener-informacion-desde-el-propio-proceso",link:"#obtener-informacion-desde-el-propio-proceso",children:[]},{level:3,title:"Obtener información de un proceso lanzado",slug:"obtener-informacion-de-un-proceso-lanzado",link:"#obtener-informacion-de-un-proceso-lanzado",children:[]}]}],path:"/es/unit2/processbuilder.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.2 Gestión de procesos en Java - ProcessBuilder y Process\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
<DocumentCover-component titulo="2.2 Gestión de procesos en Java - ProcessBuilder y Process" />\r
\r
# 2.2 Gestión de procesos en Java - ProcessBuilder y Process\r
\r
[[toc]]\r
\r
## 2.2.1 Preparación y configuración de un proceso\r
\r
En el paquete \`java.lang\` tenemos dos clases para la gestión de procesos.\r
\r
* \`java.lang.ProcessBuilder\` [Referencia API Java](https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.html)\r
* \`java.lang.Process\` [Referencia API Java](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ProcessBuilder.html)\r
\r
Las instancias de **ProcessBuilder** gestionan los atributos de los procesos, mientras que las instancias de **Process** controlan la ejecución de esos mismos procesos cuando se ejecutan.\r
\r
Antes de ejecutar un nuevo proceso, podemos configurar los parámetros de ejecución del mismo usando la clase \`ProcessBuilder\`.\r
\r
ProcessBuilder es una clase auxiliar de la clase Process, que veremos más adelante, y se utiliza para controlar algunos parámetros de ejecución que afectarán al proceso. A través de la llamada al método \`start\` se crea un nuevo proceso en el sistema con los atributos definidos en la instancia de ProcessBuilder.\r
\r
\`\`\`java\r
    ProcessBuilder pb = new ProcessBuilder("CMD", "/C", "DIR");\r
    Process p = pb.start();\r
\`\`\`\r
\r
Si llamamos varias veces al método start, se crearán tantos nuevos procesos como llamadas hagamos, todos ellos con los mismos atributos.\r
\r
La clase ProcessBuilder define un par de constructores:\r
\r
\`\`\`java:no-line-numbers\r
ProcessBuilder(List<String> command)\r
ProcessBuilder(String... command)\r
\`\`\`\r
\r
El funcionamiento de ambos es el mismo. En el primer constructor se pasa el comando a ejecutar y la lista de argumentos como una lista de cadenas. Por contra, en el segundo constructor, el comando y sus argumentos se pasan a través de un número variable de cadenas (String ... es lo que en Java se llama varargs). La versión que utilicemos depende del formato en que tengamos los datos.\r
\r
::: danger Argumentos y parámetros\r
Si queremos lanzar un programa con parámetros (modificadores que hacen que cambie la forma de funcionar un programa como -h /s ...) el comando no puede ser pasado al constructor directamente como un único string, debe ser preprocesado para convertirlo en una lista y que funcione.\r
\r
\`\`\`java\r
// Formas diferentes de pasar el comando a los constructores de ProcessBuilder\r
// 1ª forma: usando una cadena. Falla con parámetros\r
// Sólo funciona con programas que tengan argumentos\r
String command1 = "notepad.exe prueba1.txt"\r
ProcessBuilder pb = new ProcessBuilder(command1);\r
\r
// 2ª forma: usando un array de cadenas. Funciona con parámetros\r
String[] command2 = {"cmd", "/c", "dir", "/o"};\r
ProcessBuilder pb = new ProcessBuilder(command2);\r
\r
// 3ª forma: usando una cadena y dividiéndola para convertirla en una lista\r
String command3 =  "c:/windows/system32/shutdown -s -t 0";  \r
// La expresión regular \\s significa partir por los espacios en blanco\r
ProcessBuilder pb = new ProcessBuilder(command3.split("\\\\s"));\r
// ESTA ES LA MEJOR FORMA PARA QUE FUNCIONE EN TODOS LOS CASOS\r
\`\`\`\r
\r
:::\r
\r
::: warning Apagar el sistema operativo\r
El comando \`shutdown -s\` sirve para apagar el sistema. En windows es necesario proporcionar la ruta completa al comando, por ejemplo C:\\Windows\\System32\\shutdown.\r
\r
Podemos usar como parámetro -s para apagar el sistema, , -r para reiniciar , -h para hibernar y -t para indicar un tiempo de espera antes de apagar.\r
\r
[Referencia del comando shutdown de Windows](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/shutdown)\r
:::\r
\r
::: question Activity psp.activities.U2A1_Shutdowner\r
Crea una nuevo proyecto Java (package psp.actividades y como clase principal U2A1_Shutdowner). \r
Usando la línea de comandos, pide al usuario qué acción quiere realizar (apagar, reiniciar o suspender) y cuánto tiempo quiere dejar antes de realizar la acción de apagado del sistema..\r
\r
Busca información sobre el funcionamiento del comando shutdown en GNU/Linux y haz que tu aplicación funcione para ambos sistemas..\r
\r
La aplicación tiene que preparar el comando correcto para la selección que haya hecho el usuario y para el sistema operativo en el que la esté ejecutando.\r
\r
Muestra por consola el resultado del método ProcessBuilder.command() de forma legible.\r
:::\r
\r
:::details Solución de U2A1_Shutdowner\r
\r
\`\`\`java\r
public class U2A1_Shutdowner {\r
\r
    public static void main(String[] args) throws IOException {\r
        // Ask for the required information to prepare the command\r
        Scanner keyboard = new Scanner(System.in);\r
        \r
        System.out.print("Select your option (s-shutdown / r-reboot / h-hibernate): ");\r
        String shutdownOption = keyboard.nextLine();        \r
        \r
        System.out.print("How much seconds will the command wait to be run? (0 means immediately): ");\r
        String shutdownTime = keyboard.nextLine();        \r
        \r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "C:/Windows/System32/shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        } else {\r
            command = "shutdown -" + shutdownOption + " -t " + shutdownTime;\r
        }\r
        \r
        // Prepare the process and launch it\r
        ProcessBuilder shutdowner = new ProcessBuilder(command.split("\\\\s"));\r
        //shutdowner.start();\r
        \r
        // Show the command to be run\r
        System.out.print("El comando a ejecutar es:  ");\r
        for (String commandPart: shutdowner.command()) {\r
            System.out.print(commandPart + " ");\r
        }\r
        System.out.println("");\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
### Modificar el comando en tiempo de ejecución\r
\r
Puede ser que todo el comando, o parte del mismo, no lo tengamos en el momento de llamar a los constructores de ProcessBuilder. Se puede cambiar, modificar y consultar a posteriori con el método \`command\`\r
\r
Al igual que con los constructores, tenemos dos versiones del método command\r
\r
\`\`\`java:no-line-numbers\r
    command(List<String> command)\r
    command(String... command)\r
\`\`\`\r
\r
y la tercera forma de este método (sin parámetros) sirve para obtener una lista del comando pasado al constructor o puesto con alguna de las formas anterior del método command. Lo interesante es que una vez que tenemos la lista, podemos modificarla usando los métodos de la clase List.\r
\r
En el siguiente ejemplo, en el momento de definir el comando, nos falta saber la última parte, el directorio temporal. Además, si queremos hacer que la ejecución sea multiplataforma, el shell a ejecutar tampoco lo sabemos.\r
Dependiendo del SO se añaden dos valores al principio y un valor al final, con el método add de la clase List.\r
\r
\`\`\`java\r
// Sets and modifies the command after ProcessBuilder object is created\r
String command = "java -jar install.jar -install"; // tmp dir is missing\r
ProcessBuilder pbuilder = new ProcessBuilder(command.split("\\\\s"));\r
if (isWindows) {\r
    pbuilder.command().add(0, "cmd"); // Sets the 1st element\r
    pbuilder.command().add(1, "/c"); // Sets the 2nd element\r
    pbuilder.command().add("c:/temp"); // Sets the last element\r
    // Command to run cmd /c java -jar install.jar -install c:/temp\r
} else {\r
    pbuilder.command().add(0, "sh"); // Sets the 1st element\r
    pbuilder.command().add(1, "-c"); // Sets the 2nd element\r
    pbuilder.command().add("/tmp"); // Sets the last element\r
    // Command to run: sh -c java -jar install.jar -install /tmp\r
}\r
\r
// Starts the process\r
pbuilder.start();\r
\`\`\`\r
\r
### Configuraciones adicionales de un proceso\r
\r
Algunos de los atributos que podemos configurar para un proceso son:\r
\r
* Establecer el directorio de trabajo donde el proceso se ejecutará\r
  \r
  Podemos cambiar el directorio de trabajo por defecto llamando al método \`directory\` y pasándole un objeto de tipo File. **Por defecto, el directorio de trabajo se establece al valor de la variable del sistema user.dir**. Este directorio es el punto de partida para acceder a ficheros, imágenes y todos los recursos que necesite nuestra aplicación.\r
\r
    \`\`\`java\r
    // Cambia el directorio de trabajo a la carpeta personal del usuario\r
    pbuilder.directory(new File(System.getProperty("user.home")));\r
    \`\`\`\r
\r
* Configurar o modificar variables de entorno para el proceso con el método \`environment()\`\r
\r
    \`\`\`java\r
    // Retrieve and modify the process environment\r
    Map<String, String> environment = pbuilder.environment();\r
    // Get the PATH environment variable and add a new directory\r
    String systemPath = environment.get("path") + ";c:/users/public";\r
    environment.replace("path", systemPath);\r
    // Add a new environment variable and use it as a part of the command\r
    environment.put("GREETING", "Hola Mundo");\r
    processBuilder.command("/bin/bash", "-c", "echo $GREETING");\r
    \`\`\`\r
\r
    \`\`\`java\r
    // Indicamos el directorio donde se encuentra el ejecutable\r
    File directorio = new File ("bin");\r
    pb.directory(directorio);\r
\r
    // Mostramos la información de las variables de entorno\r
    Map variablesEntorno = pb.environment();\r
    System.out.println(variablesEntorno);\r
\r
    // Mostramos el nombre del proceso y sus argumentos\r
    List command = pb.command();\r
    Iterator iter = l.iterator();\r
    while (iter.hasNext()) {\r
        System.out.println(iter.next());\r
    }\r
    \`\`\`\r
\r
    ::: info Variables de entorno vs Propiedades del sistema\r
    Con la clase Runtime accedemos a las variables del sistema mientras que con ProcessBuilder lo hacemos a las propiedades del sistema, que son diferentes.\r
    :::\r
\r
* Redireccionar la entrada y salida estándar\r
* Heredar la E/S estándar del proceso padre usando el método ProcessBuilder.inheritIO()\r
  \r
  *Estas dos configuraciones se verán en el siguiente apartado.*\r
\r
::: question Actividad psp.activities.U2A2_DirectorioTrabajo\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A2_DirectorioTrabajo y como clase principal psp.activities.U2A2_WorkingDirectory)\r
Escribe un programa que ejecute el comando ls o dir.\r
Modifica el valor de la propiedad user.dir.\r
En la misma aplicación, cambiar el directorio de trabajo a la carpeta c:/temp o /tmp, dependiendo del sistema operativo.\r
\r
Muestra el valor devuelto por el método directory()\r
\r
* Después de crear la instancia de ProcessBuilder\r
* Después de cambiar el valor de user.dir\r
* Después de cambiar el directorio de trabajo al directorio temporal del sistema.\r
\r
*En este momento tu programa todavía no mostrará ningún listado.*\r
:::\r
\r
::: details Solución de U2A2_DirectorioTrabajo\r
\r
\`\`\`java\r
public class U2A2_WorkingDirectory {\r
\r
    public static void main(String[] args) throws IOException, InterruptedException {\r
        // Prepare the command\r
        String command;\r
        if (System.getProperty("os.name").toLowerCase().startsWith("windows")) {\r
            command = "cmd /c dir";\r
        } else {\r
            command = "sh -c ls";\r
        }\r
               \r
        //1st - Default working directory\r
        \r
        // Prepare the process \r
        ProcessBuilder commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir\r
        commander.start().waitFor();\r
        \r
        \r
        //2nd - Change user.dir but not the working directory\r
        \r
        // Change the user.dir system property\r
        System.setProperty("user.dir", System.getProperty("user.home"));\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
        \r
        // Launch the process and show its result\r
        // Working directory is null but the process is run on the current dir        \r
        commander.start().waitFor();\r
        \r
        \r
        // 3rd - Change the working directory\r
        \r
        // Prepare the process\r
        commander = new ProcessBuilder(command.split("\\\\s"));       \r
        commander.inheritIO();\r
        \r
        // Show Process and System properties\r
        commander.directory(new File(System.getProperty("user.home")));             \r
        System.out.println("Working directory: " + commander.directory());\r
        System.out.println("user.dir variable: " + System.getProperty("user.dir"));\r
\r
        // Launch the process and show its result\r
        // Working directory is user.home and the process is run on it\r
        commander.start().waitFor();        \r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.2 Acceso al proceso una vez en ejecución\r
\r
LA clase \`Process\` es una clase abstracta definida en el paquete java.lang y contiene la información del proceso en ejecución. Tras invocar al método \`start\` de ProcessBuilder, éste devuelve una referencia al proceso en forma de objeto Process.\r
\r
Los métodos de la clase Process pueden ser usados para realizar operaciones de E/S desde el proceso, para comprobar su estado, su valor de retorno, para esperar a que termine de ejecutarse y para forzar la terminación del proceso. Sin embargo estos métodos no funcionan sobre procesos especiales del SO como pueden ser servicios, shell scripts, demonios, etc.\r
\r
> [Especificación java.lang.Process](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Process.html)\r
\r
::: warning Entrada / Salida desde el proceso hijo\r
Curiosamente  **los procesos lanzados con el método start() no tienen una consola asignada.**. Por contra, estos procesos redireccionan los streams de E/S estándar (stdin, stdout, stderr) al proceso padre. Si se necesita, se puede acceder a ellos a través de los streams obtenidos con los métodos definidos en la clase Process como getInputStream(), getOutputStream() y  getErrorSteam(). Esta es la forma de enviar y recibir información desde los subprocesos.\r
:::\r
\r
Los principales métodos de esta clase son:\r
\r
| Método                                       | Descripción                                                                                                                                                                                                                                                                                                      |\r
| :------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| int exitValue()                              | Código de finalización devuelto por el proceso hijo (ver Info más abajo)                                                                                                                                                                                                                                         |\r
| Boolean isAlive()                            | Comprueba si el proceso todavía está en ejecución                                                                                                                                                                                                                                                                |\r
| int waitFor()                                | hace que el proceso padre se quede esperando a que el proceso hijo termine. El entrono que devuelve es el código de finalización del proceso hijo                                                                                                                                                                |\r
| Boolean waitFor(long timeOut, TimeUnit unit) | El funcionamiento es el mismo que en el caos anterior sólo que en esta ocasión podemos especificar cuánto tiempo queremos esperar a que el proceso hijo termine. El método devuelve true si el proceso termina antes de que pase el tiempo indicado y false si ha pasado el tiempo y el proceso no ha terminado. |\r
| void destroy()                               | Estos dos métodos se utilizan para matar al proceso. El segundo lo hace de forma forzosa.                                                                                                                                                                                                                        |\r
| Process destroyForcibly()                    |\r
\r
 Veamos un sencillo ejemplo. Una vez lanzado el programa espera durante 10 segundos y a continuación mata el proceso.\r
\r
\`\`\`java\r
public class ProcessDemo {\r
\r
   public static void main(String[] args) throws Exception {\r
\r
      ProcessBuilder pb = new ProcessBuilder("C:/Program Files (x86)/Notepad++/notepad++.exe");\r
      // Effectively launch the process\r
      Process p = pb.start();\r
      // Check is process is alive or not\r
      boolean alive = p.isAlive();\r
      // Wait for the process to end for 10 seconds.\r
      if (p.waitFor(10, TimeUnit.SECONDS)) {\r
          System.out.println("Process has finished");\r
      } else {\r
          System.out.println("Timeout. Process hasn't finished");\r
      }\r
      // Force process termination.\r
      p.destroy();\r
      // Check again if process remains alive\r
      alive = p.isAlive();\r
      // Get the process exit value\r
      int status = p.exitValue();        \r
   }\r
}\r
\`\`\`\r
\r
::: info Códigos de terminación\r
Un código de salida (exit code o a veces también return code) es el valor que un proceso le devuelve a su proceso padre para indicarle cómo ha acabado. Si un proceso acaba con un valor de finalización 0 es que todo ha ido bien, cualquier otro valor entre 1 to 255 indica alguna causa de error.\r
:::\r
\r
::: question Actividad psp.activities.U2A3_ExitValue\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A3_ExitValue y como clase principal psp.activities.U2A3_ExitValue).\r
Prepara un programa que ejecute varios comandos (notepad, calc, comandos shell) uno detrás de otro, de forma secuencial y haz que tu programa obtenga el código de finalización de cada uno de ellos.\r
Para cada programa imprime el nombre y su código de finalización.\r
\r
Prueba a poner aplicaciones que no existan o comandos con parámetros incorrectos.\r
\r
¿Qué hace Netbeans si pones System.exit(10) para acabar tu programa?. Fíjate en la consola.\r
¿Qué hace Netbeans si pones System.exit(0) para acabar tu programa.?\r
Cuál es entonces el valor por defecto?\r
:::\r
\r
::: details Solución de U2A3_ExitValue\r
\r
\`\`\`java\r
public class U2A3_ExitValue {\r
\r
    public static void main(String[] args) {\r
        do {\r
            // Código para pedir un programa/comando a ejecutar\r
            Scanner teclado = new Scanner(System.in);\r
            System.out.println("Introduce el programa / comando que quieres ejecutar (intro para acabar): ");\r
            String comando = teclado.nextLine();\r
            \r
            if (comando.equals("")) System.exit(0);\r
\r
            try {\r
                // Preparamos el entrono de ejecución del proceso\r
                // Como no sabemos el contenido del comando, forzamos su conversión\r
                // a una lista para que no haya problemas con su ejecución\r
                ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
\r
                // Lanzamos el proceso hijo\r
                Process p = pb.start();          \r
\r
                // Esperamos a que acabe para recoger el valor de salida\r
                int exitValue = p.waitFor();\r
\r
                if (exitValue == 0) {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
                } else {\r
                    System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Código (" + exitValue + ")");\r
                }\r
\r
            } catch (InterruptedException | IOException ex) {\r
                System.err.println(ex.getLocalizedMessage());\r
                ex.printStackTrace();\r
            }                       \r
        } while (true);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
\r
::: danger Gestión de excepciones\r
La llamada al método **waitFor** hace que el proceso padre se bloquee hasta que el proceso hijo termina o bien hasta que el bloqueo es interrumpido por alguna señal del sistema (Excepción) que recibe el proceso padre.\r
\r
Es mejor gestionar las excepciones lo más cerca posible del origen en vez de pasarlas a niveles superiores.\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.3 Lanzar una clase Java como proceso desde otra clase java en el mismo proyecto\r
\r
Para las actividades os pediré que programéis tanto el proceso padre como el proceso hijo. Para hacer eso, una de las clases tendrá que lanzar a la otra.\r
\r
Para hacer esto, ambas clases deben tener un método main. Así que en las propiedades del proyecto Netbeans deberemos seleccionar cuál de las clases se ejecutará primero, normalmente la clase \`Lanzador o Launcher\` (proceso padre).\r
\r
![Seleccionar clase principal](../../media/unit2/seleccionmain.png)\r
\r
Antes de que una clase pueda lanzar a otra, al menos la segunda (proceso hijo) debe estar compilada, es decir, el archivo .class debe haberse creado dentro del directorio build/classes.\r
\r
![Seleccionar directorio de trabajo ](../../media/unit2/comandotree.png)\r
\r
Entonces y sólo entonces, previa configuración de los parámetros de ejecución del proceso tal y como se muestra en el ejemplo, se podrá ejecutar una clase desde otra.\r
\r
::: info Directorio de trabajo\r
\r
Si nos fijamos en la estructura de directorios de un proyecto y entendemos cómo se invocan unas clases a otras, entenderemos porqué el directorio de trabajo debe ser *build/classes*.\r
\r
En Java, cuando se ejecuta una clase \`java paquete.clase\`, la MV Java espera encontrar los directorios que forman el paquete (psp/u2/actividad10) a partir del punto donde se está invocando el comando. Por eso, para que pueda encontrar la clase (el archivo .class), debemos ubicarnos previamente en el directorio \`build/classes\`\r
\`\`\`java\r
// Prepare the environment and the command\r
ProcessBuilder pb = new ProcessBuilder("java", "psp.u2.actividad10.Sumador");\r
pb.directory(new File("build/classes"));\r
Process p = pb.start();\r
\`\`\`\r
\r
:::\r
\r
::: question Actividad psp.activities.U2A4_Lanzador\r
Crea un nuevo proyecto Java (Ant > Java Application) (configura como nombre del proyecto U2A3_Lanzador y como clase principal psp.activities.*U2A4_Lanzador*).\r
\r
Ahora, en el mismo proyecto y dentro del mismo paquete crea otra clase, U2A4_Lanzado, con un método main que recibirá el nombre del programa que debe ejecutar como parámetro del método main(args). Haz que esta aplicación cree un nuevo proceso para ejecutar el programa recibido como parámetro.\r
\r
La clase terminará devolviendo como código de finalización el que el programa lanzado le haya devuelto a ella.\r
\r
> Método System.exit()\r
>\r
> * Cero. El código cero debe devolverse cuando la ejecución del proceso haya ido bien, esto es, que ha terminado su ejecución sin problemas.\r
> * Distinto de cero. AUn código distinto de cero indica una terminación con errores. Java nos permite usar códigos diferentes para los diferentes tipos de error.\r
\r
Por último, podemos hacer que U2A4_Lanzador pregunte al usuario qué aplicación quiere ejecutar y pasársela a la clase U2A4_Lanzado.\r
\r
En Lanzador recoge el código de finalización de Lanzado y muestra un mensaje indicando si el proceso terminó bien o con errores.\r
:::\r
\r
::: details Solución de U2A4_Lanzador\r
\r
\`\`\`java\r
public class U2A4_Launcher {\r
\r
    public static void main(String[] args) {\r
\r
        // Código para pedir un programa/comando a ejecutar\r
        Scanner teclado = new Scanner(System.in);\r
        System.out.println("Introduce el programa / comando que quieres ejecutar: ");\r
        String comando = teclado.nextLine();\r
\r
        try {\r
            // Preparamos el entrono de ejecución del proceso\r
            // Como no sabemos el contenido del comando, forzamos su conversión\r
            // a una lista para que no haya problemas con su ejecución\r
            comando = "java psp.activities.U2A4_Commander " + comando;\r
            ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));\r
            pb.directory(new File("build/classes"));\r
\r
            // Lanzamos el proceso hijo\r
            Process p = pb.start();          \r
\r
            // Esperamos a que acabe para recoger el valor de salida\r
            int exitValue = p.waitFor();\r
\r
            if (exitValue == 0) {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado bien");\r
            } else {\r
                System.out.println("El comando " + pb.command().toString() + " ha finalizado con errores. Código (" + exitValue + ")");                \r
            }\r
        } catch (InterruptedException | IOException ex) {\r
            System.err.println(ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }                       \r
    }\r
}\r
\r
public class U2A4_Commander {\r
\r
    public static void main(String[] args) throws Exception {       \r
        // Lectura de información desde los parámetros de entrada \r
        // Se supone que recibimos: args[0] args[1] args[2] ..... args[args.length-1 --> comando a ejecutar\r
        String comando = "";\r
        for (int i = 0; i < args.length; i++) {\r
            comando += args[i] + " ";\r
        }\r
        comando.trim();\r
                \r
        ProcessBuilder pb = new ProcessBuilder(comando.split("\\\\s"));            \r
\r
        // Lanzamos el proceso hijo\r
        Process p = pb.start();          \r
\r
        // Esperamos a que acabe para recoger el valor de salida\r
        int exitValue = p.waitFor();\r
\r
        System.exit(exitValue);\r
    }    \r
}\r
\`\`\`\r
\r
:::\r
\r
::: warning Programación de clases "hijas"\r
Debemos tener en cuenta que una clase se puede ejecutar de forma independiente o puede ser llamada desde otro proceso.\r
\r
Por eso, el código de las clases, hijas o padres, se hace sin tener en cuenta cómo van a ser llamadas. Debe ser **independiente** tal y como lo son unos procesos de otros.\r
\r
Así, en el anterior proyecto yo podría ejecutar la clase psp.activities.U2A4_Commander de forma independiente, pasándole el nombre de los programas.\r
\r
Puedo hacerlo invocándola desde línea de comandos o desde Netbeans:\r
- java psp.activities.U2A4_Commander programa1 programa2 programa3\r
- En las propiedades del proyecto, en el apartado Run, seleccionando U2A4_Commander como clase principal y poniendo como Arguments: programa1 programa2 programa3\r
:::\r
\r
<div class="pagebreak"></div>\r
\r
## 2.2.4 Información de los procesos en Java\r
\r
Una vez que un proceso está en ejecución podemos obtener información acerca de ese proceso usando los métodos de la clase \`java.lang.ProcessHandle.Info\`:\r
\r
* el comando usado para lanzar el proceso\r
* Los argumentos/parámetros que recibió el proceso\r
* El instante de tiempo en el que se inició el proceso\r
* El tiempo de CPU que ha usado el proceso y el usuario que lo ha lanzado\r
\r
### Obtener información desde el propio proceso\r
\r
Aquí tenemos un sencillo ejemplo de cómo hacerlo para obtener información del proceso actual.\r
\r
\`\`\`java{2-3}\r
// Get information about the current process\r
ProcessHandle processHandle = ProcessHandle.current();\r
ProcessHandle.Info processInfo = processHandle.info();\r
\r
System.out.println("PID: " + processHandle.pid());\r
System.out.println("Arguments: " + processInfo.arguments());\r
System.out.println("Command: " + processInfo.command());\r
System.out.println("Instant: " + processInfo.startInstant());\r
System.out.println("Total CPU duration: " + processInfo.totalCpuDuration());\r
System.out.println("User: " + processInfo.user());\r
\`\`\`\r
\r
### Obtener información de un proceso lanzado\r
\r
En el ejemplo anterior hemos obtenido la información del proceso actual (\`ProcessHandle.current()\`), así que si estamos en el proceso padre, sólo podemos mostrar su información, pero no la de su hijo.\r
\r
También es posible acceder a la información de un proceso lanzado (proceso hijo). En este caso necesitamos la instancia de \`java.lang.Process\` para llamar a su método \`toHandle()\` y obtener la instancia de  \`java.lang.ProcessHandle\` del proceso hijo..\r
\r
\`\`\`java{3-4}\r
// Get information about a child process from parent\r
Process process = processBuilder.inheritIO().start();\r
ProcessHandle childProcessHandle = process.toHandle();\r
ProcessHandle.Info childProcessInfo = childProcessHandle.info();\r
\`\`\`\r
\r
A partir de ahí, el código para acceder a la información y detalles del proceso hijo es idéntico al ejemplo anterior.\r
`]},{title:"2.1 Creación de procesos en Java con Runtime",headers:[{level:2,title:"2.1.1. Creación rápida de procesos",slug:"_2-1-1-creacion-rapida-de-procesos",link:"#_2-1-1-creacion-rapida-de-procesos",children:[]},{level:2,title:"2.1.2 Propiedades del sistema y comandos del sistema",slug:"_2-1-2-propiedades-del-sistema-y-comandos-del-sistema",link:"#_2-1-2-propiedades-del-sistema-y-comandos-del-sistema",children:[]}],path:"/es/unit2/runtime.html",pathLocale:"/es/",extraFields:[`---\r
title: 2.1 Creación de procesos en Java con Runtime\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="2.1. Creación de procesos con Java con Runtime" />\r
\r
# 2.1. Creación rápida de procesos con Java con Runtime\r
\r
[[toc]]\r
\r
## 2.1.1. Creación rápida de procesos\r
\r
La clase java.lang.Runtime se usa principalmente para interactuar con el JRE de Java. Esta clase proporciona métodos para lanzar procesos, llamar al recolector de basura (Garbage Collector), saber la cantidad de memoria disponible y libre, etc.\r
\r
> [Especificación java.lang.Runtime](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runtime.html)\r
\r
Cada aplicación en Java tiene acceso a una única instancia de *java.lang.Runtime* a través del método \`Runtime.getRuntime()\` que devuelve la instancia **singleton** de la clase Runtime.\r
\r
::: question Patrones de diseño: Singleton\r
¿Qué son los patrones de diseño? ¿Qué es y para qué se usa el patrón de diseño singleton?\r
\r
Investiga cómo realizar una clase que siga el patrón de diseño singleton.\r
\r
[Refactoring.Guru Patrones de diseño](https://refactoring.guru/es/design-patterns/java)\r
:::\r
\r
El método que nos interesa a nosotros para la creación de procesos es\r
\r
> public Process exec(String command) throws IOException\r
\r
Veamos un ejemplo sencillo de uso de este método\r
\r
\`\`\`java\r
public static void main(String[] args) throws IOException {\r
    // Launch notepad app\r
    Runtime.getRuntime().exec("notepad.exe");\r
\r
    // This way always works\r
    // String separator = System.getProperty("file.separator");\r
    // Runtime.getRuntime()\r
    //    .exec("c:"+separator+"windows"+separator+"notepad.exe");\r
\r
    // This way used to work (UNIX style paths)\r
    // Runtime.getRuntime().exec("c:/windows/notepad.exe");\r
}\r
\`\`\`\r
\r
Se puede observar que en el parámetro que pasamos al método \`exec\` indicamos el programa que queremos ejecutar. En este caso, como el *notepad* se encuentra en el PATH del sistema, no es necesario indicar la ruta donde se encuentra el programa. En otro caso, sí tendríamos que hacerlo.\r
\r
<div class="pagebreak"></div>\r
\r
## 2.1.2 Propiedades del sistema y comandos del sistema\r
\r
Si tenemos pensado desarrollar aplicaciones que funcionen en diferentes SO tendremos que enfrentarnos a la problemática del funcionamiento diferente de los distintos SO.\r
\r
Vamos a ver algunos ejemplos que pueden servir como guía para otros problemas similares a los expuestos.\r
\r
::: danger File separator\r
Para indicar las rutas en un sistema los sistemas UNIX emplean el caracter  **/** como separador mientras que los sistemas Windows usan el caracter **\\\\** . En resumen, / en *X y \\ en Windows.\r
\r
¿Cómo podemos hacer entonces que nuestras aplicaciones sean independientes del SO en el que se ejecutan?\r
\r
Para este tipo de cuestiones vamos a utilizar de forma recurrente las propiedades del sistema mediante \`System.getProperty(String propName)\`. Estas propiedades se configuran con el propio sistema operativo, aunque las podemos modificar usando los parámetros de ejecución de la máquina virtual\r
\r
> String separator = System.getProperty("file.separator");\r
\r
o\r
\r
> -Dfile.separator\r
\r
Aunque siempre es una buena práctica usar el caracter **/** en las rutas ya que Java es capaz de convertirlas al sistema en el que se ejecuta.\r
:::\r
\r
Si lo que queremos es ejecutar un comando del SO, tenemos que hacerlo, al igual que si lo hacemos manualmente, a través del shell del sistema, donde volvemos a encontrar la dicotomía entre sistemas UNIX y sistemas Windows.\r
\r
Vamos a ver el código que, a través de las propiedades del sistema, nos permite obtener un listado de los archivos existentes en la carpeta personal del usuario.\r
\r
\`\`\`java\r
// Primero obtenemos la carpeta del usuario\r
String homeDirectory = System.getProperty("user.home");\r
boolean isWindows = System.getProperty("os.name")\r
  .toLowerCase().startsWith("windows");\r
\r
if (isWindows) {\r
    Runtime.getRuntime()\r
      .exec(String.format("cmd.exe /c dir %s", homeDirectory));\r
} else {\r
    Runtime.getRuntime()\r
      .exec(String.format("sh -c ls %s", homeDirectory));\r
}\r
\`\`\`\r
\r
::: info Modo shell no interactivo\r
Como se puede observar, tanto para Windows como UNIX se ha usado el modificador **c** del comando. Este modificador indica que se abra un shell, se ejecute el comando recibido y se cierre el proceso del shell.\r
:::\r
\r
A continuación podemos ver un ejemplo de respuesta ante la pulsación de un botón, en una app gráfica, para abrir una página en el navegador. Tenemos cómo se haría en sistemas *X y comentado una de las formas de hacerlo en Windows.\r
\r
\`\`\`java\r
// Calling app example\r
public void mouseClicked(MouseEvent e) {\r
  // Launch Page\r
  try {\r
    // Linux version\r
    Runtime.getRuntime().exec("open http://localhost:8153/go");\r
    // Windows version\r
    // Runtime.getRuntime().exec("explorer http://localhost:8153/go");\r
  } catch (IOException e1) {\r
    // Don't care\r
  }\r
}\r
\`\`\`\r
\r
::: question System properties\r
Vamos a crear nuestro primer programa en Java, que no va a ser tan sencillo como pueda parecer\r
\r
Usando métodos de las clases System y Runtime hacer un programa que muestre\r
\r
- todas las propiedades establecidas en el sistema operativo y sus valores.\r
- memoria total, memoria libre, memoria en uso y los procesadores disponibles\r
\r
Mira los métodos que proporcionan las clases Runtime  y system. Intenta obtener una lista u otra estructura de datos que te permita recorrer las propiedades para ir mostrando sus nombres y valores.\r
:::\r
\r
::: details Solución propuesta para la actividad anterior\r
\r
\`\`\`java{22,25,32,38,44}\r
long freeMemory = Runtime.getRuntime().freeMemory();\r
long availableMemory = Runtime.getRuntime().totalMemory();\r
long usedMemory = availableMemory - freeMemory;\r
\r
/*** Runtime.getRuntime() usage ***/\r
// Show system information\r
// Memory will be shown in MBytes formatted with 2-decimal places\r
DecimalFormat megabytes = new DecimalFormat("#.00");\r
System.out.println("Available memory in JVM(Mbytes): " + \r
        megabytes.format((double)availableMemory/(1024*1024)));\r
System.out.println("Free memory in JVM(Mbytes): " + \r
        megabytes.format((double)freeMemory/(1024*1024)));\r
System.out.println("Used memory in JVM(Mbytes): " + \r
        megabytes.format((double)usedMemory/(1024*1024)));\r
\r
System.out.println ("Processors in the system: " \r
        + Runtime.getRuntime().availableProcessors());\r
\r
/*** System.getProperties() usage ***/\r
// Show each pair of property:value from System properties\r
\r
// 1st. As a lambda expression using anonymous classes\r
System.getProperties().forEach((k,v) -> System.out.println(k + " => " + v));\r
\r
// 2nd. As a Map.entrySet \r
for (Map.Entry<Object, Object> entry : System.getProperties().entrySet()) {\r
    Object key = entry.getKey();\r
    Object val = entry.getValue();\r
    System.out.println("> " + key + " => " + val);\r
}\r
\r
// 3rd. As a Map.keySet\r
for (Object key : System.getProperties().keySet().toArray())\r
{\r
    System.out.println(">> " + key+":"+System.getProperty(key.toString()));\r
}\r
\r
// Other methods found by students, based on a Properties object methods.\r
Properties prop = System.getProperties();\r
for (String propName: prop.stringPropertyNames()) {\r
  System.out.println(propName +  ":" + System.getProperty(propName));\r
}\r
        \r
// Or directly to the console using \r
prop.list(System.out);\r
\`\`\`\r
:::\r
\r
::: info Formato numérico\r
Todos los lenguajes de programación tienen varias formas de mostrar la información al usuario. Cuando se trata de mostrar información a a través de la consola, tenemos un par de alternativas para formatear la información numérica.\r
\r
- [NumberFormat](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/text/DecimalFormat.html)\r
\r
Si usamos la clase NumberFormat o cualquiera de sus descendientes podemos controlar con bastante precisión cómo se verán los números, usando patrones.\r
\r
\`\`\`java:no-line-numbers\r
DecimalFormat numberFormat = new DecimalFormat("#.00");\r
// Si usamos hashes en vez de ceros permitimos que .30 se vea como 0.3\r
// (los dígitos adicionales son opcionales)\r
System.out.println(numberFormat.format(number));\r
\`\`\`\r
\r
- [System.out.printf](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html)\r
\r
Heredado de la sintaxis de la función printf de C, podemos utilizar la sintaxis de java.util.Formatter para configurar cómo será visualizada la información.\r
\r
\`\`\`java:no-line-numbers\r
System.out.printf("\\n$%10.2f",shippingCost);\r
// % rellena con hasta 10 posiciones los números\r
// para justificarlos a la derecha.\r
System.out.printf("%n$%.2f",shippingCost);\r
\`\`\`\r
\r
:::\r
\r
::: info Usando colores en la salida por consola\r
\r
Hay una forma sencilla de mostrar información por consola usando diferentes colores. Os dejo un ejemplo de código con la definición de algunos colores y la forma de usarlos.\r
\r
\`\`\`java:no-line-numbers\r
public class UsarColoresEnConsola {\r
\r
public static final String ANSI_RESET = "\\u001B[0m";\r
public static final String ANSI_BLACK = "\\u001B[30m";\r
public static final String ANSI_RED = "\\u001B[31m";\r
public static final String ANSI_GREEN = "\\u001B[32m";\r
public static final String ANSI_YELLOW = "\\u001B[33m";\r
public static final String ANSI_BLUE = "\\u001B[34m";\r
public static final String ANSI_PURPLE = "\\u001B[35m";\r
public static final String ANSI_CYAN = "\\u001B[36m";\r
public static final String ANSI_WHITE = "\\u001B[37m";\r
\r
public static final String ANSI_BLACK_BACKGROUND = "\\u001B[40m";\r
public static final String ANSI_RED_BACKGROUND = "\\u001B[41m";\r
public static final String ANSI_GREEN_BACKGROUND = "\\u001B[42m";\r
public static final String ANSI_YELLOW_BACKGROUND = "\\u001B[43m";\r
public static final String ANSI_BLUE_BACKGROUND = "\\u001B[44m";\r
public static final String ANSI_PURPLE_BACKGROUND = "\\u001B[45m";\r
public static final String ANSI_CYAN_BACKGROUND = "\\u001B[46m";\r
public static final String ANSI_WHITE_BACKGROUND = "\\u001B[47m";\r
\r
    public static void main(String[] args) {\r
        System.out.println(ANSI_GREEN + ANSI_WHITE_BACKGROUND + "Hola" \r
                            + ANSI_BLUE + ANSI_YELLOW_BACKGROUND + " Adiós" + ANSI_RESET);\r
    }\r
}\r
\`\`\`\r
\r
:::\r
`]},{title:"3.4 Mecanismos alternativos de sincronización",headers:[{level:2,title:"3.4.1. Semáforos",slug:"_3-4-1-semaforos",link:"#_3-4-1-semaforos",children:[]},{level:2,title:"3.4.2. Mecanismos de alto nivel",slug:"_3-4-2-mecanismos-de-alto-nivel",link:"#_3-4-2-mecanismos-de-alto-nivel",children:[{level:3,title:"Colas concurrentes",slug:"colas-concurrentes",link:"#colas-concurrentes",children:[]},{level:3,title:"Colecciones concurrentes",slug:"colecciones-concurrentes",link:"#colecciones-concurrentes",children:[]},{level:3,title:"Variables atómicas",slug:"variables-atomicas",link:"#variables-atomicas",children:[]}]},{level:2,title:"3.4.3 Executors, Callables y Future",slug:"_3-4-3-executors-callables-y-future",link:"#_3-4-3-executors-callables-y-future",children:[]}],path:"/es/unit3/alternatives.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.4 Mecanismos alternativos de sincronización\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.4 Mecanismos alternativos de sincronización" />\r
\r
# 3.4 Mecanismos alternativos de sincronización\r
\r
[[toc]]\r
\r
## 3.4.1. Semáforos\r
\r
Otro posible mecanismo para sincronizar hilos son los \`semáforos\`. Un semáforo es un mecanismo para permitir, o restringir, el acceso a recursos compartidos en un entorno de multiprocesamiento, con varios hilos ejecutándose de forma concurrente.\r
\r
> Especificación de [java.util.concurrent.Semaphore](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Semaphore.html)\r
\r
Los semáforos se emplean para permitir el acceso a diferentes partes de programas (llamados secciones críticas) donde se manipulan variables o recursos que deben ser accedidos de forma especial. Según el valor con que son inicializados se permiten a más o menos procesos utilizar el recurso de forma simultánea.\r
\r
El funcionamiento de los semáforos se basa en el uso de dos métodos, así como en el valor inicial \`permits\` con el que se crea el semáforo:\r
\r
- release(): Ejecutado por un hilo para liberar el semáforo cuando el hilo ha terminado de ejecutar la sección crítica. Por defecto se incrementa la variable \`permits\` en 1, aunque puede recibir un valor e incrementarla en esa cantidad.\r
- acquire(): Ejecutado por un hilo para acceder al semáforo. Para que un hilo pueda tomar el control del semáforo y no quedarse bloqueado, la variable \`permits\`debe tener un valor mayor que cero. También puede recibir un valor, por lo que \`permits\` tendrá que ser mayor que dicho valor.\r
- permits: Se inicializa a la cantidad de recursos existentes o hilos que queramos que puedan acceder simultáneamente. Así, cada proceso, al ir solicitando un recurso, verificará que el valor del semáforo sea mayor de 0; si es así es que existen recursos libres, seguidamente acaparará el recurso y restará el valor del semáforo.\r
Cuando el semáforo alcance el valor 0, significará que todos los recursos están siendo utilizados, y los procesos que quieran solicitar un recurso deberán esperar a que el semáforo sea positivo (algún hilo haga un release).\r
\r
:::info Mutex\r
Un tipo simple de semáforo es el binario, que puede tomar solamente los valores 0 y 1.\r
\r
Se inicializan en 1 y son usados cuando sólo un proceso puede acceder a un recurso a la vez. Se les suele llamar mutex.\r
\r
Tienen un funcionamiento similar a synchronized, funcionando en exclusión mutua (**mut**ual **ex**clusion).\r
:::\r
\r
Veamos un ejemplo en el que varios Productores y Consumidores acceden de forma simultánea a un objeto compartido\r
\r
\`\`\`java {class="line-numbers",5-7,13,15,20,27,37,39,44,51}\r
public class Almacen {\r
\r
  private final int MAX_LIMITE = 20;\r
  private int producto = 0;\r
  private Semaphore productor = new Semaphore(MAX_LIMITE);\r
  private Semaphore consumidor = new Semaphore(0);\r
  private Semaphore mutex = new Semaphore(1);\r
\r
  public void producir(String nombreProductor) {\r
    System.out.println(nombreProductor + " intentando almacenar un producto");\r
    try {\r
        // En el ejemplo, hasta 20 productores pueden acceder a la vez      \r
        productor.acquire();\r
        // Sin embargo, sólo 1 (consumidor/productor) a la vez podrá actualizar \r
        mutex.acquire();\r
\r
        producto++;\r
        System.out.println(nombreProductor + " almacena un producto. "\r
            + "Almacén con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
      \r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // El productor permite que un consumidor pueda acceder\r
      consumidor.release();\r
    }\r
\r
  }\r
\r
  public void consumir(String nombreConsumidor) {\r
    System.out.println(nombreConsumidor + " intentando retirar un producto");\r
    try {\r
        // En el ejemplo siempre tiene que llegar un consumidor antes que un productor\r
        consumidor.acquire();\r
        // Sin embargo, sólo 1 (consumidor/productor) a la vez podrá actualizar \r
        mutex.acquire();\r
\r
        producto--;\r
        System.out.println(nombreConsumidor + " retira un producto. "\r
            + "Almacén con " + producto + (producto > 1 ? " productos." : " producto."));\r
        mutex.release();\r
\r
        Thread.sleep(500);\r
    } catch (InterruptedException ex) {\r
      Logger.getLogger(Almacen.class.getName()).log(Level.SEVERE, null, ex);\r
    } finally {\r
      // El consumidor avisa para que un productor pueda volver a dejar productos.\r
      productor.release();\r
\r
    }\r
  }\r
\r
}\r
\`\`\`\r
\r
## 3.4.2. Mecanismos de alto nivel\r
\r
Java, en su paquete \`java.util.concurrent\` proporciona varias clases \`thread-safe\` que nos permiten acceder a los elementos de colecciones y tipos de datos sin preocuparnos de la concurrencia.\r
\r
Es un paquete muy amplio que contiene multitud de clases que podemos utilizar en nuestros desarrollos multihilo para simplificar la complejidad de los mismos.\r
\r
### Colas concurrentes\r
\r
La interfaz **BlockingQueue** define una cola \`FIFO\` que bloquea hilos que intentan extraer un elemento si la cola está vacía, hasta que vuelva a haber elementos. También permite establecer un número máximo de elementos, de marea que se bloquean los procesos cuando intentan añadir por encima de ese límite, a la espera que se extraigan.\r
\r
Las clases LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue, PriorityBlockingQueue y DelayQueue implementan la interfaz BlockingQueue.\r
\r
### Colecciones concurrentes\r
\r
El uso de colecciones simultáneas es una forma recomendada de crear estructuras de datos compatibles con procesos. Dichas colecciones incluyen ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, CopyOnWriteArraylist y CopyOnWriteArraySet.\r
\r
**ConcurrentMap** es una subinterfaz de \`java.util.Map\` con operaciones atómicas para eliminar o reemplazar pares clave/valor existentes o añadir pares clave/valor no existentes. ConcurrentHashMap es la versión thread-safe análoga a HashMap.\r
\r
### Variables atómicas\r
\r
El paquete \`java.util.concurrent.atomic\` incluye clases que proporcionan acciones atómicas sobre tipos de datos básicos. Tenemos AtomicBoolean, AtomicInteger, AtomicDouble, .... y proporcionan métodos para recuperar su valor, incrementar, decrementar, etc.\r
\r
## 3.4.3 Executors, Callables y Future\r
\r
Existen muchas aproximaciones y librerías que permiten el uso y gestión de hilos desde un programa. Una de las que nos ofrece Java como parte del JDK es la interfaz Executors.\r
\r
\`Executors\` nos va a permitir definir un pool de threads (un conjunto de hilos) que se encargarán de ejecutar las tareas, pero con un límite en cuanto al número de hilos creados y gestionando  la JVM la cola de hilos que serán ejecutados en ese pool.\r
\r
Se sale del ámbito de este módulo estudiar y analizar el funcionamiento de Executors y todas sus posibilidades. Aquí os dejo un enlace a un artículo que lo explica con un ejemplo muy ilustrativo.\r
\r
[Executors: Ejemplo supermercado](https://jarroba.com/multitarea-e-hilos-en-java-con-ejemplos-ii-runnable-executors/)\r
\r
\`Callable\` viene a poner solución a uno de los problemas que tenemos con la interfaz Runnable, la posibilidad de devolver un valor desde este método.\r
\r
Si se necesita que un proceso devuelva datos al finalizar, se debe crear una clase que implemente la interfaz Callable y defina un método \`call()\` que desempeñe la misma función que run() en Runnable. En este caso se tendrán que crear los procesos de forma diferente; la clase Thread no acepta un objeto Callable como argumento. Por contra, la clase Executors ofrece diversos métodos estáticos que crean un proceso a partir de su clase Callable.\r
\r
\`Future\` es una interfaz que implementa el objeto que devuelve el resultado de la ejecución de un Callable. Se puede seguir ejecutando una aplicación hasta que necesite obtener el resultado del hilo *Callable*, momento en el que se invoca el método get() en la instancia Future. Si el resultado ya está disponible se recoge y en caso contrario se bloqueará en la llamada hasta que su método call() devuelva el resultado.\r
`]},{title:"3.6 Anexo II - ArrayList hoja de referencia de los alumnos",headers:[{level:2,title:"A. Definición y creación",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de ArrayList",slug:"a-1-constructores-de-arraylist",link:"#a-1-constructores-de-arraylist",children:[]}]},{level:2,title:"B. Métodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creación de un ArrayList",slug:"b-1-creacion-de-un-arraylist",link:"#b-1-creacion-de-un-arraylist",children:[]},{level:3,title:"B.2. Añadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si un elemento ya existe",slug:"b-3-comprobar-si-un-elemento-ya-existe",link:"#b-3-comprobar-si-un-elemento-ya-existe",children:[]},{level:3,title:"B.4. Acceder a un elemento del ArrayList",slug:"b-4-acceder-a-un-elemento-del-arraylist",link:"#b-4-acceder-a-un-elemento-del-arraylist",children:[]},{level:3,title:"B.5. Otras funciones de utilidad",slug:"b-5-otras-funciones-de-utilidad",link:"#b-5-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Añadir datos a un ArrayList",slug:"c-anadir-datos-a-un-arraylist",link:"#c-anadir-datos-a-un-arraylist",children:[{level:3,title:"C.1. Añadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Añadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Añadir / eliminar elementos desde código",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colección",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el método forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colección",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Búsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Búsqueda usando los métodos de la clase",slug:"e-1-busqueda-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Búsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Búsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Búsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtención de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenación de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar usando métodos de Collection",slug:"g-1-ordenar-usando-metodos-de-collection",link:"#g-1-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.2. Ordenar con expresiones lambda",slug:"g-2-ordenar-con-expresiones-lambda",link:"#g-2-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.3. Ordenar con API Stream",slug:"g-3-ordenar-con-api-stream",link:"#g-3-ordenar-con-api-stream",children:[]}]}],path:"/es/unit3/arraylist_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.6 Anexo II - ArrayList hoja de referencia de los alumnos\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.6 Anexo II - ArrayList hoja de referencia de los alumnos" />\r
\r
# 3.6 Anexo II - ArrayList hoja de referencia de los alumnos\r
\r
::: info Autoría\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del módulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la información a la que podréis acceder durante los exámenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definición y creación\r
\r
Una colección representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacén donde poder guardarlos. En Java, se emplea la interfaz genérica \`Collection\` para este propósito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de métodos comunes, como pueden ser: añadir, eliminar, obtener el tamaño de la colección.\r
\r
Partiendo de la interfaz genérica Collection extienden otra serie de interfaces genéricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
La clase ArrayList en Java permite almacenar datos en memoria de forma similar a los Arrays con la ventaja de que el numero de elementos que almacena lo hace de forma dinámica, es decir, que no es necesario declarar su tamaño como pasa con los Arrays. Los elementos pueden añadirse o eliminarse según necesidad.\r
\r
### A.1. Constructores de ArrayList\r
\r
ArrayList proporciona 3 constructores que definen la capacidad inicial de la colección o si la inicializamos a partir de los valores de otra colección.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de ArrayList vacía.\r
ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\r
// ArrayList(int initialCapacity). Crea una instancia de ArrayList con una capacidad inicial especificada. \r
ArrayList<Persona> listaPersonas = new ArrayList<>(10);\r
\r
// ArrayList(Collection c). Crea una instancia de ArrayList a partir de otra colección de datos. Los datos se añaden en el orden en el que el Iterator de la otra colección los recorra.\r
ArrayList<Persona> listaPersonas = new ArrayList<>(c);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Métodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendríamos con la ejecución de estos métodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "García", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martínez", 65, 1.84d, 82, "Hombre");\r
  Persona p3 = new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre");\r
  Persona p4 = new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer");\r
\`\`\`\r
\r
### B.1. Creación de un ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un ArrayList de Personas\r
  ArrayList<Persona> listaPersonas = new ArrayList<>();\r
\`\`\`\r
\r
### B.2. Añadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Añadir un objeto Persona al final del ArrayList\r
  listaPersonas.add(p1);\r
\r
  // Añade el elemento al ArrayList en la posición 'n+1'. \r
  // Cuidado, no podemos insertar en posiciones que no existen.\r
  listaPersonas.add(1, p1);\r
  \r
  // Borra el elemento de la posición 'n+1' del ArrayList   \r
  // Cuidado, no podemos eliminar de posiciones que no existen.\r
  listaPersonas.remove(2);\r
\r
  // Borra el primer objeto pasado encontrado en el ArrayList que se le pasa como parámetro.  \r
  listaPersonas.remove(p1);  \r
\`\`\`\r
\r
::: info Duplicados\r
Si ya existe un elemento en el ArrayList, esta colección no controla la existencia de duplicados, por lo que tendremos el mismo objeto en dos posiciones diferentes.\r
Podemos evitarlo comprobando previamente si ya existe ese objeto, como veremos a continuación.\r
:::\r
\r
### B.3. Comprobar si un elemento ya existe\r
\r
\`\`\`java:no-line-numbers\r
  // Comprueba si existe del objeto que se le pasa como parámetro\r
  listaPersonas.contains(p4);\r
\r
  // Devuelve la posición del primer objeto pasado encontrado en el ArrayList  \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.indexOf(p1);\r
\r
  // Devuelve la posición del último objeto pasado en el ArrayList   \r
  // Si no lo encuentra, devuelve -1\r
  listaPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### B.4. Acceder a un elemento del ArrayList\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el elemento que esta en la posición 'n+1' del ArrayList\r
  listaPersonas.get(2);\r
\`\`\`\r
\r
### B.5. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Devuelve el numero de elementos del ArrayList\r
  listaPersonas.size();\r
\r
  //Borra todos los elementos de ArrayList   \r
  listaPersonas.clear();\r
\r
  // Devuelve true si el ArrayList esta vacío. Sino Devuelve false   \r
  listaPersonas.isEmpty();\r
\r
  // Pasa el ArrayList a un Array \r
  Object[] array = listaPersonas.toArray();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Añadir datos a un ArrayList\r
\r
::: info Orden de los elementos en un ArrayList\r
Cuando añadimos elementos a un ArrayList, el orden de inserción se conserva.\r
\r
Una Lista, por definición, siempre mantiene el orden de los elementos. Esto no es solo para ArrayList, sino para todo tipo de listas como LinkedList, Vector, y el resto de clases que implementan el interfaz \`java.util.List\` .\r
\r
:::\r
\r
### C.1. Añadir elementos desde el constructor\r
\r
A la hora de crear el ArrayList, podemos añadirle datos, usando la sintaxis del doble corchete o bien con la construcción List.of o Arrays.asList\r
\r
\`\`\`java:no-line-numbers\r
  // Crea una nueva lista y a la vez la inicializa con valores  \r
  ArrayList<Persona> lista1 = new ArrayList<>() {{\r
      add(p1);\r
      add(p2);\r
  }};\r
\r
  // En este caso indicamos los valores como si de parámetros se tratase\r
  // De esta forma podemos añadir hasta un máximo de 10 elementos\r
  ArrayList<Persona> lista2 = new ArrayList<>(\r
        List.of(p1, p2, p3)\r
  );\r
\r
  // De forma similar al caso anterior, con una construcción a partir de un Array\r
  ArrayList<Persona> lista3 = new ArrayList<>(\r
        Arrays.asList(p1, p2, p3)\r
  );       \r
\`\`\`\r
\r
### C.2. Añadir elementos desde otras colecciones\r
\r
Podemos inicializar un ArrayList, como hemos visto en los ejemplos anteriores, desde varios tipos de colecciones (listas) que poseen características similares.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del código anterior, creamos un nuevo ArrayList a partir de lista2\r
  ArrayList<Persona> lista4 = new ArrayList<>(lista3);  \r
  \r
  // Añade todos los elementos de la lista que indiquemos como argumento al final del ArrayList\r
  lista4.addAll(lista3);\r
\r
  // Hace lo mismo, pero lo inserta en la posición indicada (debe existir al menos la posición anterior)  \r
  lista4.addAll(lista3,2);\r
\`\`\`\r
\r
### C.3. Añadir / eliminar elementos desde código\r
\r
\`\`\`java:no-line-numbers\r
  // Añadir un elemento al final de la lista\r
  lista4.add(p4);\r
  // Añade un elemento en la posición indicada. El elemento que ocupaba esa posición y todos los que había detrás, se mueven una posición a la derecha.\r
  // En el ejemplo, inserta p1 al principio de la lista.\r
  lista4.add(0,p1);   // Inserta p1 al principio de la lista.\r
  \r
  // Eliminar un elemento. Si existe lo elimina y devuelve true, si no devuelve false\r
  boolean existe = lista4.remove(p1);  \r
  // Eliminar un elemento por índice. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = lista4.remove(2);  \r
  // Elimina del ArrayList todos aquellos elementos que coinciden con los indicados en la lista que pasamos como argumento \r
  lista4.removeAll(lista3);\r
  // Elimina del ArrayList todos aquellos elementos que cumplen con el predicado (la condición) descrita como argumento en el método e indicada como expresión lambda\r
  lista4.removeIf(p->p.getEdad()<18);   // Elimina los menores de 18\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colección\r
\r
Vamos a preparar un ArrayList para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList creation\r
  ArrayList<Persona> grupoPersonas = new ArrayList<>() {{\r
    add(new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
    add(new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
    add(new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
    add(new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
    add(new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
    add(new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\r
\`\`\`\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por índice\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(i));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el ArrayList es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colección)\r
\r
\`\`\`java:no-line-numbers\r
    // Obtenemos un objeto de tipo Persona en cada iteración del bucle\r
    for (Persona p: grupoPersonas) {\r
        System.out.println(p);\r
    }\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colección y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un método iterator() que devuelve una instancia de Iterator para recorrer la colección.\r
\r
Iterator tiene 4 métodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento más en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el último elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acción indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la lista\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el método forEach con expresiones lambda\r
\r
En este caso aprovechamos el método foreach de las colecciones para poder realizar una acción concreta sobre cada uno de los elementos de la misma.\r
\r
De forma similar al bucle foreach, indicamos un elemento de la lista y la acción a realizar sobre el mismo\r
\r
\`\`\`java:no-line-numbers\r
  // Para cada persona (p) -> Acción a realizar\r
  grupoPersonas.forEach(p -> System.out.println(p));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colección\r
\r
Mientras se está recorriendo una colección, no con todos los tipos de bucles se puede modificar (añadir/eliminar elementos) de la colección. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendríamos problemas. Al acceder por índice, podemos añadir o eliminar elementos mientras se recorre la colección.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.get(i).getNombre().equals("Jordi")) {\r
      grupoPersonas.remove(i);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Persona p : grupoPersonas) {\r
    if (p.getPeso()>100) {\r
      grupoPersonas.remove(p);\r
    }\r
    System.out.println("Eliminada: " + p);\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Siempre que usemos el método remove de Iterator para eliminar elementos de la colección mientras la recorremos, podremos hacerlo sin que se genere ninguna excepción.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Persona> iterator = grupoPersonas.iterator();\r
  while (iterator.hasNext()) {\r
    Persona p = iterator.next();\r
    if (p.getAltura() < 100) {\r
      // Si borramos usando iterator.remove funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el método forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.forEach((p) -> {if (p.getNombre().equals("Jordi")) grupoPersonas.remove(p);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colección, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Búsqueda de elementos\r
\r
Para buscar elementos en un ArrayList hay distintas formas de hacerlo. Desde los propios métodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Búsqueda usando los métodos de la clase\r
\r
La clase ArrayList nos ofrece diferentes alternativas para buscar y/o saber si un elemento está presente en la colección. Así, podemos usar los métodos\r
\r
\`\`\`java:no-line-numbers\r
  // Comprobar si está el objeto en la colección\r
  boolean existe = grupoPersonas.contains(p1);\r
  // O simplemente obtener su posición, si lo encuentra\r
  grupoPersonas.indexOf(p1);\r
  grupoPersonas.lastIndexOf(p1);\r
\`\`\`\r
\r
### E.2. Búsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colección hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> it = grupoPersonas.iterator();\r
  while (it.hasNext()) {\r
    Persona p = it.next();\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado: " + p);\r
      break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Búsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Encontrado:: " + p);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Búsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestión de las colecciones.\r
Podemos emplear varios métodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolección\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
\r
  // Obtener un subarray con los elementos que cumplan el criterio\r
  grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList());\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);   \r
  }\r
\r
  for (Persona p : grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .collect(Collectors.toList())) {\r
      System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuántos cumplen el criterio de búsqueda\r
  grupoPersonas.stream().filter(p -> p.getAltura() > 170).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Persona> first = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)\r
          .findFirst();\r
\r
  // Obtener cualquiera que cumpla el criterio, o null si no hay ninguno\r
  Persona any = grupoPersonas.stream()\r
          .filter(p -> p.getAltura() > 170)                \r
          .findAny()\r
          .orElse(null);\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtención de subcolecciones\r
\r
Lo podemos considerar un tipo especial de búsqueda en el que el objetivo es conseguir una colección con los elementos que cumplan un determinado criterio.\r
\r
Así, la forma de buscar es idéntica a la del apartado anterior, pero en este caso lo que obtendremos de esa búsqueda será una nueva lista con un subconjunto de elementos de la original\r
\r
### F.1. Subcolecciones usando bucles\r
\r
Para obtener los elementos podemos aplicar lo aprendido en el anterior punto. Buscaremos elemento a elemento y, cuando se cumpla una condición especificada, añadiremos los elementos encontrados a una nueva colección.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas = new ArrayList<>();\r
  for (Persona p : grupoPersonas) {\r
    if (p.getNombre().startsWith("M")) {\r
      personas.add(p);\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
La idea es similar al punto anterior\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas2 = new ArrayList<>();\r
  grupoPersonas.forEach(p -> {\r
    if (p.getNombre().startsWith("M")) {\r
      personas2.add(p);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener directamente una subcolección mediante el filtrado, haciendo subconjuntos y guardando el resultado.\r
\r
Con API Stream podemos guardar el resultado usando diferentes formas de .collect, que darán como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // ArrayList de Personas cuyo nombre empieza por "M"\r
  ArrayList<Persona> personas3 = (ArrayList<Persona>) grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toList());\r
\r
  // Conjunto de Personas cuyo nombre empieza por "M"\r
  Set<Persona> personas4 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toSet());\r
  \r
  // Mapa de Personas cuyo nombre empieza por "M"\r
  // En la construcción del mapa, hay que elegir un campo que sirva de clave\r
  Map<String, Persona> personas5 = grupoPersonas.stream()\r
          .filter(p -> p.getNombre().startsWith("M"))\r
          .collect(Collectors.toMap(Persona::getApellidos, Function.identity()));\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenación de elementos\r
\r
### G.1. Ordenar usando métodos de Collection\r
\r
Si lo que queremos es tener el conjunto ordenados, la forma más fácil es ordenarla usando el método sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Ordena según el método compareTo sobrescrito al implementar el interfaz Comparable\r
  // Si no se ha implementado, ordena según el orden natural\r
  Collections.sort(grupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(grupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su método \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos más adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.2. Ordenar con expresiones lambda\r
\r
De esta forma no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparación que queremos hacer como parámetro del método sort.\r
\r
Así podemos tener distintas formas de ordenar, según nos convenga.\r
\r
\`\`\`java:no-line-numbers\r
  // Indicamos la comparación que queremos hacer. Podemos usar compareTo \r
  Collections.sort(grupoPersonas, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(grupoPersonas);      \r
\r
  // o bien podemos definir nuestro propio comparador\r
  Collections.sort(grupoPersonas, (p1, p2) -> {\r
    String nombreCompleto1 = p1.getApellidos() + ", " + p1.getNombre();\r
    String nombreCompleto2 = p2.getApellidos() + ", " + p2.getNombre();\r
    return nombreCompleto1.compareTo(nombreCompleto2);\r
});\r
\`\`\`\r
\r
### G.3. Ordenar con API Stream\r
\r
Con API Stream usamos también el método sorted para indicar qué comparación se debe realizar. Tenemos varias opciones en función del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el más flexible es aquel en el que indicamos, mediante una expresión lambda, qué comparación realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en una nueva lista con los elementos ordenados\r
  ArrayList<Persona> grupoPersonasOrdenado = (ArrayList<Persona>) grupoPersonas.stream()\r
          // En este caso ordenamos por apellido, ascendente.\r
          .sorted((p1, p2) -> p1.getApellidos().compareTo(p2.getApellidos()))\r
          // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
          //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
          .collect(Collectors.toList());\r
\`\`\`\r
\r
::: info Encadenar métodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolección con los resultados.\r
\r
Es lo más parecido que vamos a encontrar a una consulta SQL para los datos de una colección cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantáneas, sin lugar a bugs, con muy poco código.\r
:::\r
`]},{title:"3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans",headers:[],path:"/es/unit3/debugger_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans" />\r
\r
# 3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans\r
\r
Los entornos de desarrollo Java proporcionan las herramientas necesarias para la depuración (debugging) de aplicaciones multihilo.\r
\r
Al igual que en aplicaciones monohilo, podemos ubicar los breakpoints en el punto en el que nos interese detener la ejecución del programa, para de esta forma poder inspeccionar el estado de los objetos, los valores de las propiedades, etc.\r
\r
Para poder monitorizar los hilos de un programa, debemos activar la ventana de Debugging desde el menu *Window > Debugging > Debugging (Alt+Shift +9)*\r
\r
![Activar thread debug](../../media/unit3/NetbeansDebug1.jpg)\r
\r
A partir de ese momento podremos ver la parte derecha las opciones de depuración de hilos junto con toda la información de los hilos que se están ejecutando en nuestra aplicación.\r
\r
Veamos el significado de lo que Netbeans nos muestra en esta caja de diálogo\r
\r
![Diálogo depuración threads](../../media/unit3/NetbeansDebug2.jpg)\r
\r
- Con una franja de color verde a la izquierda y resaltado también en color verde vemos lo que Netbeans denomina el *current thread*, es decir, el hilo que estamos depurando y sobre el que se aplicarán las acciones de depuración como Step Into, StepOver, Pause, Continue, etc. Además, podremos inspeccionar el valor de las variables para ese hilo en concreto.\r
- Con una franja de color amarillo en la parte izquierda, y relacionado con el aviso de la parte inferior, vemos los hilos que están parados en algún breakpoint marcado por nosotros. Este color y los avisos están para que atendamos al hilo y podamos visualizar su estado o continuar con su ejecución.\r
- En la parte derecha de cada hilo tenemos un acceso rápido a la función de Reanudar o Pausar cada uno de los threads activos.\r
  \r
![Cambio de hilo](../../media/unit3/NetbeansDebug3.jpg)\r
\r
Pulsando con el botón derecho sobre cualquiera de los hilos podemos convertirlo en el *current thread*. Así pasamos a controlar la ejecución e inspección de ese hilo mientras los demás siguen pausados o bien continuan su ejecución.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug4.jpg)\r
\r
Además, la rueda dentada que está al lado del identificador de cada hilo nos dá información del estado del hilo.\r
\r
- Cuando la rueda está de color naranja indica que el hilo está suspendido en espera de nuestra atención.\r
- Cuando la rueda está verde, indica que el hilo está en ejecución. Si ponemos el ratón encima podemos obtener información de su estado. Como se puede observar en la imagen, el hilo 2 está en ejecución aunque se encuentra en estado de espera. Es un hilo que está bloqueado en un join.\r
\r
![Estado de los hilos](../../media/unit3/NetbeansDebug5.jpg)\r
\r
Por último, la depuración de hilos también nos ayuda a detectar cómo los hilos están sincronizándose con el uso de monitores. Podemos ver si un hilo tiene un monitor (bloqueo) bajo su control, y qué hilos están esperando a que se libere un bloqueo para poder continuar.\r
\r
Como herramienta adicional, Netbeans nos proporciona una utilidad (*Debug > Check for deadlocks*) que comprueba si hay hilos que estén en un interbloqueo, informándonos de los monitores que tienen bajo su control y de los monitores para los que están realizando alguna espera.\r
`]},{title:"3.7 Anexo III - HashMap hoja de referencia de los alumnos",headers:[{level:2,title:"A. Definición y creación",slug:"a-definicion-y-creacion",link:"#a-definicion-y-creacion",children:[{level:3,title:"A.1. Constructores de HashMap",slug:"a-1-constructores-de-hashmap",link:"#a-1-constructores-de-hashmap",children:[]}]},{level:2,title:"B. Métodos y propiedades generales",slug:"b-metodos-y-propiedades-generales",link:"#b-metodos-y-propiedades-generales",children:[{level:3,title:"B.1. Creación de un HashMap",slug:"b-1-creacion-de-un-hashmap",link:"#b-1-creacion-de-un-hashmap",children:[]},{level:3,title:"B.2. Añadir y eliminar elementos",slug:"b-2-anadir-y-eliminar-elementos",link:"#b-2-anadir-y-eliminar-elementos",children:[]},{level:3,title:"B.3. Comprobar si una clave o un valor existen",slug:"b-3-comprobar-si-una-clave-o-un-valor-existen",link:"#b-3-comprobar-si-una-clave-o-un-valor-existen",children:[]},{level:3,title:"B.4. Acceder a las partes del mapa",slug:"b-4-acceder-a-las-partes-del-mapa",link:"#b-4-acceder-a-las-partes-del-mapa",children:[]},{level:3,title:"B.5. Acceder a un elemento del mapa",slug:"b-5-acceder-a-un-elemento-del-mapa",link:"#b-5-acceder-a-un-elemento-del-mapa",children:[]},{level:3,title:"B.6. Otras funciones de utilidad",slug:"b-6-otras-funciones-de-utilidad",link:"#b-6-otras-funciones-de-utilidad",children:[]}]},{level:2,title:"C. Añadir datos a un HashMap",slug:"c-anadir-datos-a-un-hashmap",link:"#c-anadir-datos-a-un-hashmap",children:[{level:3,title:"C.1. Añadir elementos desde el constructor",slug:"c-1-anadir-elementos-desde-el-constructor",link:"#c-1-anadir-elementos-desde-el-constructor",children:[]},{level:3,title:"C.2. Añadir elementos desde otras colecciones",slug:"c-2-anadir-elementos-desde-otras-colecciones",link:"#c-2-anadir-elementos-desde-otras-colecciones",children:[]},{level:3,title:"C.3. Añadir / eliminar elementos desde código",slug:"c-3-anadir-eliminar-elementos-desde-codigo",link:"#c-3-anadir-eliminar-elementos-desde-codigo",children:[]}]},{level:2,title:"D. Recorrer la colección",slug:"d-recorrer-la-coleccion",link:"#d-recorrer-la-coleccion",children:[{level:3,title:"D.1. Usando un bucle for",slug:"d-1-usando-un-bucle-for",link:"#d-1-usando-un-bucle-for",children:[]},{level:3,title:"D.2. Usando un bucle foreach de Java",slug:"d-2-usando-un-bucle-foreach-de-java",link:"#d-2-usando-un-bucle-foreach-de-java",children:[]},{level:3,title:"D.3. Usando Iterator",slug:"d-3-usando-iterator",link:"#d-3-usando-iterator",children:[]},{level:3,title:"D.4. Usando el método forEach con expresiones lambda",slug:"d-4-usando-el-metodo-foreach-con-expresiones-lambda",link:"#d-4-usando-el-metodo-foreach-con-expresiones-lambda",children:[]},{level:3,title:"D.5 Eliminando / Modificando elementos mientras se itera sobre la colección",slug:"d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",link:"#d-5-eliminando-modificando-elementos-mientras-se-itera-sobre-la-coleccion",children:[]}]},{level:2,title:"E. Búsqueda de elementos",slug:"e-busqueda-de-elementos",link:"#e-busqueda-de-elementos",children:[{level:3,title:"E.1. Búsqueda por clave o usando los métodos de la clase",slug:"e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",link:"#e-1-busqueda-por-clave-o-usando-los-metodos-de-la-clase",children:[]},{level:3,title:"E.2. Búsqueda por el valor de una propiedad",slug:"e-2-busqueda-por-el-valor-de-una-propiedad",link:"#e-2-busqueda-por-el-valor-de-una-propiedad",children:[]},{level:3,title:"E.3. Búsqueda usando expresiones lambda",slug:"e-3-busqueda-usando-expresiones-lambda",link:"#e-3-busqueda-usando-expresiones-lambda",children:[]},{level:3,title:"E.4. Búsqueda usando API Stream",slug:"e-4-busqueda-usando-api-stream",link:"#e-4-busqueda-usando-api-stream",children:[]}]},{level:2,title:"F. Obtención de subcolecciones",slug:"f-obtencion-de-subcolecciones",link:"#f-obtencion-de-subcolecciones",children:[{level:3,title:"F.1. Subcolecciones usando bucles",slug:"f-1-subcolecciones-usando-bucles",link:"#f-1-subcolecciones-usando-bucles",children:[]},{level:3,title:"F.2. Subcolecciones usando expresiones lambda",slug:"f-2-subcolecciones-usando-expresiones-lambda",link:"#f-2-subcolecciones-usando-expresiones-lambda",children:[]},{level:3,title:"F.3. Subcolecciones usando API Stream",slug:"f-3-subcolecciones-usando-api-stream",link:"#f-3-subcolecciones-usando-api-stream",children:[]}]},{level:2,title:"G. Ordenación de elementos",slug:"g-ordenacion-de-elementos",link:"#g-ordenacion-de-elementos",children:[{level:3,title:"G.1. Ordenar por clave",slug:"g-1-ordenar-por-clave",link:"#g-1-ordenar-por-clave",children:[]},{level:3,title:"G.2. Ordenar usando métodos de Collection",slug:"g-2-ordenar-usando-metodos-de-collection",link:"#g-2-ordenar-usando-metodos-de-collection",children:[]},{level:3,title:"G.3. Ordenar con expresiones lambda",slug:"g-3-ordenar-con-expresiones-lambda",link:"#g-3-ordenar-con-expresiones-lambda",children:[]},{level:3,title:"G.4. Ordenar con API Stream",slug:"g-4-ordenar-con-api-stream",link:"#g-4-ordenar-con-api-stream",children:[]}]}],path:"/es/unit3/hashmap_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.7 Anexo III - HashMap hoja de referencia de los alumnos\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.7 Anexo III - HashMap hoja de referencia de los alumnos" />\r
\r
# 3.7 Anexo III - HashMap hoja de referencia de los alumnos\r
\r
::: info Autoría\r
Esto es un extracto del trabajo *Reto I (Challenge I)* realizado por mis alumnos como parte del módulo de PSP.\r
He tomado partes de los diferentes trabajos entregados para complementar la información a la que podréis acceder durante los exámenes.\r
\r
Gracias a todos.\r
:::\r
\r
Para los ejemplos vamos a trabajar con la siguiente clase\r
\r
![Diagrama de clases](../../media/unit3/Collections_class_diagram.png)\r
\r
<!--\r
\`\`\`puml\r
class Persona {\r
  - String nombre\r
  - String apellidos\r
  - int edad\r
  - double altura\r
  - int peso\r
  - String genero\r
  + Persona(String nombre, String apellidos, int edad, double altura, int peso, String genero)\r
  + String getNombre()\r
  + void setNombre(String nombre)\r
  + String getApellidos()\r
  + void setApellidos(String nombre)\r
  + int getEdad()\r
  + void setEdad(int edad)\r
  + double getAltura()\r
  + void setAltura(double altura)\r
  + int getPeso()\r
  + void setPeso(int peso)\r
  + String getGenero()\r
  + void setGenero(String genero)\r
}\r
\`\`\`\r
-->\r
\r
<div class="pagebreak"></div>\r
\r
## A. Definición y creación\r
\r
Una colección representa un grupo de objetos. Esto objetos son conocidos como elementos. Cuando queremos trabajar con un conjunto de elementos, necesitamos un almacén donde poder guardarlos. En Java, se emplea la interfaz genérica \`Collection\` para este propósito. Gracias a esta interfaz, podemos almacenar cualquier tipo de objeto y podemos usar una serie de métodos comunes, como pueden ser: añadir, eliminar, obtener el tamaño de la colección.\r
\r
Partiendo de la interfaz genérica Collection extienden otra serie de interfaces genéricas. Estas subinterfaces aportan distintas funcionalidades sobre la interfaz anterior.\r
\r
Un HashMap básicamente designa claves únicas para los valores correspondientes que se pueden recuperar en cualquier punto dado, es decir, nos permite almacenar elementos asociando a cada clave un valor.\r
\r
Para cada clave tenemos un valor asociado. Podemos después buscar fácilmente un valor para una determinada clave. Las claves en el diccionario no pueden repetirse.\r
\r
### A.1. Constructores de HashMap\r
\r
HashMap proporciona 4 constructores que definen la capacidad inicial de la colección y en qué momento debe redimensionarse. Son parámetros para mejorar el rendimiento en el uso del HashMap.\r
\r
\`\`\`java:no-line-numbers\r
// Crea una instancia de HashMap con una capacidad inicial de 16 y un factor de carga de 0,75.\r
HashMap<Integer, String> hm1 = new HashMap<>(); \r
\r
// HashMap(int initialCapacity). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga de 0,75. \r
HashMap<Integer, String> hm1 = new HashMap<>(10); \r
\r
// HashMap(int initialCapacity, float loadFactor). Crea una instancia de HashMap con una capacidad inicial especificada y un factor de carga especificados. \r
HashMap<Integer, String> hm1 = new HashMap<>(5, 0.75f); \r
\r
//HashMap(Mapa de mapas) . Crea una instancia de HashMap con las mismas asignaciones que el mapa especificado. \r
HashMap<Integer, String> hm1 = new HashMap<>();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## B. Métodos y propiedades generales\r
\r
Partiendo de una serie de objetos, vamos a ver el resultado que obtendríamos con la ejecución de estos métodos\r
\r
\`\`\`java:no-line-numbers\r
  Persona p1 = new Persona("Manuel", "García", 44, 1.74d, 80, "Hombre");\r
  Persona p2 = new Persona("Juan", "Martínez", 65, 1.84d, 82, "Hombre");\r
\`\`\`\r
\r
### B.1. Creación de un HashMap\r
\r
\`\`\`java:no-line-numbers\r
  // Crear un HashMap con claves de tipo String y valores de tipo Persona\r
  HashMap<String,Persona> DNIs = new HashMap<>();\r
\`\`\`\r
\r
### B.2. Añadir y eliminar elementos\r
\r
\`\`\`java:no-line-numbers\r
  // Element.put(k,v) - Añade un par clave-valor al mapa.\r
  DNIs.put("390543M",p);\r
  // Element.remove(Object key) - Removes the key and his value.\r
  DNIs.remove("298423Z");// Will remove (“390543M”, p1) from the map.\r
\`\`\`\r
\r
::: warning Clave ya existente\r
Si ya existe un elemento con la misma clave en el mapa, el método put reemplaza el valor existente por el nuevo.\r
Podemos evitarlo comprobando previamente si ya existe esa clave o con el método **DNIs.putIfAbsent(k,v)**.\r
:::\r
\r
### B.3. Comprobar si una clave o un valor existen\r
\r
\`\`\`java:no-line-numbers\r
  // Element.containsKey(Key) – Comprueba si existe la clave dada\r
  DNIs.containsKey("390543M");\r
  // Element.containsValue(Value) – Comprueba si existe el valor dado asociado a alguna clave\r
  DNIs.containsValue(p2);\r
\`\`\`\r
\r
### B.4. Acceder a las partes del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.keySet() - Obtiene el conjunto de claves del mapa\r
  Set<String> claves = DNIs.keySet();\r
  // Element.values() - Obtiene el conjunto de valores almacenados en el mapa\r
  Collection<Persona> valores = DNIs.values();\r
  // Element.entrySet() - Obtiene el conjunto de pares clave-valor del mapa\r
  Set<Entry<String,Persona>> tuplas = DNIs.entrySet();\r
\`\`\`\r
\r
### B.5. Acceder a un elemento del mapa\r
\r
\`\`\`java:no-line-numbers\r
  // Element.get(Key) - Obtiene el valor asociado a la clave\r
  Persona p = DNIs.get("390543")\r
\`\`\`\r
\r
### B.6. Otras funciones de utilidad\r
\r
\`\`\`java:no-line-numbers\r
  // Element.size() - Devuelve el número de elementos en el mapa\r
  int size = DNIs.size();\r
  //Element.clear() - Elimina todas las asignaciones y vacía el mapa\r
  DNIs.clear();\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## C. Añadir datos a un HashMap\r
\r
::: info Orden de los elementos en el HashMap\r
Cuando añadimos elementos a una HashMap, el orden de inserción no se conserva. Internamente, para cada elemento, se genera un hash separado y los elementos se indexan en función de este hash para hacerlo más eficiente. Antes de añadir un elemento, como se ha avisado antes, es recomendable comprobar si ya existe para no sustituirlo\r
:::\r
\r
### C.1. Añadir elementos desde el constructor\r
\r
A la hora de crear el Hashmap, podemos añadirle datos, usando la sintaxis del doble corchete o bien con la construcción Map.of\r
\r
\`\`\`java:no-line-numbers\r
  // Crea un nuevo mapa y a la vez lo inicializa con valores  \r
  HashMap<String, Persona> map1 = new HashMap<>() {{\r
    put("390543M", p1);\r
    put("298423Z", p2);\r
  }};\r
  // En este caso indicamos los pares clave valor como si de un array se tratase\r
  // De esta forma podemos añadir hasta un máximo de 10 elementos\r
  HashMap<String, Persona> map2 = new HashMap<>(\r
    Map.of("390543M", p1, "298423Z", p2)\r
  );\r
\`\`\`\r
\r
### C.2. Añadir elementos desde otras colecciones\r
\r
Al ser una colección compuesta por una clave y un valor, la inicialización se limita a los tipos de colecciones que tienen una estructura similar.\r
\r
\`\`\`java:no-line-numbers\r
  // Partiendo del código anterior, creamos un nuevo mapa a partir de map2\r
  HashMap<String, Persona> map3 = new HashMap<>(map2);\r
  // O bien copiando todos los pares clave-valor\r
  map3.putAll(map2);  \r
\`\`\`\r
\r
### C.3. Añadir / eliminar elementos desde código\r
\r
\`\`\`java:no-line-numbers\r
  // Añadir y si existe la clave reemplazarlo\r
  DNIs.put("390543M", p1);\r
  // Añadir sólo si la clave no existe\r
  DNIs.putIfAbsent("390543M", p1);\r
  // Eliminar un elemento. Si la clave existe devuelve el valor asociado, si no devuelve null\r
  Persona eliminada = map3.remove("390543M");  \r
  // Eliminar un par clave-valor. Si existe la tupla, la elimina y devuelve true, si no devuelve false\r
  boolean existe = map3.remove("390543M", p1);  \r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## D. Recorrer la colección\r
\r
Vamos a preparar un HashMap para recorrerlo y usarlo en los siguientes apartados\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap creation\r
  HashMap<String, Persona> grupoPersonas = new HashMap<>() {{\r
          put("12345678A", new Persona("Nombre1", "Apellido1", 35, 1.66d, 71, "Mujer"));\r
          put("23456789B", new Persona("Nombre2", "Apellido2", 40, 1.84d, 88, "Mujer"));\r
          put("34567890C", new Persona("Nombre3", "Apellido3", 52, 1.70d, 66, "Hombre"));\r
          put("45678901D", new Persona("Nombre4", "Apellido4", 23, 1.96d, 98, "Mujer"));\r
          put("56789012E", new Persona("Nombre5", "Apellido5", 16, 1.55d, 60, "Hombre"));\r
          put("67890123F", new Persona("Nombre6", "Apellido6", 20, 1.75d, 74, "Hombre"));\r
  }};\r
\`\`\`\r
\r
::: info Tipos de valores\r
Vamos a mostrar ejemplos de cómo recorrer cada uno de los elementos que componen el HashMap, claves, valores y pares clave-valor.\r
\r
.entrySet() - devuelve el conjunto de pares clave-valor\r
\r
.keySet() - devuelve el conjunto de claves\r
\r
.values() - devuelve la colección de valores\r
:::\r
\r
### D.1. Usando un bucle for\r
\r
Con el bucle for iteramos de forma natural accediendo a los elementos por índice, por lo que vamos a necesitar una forma de obtener el índice (i) de cada elemento para recorrer el HashMap.\r
\r
En este caso, vamos a usar el índice de la clave, a través del método toArray.\r
\r
::: warning Orden de los elementos en el HashMap\r
Es importante recordar y tener en cuenta que los elementos en un HashMap se ordenan automáticamente en base a una función Hash (resumen) que permite realizar una búsqueda muy rápida sobre la clave. Por lo tanto, no podemos esperar que el recorrido por índice coincida con el orden en el que los elementos se añaden al mapa.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    System.out.println(grupoPersonas.get(map.keySet().toArray()[i]));\r
  }\r
\`\`\`\r
\r
### D.2. Usando un bucle foreach de Java\r
\r
Otra forma de recorrer el HashMap es con un bucle similar al foreach de C#, aunque con el formato de un bucle for, pero en este caso indicando for(elemento : colección)\r
\r
\`\`\`java:no-line-numbers\r
  // Recorremos la estructura obteniendo la tupla (k,v) en cada iteración\r
  for (Map.Entry<String, Persona> entry : grupoPersonas.entrySet()) {\r
        System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());\r
  }\r
\`\`\`\r
\r
o bien para ir mostrando las claves\r
\r
\`\`\`java:no-line-numbers\r
  for (String key : grupoPersonas.keySet()) {\r
    System.out.println("DNI = " + key);\r
  }\r
\`\`\`\r
\r
o los valores\r
\r
\`\`\`java:no-line-numbers\r
  for (Person value : grupoPersonas.values()) {\r
    System.out.println("Value = " + value);\r
\`\`\`\r
\r
### D.3. Usando Iterator\r
\r
El interface Iterator de Java permite movernos por una colección y acceder a sus elementos\r
\r
::: info java.lang.Iterator\r
Todas las colecciones de Java incluyen un método iterator() que devuelve una instancia de Iterator para recorrer la colección.\r
\r
Iterator tiene 4 métodos:\r
\r
- **hasNext()** - devuelve true si hay un elemento más en la lista\r
- **next()** - devuelve el siguiente elemento de la lista\r
- **remove()** - elimina el último elemento de la lista que hemos obtenido con next()\r
- **forEachRemaining()** - realiza la acción indicada con cada uno de los elementos que quedan por recorrer de la lista\r
:::\r
\r
Vamos a ver un ejemplo con los valores de la colección\r
\r
\`\`\`java:no-line-numbers\r
  Iterator<Persona> iterator = grupoPersonas.values().iterator();  \r
  while (iterator.hasNext()) {\r
    System.out.println(iterator.next());\r
}\r
\`\`\`\r
\r
### D.4. Usando el método forEach con expresiones lambda\r
\r
En este caso aprovechamos el método foreach de las colecciones para poder realizar una acción concreta sobre cada uno de los elementos de la misma\r
\r
\`\`\`java:no-line-numbers\r
  // Pares (clave,valor)\r
  grupoPersonas.forEach((k,v) -> System.out.println("Clave: " + k + ", Values: " + v));\r
  // Claves\r
  grupoPersonas.keySet().forEach(k -> System.out.println("Clave: " + k));\r
  // Valores\r
  grupoPersonas.values().forEach(v -> System.out.println("Values: " + v));\r
\`\`\`\r
\r
### D.5 Eliminando / Modificando elementos mientras se itera sobre la colección\r
\r
Mientras se está recorriendo una colección, no con todos los tipos de bucles se puede modificar (añadir/eliminar elementos) de la colección. Vamos a ver el comportamiento de cada uno de ellos.\r
\r
#### D.5.1 Con un bucle for\r
\r
En este caso no tendríamos problemas. Al acceder por índice, podemos añadir o eliminar elementos mientras se recorre la colección.\r
\r
\`\`\`java:no-line-numbers\r
  for (int i = 0; i < grupoPersonas.size(); i++) {\r
    if(grupoPersonas.keySet().toArray()[i].equals("23456789B")) {\r
      grupoPersonas.remove(grupoPersonas.entrySet().toArray()[i]);\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.2 Con un bucle foreach de Java\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  for (Map.Entry<String, Persona> p : grupoPersonas.entrySet()) {\r
    if (p.getKey().equals("34567890C")) {\r
      personas.remove(p.getKey());\r
    }\r
    System.out.println("Clave: " + p.getKey() + " Valor: " + p.getValue().toString());\r
}\r
\`\`\`\r
\r
#### D.5.3 Con Iterator\r
\r
Si usamos el método remove para eliminar elementos de la colección mientras la recorremos, podremos hacerlo sin que se genere ninguna excepción.\r
\r
\`\`\`java:no-line-numbers{5}\r
  Iterator<Entry<String, Persona>> iterator = grupoPersonas.entrySet().iterator();\r
  while (iterator .hasNext()) {\r
    Map.Entry<String, Persona> p = (Map.Entry<String, Persona>) iterator.next();\r
    if (p.getKey().equals("12345678A")) {\r
      // Si borramos usando iterator.remove o el método remove(key) de HashMap, funciona\r
      iterator.remove();\r
    }\r
  }\r
\`\`\`\r
\r
#### D.5.4 Con el método forEach y expresiones lambda\r
\r
::: danger No modificable mientras se recorre\r
Si intentamos eliminar un elemento mientras lo recorremos con foreach, provocaremos una \`java.util.ConcurrentModificationException\`.\r
Por lo tanto, sólo debemos usar este bucle si queremos leer sus elementos sin modificar la estructura de la colección.\r
:::\r
\r
\`\`\`java:no-line-numbers\r
  // Elimina si encuentra un elemento concreto\r
  grupoPersonas.keySet().forEach((k) -> {if (k.equals("34567890C")) grupoPersonas.remove(k);});\r
\`\`\`\r
\r
Otra cosa es que intentemos hacer cambios en los valores de la colección, por ejemplo, intercambiar los apellidos\r
\r
\`\`\`java:no-line-numbers\r
  // Intercambia los apellidos de todas las personas\r
  grupoPersonas.values().forEach((p) -> {\r
      String aux = p.getApellidos();\r
      p.setApellidos(p.getNombre());\r
      p.setNombre(aux);                \r
    }\r
  );\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## E. Búsqueda de elementos\r
\r
Para buscar elementos en un HashMap hay distintas formas de hacerlo. Desde los propios métodos que nos ofrece la clase hasta el uso de API Stream. Vamos a describir cada uno de ellos\r
\r
### E.1. Búsqueda por clave o usando los métodos de la clase\r
\r
La clase HashMap nos ofrece diferentes alternativas para buscar y/o saber si un elemento está presente en la colección. Así, podemos usar los métodos\r
\r
\`\`\`java:no-line-numbers\r
  // A partir de una clave, obtener el valor\r
  grupoPersonas.get("34567890C");\r
  // O simplemente comprobar si existe esa clave o ese valor antes de buscarlo\r
  grupoPersonas.containsKey("34567890C");\r
  grupoPersonas.containsValue(person);\r
\`\`\`\r
\r
### E.2. Búsqueda por el valor de una propiedad\r
\r
A diferencia del caso anterior, si queremos buscar un objeto que contenga un valor concreto en un campo, debemos recorrer la colección hasta encontrarlo. Para eso, una de las alternativas es usar alguno de los bucles vistos anteriormente.\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
  Iterator<Map.Entry<String, Persona>> it = grupoPersonas.entrySet().iterator();\r
  while (it.hasNext()) {\r
    Map.Entry<String, Persona> entry = it.next();\r
    if (((Persona)entry.getValue()).getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + entry.getKey() + ", Value: " +\r
      entry.getValue());\r
    break;\r
    }\r
  }\r
\`\`\`\r
\r
### E.3. Búsqueda usando expresiones lambda\r
\r
Mediante expresiones lambda, podemos incluir una condicional que nos haga el filtrado de elementos que deseemos\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
  grupoPersonas.forEach((k, v) -> {\r
    if (v.getNombre().equals("Jorge")) {\r
      // Se puede obtener el elemento o bien modificarlo\r
      System.out.println("Key: " + k + ", Value: " + v);\r
    }\r
  });\r
  \`\`\`\r
\r
### E.4. Búsqueda usando API Stream\r
\r
En este tipo de acciones es donde ya podemos empezar a ver la potencia que ofrece el API Stream para el manejo y gestión de las colecciones.\r
Podemos emplear varios métodos, como filter, findAny, findFirst, allMatch, anyMatch, count, distinct. Como veremos en el siguiente apartado, esos resultados los podemos guardar en forma de subcolección\r
\r
\`\`\`java:no-line-numbers\r
  // Puede haber más de un elemento que cumpla el criterio de búsqueda\r
\r
  // Obtener un submapa con los elementos que cumplan el criterio\r
  grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("abc"))\r
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // O bien recorrer la lista de entradas obtenidas\r
  for (Entry<String, Persona> p : grupoPersonas.entrySet().stream()\r
      .filter(k -> k.getKey().equals("abc"))\r
      .collect(Collectors.toList())) {\r
          System.out.println(p.getValue());   // Sacamos el valor de la tupla <clave,valor>\r
  }\r
\r
  for (Persona p : grupoPersonas.entrySet().stream()\r
      .filter((k) -> k.getKey().equals("98761234D"))\r
      .map(Map.Entry::getValue)         // Cogemos sólo los valores del entryMap\r
      .collect(Collectors.toList())) {\r
          System.out.println(p);        // Muestra solo la persona\r
  }\r
\r
  // Saber cuántos cumplen el criterio de búsqueda\r
  grupoPersonas.entrySet().stream().filter(k -> k.getKey().equals("abc")).count();\r
\r
  // Obtener el primero que cumpla el criterio, si es que hay alguno\r
  Optional<Entry<String,Persona>> s = grupoPersonas.entrySet().stream()\r
    .filter(k -> k.getKey().equals("6780123F"))\r
    .findFirst();\r
  \`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## F. Obtención de subcolecciones\r
\r
Lo podemos considerar un tipo especial de búsqueda en el que el objetivo es conseguir una colección con los elementos que cumplan un determinado criterio.\r
\r
Así, la forma de buscar es idéntica a la del apartado anterior, pero en este caso lo que obtendremos de esa búsqueda será un nuevo tipo de colección, no necesariamente otro HashMap.\r
\r
### F.1. Subcolecciones usando bucles\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String,Persona> personas2 = new HashMap<String,Persona>();\r
  for (Entry<String, Persona> e : grupoPersonas.entrySet()) {\r
    if(e.getKey().endsWith("F")) {\r
      personas2.put(e.getKey(), e.getValue());\r
    }\r
  }\r
\`\`\`\r
\r
### F.2. Subcolecciones usando expresiones lambda\r
\r
En este ejemplo obtenemos un nuevo HashMap, pero también podríamos guardar la información en un ArrayList o en cualquier otro tipo de estructura.\r
\r
\`\`\`java:no-line-numbers\r
  // Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas2 = new HashMap<String, Persona>();\r
  grupoPersonas.forEach((k, v) -> {\r
    if (k.endsWith("F")) {\r
      grupoPersonas2.put(k, v);\r
    }\r
  });\r
\`\`\`\r
\r
### F.3. Subcolecciones usando API Stream\r
\r
Podemos obtener diferentes tipos de subcolecciones. Con API Stream podemos filtrar, hacer subconjuntos y guardar el resultado usando diferentes formas de .collect, que darán como resultados distintos tipos de colecciones.\r
\r
\`\`\`java:no-line-numbers\r
  // HashMap de Personas cuyo DNI acaba en "F"\r
  HashMap<String, Persona> grupoPersonas3 = (HashMap<String, Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\r
\r
  // Lista de Personas cuyo DNI acaba en "F"\r
  List<Persona> listaPersonas3 = (List<Persona>) grupoPersonas.entrySet().stream()\r
      .filter(x -> x.getKey().endsWith("F"))\r
      .collect(Collectors.toList());\r
\`\`\`\r
\r
<div class="pagebreak"></div>\r
\r
## G. Ordenación de elementos\r
\r
::: danger HashMap no garantiza el orden de los elementos\r
Como ya hemos comentado anteriormente, un HashMap es una estructura de datos en la que el orden de los elementos no está garantizado. Es por eso que si queremos mantener una copia ordenada de los elementos, deberemos recurrir a otros tipos de colecciones que sí garantizan el orden.\r
:::\r
\r
### G.1. Ordenar por clave\r
\r
Hay un tipo especial de map, TreeMap, en el que los elementos se ordenan siguiendo el orden natural de las claves. Por lo tanto es la opción ideal si queremos tener los elementos ordenados por clave.\r
\r
\`\`\`java:no-line-numbers\r
  // Así podemos recorrer el TreeMap y mostrar los elementos ordenados por clave\r
  TreeMap<String, Persona> grupoPersonasOrdenado = new TreeMap<>(grupoPersonas);\r
 \r
  Iterator it=grupoPersonasOrdenado.keySet().iterator();\r
  while(it.hasNext())\r
  {\r
    int key=(int)itr.next();\r
    System.out.println("Key: "+key+" Element: "+hashMap.get(key));\r
  }\r
\`\`\`\r
\r
### G.2. Ordenar usando métodos de Collection\r
\r
Si lo que queremos es tener el conjunto de claves o valores ordenados por separado, la forma más fácil es obtener una lista y ordenarla usando el método sort() de Collection.\r
\r
\`\`\`java:no-line-numbers\r
  // Para las claves\r
  List<String> clavesGrupoPersonas = new ArrayList<>(grupoPersonas.keySet());\r
  Collections.sort(clavesGrupoPersonas);\r
\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas = new ArrayList<>(grupoPersonas.values());\r
  // Ordena según el método compareTo sobrescrito al implementar el interfaz Comparable\r
  Collections.sort(valoresGrupoPersonas);\r
  // Ordena por un campo cualquiera que indiquemos\r
  Collections.sort(valoresGrupoPersonas, Comparator.comparing(Persona::getApellidos));\r
  // Con Comparator tenemos disponibles varios comparadores (naturalOrder, reverseOrder, nullsFirst, ....)\r
\`\`\`\r
\r
::: info Interfaz Comparable\r
Para que la primera forma de sort funcione, la clase Persona debe implementar el interfaz Comparable y sobrescribir su método \`compareTo\` para definir la forma de ordenar los objetos de tipo Persona.\r
\r
Veremos más adelante que tenemos formas de definir el comparador usando expresiones lambda o APi Stream, permitiendo mayor flexibilidad a la hora de comparar elementos.\r
\r
\`\`\`java:no-line-numbers\r
  // Un ejemplo, si queremos ordenar a las personas por edad\r
    @Override\r
    public int compareTo(Object o) {        \r
        return ((Integer)this.getEdad()).compareTo((Integer)((Persona)o).getEdad());\r
    }\r
\`\`\`\r
\r
:::\r
\r
### G.3. Ordenar con expresiones lambda\r
\r
Si usamos una lista, no es necesario implementar el interfaz Comparable, ya que podemos indicar la comparación que queremos hacer como parámetro del método sort\r
\r
\`\`\`java:no-line-numbers\r
  // Para los valores\r
  List<Persona> valoresGrupoPersonas2 = new ArrayList<>(grupoPersonas.values());\r
  // Indicamos la comparación que queremos hacer. Podemos usar compareTo o definir\r
  // nuestro propio comparador\r
  Collections.sort(valoresGrupoPersonas2, (e1, e2) -> ((Integer)e1.getEdad()).compareTo(e2.getEdad()));\r
  System.out.println(valoresGrupoPersonas2);      \r
\`\`\`\r
\r
### G.4. Ordenar con API Stream\r
\r
Con API Stream usamos también el método sorted para indicar qué comparación se debe realizar. Tenemos varias opciones en función del tipo de dato que pasemos.\r
\r
Como en el caso anterior, el más flexible es aquel en el que indicamos, mediante una expresión lambda qué comparación realizar.\r
\r
\`\`\`java\r
  // Guardamos el resultado en un LinkedHashMap que sí garantiza el orden\r
  Map<String, Persona> sortedMap = grupoPersonas.entrySet().stream()\r
      // En este caso ordenamos por apellido, ascendente.\r
      .sorted((e1, e2) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      // Si queremos hacerlo descendente, ponemos .sorted((e2,e1) -> ......\r
      //.sorted((e2, e1) -> e1.getValue().getApellidos().compareTo(e2.getValue().getApellidos()))\r
      .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\r
\`\`\`\r
\r
::: info Encadenar métodos\r
Al final, el uso de API Stream nos permite en una misma sentencia, buscar los elementos que queramos, ordenarlos y generar una subcolección con los resultados.\r
\r
Es lo más parecido que vamos a encontrar a una consulta SQL para los datos de una colección cualquiera.\r
\r
Aunque su sintaxis no es muy clara, si aprendemos a usarla correctamente, podremos realizar operaciones instantáneas, sin lugar a bugs, con muy poco código.\r
:::\r
`]},{title:"3 Introducción",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit3/",pathLocale:"/es/",extraFields:[`---\r
title: 3 Introducción\r
---\r
\r
# Tema 3. Programación multihilo\r
\r
Tras aprender los conceptos básicos de la programación concurrente y ver cómo los procesos pueden colaborar para conseguir multitarea, en este tema vamos a poner la mirada dentro de un proceso.\r
\r
La ejecución de un proceso comienza con un único hilo, pero se pueden crear más sobre la marcha. Los distintos hilos de un mismo proceso comparten:\r
\r
- El espacio de memoria asignado al proceso\r
- La información de acceso a ficheros (incluyendo stdin, stdout y stderr).\r
\r
Las características anteriores son las que los diferencias de los procesos. En cambio, cada hilo tiene sus propios valores para\r
\r
- Los registros del procesador\r
- El estado de su pila (stack), donde entre otras cosas se almacenan las variables locales.\r
  \r
Por lo tanto, vamos a utilizar los threads para realizar programación concurrente y/o paralela dentro de un proceso.\r
\r
Aunque los hilos se ejecutan en el contexto de un procesos, cada uno tiene su TCB (Tread Control Block) que es sensiblemente más pequeños que el PCB (Process Control Block) porque entre los hilos comparten gran parte de ese PCB. Por eso veremos que a los hilos también se le llama \`lightweight processes\` (procesos ligeros) y por tanto los cambios de contexto en el procesador son mucho menos costosos para los hilos que para los procesos.\r
\r
::: warning Hilos: comunicación vs sincronización \r
Por todo lo comentado, el intercambio de información entre hilos es sencillo, dado que los distintos hilos de un mismo proceso comparten la memoria asignada al proceso.\r
\r
Sin embargo, los hilos deben coordinarse para el acceso a los contenidos de la memoria y a los ficheros, lo cual hace que esa coordinación y sincronización sea la parte complicada de uso.\r
\r
De eso va este tema.\r
:::\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Conocer las técnicas básicas para desarrollar aplicaciones multihilo en Java\r
- Crear y lanzar varios hilos que compartan información\r
- Depurar aplicaciones multihilo\r
- Usar los métodos de sincronización para procesos y subprocesos\r
- Compartir información entre los hilos de un proceso\r
- Aprender acerca de los problemas de acceso a memoria compartida\r
- Usar diferentes técnicas de programación para sincronizar la ejecución de los threads.\r
`]},{title:"3.3 Modelo productor-consumidor",headers:[{level:2,title:"3.3.1. Esquema de sincronización y comunicación de hilos",slug:"_3-3-1-esquema-de-sincronizacion-y-comunicacion-de-hilos",link:"#_3-3-1-esquema-de-sincronizacion-y-comunicacion-de-hilos",children:[]},{level:2,title:"3.3.2 Clase Principal",slug:"_3-3-2-clase-principal",link:"#_3-3-2-clase-principal",children:[]},{level:2,title:"3.3.3 Clase Productor y Consumidor",slug:"_3-3-3-clase-productor-y-consumidor",link:"#_3-3-3-clase-productor-y-consumidor",children:[]},{level:2,title:"3.3.4 Clase Compartida. Sincronización de hilos",slug:"_3-3-4-clase-compartida-sincronizacion-de-hilos",link:"#_3-3-4-clase-compartida-sincronizacion-de-hilos",children:[]}],path:"/es/unit3/producer-consumer.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.3 Modelo productor-consumidor\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.3 Modelo productor-consumidor" />\r
\r
# 3.3 Modelo productor-consumidor\r
\r
[[toc]]\r
\r
## 3.3.1. Esquema de sincronización y comunicación de hilos\r
\r
La sincronización de threads implica disponer de mecanismos que permitan asegurar que no se producen situaciones de \`inanición o starvation\` (bloqueo de hilos como consecuencia del acceso a recursos compartidos limitados), \`interbloqueos\` (espera por parte de los hilos cuando una condición no puede ser satisfecha) y que, por lo tanto, se opera de forma correcta con los recursos compartidos por hilos concurrentes.\r
\r
En esta sección vamos a ejemplificar la compartición de recursos a través de un objeto contenedor (objeto compartido) mediante el famoso algoritmo del Productor-Consumidor que podemos ver resumido en [Wikipedia](https://es.wikipedia.org/wiki/Problema_productor-consumidor).\r
\r
Si no se implementasen medidas de control, ya hemos visto que podrían darse situaciones anómalas como:\r
\r
- El consumidor puede obtener los elementos producidos más de una vez, excediendo la producción del mismo (poder dejar la cuenta en números rojos en el ejemplo del banco, o que un lector pueda leer un libro antes de estar terminado).\r
- El productor sea más rápido que el Consumidor y genere más información de la que el sistema pueda almacenar, o bien parte de la información que genere se pierda sin que un Consumidor la haya recuperado.\r
- El Consumidor sea más rápido que el Productor y puede terminar consumiendo dos o más veces el mismo valor, generando información inconsistente en el sistema.\r
\r
Todas estas circunstancias son las que conocemos como condiciones de carrera o \`race conditions\`.\r
\r
El esquema de clases representado por este modelo se repite fielmente entre los diferentes ejercicios que vamos a realizar, es lo que denominamos el modelo Productor-Consumidor.\r
\r
![Producer-Consumer](./../../media/unit3/ProducerConsumer.png)\r
\r
Este modelo se basa en tres clases, aunque dependiendo del problema, podemos encontrarnos que no tenemos **productor** o **consumidor**.\r
\r
::: info Modelo como patrón de diseño\r
Es importante que nos ajustemos al esquema presentado en el modelo.\r
\r
Como ya se ha dicho, a veces no habrá productor, otras no estará el consumidor, en otras el código de bloqueo estará sólo en una de las clases, pero no debemos inventar ni añadir nada al esquema, debemos encajar el problema a solucionar dentro del código proporcionado.\r
:::\r
\r
## 3.3.2 Clase Principal\r
\r
> La clase principal siempre va a tener la misma estructura. El siguiente código se puede usar como plantilla\r
\r
En esta clase se declara el objeto o propiedad que van a compartir el productor y el consumidor. Este objeto es a través del que se realiza la comunicación, sincronización e intercambio de información entre los hilos.\r
\r
Aquí se representa como un objeto, aunque puede ser una Colección o cualquier estructura de datos que puedan compartir los hilos.\r
\r
\`\`\` java {4,5,6}\r
public class ClasePrincipal { \r
\r
    public static void main(String[] args) {    \r
        ClaseCompartida objetoCompartido = new ClaseCompartida();\r
        Productor productor  = new Productor(objetoCompartido);\r
        Consumidor consumidor  = new Consumidor(objetoCompartido);\r
        productor.start();\r
        consumidor.start();\r
\r
        // No es obligatorio, pero en ocasiones puede interesar que la ClasePrincipal\r
        // espere a que acaben los hilos\r
        productor.join();\r
        consumidor.join();\r
\r
        // Acciones a realizar una vez hayan acabado el productor y el consumidor\r
    }\r
    \r
}\r
\`\`\`\r
\r
::: warning Número de hilos por tipo\r
En el ejemplo se crea un hilo de cada tipo. Esto no tiene porqué ser así.\r
\r
Cada problema determinará el número de hilos *Productores* y *Consumidores* necesarios, por lo que será en este método main, o en algún otro método de la *ClasePrincipal* donde se realice la gestión de los hilos.\r
\r
De igual forma, dependerá de cada problema si el hilo principal debe esperar a que el resto finalice o no.\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.3 Clase Productor y Consumidor\r
\r
> Por otro lado vamos a tener la clase del **productor** y del **consumidor** que se encargan de realizar las llamadas necesarias a los métodos del objeto compartido que reciben como parámetro.\r
\r
Estas dos clases son las que van a tener, dentro del método **run**, la lógica de la aplicación, accediendo al objeto compartido, modificando las propiedades compartidas entre los diferentes hilos (productores y/o consumidores) y actualizando el estado del objeto compartido para que module su funcionalidad.\r
\r
\`\`\` java {2,5,15}\r
public class Consumidor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Consumidor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecución del método run estará normalmente gestionada por un bucle\r
        // que controlará el ciclo de vida del hilo y se adaptará al problema.\r
        // En el caso de simulaciones se harán esperas proporcionales.\r
        try {\r
            // Código que hace el hilo consumidor\r
            objetoCompartido.accionDeConsumir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
}    \r
\`\`\`\r
\r
\`\`\` java {2,5,15}\r
public class Productor extends Thread {\r
    private ClaseCompartida objetoCompartido;\r
    \r
    Productor(ClaseCompartida objetoCompartido) {\r
        this.objetoCompartido = objetoCompartido;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        // La ejecución del método run estará normalmente gestionada por un bucle\r
        // que controlará el ciclo de vida del hilo y se adaptará al problema.\r
        // En el caso de simulaciones se harán esperas proporcionales.\r
        try {\r
            // Código que hace el hilo productor\r
            objetoCompartido.accionDeProducir();\r
            // La espera es opcional\r
            Thread.sleep((long)(Math.random()*1000+1000));\r
        } catch (InterruptedException ex) {\r
\r
        }         \r
    }\r
} \r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 3.3.4 Clase Compartida. Sincronización de hilos\r
\r
 El modelo se completa con la clase compartida. Aquí vamos a crear los métodos a los que acceden productores y consumidores y, además, vamos a realizar la sincronización entre hilos para que no se produzcan \`condiciones de carrera\`.\r
\r
\`\`\` java {2,9,11,14,21,25,28,30,33,40,44}\r
public class ClaseCompartida {\r
    int valorAccedidoSimultaneamente;\r
    \r
    ClaseCompartida() {\r
        // Se inicializa el valor\r
        this.valorAccedidoSimultaneamente = 0;\r
    }\r
\r
    public synchronized void accionDeConsumir() {\r
        // Si no se cumple la condición para poder consumir, el consumidor debe esperar\r
        while (valorAccedidoSimultaneamente == 0) {\r
            try {\r
                System.out.println("Consumidor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizará la gestión de la Interrupción\r
            }\r
        }\r
                \r
        // Cuando se ha cumplido la condición para consumir, el consumidor consume\r
        valorAccedidoSimultaneamente--;\r
        System.out.printf("Se ha consumido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
    \r
    public synchronized void accionDeProducir () {\r
        // Si no se cumple la condición para poder producir, el productor debe esperar\r
        while (valorAccedidoSimultaneamente > 10) {\r
            try {\r
                System.out.println("Productor espera...");\r
                wait();\r
            } catch (InterruptedException ex) {\r
                // Si es necesario se realizará la gestión de la Interrupción                \r
            }\r
        }\r
        \r
        // Cuando se ha cumplido la condición para producir, el productor produce\r
        valorAccedidoSimultaneamente++;\r
        System.out.printf("Se ha producido: %d.\\n", valorAccedidoSimultaneamente);        \r
\r
        // Se activa a otros hilos que puedan estar en espera\r
        notifyAll();\r
    }\r
}\r
\`\`\`\r
\r
Lo interesante del código anterior, como ya hemos visto con anterioridad, es la pareja de métodos \`wait / notifyAll\`, junto con el modificador \`synchronized\`.\r
\r
- Cuando se llama a un método **synchronized** este método se ejecuta sí y solo sí no hay otro hilo ejecutando otro método **synchronized** \`del mismo objeto\`. Si se diese ese caso, el hilo se quedará en espera hasta que otro hilo libere el monitor. En ese momento todos los hilos que estén esperando se despiertan y sólo uno de ellos, el que consigue el monitor, puede ejecutar el código **synchronized" en exclusión mutua.\r
- Cuando se hace una llamada al método **wait**, un hilo se queda en espera y, además, libera el bloqueo del monitor. El hilo se quedará en espera hasta que otro hilo ejecute una llamada de señalización (**notify/notifyAll**).\r
- Cuando se hace una llamada al método **notify** o **notifyAll**, uno o todos los hilos que están en espera por haber hecho **wait** se despiertan y pasan a esperar poder tomar el control del bloqueo del **synchronized**. A partir de ese momento, de forma aleatoria, uno de ellos o de los que ya estaban en la cola del bloqueo **synchronized** toma el control y o bien empieza o bien sigue ejecutándose por donde se quedó (en caso de que hubiese llamado a **wait**).\r
  \r
> Con los métodos **wait**, **notify/notifyAll** y los bloques de código **synchronized** se consigue evitar que varios hilos puedan modificar a la vez una variable *(Ver líneas 21 y 40 del ejemplo anterior)*.\r
\r
::: info Resumen del modelo Productor-Consumidor\r
El modelo Productor-Consumidor original trabaja con un buffer en el que el Productor va depositando información y el Consumidor la va sacando, de forma que el buffer nunca se llene ni se pueda leer si está vacío.\r
\r
En nuestro ejemplo, lo hemos simplificado al uso de una variable que nunca puede exceder el valor de 10 ni ser inferior a 0.\r
\r
Como ya hemos dicho, esa variable puede ser cualquier tipo de dato, y el código de las clases variará en función de ello, para adaptarlo al problema y al control del tipo de dato utilizado.\r
\r
Además, las condiciones o estados que se utilizan para las esperas y las actualizaciones será lo que nosotros, como programadores, tengamos que adaptar al modelo para hacerlo funcionar en situaciones diferentes.\r
:::\r
`]},{title:"3.1. Clases Java para la gestión de hilos",headers:[{level:2,title:"3.1.1. El interfaz Runnable",slug:"_3-1-1-el-interfaz-runnable",link:"#_3-1-1-el-interfaz-runnable",children:[{level:3,title:"Clase Java que implementa la interfaz Runnable",slug:"clase-java-que-implementa-la-interfaz-runnable",link:"#clase-java-que-implementa-la-interfaz-runnable",children:[]},{level:3,title:"Implementación con clase anónima de la interfaz Runnable",slug:"implementacion-con-clase-anonima-de-la-interfaz-runnable",link:"#implementacion-con-clase-anonima-de-la-interfaz-runnable",children:[]},{level:3,title:"Implementación de Runnable a través de una expresión Lambda",slug:"implementacion-de-runnable-a-traves-de-una-expresion-lambda",link:"#implementacion-de-runnable-a-traves-de-una-expresion-lambda",children:[]},{level:3,title:"Llamar al método run de una clase que implemente Runnable",slug:"llamar-al-metodo-run-de-una-clase-que-implemente-runnable",link:"#llamar-al-metodo-run-de-una-clase-que-implemente-runnable",children:[]}]},{level:2,title:"3.1.2 Thread subclass",slug:"_3-1-2-thread-subclass",link:"#_3-1-2-thread-subclass",children:[]},{level:2,title:"3.1.3 Starting a Thread With a Runnable",slug:"_3-1-3-starting-a-thread-with-a-runnable",link:"#_3-1-3-starting-a-thread-with-a-runnable",children:[{level:3,title:"Subclass or Runnable?",slug:"subclass-or-runnable",link:"#subclass-or-runnable",children:[]}]},{level:2,title:"3.1.4 Métodos de la clase java.lang.Thread",slug:"_3-1-4-metodos-de-la-clase-java-lang-thread",link:"#_3-1-4-metodos-de-la-clase-java-lang-thread",children:[{level:3,title:"Cómo pausar un hilo",slug:"como-pausar-un-hilo",link:"#como-pausar-un-hilo",children:[]},{level:3,title:"Gestión de la prioridad de los hilos",slug:"gestion-de-la-prioridad-de-los-hilos",link:"#gestion-de-la-prioridad-de-los-hilos",children:[]}]}],path:"/es/unit3/runnable.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.1. Clases Java para la gestión de hilos\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.1. Clases Java para la gestión de hilos" />\r
\r
# 3.1. Clases Java para la gestión de hilos\r
\r
[[toc]]\r
\r
## 3.1.1. El interfaz Runnable\r
\r
Un hilo (thread en adelante) puede ejecutar código Java dentro de tu aplicación Java.\r
\r
![alt_text](../../media/unit3/Single_vs_MultiThreaded_Approaches.jpg)\r
\r
Cuando un programa Java se lanza (se convierte en un proceso) empieza a ejecutarse por su método main() que lo ejecuta el thread principal (main), un hilo especial creado por la Java VM para ejecutar la aplicación. Desde un proceso se pueden crear e iniciar tantos threads como necesites. Estos hilos ejecutarán partes del código de la aplicación en paralelo con el thread principal\r
\r
Los thread en Java son objetos como cualquier otro. Un thread es una instancia de la clase java.lang.Thread, o instancias de clases que heredan de ésta. Como ya hemos icho, además de ser objetos, los threads tienen la capacidad de ejecutar código.\r
\r
La forma más usada para indicar a un thread qué código queremos que ejecute es creando una clase que implemente la interfaz  \`java.lang.Runnable\`.\r
\r
Esta interfaz es una interfaz estándar que viene con la plataforma Java. La interfaz Runnable sólo tiene un único método, void run().\r
\r
> [java.lang.Runnable specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Runnable.html)\r
\r
Sea lo que sea lo que el thread tenga que hacer, debe estar incluido en la implementación del método run. Tenemos tres posibilidades de implementar dicha interfaz:\r
\r
- Crear una clase Java que implemente la interfaz Runnable.\r
- Crear una clase anónima que implemente la interfaz Runnable.\r
- Crear una expresión Lambda que implemente la interfaz Runnable.\r
\r
En las siguientes secciones podemos ver cómo usar cada una de ellas.\r
\r
### Clase Java que implementa la interfaz Runnable\r
\r
La primera forma que vamos a ver es creando una clase que implementa la interfaz. Podemos ver un ejemplo básico en el siguiente código:\r
\r
\`\`\`java\r
public class MyRunnable implements Runnable {\r
\r
  public void run(){\r
      System.out.println("MyRunnable running");\r
  }\r
}\r
\`\`\`\r
\r
Todo lo que hace la implementación es imprimir el texto "MyRunnable running". Tras ejecutar esa línea de código, el método run termina y el thread que estuviese ejecutándolo se pararía.\r
\r
### Implementación con clase anónima de la interfaz Runnable\r
\r
Otra forma de obtener un objeto que implemente Runnable es crear una clase anónima. A continuación tenemos un ejemplo de cómo hacerlo\r
\r
\`\`\`java\r
Runnable myRunnable =\r
    new Runnable(){\r
        public void run(){\r
            System.out.println("Runnable running");\r
        }\r
    }\r
\`\`\`\r
\r
Salvo por el hecho de usar una clase anónima, el ejemplo hace exactamente lo mismo que el anterior en el que se creaba una clase que implementaba la interfaz.\r
\r
### Implementación de Runnable a través de una expresión Lambda\r
\r
Para la tercera forma nos vamos a basar en la característica de la interfaz Runnable, esto es, que sólo tiene un único método a implementar, el método run. Aunque Runnable no es una interfaz funcional, podemos crear una expresión Lambda que no dará lugar a confusión acerca del método que se quiere ejecutar. Por este motivo podemos usar la expresión lambda como si Runnable fuese una interfaz funcional.\r
\r
Vamos a verlo con un ejemplo\r
\r
\`\`\`java\r
Runnable runnable =\r
        () -> { System.out.println("Lambda Runnable running"); };\r
\`\`\`\r
\r
### Llamar al método run de una clase que implemente Runnable\r
\r
Vamos a fijarnos en este ejemplo\r
\r
\`\`\`java{1,13,23}\r
public class LiftOff implements Runnable {\r
    private int countDown = 10;\r
    private static int taskCount = 0;\r
    private final int id = taskCount;\r
    \r
    public LiftOff() {}\r
    \r
    public LiftOff(int countDown) {\r
        this.countDown = countDown;\r
    }\r
    \r
    @Override\r
    public void run() {\r
        while (countDown > 0) {\r
            System.out.println("#" + id + " (" + countDown + ")" );\r
            countDown--;\r
        }\r
        System.out.println("Lanzamiento (" + id + ")");\r
    }\r
    \r
    public static void main(String[] args) {\r
        LiftOff launch = new LiftOff();\r
        launch.run();\r
        System.out.println("Comienza la cuenta atrás!");\r
    }    \r
}\r
\`\`\`\r
\r
Copia el código anterior y ejecútalo en tu IDE. ¿Qué ves en la salida?\r
\r
::: question ¿Qué está pasando con la ejecución del programa anterior?\r
Tras ejecutarlo, ¿el mensaje "Comienza la cuenta atrás!" está puesto en el sitio correcto?\r
\r
intenta crear más instancias del la clase LiftOff y haz que se ejecuten todas (dentro del main)\r
\r
Si observas la salida de aplicación, ¿está haciendo algo diferente a una aplicación monohilo?\r
¿Qué puedes extraer de la salida del programa?\r
:::\r
\r
::: details Respuesta a las cuestiones planteadas\r
El mensaje debería mostrarse antes que la cuenta atrás. De hecho la instrucción con el System.out está después de la llamada al método run.\r
\r
Como se puede observar, no estamos haciendo nada diferente. El código de run se está ejecutando uno después de otro.\r
\r
En realidad, **no estamos creando nuevos threads**, lo único que hemos hecho hasta ahora es implementar una interfaz, pero llamando al método run estamos haciendo que el hilo principal de la aplicación, el único hilo de momento, esté ejecutando un método run, después otro, después otro, ... y cuando ha acabado con todos hace el System.out.\r
:::\r
\r
## 3.1.2 Thread subclass\r
\r
Además de implementando la interfaz Runnable, la segunda forma que tenemos de indicar a un thread el código a ejecutar es creando una subclase de  \`java.lang.Thread\` y sobrescribiendo el método run(). La clase Thread implementa de forma implícita la interfaz Runnable. Al igual que con Runnable, el método run() contiene el código que ejecutará un thread cuando se llame al método \`start()\`.\r
\r
> [java.lang.Thread specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html)\r
\r
Vamos a ver un ejemplo de creación de una clase que herede de Thread:\r
\r
\`\`\`java\r
public class MyThread extends Thread {\r
  public void run(){\r
      System.out.println("MyThread running");\r
  }\r
}\r
\`\`\`\r
\r
Para crear y lanzar un nuevo thread tenemos que usar el siguiente código\r
\r
\`\`\`java\r
MyThread myThread = new MyThread();\r
myTread.start();\r
\`\`\`\r
\r
La llamada al método start() devuelve el control al thread principal en cuanto el hilo asociado se inicia. A diferencia del ejemplo de la cuenta atrás, cuando llamamos al método start  **el hilo principal no espera a que el método run() se ejecute por completo** antes de seguir. El método run() se ejecutará en un hilo de ejecución diferente, dentro del mismo proceso y compitiendo por las unidades de procesamiento del sistema. Al igual que en los casos anteriores, cuando se ejecute el método run() mostrará por pantalla el mensaje "MyThread running" y el hilo terminará su ejecución (y su vida) porque finaliza el código del método run().\r
\r
El ejemplo se puede repetir con una clase anónima, aunque ya no con una expresión lambda, ya que la clase Thread tiene muchos más métodos y no es una interfaz funcional.\r
\r
\`\`\`java\r
Thread thread = new Thread(){\r
  public void run(){\r
    System.out.println("Thread Running");\r
  }\r
}\r
\r
thread.start();\r
\`\`\`\r
\r
El ejemplo mostrará el mensaje "Thread running" cuando el método run() se ejecutado por el nuevo thread.\r
\r
::: question Ejemplo Cuenta atrás\r
Copia el ejemplo original de la "Cuenta Atrás" y haz que la clase LiftOff ahora herede de Thread.\r
Ahora, en vez de llamar directamente al método run, haz que los threads llamen al método start().\r
\r
El mensaje "Comienza la cuenta atrás!" ¿aparece ahora en el sitio correcto? ¿Porqué sale antes si en el código está después?\r
\r
Crea nuevas instancias de LiftOff y has que se lancen en el main\r
¿En qué ha cambiado ahora la ejecución de las aplicación respecto a una aplicación monohilo?\r
¿Qué puedes extraer de la salida del programa?\r
:::\r
\r
::: details Respuesta a las cuestiones planteadas\r
Ahora el mensaje "Comienza la cuenta atrás!" sí aparece, en la salida, en la posición correcta, es decir, antes de la cuenta atrás. Si observamos el código, siguiendo una lógica secuencial, el mensaje debería aparecer después, como pasó en la primera prueba que hicimos.\r
\r
La diferencia ahora es que el código del run() lo está ejecutando un hilo diferente, y desde el momento en que se hace el start() el control vuelve al hilo principal (main) que continúa ejecutando las líneas de código que hay en el método main. La creación de un hilo, aunque menos que la de un proceso, también tiene un coste de recursos y temporal, por lo que el hilo tarda unos instantes en empezar a ejecutarse. Por eso el hilo principal tiene tiempo de ejecutar la siguiente instrucción y mostrar el mensaje.\r
\r
La gran diferencia ahora, que podemos observar en la salida, es que los hilos se están ejecutando concurrentemente, ya que vemos como sus salidas se intercalan.\r
\r
Esa es la diferencia más obvia. Sin embargo, si ejecutamos el programa varias veces, podremos observar que no hay dos ejecuciones iguales. No depende de nosotros el orden en el que se ejecutan las instrucciones, sino que depende de la planificación que realice el SO. En este contexto nos encontramos con una ejecución aleatoria o **indeterminista** como la denominamos en el primer tema.\r
\r
El cómo controlar ese orden es lo que trabajaremos en la segunda parte del tema.\r
:::\r
\r
::: info ¿Cuándo termina un proceso?\r
En el ejemplo anterior, la última línea del hilo principal se ejecuta antes que el código de los hilos. ¿Qué pasa entonces con el proceso?\r
\r
En un proceso monohilo, estamos acostumbrados a que el proceso sigue en ejecución (vivo) mientras el código que hayamos puesto en el main esté ejecutándose. En concreto mientras el main-thread esté en ejecución.\r
\r
![Ciclo de vida de un proceso](../../media/unit3/threads_process_end.png)\r
\r
Cuando un proceso tiene mas hilos, la norma es que el proceso no finaliza su ejecución hasta que el último de los hilos haya terminado. Así que podemos encontrarnos, como en ejemplo de la cuenta atrás, que el main-thread acaba y el proceso sigue en ejecución.\r
:::\r
\r
## 3.1.3 Starting a Thread With a Runnable\r
\r
Para hacer que un thread ejecute el código del método run de una clase (instancia de clase, clase anónima, expresión lambda) que implemente la interfaz Runnable, tenemos que pasar esa instancia como parámetro en el constructor de la clase Thread. Veamos cómo se hace:\r
\r
\`\`\`java\r
Runnable runnable = new MyRunnable(); // or an anonymous class, or lambda...\r
\r
Thread thread = new Thread(runnable);\r
thread.start();\r
\`\`\`\r
\r
Cuando se inicia el thread, llamando a su método start(), se crea un nuevo thread que ejecuta el código del método run de la instancia MyRunnable. El ejemplo anterior imprimirá el texto "MyRunnable running (ver el código de MyRunnable en los ejemplos anteriores).\r
\r
::: info\r
En resumen, tenemos dos formas de indicarle a un thread qué código debe ejecutar.\r
\r
- Crear una subclase de Thread y sobrescribir el método run().\r
- Pasar una instancia de un objeto que implemente la interfaz Runnable al constructor de Thread.\r
\r
**En ambos casos, para que se cree el thread y ejecute el código del método run, debemos llamar al método start() del objeto Thread.**\r
:::\r
\r
<CodeGroup>\r
<CodeGroupItem title="Extends Thread" active>\r
\r
\`\`\`java{1,7}\r
public class EjemploThread extends Thread {\r
  public void run() {\r
    // Código del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    EjemploThread hilo = new EjemploThread();\r
    hilo.start();\r
  }\r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Runnable">\r
\r
\`\`\`java{1,7}\r
public class EjemploRunnable implements Runnable {\r
  public void run() {\r
    // Código del hilo\r
  }\r
\r
  public static void main(String[] args) {\r
    Thread hilo = new Thread(new EjemploRunnable());\r
    hilo.start();\r
  }    \r
}\r
\`\`\`\r
\r
</CodeGroupItem>\r
</CodeGroup>\r
\r
### Subclass or Runnable?\r
\r
No hay nada que indique que una forma es mejor que otra. Ambos métodos son similares y el resultado es el mismo. . **El método preferido debería ser implementar Runnable**, y pasarle la instancia al constructor de Thread.\r
\r
unas cuantas razones en contra de usar Thread\r
\r
- Cuando heredamos de la clase Thread, no estamos sobrescribiendo ninguno de sus métodos. Por contra, estamos sobrescribiendo un método de la interfaz Runnable (que Thread implementa internamente . Esto supone una clara violación del principio IS-A del Thread.\r
- Cuando pasamos la instancia de Runnable y la utilizamos como argumento en el constructor de Thread estamos usando composición y no herencia, lo cual permite mucha más flexibilidad.\r
- Si heredamos de Thread, ya no podemos heredar de otras clases. Esto supone un gran problema cuando usamos librerías o componentes gráficos, ya que Java noi permite la herencia múltiple.\r
- Desde Java 8 en adelante, la interfaz Runnable se puede representar con expresiones lambda\r
\r
::: danger Error común: Llamar a run () en vez de a start()\r
Cuando empezamos a trabajar con hilos, un error muy común es llamar directamente al método run en vez de llamar al método start():\r
\r
> Thread newThread = new Thread(MyRunnable());\r
> newThread.run();  //should be start();\r
\r
or\r
\r
> MyRunnable runnable = new MyRunnable();\r
> runnable.run();  \r
\r
En principio no notamos ningún error ya que el código de run() se ejecuta y podemos ver los resultados. Sin embargo, ese código **no es ejecutado por el nuevo thread** que acabamos de crear. El método run() es ejecutado por el thread que ha creado el objeto, es decir, el mismo thread que ha ejecutado las líneas anteriores a la llamada a run().\r
\r
Para hacer que el método run, de una instancia que implemente Runnable o de una que herede de Thread, sea ejecutado por un el nuevo thread que acabamos de crear, newThread, debemos llamar al método newThread.start().\r
:::\r
\r
## 3.1.4 Métodos de la clase java.lang.Thread\r
\r
Si miramos a la definición de la clase Thread veremos que tiene muchos métodos. Debemos tener cuidado ya que algunos de estos métodos como stop(), suspend(), resume() and destroy()  han sido marcados como \`obsoletos(deprecated)\`.\r
\r
Veamos algunos de los métodos de la clase Thread más utilizados:\r
\r
| Method                      | Description                                                                                                                                                                                                            |\r
| :-------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| start()                     | Hace que un nuevo thread ejecute el código del método run()                                                                                                                                                            |\r
| boolean isAlive()           | Comprueba si un thread está vivo o no                                                                                                                                                                                  |\r
| sleep(long ms)              | Cambia el estado del thread a bloqueado durante los ms indicados                                                                                                                                                       |\r
| run()                       | Es el código que el thread ejecuta. Es llamado por el método start(). Representa el ciclo de vida de un thread.                                                                                                        |\r
| String toString()           | Devuelve una representación legible de un thread [nombre, priority, nombre_del_grupo                                                                                                                                   |\r
| long getId()                | Devuelve el identificador del thread (es un id asignado por el proceso)                                                                                                                                                |\r
| void yield()                | Hace que el hilo pare su ejecución instantáneamente volviendo a la cola y permitiendo que otros hilos y/o procesos se ejecuten.                           |\r
| void join()                 | Se llama desde otro thread y hace que el thread que lo invoca se bloquee hasta que el thread termine. Es parecido a p.waitFor() para los procesos                                                                      |\r
| String getName()            | Obtiene el nombre del thread                                                                                                                                                                                           |\r
| String setName(String name) | Cambia el nombre del thread                                                                                                                                                                                            |\r
| int getPriority()           | Obtiene la prioridad del thread                                                                                                                                                                                        |\r
| setPriority(int p)          | Modifica la prioridad del thread                                                                                                                                                                                       |\r
| void interrupt()            | Interrumpe la ejecución del thread provocando que salte una excepción de tipo InterruptedException                                                                                                                     |\r
| boolean interrupted()       | Comprueba si un thread ha sido interrumpido                                                                                                                                                                            |\r
| Thread.currentThread()      | Método estático de la clase Thread que devuelve una referencia al hilo que está ejecutando el código                                                                                                                   |\r
| boolean isDaemon()          | Comprueba si un hilo es un servicio/demonio. Un proceso/hilo de baja prioridad que se ejecuta de forma independiente de su proceso padre. Un proceso puede finalizar aunque un hilo *daemon* esté todavía ejecutándose. |\r
| setDaemon(boolean on)       | Convierte un hilo en un demonio/servicio. Por defecto todos los hilos se crean como hilos de usuario.                                                                                                                  |\r
| int activeCount()           | Devuelve el número de hilos pertenecientes a un grupo que siguen activos.                                                                                                                                              |\r
| Thread.State getState()     | Devuelve el estado actual del hilo. Los posibles valores son NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING or TERMINATED.                                                                                             |\r
\r
La clase Thread también tiene unos 9 constructores, la mayoría de ellos están duplicados permitiendo recibir un objeto Runnable como parámetro\r
\r
| Constructores de la clase Thread                                                                      |\r
| :---------------------------------------------------------------------------------------------------- |\r
| Thread()                                                                                              |\r
| Thread​(Runnable target)                                                                              |\r
| Thread​(String name)                                                                                  |\r
| Thread​(Runnable target, String name)                                                                 |\r
| Thread​(ThreadGroup group, Runnable target)                                                           |\r
| Thread​(ThreadGroup group, Runnable target, String name)                                              |\r
| Thread​(ThreadGroup group, Runnable target, String name, long stackSize)                              |\r
| Thread​(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals) |\r
\r
Veamos un ejemplo práctico de uso de todos estos métodos\r
\r
\`\`\`java\r
public class U3S2_ThreadMethodsExample extends Thread {\r
    \r
    U3S2_ThreadMethodsExample (ThreadGroup group, String name) {\r
        // Call to parent class constructor with group and thread name\r
        super(group, name);\r
    }\r
    \r
    @Override\r
    public void run() {\r
        String threadName = Thread.currentThread().getName();\r
        System.out.println("["+threadName+"] " + "Inside the thread");\r
        System.out.println("["+threadName+"] " + "Priority: " \r
          + Thread.currentThread().getPriority());\r
        Thread.yield();\r
        System.out.println("["+threadName+"] " + "Id: " \r
          + Thread.currentThread().getId());\r
        System.out.println("["+threadName+"] " + "ThreadGroup: " \r
          + Thread.currentThread().getThreadGroup().getName());\r
        System.out.println("["+threadName+"] " + "ThreadGroup count: " \r
          + Thread.currentThread().getThreadGroup().activeCount());\r
    } \r
    \r
    public static void main(String[] args) {\r
        // main thread \r
        Thread.currentThread().setName("Main");\r
        System.out.println(Thread.currentThread().getName());\r
        System.out.println(Thread.currentThread().toString());\r
        \r
        ThreadGroup even = new ThreadGroup("Even threads");\r
        ThreadGroup odd = new ThreadGroup("Odd threads");\r
        \r
        Thread localThread = null;\r
        for (int i=0; i<10; i++) {\r
            localThread = new U3S2_ThreadMethodsExample((i%2==0)?even:odd, "Thread"+i);\r
            localThread.setPriority(i+1);\r
            localThread.start();\r
        }\r
              \r
        try {\r
            localThread.join(); // --> Will wait until last thread ends \r
                                // like a waitFor() for processes\r
        } catch (InterruptedException ex) {\r
            ex.printStackTrace();\r
            System.err.println("The main thread was interrupted while waiting for " \r
              + localThread.toString() + "to finish");\r
        }\r
        System.out.println("Main thread ending");\r
    }    \r
}\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver cómo tenemos que ayudarnos del método estático \`Thread.currentThread()\` para saber qué hilo está ejecutándose en cada momento, ya que hay muchos hilos ejecutando el mismo código al mismo tiempo.\r
\r
Hemos creado una única clase para los hilos y para el hilo principal. No debería ser una práctica común más allá de los ejemplos. Es mejor separar el código del objeto que hereda de Thread o que implementa Runnable en una clase aparte.\r
\r
También es importante hacer ver que la clase Thread (o Runnable) puede tener sus propios constructores, propiedades y métodos, más allá del método run que están obligadas a sobrescribir. También puede invocar a los constructores de la superclase haciendo uso de super().\r
\r
:::question Dividir el código en dos clases\r
Copia el código de ThreadMethodsExample y divídelo en dos clases. Por un lado, una que contenga a la clase que extiende de Thread y otra que simplemente tenga el método main y el código para crear y lanzar los hilos..\r
\r
Una vez dividido el código cambia U3S2_ThreadMethodsExample para que implemente la interfaz Runnable. Haz los cambios oportunos en la otra clase para que todo vuelva a funcionar como antes.\r
:::\r
\r
Si ejecutas el programa podrás ver que aunque los threads son lanzados en orden (1, 2, 3 etc.) su ejecución ya no se realiza de forma secuencial, pudiendo ocurrir que el thread 1 no sea el primero en mostrar su nombre por la salida estándar (System.out). Esto es debido a que los threads se ejecutan en paralelo y no de forma secuencial. La JVM y/o el sistema operativo determinan el orden en el que se ejecutan. Este orden no tiene porqué ser el mismo en el que se lanzaron ni cada vez que se ejecutan.\r
\r
### Cómo pausar un hilo\r
\r
Un thread puede pausar su propia ejecución llamando al método estático **Thread.sleep()**. El método sleep() recibe como parámetro el número de milisegundos que quiere estar pausado antes de volver a ponerse como listo para ejecución. No es un método preciso al 100% (menos aún si utilizamos la versión que recibe ms y ns), pero aún así es bastante preciso. A continuación tenemos un ejemplo de un thread que se pausa durante 3 segundos (3000ms) llamando al método sleep():\r
\r
\`\`\`java:no-line-numbers\r
try {\r
    Thread.sleep(3000L);\r
} catch (InterruptedException e) {\r
    e.printStackTrace();\r
}\r
\`\`\`\r
\r
::: info Simulación de sistema reales\r
Este es un método que vamos a utilizar exhaustivamente en las actividades para simular períodos de tiempo y acelerar las simulaciones.\r
\r
Por ejemplo, podemos hacer un ajuste para que cada hora *real* se reduzca a un segundo. De esta forma podremos simular un día completo en tan solo 24 segundos.\r
\r
También es interesante su uso para utilizar períodos de tiempo aleatorios en la ejecución de cada hilo, permitiendo así una simulación realista de los eventos en un sistema real.\r
:::\r
\r
En Java podemos generar números aleatorios en el rango de los enteros, long, float y double.\r
\r
Tenemos tres métodos básicos para hacerlo\r
\r
#### Method 1: Usando la clase Random\r
\r
Podemos usar la clase  \`java.util.Random\` para generar datos aleatorios, siguiendo los siguientes pasos:\r
\r
- Importar la clase java.util.Random\r
- Crear una instancia de la clase Random, por ejemplo \`Random rand = new Random()\`\r
- Llamar a alguno de los métodos del objeto:\r
  - nextInt(limitesuperior) genera números aleatorios en el rango 0 a límitesuperior-1.\r
  - nextFloat() genera un float entre 0.0 and 1.0.\r
  - nextDouble() genera un double entre 0.0 and 1.0.\r
  \r
Si llamamos al método nextInt con parámetros (el límite superior), obtendremos números enteros en el rango\r
\r
> int randomWithNextIntWithinARange = random.nextInt(max)\r
\r
Esto nos dará un número entre  *0 (inclusive)* y *max* (no incluido) [min, max[. El valor del límite debe ser mayor que 0 sino obtendremos una java.lang.IllegalArgumentException.\r
\r
#### Method 2: Usando Math.random\r
\r
Para generar números aleatorios en un rango podemos usar Math.random() siguiendo los pasos detallados a continuación:\r
\r
- Declarar el valor mínimo del rango\r
- Declarar el valor máximos del rango\r
- Usar la fórmula \`Math.random()*(max-min)+min\` para generar valores entre  *min* y *max*, ambos inclusive [min, max].\r
\r
El valor devuelto por Math.random() está en el rango [0, 1]\r
\r
Para generar números entre 0 y un límite superior (50)\r
\r
> Math.random()*50\r
\r
Para generar números entre 1 y un límite superior (50)\r
\r
> Math.random()*49+1\r
\r
Para generar números en un rango predeterminado [200, 500]\r
\r
> Math.random()*300+200\r
\r
#### Method 3: Usar ThreadLocalRandom\r
\r
La clase \`java.util.Random\` no tiene buen rendimiento en entornos multihilo. De forma simplificada, el motivo es la contención, ya que muchos hilos comparten la misma instancia de Random y se tiene que secuenciar y sincronizar el acceso a sus métodos.\r
\r
Para evitar esa limitación, Java introdujo la clase \`java.util.concurrent.ThreadLocalRandom\` para generar números aleatorios en entornos multihilo.\r
\r
Si llamamos al método \`ThreadLocalRandom.current()\` nos devolverá la instancia de ThreadLocalRandom para el hilo actual. A partir de aquí podemos generar valores aleatorios llamando a los métodos de la clase con la instancia obtenida.\r
\r
Para generar valores enteros sin límite:\r
\r
> int unboundedRandomValue = ThreadLocalRandom.current().nextInt());\r
\r
Para generar valores enteros en un rango dato, es decir, con un límite superior e inferior [0, 100[:\r
\r
> int boundedRandomValue = ThreadLocalRandom.current().nextInt(0, 100);\r
\r
Al igual que con Random, 0 está incluido en el rango mientra que 100 no.\r
\r
También podemos generar otros tipos de datos como long y Double llamando a los métodos \`nextLong()\` y \`nextDouble()\` de forma similar a los ejemplos anteriores.\r
\r
La clase ThreadLocalRandom hereda de Random, por lo que comparten muchos métodos y funcionalidad.\r
\r
### Gestión de la prioridad de los hilos\r
\r
Los hilos heredan la prioridad del padre en Java, pero este valor puede ser cambiado con el método \`setPriority()\` y con \`getPriority()\` podemos saber la prioridad de un hilo.\r
\r
El valor de la prioridad varía entre 1 y 10. *Cuanto más alto es el valor, mayor es la prioridad*. La clase Thread define las siguientes constantes \`MIN_PRIORITY\` (valor 1) \`MAX_PRIORITY\` (valor 10) y \`NORM_PRIORITY\` (valor 5). El planificador elige el hilo en función de su prioridad. Si dos hilos tienen la misma prioridad realiza un round-robin, es decir de forma cíclica va alternando los hilos.\r
\r
El hilo de mayor prioridad seguirá funcionando hasta que ceda el control por:\r
\r
- Cede el control llamando al método yield().\r
- Deja de ser ejecutable (por muerte o por bloqueo)\r
- Aparece un hilo de mayor prioridad, por ejemplo si se encontraba en estado dormido por una operación de E/S o bien es desbloqueado por otro con los métodos notifyAll() / notify().\r
\r
\`\`\`java\r
class U3S3_HiloPrioridad1 extends Thread {\r
  private int c = 0;\r
  private boolean stopHilo = false;\r
  public long getContador () {\r
    return c;\r
  }\r
  public long pararHilo() {\r
    stopHilo = true;\r
  }\r
  @Override\r
  public void run() {\r
    while (!stopHilo) c++;\r
  }\r
}\r
\r
public class U3S3_EjemploHiloPrioridad1 {\r
  public static void main(String args[]) {\r
    U3S3_HiloPrioridad1 h1 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h2 = new U3S3_HiloPrioridad1();\r
    U3S3_HiloPrioridad1 h3 = new U3S3_HiloPrioridad1();\r
\r
    h1.setPriority(Thread.NORM_PRIORITY);\r
    h2.setPriority(Thread.MAX_PRIORITY);\r
    h3.setPriority(Thread.MIN_PRIORITY);\r
\r
    h1.start();\r
    h2.start();\r
    h3.start();\r
\r
    try {\r
      Thread.sleep(10000);\r
        } catch (InterruptedException e) {}\r
\r
    h1.pararHilo();\r
    h2.pararHilo();\r
    h3.pararHilo();\r
\r
    System.out.println("h2 (Prio. Máx: "+h2.getContador());\r
    System.out.println("h1 (Prio. Normal: "+h1.getContador());\r
    System.out.println("h3 (Prio. Mínima: "+h3.getContador());\r
  }\r
}\r
\`\`\`\r
`]},{title:"3.2 Sincronización y comunicación de hilos",headers:[{level:2,title:"3.2.1. Memoria compartida",slug:"_3-2-1-memoria-compartida",link:"#_3-2-1-memoria-compartida",children:[]},{level:2,title:"3.2.2. Sincronización",slug:"_3-2-2-sincronizacion",link:"#_3-2-2-sincronizacion",children:[{level:3,title:"Monitores y bloqueos",slug:"monitores-y-bloqueos",link:"#monitores-y-bloqueos",children:[]},{level:3,title:"Secciones críticas",slug:"secciones-criticas",link:"#secciones-criticas",children:[]},{level:3,title:"Sincronización y actualización de la información",slug:"sincronizacion-y-actualizacion-de-la-informacion",link:"#sincronizacion-y-actualizacion-de-la-informacion",children:[]}]},{level:2,title:"3.2.3 Sincronización entre hilos",slug:"_3-2-3-sincronizacion-entre-hilos",link:"#_3-2-3-sincronizacion-entre-hilos",children:[]}],path:"/es/unit3/synchronization.html",pathLocale:"/es/",extraFields:[`---\r
title: 3.2 Sincronización y comunicación de hilos\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="3.2 Sincronización y comunicación de hilos" />\r
\r
# 3.2 Sincronización y comunicación de hilos\r
\r
[[toc]]\r
\r
::: info Vocabulario\r
\r
- **Condición de carrera**: Situación en que el correcto funcionamiento de un programa depende del orden en que se intercale la ejecución de las instrucciones de sus diferente hilos. Esto ocurre cuando uno o más hilos acceden a información compartida de forma concurrente e intentan modificarla a la vez.\r
- **Deadlock**: Situación en que dos o más hilos están bloqueados mutuamente, todos ellos esperando para conseguir el bloqueo sobre objetos bloqueados por otros hilos, de manera que ninguno de ellos podrá continuar nunca.\r
- **Sección crítica**: Fragmento de un programa que no puede ejecutar de manera simultánea (concurrentemente) más de un hilo del programa, es decir, que distintos hilos deben ejecutar en exclusión mutua\r
- **Thread-safe**: Se dice de una clase cuyos métodos implementan los mecanismos de sincronización necesarios para el uso concurrente de sus objetos por parte de distintos hilos, de manera que **no es necesario ningún mecanismo de sincronización externo** a la propia clase.\r
\r
:::\r
\r
## 3.2.1. Memoria compartida\r
\r
A menudo los hilos necesitan comunicarse unos con otros. La forma que tienen de hacerlo consiste en compartir un objeto.\r
\r
Vamos a desarrollar un ejemplo en el que dos hilos comparten un objeto de la clase Contador.\r
\r
![alt_text](../../media/unit3/SumadorRestador_uml.jpg)\r
\r
<!--\r
\`\`\`puml\r
class Contador {\r
  - int c = 0\r
  + Contador(int c)\r
  +void incrementa()\r
  +void decrementa()\r
  + int valor()\r
}\r
class Sumador extends Thread {\r
  - Contador c\r
  + Sumador(String name, Contador c)\r
  + void run()\r
\r
}\r
class Restador implements Runnable{\r
  - Contador c\r
  + Restador(String name, Contador c)\r
  + void run()\r
\r
}\r
Restador o-- Contador\r
Sumador o-- Contador\r
\`\`\`\r
-->\r
\r
Para probar el objeto compartido, en una cuarta clase que contiene el main se crea un objeto Contador que se inicializa a 100 y se crean y lanzan dos threads, uno de tipo Sumador y otro de tipo Restador. En la clase Sumador se usa el método del objeto Contador que incrementa en uno su valor mientras que en la clase Restador se usa el método que decrementa en uno su valor. Cada una va a realizar la acción 300 veces, esperando entre cada acción un tiempo aleatorio entre 50ms y 150ms.\r
Es muy importante asegurarse que pasamos el mismo objeto Contador como parámetro al constructor de Sumador y de Restador, para que ambos trabajen con la misma instancia.\r
\r
::: question Comportamiento esperado\r
Crea las cuatro clases en función del diagrama de clases proporcionado. Asegúrate que Sumador hereda de Thread y Restador implementa la interfaz Runnable para comprobar las diferencias de uso y creación de threads a partir de cada tipo de clase.\r
\r
¿Qué debería ocurrir tras ejecutar el código?\r
\r
Comprueba lo que pasa realmente. Intenta ejecutar el programa varias veces para ver si puedes obtener resultados diferentes.\r
:::\r
\r
:::details Código del ejemplo\r
\r
\`\`\`java{4,7,9}\r
public class U3S3_SharedMemory {\r
  public static void main(String[] args) throws InterruptedException {\r
    // Inicializar el objeto Contador\r
    Contador c = new Contador(100);\r
    \r
    // Crear y lanzar 2 hilos (Sumador + Restador)\r
    Sumador s1 = new Sumador("Sumador1", c);\r
    Restador r1 = new Restador("Restador1", c);\r
    Thread h1 = new Thread(r1);\r
    \r
    s1.start();\r
    h1.start();\r
    \r
    // El hilo principal espera a que los hilos s1 y r1 terminen\r
    s1.join();\r
    h1.join();\r
    \r
    System.out.println("El valor final de c es " + c.valor());\r
    \r
  }\r
\`\`\`\r
\r
\`\`\`java\r
public class Contador {\r
  private int c = 0;\r
  \r
  public Contador(int c) {\r
    this.c = c;\r
  }\r
  \r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
  \r
  public int valor() {\r
    return c;\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,5,14}\r
public class Sumador extends Thread {\r
  private Contador c;\r
  public Sumador(String name, Contador c) {\r
    // To set the thread name we can access the Thread class constructor\r
    super(name);\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.incrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());\r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }\r
    }\r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{1,3,13,17}\r
public class Restador implements Runnable {\r
  private Contador c;\r
  private String name;\r
  public Restador(String name, Contador c) {\r
    // Restador doesn't extend Thread, so it cannot call the Thread constructor\r
    // super(name);\r
    this.name = name;\r
    this.c = c;    \r
  }\r
  \r
  @Override\r
  public void run() {\r
    Thread.currentThread().setName(this.name);\r
    // Ejecutar 300 veces con espera entre 50ms y 150ms\r
    for (int i = 0; i < 300; i++) {      \r
      try {\r
        c.decrementa();\r
        System.out.println(Thread.currentThread().getName() + " " + c.valor());              \r
        Thread.sleep((long) (Math.random() * 100 + 50));\r
      } catch (InterruptedException ex) {\r
        // Nothing\r
      }      \r
    }    \r
  }\r
}\r
\`\`\`\r
\r
Si ejecutamos el programa, la mayoría de veces obtendremos el resultado esperado, 100. Sin embargo, hay ocasiones en que podemos encontrar otros valores tales como 99, 101 o cualquier otro.\r
\r
Para evitar problemas de sincronización (son problemas como hemos visto aleatorios y muy difíciles de detectar), necesitamos que los hilos estén sincronizados entre sí.\r
:::\r
\r
Si analizamos el problema anterior, veremos que se está intentando ejecutar el siguiente código en paralelo desde diferentes hilos, en **la misma instancia (memoria compartida)**:\r
\r
\`\`\`java\r
  public void incrementa() {\r
    c++;\r
  }\r
  public void decrementa() {\r
    c--;\r
  }\r
\`\`\`\r
\r
Si aplicásemos las condiciones de Bernstein a esos dos métodos, veríamos que no se cumple ninguna de las tres, por lo que ese código no puede ser ejecutado concurrentemente, al menos no sin tener problemas de concurrencia.\r
\r
Así, para evitar que varios hilos ejecuten esos métodos de forma concurrente, necesitamos estructuras de programación que nos ayuden a conseguirlo.\r
\r
## 3.2.2. Sincronización\r
\r
El código anterior no funciona porque las operaciones que se realizan en los métodos incrementa y decrementa no son atómicas, sino que se descomponen en operaciones más simples que se ejecutan una tras otra.\r
\r
Cuando estas operaciones se ejecutan en un hilo, la ejecución del hilo se puede interrumpir y se pueden intercalar entre ellas operaciones de otros hilos. Según cómo se intercalen las operaciones y los datos a los que accedan, se pueden obtener resultados no esperados. Esto es lo que se conoce como una \`condición de carrera\`.\r
\r
Como vimos en la primera parte del tema, la comunicación entre threads se produce principalmente mediante el acceso compartido a objetos y sus propiedades. Este mecanismo de comunicación es muy eficiente pero presenta dos tipos de errores:\r
\r
- Interferencia entre threads\r
- Errores de consistencia de la información en memoria.\r
\r
La herramienta de programación que utilizamos para prevenir este tipo de errores es la *sincronización*.\r
\r
La mayor parte del tiempo, los threads no tienen en cuenta al resto de hilos que se ejecutan en el programa ni les importa lo que éstos hagan. Pero si necesitan algo de otro thead, entonces necesitan la sincronización.\r
\r
### Monitores y bloqueos\r
\r
La sincronización en Java se realiza usando \`monitores\`. Es una propiedad que proporciona la clase Object, por lo tanto todas nuestras clases Java, directa o indirectamente, heredan esta propiedad de Object. Este mecanismo permite a un único thread a la vez ejecutar la sección de código protegida por el monitor.\r
\r
Un monitor no es más que un bloqueo sobre un objeto. **Cada objeto tiene un y sólo un bloqueo (candado) interno asociado**. El bloqueo de un objeto solamente puede ser adquirido por un thread en cada momento.\r
\r
La sincronización implica muchos conceptos. El más utilizado es la \`exclusión mutua\` (**sólo un hilo puede disponer de un monitor a la vez)**. Por lo tanto, la sincronización utilizando monitores significa que cuando un hilo accede a una sección protegida por un monitor, ningún otro hilo puede acceder a esa o a cualquier otra sección protegida por ese mismo monitor, hasta que el hilo salga de la sección protegida\r
\r
Pero la sincronización también asegura que las escrituras en memoria realizadas por un thread dentro de un bloque protegido por un monitor son accesibles al resto de threads que accedan a los bloques protegidos por ese mismo monitor.\r
\r
::: danger Un objeto, un monitor\r
He recalcado en varias ocasiones que los bloques de código a los que se accede en exclusión mutua son aquellos que están protegidos por el mismo monitor. Esto es lo mismo que decir a aquellos que se realizan sobre el mismo objeto.\r
Cada objeto tiene asociado un monitor y la exclusión mutua y la sincronización de memoria tiene sentido si varios threads usan el mismo monitor para su sincronización.\r
:::\r
\r
Cada objeto gestiona una cola de hilos que quieren conseguir el bloqueo **(monitor)** del mismo. Como suele ser habitual, la elección del proceso de la cola que conseguirá el bloqueo es totalmente indeterminista, depende de múltiples factores y no sigue ningún orden preestablecido.\r
\r
### Secciones críticas\r
\r
En Java la palabra reservada \`synchronized\` sirve para hacer que un bloque de código o un método sea protegido por el cerrojo del objeto. Para ejecutar un bloque o un método sincronizado, los hilos deben conseguir previamente el bloqueo (candado) del objeto, debiendo esperar a que quede libre (el hilo que lo tiene lo libere) si el monitor ya ha sido adquirido por otro hilo.\r
\r
Esto ocurre sólo si se está intentando **acceder al monitor del mismo objeto que otro hilo** ya tenga en propiedad.\r
\r
La palabra reservada synchronized puede aplicarse en distintos tipos de bloques de código y, en cada caso, se utilizará un objeto de bloqueo distinto.\r
\r
- Métodos no estáticos\r
- Static methods\r
- Code blocks inside methods\r
\r
Para métodos no estáticos se añade la palabra reservada synchronized a la definición del método.\r
\r
\`\`\`java{3}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
}\r
\`\`\`\r
\r
El bloqueo se aplica sobre el objeto sobre el que se ejecuta el método, es decir, **el objeto \`this\`**. En este caso dos hilos no podrían ejecutar a la vez dos métodos del mismo objeto marcados como synchronized.\r
\r
Cada objeto que instanciemos de la clase tendrá su propio monitor asociado que no interferirá con los bloqueos que se hayan hecho sobre otros objetos de la misma clase.\r
\r
Como ya hemos dicho, este comportamiento sólo es válido si todos los métodos sincronizados a los que se quiere acceder pertenecen a la misma instancia. De este modo el monitor es el mismo y se aplica la exclusión mutua en la ejecución de los bloques de código protegidos por el monitor.\r
\r
\`\`\`java{3,6}\r
public class Counter {\r
 private int count = 0;\r
 public synchronized void add(int value){\r
   this.count += value;\r
 }\r
 public synchronized void sub(int value){\r
   this.count -= value;\r
 }\r
}\r
\`\`\`\r
\r
::: info Sincronización con métodos estáticos\r
En este caso el bloqueo se realiza sobre la clase a la que pertenece el método. Como **sólo hay una instancia de cada objeto clase en la JVM**, sólo un hilo a la vez podrá adquirir el monitor y ejecutar el código protegido de una clase estática..\r
:::\r
\r
La sincronización no tiene porqué realizarse sobre todo un método, *aunque es lo más recomendable*. A veces es preferible sincronizar sólo una parte de un método. Otras no es posible sincronizar el método completo. Para sincronizar un bloque de código usamos la palabra reservada synchronized seguida, entre paréntesis, del objeto del que usaremos el monitor. El código protegido se ubicará entre un par de llaves.\r
\r
\`\`\`java{2}\r
public void add(int value){\r
  synchronized(this){\r
    this.count += value;  \r
  }\r
 }\r
\`\`\`\r
\r
En el ejemplo se ha utilizado \`this\` como objeto para el monitor. Decimos que el codigo está sincronizado con el monitor del objeto que pongamos entre paréntesis. **Un método sincronizado usa el objeto al que pertenece como monitor, es decir, también usa this**.\r
\r
Sólo puede haber un thread ejecutando un bloque sincronizado para el mismo monitor. Los demás se quedan esperando.\r
\r
El siguiente código define dos bloques protegidos por la instancia a la que pertenecen. **En términos de sincronización, ambos bloque son totalmente equivalentes.**:\r
\r
\`\`\`java{2,8}\r
public class MyClass { \r
  public synchronized void log1(String msg1, String msg2){\r
    log.writeln(msg1);\r
    log.writeln(msg2);\r
  }\r
 \r
  public void log2(String msg1, String msg2){\r
    synchronized(this){\r
     log.writeln(msg1);\r
     log.writeln(msg2);\r
    }\r
  }\r
 }\r
\`\`\`\r
\r
Por lo tanto, sólo un thread podría ejecutar uno de los dos bloques anteriores al mismo tiempo. Si otro hilo intentase ejecutar el mismo bloque, o el otro, se quedaría bloqueado en la cola de espera del monitor hasta que el monitor quede libre.\r
\r
::: warning ¿Qué objetos se pueden usar como monitores\r
Oracle dice que se puede usar cualquier objeto como monitor de sincronización, sin embargo **recomiendan que no se sincronice sobre String, o cualquier objeto envoltorio (wrapper) de los tipos de datos primitivos** (Integer, Double, Boolean, ...).\r
\r
Para estar seguros, lo mejor es sincronizar sobre \`this\`, sobre una instancia de un objet o, en su defecto sobre un nuevo objeto de tipo object, aunque sea un objeto vacío sin propiedades ni funcionalidad.\r
:::\r
\r
### Sincronización y actualización de la información\r
\r
Sin el uso de la palabra reservada synchronized (o el modificador \`volatile\` ) no tenemos ninguna garantía de que cuando un hilo cambie el valor de una variable compartida con otros threads (por ejemplo a través de un objeto compartido entre todos los threads), los otros hilos puedan ver el valor modificado. No hay ninguna garantía de que cuando una variable se guarda en un registro de la CPU, el valor de ésta se vuelque a la memoria principal.\r
\r
Esto, en programación secuencial no supone ningún problema ya que el único hilo existente no necesita de estas actualizaciones "instantáneas". Si fuese necesario se usaría la palabra \`volatile\` para las variables a las que se quiera forzar ese comportamiento.\r
\r
En la programación multihilo, y dentro de la sincronización, un bloque protegido por un monitor nos garantiza que:\r
\r
- Cuando un hilo entra en un bloque \`synchronized\` se actualizará el valor de todas las variables visibles para el hilo.\r
- Cuando un hilo salga de un bloque \`synchronized\` todos los cambios realizados por el hilo se actualizarán en la memoria principal.\r
\r
El comportamiento descrito es similar al que provoca el uso de la palabra reservada \`volatile\`, evitando el uso de caches y la desincronización de la información entre la CPU y la memoria principal.\r
\r
El siguiente ejemplo muestra un monitor que implementa un contador:\r
\r
\`\`\`java \r
class Contador { \r
  // monitor contador\r
  private int actual; \r
  public Contador(int inicial) \r
  { \r
    actual = inicial;    \r
  } \r
  public synchronized void inc() { actual++; } \r
  public synchronized void dec() { actual--; } \r
  public synchronized int valor() { return actual;} \r
} \r
 \r
class Usuario extends Thread { \r
  // clase hilo usuario\r
  private Contador cnt; \r
  public Usuario(String nombre, Contador cnt) { \r
    super(nombre); this.cnt = cnt;    \r
  } \r
  public void run() { \r
    for (int i = 0; i < 1000; i++) { \r
      cnt.inc();          \r
      System.out.println("Hola, soy " + this.getName() + ", mi contador vale " + cnt.valor()); \r
    }    \r
  }  \r
}\r
\r
class EjemploContador { \r
  // principal\r
  final static int nHebras = 20; \r
  public static void main(String[] args) {\r
    // metodo principal      \r
    final Contador cont1 = new Contador(10);       \r
    Usuario hebra[] = new Usuario[nHebras]; \r
    for (int i = 0; i < nHebras; i++) {          \r
      //crea hebras\r
      hebra[i] = new Usuario("la hebra-" + i, cont1); \r
      // lanza hebras      \r
      hebra[i].start(); }    \r
    } \r
  }\r
}\r
\`\`\`\r
\r
Es importante hacer notar, aunque suene a pesado, que todos los hilos acceden al código protegido del objeto cont1 que se crea en el método main. Así, no puede haber dos hilos ejecutando a la vez ninguna de los tres métodos de la instancia cont1 de la clase Contador.\r
\r
::: danger Usar final con objetos de tipo monitor\r
Un objeto usado como monitor, o como memoria compartida entre hilos, debería ser de tipo **final**, porque si se le asigna un nuevo valor quedan si efecto todos los bloqueos que existan sobre dicho objeto. Un objeto de tipo final una vez que se ha creado y se le ha asignado un valor no se le puede asignar un nuevo valor.\r
:::\r
\r
## 3.2.3 Sincronización entre hilos\r
\r
Ya hemos visto un tipo de problema en el que varios hilos comparten recursos y se sincroniza el acceso a estos recursos mediante el uso de monitores. Hasta ahora, una vez que un hilo obtiene el bloqueo de un monitor, puede hacer uso del mismo de forma indiscriminada, sin tener en cuenta ninguna otra condición.\r
\r
Ahora vamos a ver cómo, en función del estado de los recursos, cada uno de los hilos podrá realizar determinadas acciones o no, permitiendo que los hilos se queden a la espera de un cambio de estado que podrá ser notificado por otros hilos.\r
\r
Para ello, además de un mecanismo de bloque sobre los recursos compartidos, será necesario un mecanismo de espera para que, en el caso de que el estado de los recursos compartidos no permita a un hilo realizar una acción, la ejecución del hilo quede en suspenso a la espera de que esa condición se cumpla.\r
\r
El mecanismo es de **espera no activa**, es decir, no se debe consumir tiempo del procesador ni recursos del sistema para comprobar si es posible continuar con la ejecución, mientras no se reciba una notificación de que el estado ha cambiado y podría permitir que el hilo continúe su ejecución.\r
\r
Esto también nos permitirá, colateralmente, controlar el orden de ejecución de los hilos en función de la relación que se establezca entre ellos.\r
\r
Para resolver este tipo de situaciones volvemos a utilizar métodos de la clase Object, accesibles para cualquier objeto.\r
\r
- **wait()**: interrumpe la ejecución del hilo actual. La ejecución del hilo queda bloqueada mientras otro hilo no ejecute el método notify (o notifyAll) sobre el objeto. Este método, por tanto, proporciona un mecanismo de espera no activa.\r
- **notify()**: desbloquea uno de los hilos que están esperando sobre un objeto tras haber ejecutado el método wait()., de manera que pueda continuar su ejecución. Este método proporciona un mecanismo de notificación para terminar con la espera no activa de los hilos que están a la espera de un objeto de bloqueo. **El orden en que se desbloquean los hilos en un objeto de bloqueo vuelve a ser indeterminista** y no tiene porqué coincidir con el orden en que se bloquearon.\r
- **notifyAll()**: desbloquea todos los hilos que están esperando sobre un objeto de bloqueo tras haber ejecutado el método wait(), de manera que puedan continuar su ejecución.\r
\r
wait , notify and notifyAll se utilizan para permitir a los hilos comunicarse entre ellos mediante un mecanismo de *signal&continue*.\r
\r
::: danger Contexto de ejecución de los métodos de sincronización\r
El hilo que llama a wait(), notify() o notifyAll() debe tener el bloqueo del monitor del objeto sobre el que se llama. Si no lo tiene, se lanzará una excepción de tipo \`java.lang.IllegalMonitorStateException\`. \r
Por lo tanto, **estos métodos deben ser llamados desde un bloque sincronizado**.\r
:::\r
\r
Cuando se llama al método **wait()**, el hilo estará dentro de un bloque sincronizado, por lo tanto tendrá el bloqueo del monitor. En ese momento el hilo libera el bloqueo de *ese monitor* y se queda en una **cola (perteneciente al objeto) de hilos en espera de ser notificados**, diferente a la de los hilos que están esperando por el bloqueo.\r
\r
Cuando se desbloquea un hilo porque otro ha llamado a **notify()/notifyAll()**, el hilo vuelve al punto donde hizo el wait(), por lo tanto sigue dentro de un bloque sincronizado. Para poder continuar con la ejecución tendrá que pasar a la **cola de hilos esperando por el bloqueo** y esperar a ser seleccionado para seguir ejecutándose.\r
\r
![Colas de un monitor](../../media/unit3/Monitor_queues.png)\r
\r
\`\`\`java\r
synchronized(objBloqueo)\r
{\r
  while(!condiciónParaPoderSeguir) {\r
    try {\r
      // Espera que la condición cambie y otro hilo avise\r
      objBloqueo.wait()\r
    } catch (InterruptedException e) {}\r
  }\r
\r
  // Si el hilo ha llegado hasta aquí, significa que o bien al principio\r
  // o bien tras haber realizado una o más esperas y haber sido notificado\r
  // de cambios por parte de otros hilos, la condición se ha cumplido\r
\r
  // Además ha conseguido el bloqueo del monitor para poder continuar \r
  // dentro del bloque synchronized\r
  realizar_operación;\r
\r
  // Esta parte es opcional. La puede realizar este mismo hilo, en este \r
  // mismo método, o bien la puede realizar otro hilo en otro método\r
  if(condiciónParaQueOtrosSigan) {\r
    objetoBloqueo.notify(); // o objetoBloqueo.notifyAll()\r
  }  \r
}\r
\`\`\`\r
\r
En el ejemplo anterior, las condiciones suelen estar basadas en propiedades del propio objBloqueo, ya que de esta forma se mantiene un estado compartido por todos los hilos.\r
\r
Veamos ahora otro ejemplo\r
\r
\`\`\`java\r
// It is the common java class on which thread will act and call wait and notify method.\r
public class Book {\r
  String title;\r
  boolean isCompleted;\r
\r
  public Book(String title) {\r
    super();\r
    this.title = title;\r
  }\r
  public String getTitle() {\r
    return title;\r
  }\r
  public void setTitle(String title) {\r
    this.title = title;\r
  }\r
  public boolean isCompleted() {\r
    return isCompleted;\r
  }\r
  public void setCompleted(boolean isCompleted) {\r
    this.isCompleted = isCompleted;\r
  } \r
}\r
\`\`\`\r
\r
\`\`\`java{14,17}\r
// It will first take a lock on book object \r
// Then, the thread will wait until other thread call notify method, then after it will complete its processing. \r
// So in this example, it will wait for BookWriter to complete the book.\r
public class BookReader implements Runnable{\r
  Book book;\r
\r
  public BookReader(Book book) {\r
    super();\r
    this.book = book;\r
  }\r
\r
  @Override\r
  public void run() {\r
    synchronized (book) {\r
      System.out.println(Thread.currentThread().getName()+" is waiting for the book to be completed: "+book.getTitle());\r
      try {\r
        book.wait();\r
      } catch (InterruptedException e) {  \r
        e.printStackTrace();\r
      }\r
      System.out.println(Thread.currentThread().getName()+": Book has been completed now!! you can read it");\r
    }\r
  } \r
}\r
\`\`\`\r
\r
\`\`\`java{15,22,25}\r
// This class will notify thread(in case of notify) which is waiting on book object. \r
// It will not give away lock as soon as notify is called, it first complete its synchronized block. \r
// So in this example, BookWriter will complete the book and notify it to BookReaders. \r
public class BookWriter implements Runnable{\r
  Book book;\r
 \r
  public BookWriter(Book book) {\r
    super();\r
    this.book = book;\r
  }\r
 \r
  @Override\r
  public void run() {\r
    synchronized (book) {\r
      System.out.println("Author is Starting book : " +book.getTitle() );\r
      try {\r
        Thread.sleep(1000);\r
      } catch (InterruptedException e) {\r
        e.printStackTrace();\r
      }\r
      book.setCompleted(true);\r
      System.out.println("Book has been completed now");\r
 \r
      book.notify();\r
      System.out.println("notify one reader");\r
    } \r
  }\r
}\r
\`\`\`\r
\r
\`\`\`java{8,9,26}\r
// This is our main class which will create object of above classes and run it.\r
public class U3S5_Books {\r
\r
  public static void main(String args[])\r
  {\r
    // Book object on which wait and notify method will be called\r
    Book book=new Book("The Alchemist");\r
    BookReader johnReader=new BookReader(book);\r
    BookReader arpitReader=new BookReader(book);\r
\r
    // BookReader threads which will wait for completion of book\r
    Thread johnThread=new Thread(johnReader,"John");\r
    Thread arpitThread=new Thread(arpitReader,"Arpit");\r
\r
    arpitThread.start();\r
    johnThread.start();\r
\r
    // To ensure both readers started waiting for the book\r
    try {\r
      Thread.sleep(3000);\r
    } catch (InterruptedException e) {\r
      e.printStackTrace();\r
    }\r
\r
    // BookWriter thread which will notify once book get completed\r
    BookWriter bookWriter=new BookWriter(book);\r
    Thread bookWriterThread=new Thread(bookWriter);\r
    bookWriterThread.start();\r
  }\r
}\r
\`\`\`\r
\r
::: details Comentarios y preguntas sobre el código anterior\r
Si ejecutamos el código anterior, tenemos que hacernos varias preguntas:\r
\r
- a) ¿Cuántos wait() se hacen? ¿Y cuántos notify()?\r
\r
**Solución**: Se están haciendo 2 wait(), 1 por cada hilo BookReader y sólo un notify(), así que algo no cuadra.\r
\r
Uno de los lectores se queda sin notificar, por lo tanto un hilo se queda esperando en un wait(). Como ese hilo no termina, el proceso tampoco. Hay que recordar que un proceso no termina hasta que lo hace el último de sus hilos. Esto en Netbeans implica que el programa no acaba y lo tenemos que parar.\r
\r
**Solución**: En este caso tenemos dos alternativas. La primera pasa por usar notifyAll() en vez de notify(). De esta forma los dos BookReader se activan y se quedan a la espera de poder tomar el bloqueo del monitor. Uno lo hará primero y el otro después, pero los dos acabarán leyendo el libro.\r
La otra opción es, siguiendo con notify(), que cada lector cuando acabe de leer el libro notifique a otros posibles lectores que haya en espera para que uno se despierte y lea el libro.\r
\r
- b) En el main hemos hecho que primero empiecen los BookReaders y una vez que están esperando el BookWriter escriba el libro y avise. ¿Qué pasa si lo hacemos al revés o si los lanzamos todos juntos y no sabemos en qué orden se van a ejecutar?\r
\r
Si lanzamos primero el BookWriter, este acaba el libro y notifica a... nadie, porque los BookReaders todavía no estarán esperando. Después llegarán los BookReaders y se quedarán los dos colgados, ya que ningún otro hilo les notificará.\r
\r
**Solución**: Los hilos ahora mismo se están bloqueando de manera indiscriminada, pero realmente deben bloquearse sólo si el libro que quieren leer no está acabado. Por lo tanto tenemos que controlar con una condición el bloqueo de los BookReader. Tal y como hemos comentado las condiciones las debe tener el objeto compartido, en este caso book, que lo comparten el BookWriter y los dos BookReader. La condición que nos sirve para discriminar si un BookReader puede continuar o no es la propiedad isCompleted que consultamos a través del método book.isCompleted(),\r
\r
\`\`\`java\r
try {\r
  if (!book.isCompleted())\r
    book.wait();\r
} catch (InterruptedException e) { \r
\`\`\`\r
\r
Con esos dos cambios la aplicación debería funcionar con cualquier número de BookReaders y de BookWriters, sin importar el orden ni la cantidad.\r
:::\r
\r
::: info ¿notify() o notifyAll()?\r
Todo dependerá del sistema que estemos programando, pero por norma general, si queremos que tras modificar el estado del sistema sólo continúe un hilo, llamaremos a notify().\r
\r
Sino, debería utilizarse notifyAll(). Si todo está bien programado el hilo comprobará si puede seguir y, en caso contrario, volverá a hacer un wait() y seguir esperando, por eso no supone un problema que que más de un hilo se active.\r
\r
El uso de notify() supone un mayor riesgo de que se produzcan bloqueos indefinidos de hilos a la espera de notificaciones que nunca van a llegar, siendo este bloqueo diferente de un interbloqueo o deadlock. Debemos ser muy cuidadosos con la programación de los mecanismos de sincronización.\r
\r
Hay que tener en cuenta también que debería haber al menos una llamada notify() por cada wait() que se haya realizado, aunque eso tampoco asegura que algún hilo no se quede bloqueado.\r
:::\r
\r
::: question Modifica el ejemplo Sumador-Restador\r
Haz las modificaciones necesarias en las clases del proyecto U3S3_SharedMemory (guárdalo como U3S3_SharedMemory_v2) para que:\r
\r
- El primer hilo que haga una operación sobre el contador sea un Sumador\r
- Después de un Sumador siempre se ejecute un Restador y después de un Restador siempre se ejecute un Sumador, haciendo una secuencia Sumador-Restador-Sumador-Restador-...\r
:::\r
\r
::: details U3S3_SharedMemory_v2\r
\r
\`\`\`java\r
public class Contador {\r
\r
    private int c = 0;\r
    boolean ahoraSumador = true;\r
\r
    public Contador(int c) {\r
        this.c = c;\r
        ahoraSumador = true;\r
    }\r
\r
    public synchronized void incrementa() {\r
        while (!ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) {\r
            }\r
        }\r
\r
        // El hilo hace su tarea\r
        c++;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = false;\r
        notifyAll();\r
\r
    }\r
\r
    public synchronized void decrementa() {\r
        while (ahoraSumador) {\r
            try {\r
                wait();\r
            } catch (InterruptedException ex) { }\r
        }\r
\r
        // El hilo hace su tarea\r
        c--;\r
        System.out.println(Thread.currentThread().getName() + " " +  valor());\r
        \r
        // Cambia el estado y avisa al resto de hilos por si alguno puede seguir\r
        ahoraSumador = true;\r
        notifyAll();\r
    }\r
\r
    public int valor() {\r
        return c;\r
    }\r
}\r
\`\`\`\r
\r
En la clase Contador hemos incorporado un estado, que controla qué hilo es el que puede ejecutar y cuál el que tiene que esperar.\r
\r
Además, como se comenta más adelante, se ha movido la salida de los hilos a los métodos de esta clase.\r
\r
\`\`\`java\r
public class Restador  implements Runnable {\r
    private Contador c;\r
    private String name;\r
    public Restador(String name, Contador c) {\r
        // super(name);\r
        this.name = name;\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        Thread.currentThread().setName(this.name);\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.decrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }        \r
    }\r
}\r
\`\`\`\r
\r
Tanto Restador como Sumador siguen siendo prácticamente idénticos.\r
\r
\`\`\`java\r
public class Sumador  extends Thread {\r
    private Contador c;\r
    public Sumador(String name, Contador c) {\r
        super(name);\r
        this.c = c;\r
        \r
    }\r
    \r
    @Override\r
    public void run() {\r
        // Ejecutar 300 veces con espera entre 50ms y 150ms\r
        for (int i = 0; i < 300; i++) {\r
            try {\r
                c.incrementa();\r
                Thread.sleep((long) (Math.random() * 100 + 50));\r
            } catch (InterruptedException ex) {\r
                // Nothing\r
            }            \r
        }\r
    }\r
}\r
\`\`\`\r
\r
La clase principal se mantiene igual.\r
:::\r
\r
::: danger Salida sincronizada\r
Como se puede observar, la salida que en el ejemplo original se realizaba en el método run de Sumador y Restador, ahora se ha movido a la clase Contador, en concreto a los métodos \`synchronized\`.\r
\r
Hay que tener cuidado con la salida por pantalla. Todos los threads están usando System.out a la vez y los resultados que se muestran por pantalla, concretamente el orden en el que se muestran, no siempre es el mismo orden en el que se han producido. Por eso es importante que las salidas de los hilos se muevan dentro de los bloques sincronizados.\r
\r
Si no controlamos la forma de mostrar la salida podemos encontrarnos con problemas que están bien resueltos pero que la salida nos dice lo contrario.\r
:::\r
\r
`]},{title:"4 Introducción",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit4/",pathLocale:"/es/",extraFields:[`---\r
title: 4 Introducción\r
---\r
\r
# Tema 4. Programación en red\r
\r
Hasta ahora hemos visto como varias aplicaciones pueden colaborar entre sí para realizar una tarea de forma conjunta (\`multiproceso\`) o bien cómo un mismo programa puede dividir una tarea en partes que se ejecuten de forma concurrente y simultánea (\`multihilo\`). Todo esto ocurre dentro de una máquina, bien sea en **monoprocesador** o **multiprocesador**, controlados por un mismo SO y compartiendo habitualmente parte de la memoria y de la E/S.\r
\r
En este tema vamos a ir un paso más allá, vamos a crear aplicaciones que funcionen en entornos distribuidos. Volvemos a tener múltiples procesos en ejecución, pero a diferencia de lo que vimos en el tema 2, en el que los procesos tenían una relación padre-hijo (lanzador-lanzado), ahora los procesos se van a ejecutar en sistemas independientes y se comunicarán a través de la red usando \`protocolos de comunicación\`.\r
\r
Podemos encontrar básicamente dos modelos de sistemas distribuidos:\r
\r
- **Cliente / Servidor**: un proceso, denominado \`servidor\`, ofrece servicios a uno o más procesos, denominados \`clientes\`.\r
- **Entre iguales (P2P)**: todos los procesos colaboran de forma similar y con un mismo fin, no existiendo una especialización ni diferenciación entre ellos..\r
\r
::: warning Procesos e Hilos\r
Para realizar un programa distribuido en el que se pueda realizar una conexión y una comunicación a través de una red de ordenadores no partimos de cero. \r
\r
La programación en red está fuertemente ligada a la programación multiproceso. Principalmente en la forma de comunicación que ya vimos entre procesos.\r
\r
Por otro lado, la especialización y el servicio que ofrece un servidor, de forma simultánea a varios clientes, está basada en la división del trabajo en hilos.\r
\r
Por todo lo comentado, todos los conceptos y conocimientos adquiridos hasta ahora nos sirven de base para avanzar en los contenidos de este tema.\r
:::\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Conocer el protocolo TCP/IP, las direcciones usadas en cada capa y y los protocolos asociados.\r
- Conocer las clases que permiten trabajar con direcciones y nombres de servidores.\r
- Aprender las características básicas de los protocolos TCP y UDP.\r
- Desarrollar aplicaciones básicas que se comuniquen usando el protocolo TCP.\r
- Desarrollar aplicaciones básicas que se comuniquen usando el protocolo UDP.\r
- Diseñar y programar protocolos para la comunicación entre aplicaciones distribuidas.\r
- Coordinar la ejecución de múltiples clientes en servidores multihilo.\r
`]},{title:"4.2 Sockets TCP",headers:[{level:2,title:"4.2.1. Comunicación cliente/servidor con sockets TCP",slug:"_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",link:"#_4-2-1-comunicacion-cliente-servidor-con-sockets-tcp",children:[{level:3,title:"Programación de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.2.2. Cliente TCP",slug:"_4-2-2-cliente-tcp",link:"#_4-2-2-cliente-tcp",children:[{level:3,title:"Streams para E/S en los sockets",slug:"streams-para-e-s-en-los-sockets",link:"#streams-para-e-s-en-los-sockets",children:[]}]},{level:2,title:"4.2.3 Servidor TCP",slug:"_4-2-3-servidor-tcp",link:"#_4-2-3-servidor-tcp",children:[]},{level:2,title:"4.2.4 Servidor multihilo",slug:"_4-2-4-servidor-multihilo",link:"#_4-2-4-servidor-multihilo",children:[]}],path:"/es/unit4/sockets-tcp.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.2 Sockets TCP\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 Sockets TCP" />\r
\r
# 4.2 Sockets TCP\r
\r
[[toc]]\r
\r
## 4.2.1. Comunicación cliente/servidor con sockets TCP\r
\r
Oracle ha resumido el uso de los sockets en un breve tutorial. Todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about sockets](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)\r
\r
La interfaz Java que da soporte a sockets TCP está constituida por las clases **ServerSocket** y **Socket**.\r
\r
- ServerSocket: es utilizada por un servidor para crear un socket en el puerto en el que escucha las peticiones de conexión de los clientes. Su método \`accept\` toma una petición de conexión de la cola, o si la cola está vacía, se bloquea hasta que llega una petición.\r
  \r
  El resultado de ejecutar accept es una instancia de Socket, a través del cual el servidor tiene acceso a los datos enviados por el cliente.\r
\r
- Socket: es utilizada tanto por el cliente como por el servidor. El cliente crea un socket especificando el nombre DNS del host y el puerto del servidor, así se crea el socket local y además se conecta con el servicio.\r
  \r
  Esta clase proporciona los métodos \`getInputStream\` y \`getOutputStream\` para acceder a los dos streams asociados a un socket (recordemos que son bidireccionales), y devuelve tipos de datos InputStream y OutputStream, respectivamente, a partir de los cuales podemos construir \`BufferedReader\` y \`PrintWriter\`, respectivamente, para poder procesar los datos de forma más sencilla.\r
\r
### Programación de aplicaciones Cliente y/o Servidor\r
\r
Al crear aplicaciones cliente y servidor puede que nos encontremos con varios escenarios, a saber:\r
\r
- Si tenemos que programar solo el servidor **deberemos definir un protocolo** de comunicación para usar ese servidor.\r
- Si tenemos que programar solo el cliente **necesitaremos conocer el protocolo** de comunicación para conectar con ese servidor.\r
- Si tenemos que programar el cliente y el servidor, tendremos que empezar por **definir el protocolo** de comunicación entre ambos.\r
\r
::: info Herramientas para definir los protocolos\r
Dentro de todos los diagramas que ofrece UML, el diagrama de secuencia es el que mejor se adapta para definir los protocolos de comunicación entre clases y las interacciones que se producen.\r
\r
Para crear estos diagramas existen multitud de herramientas, tanto de escritorio como online. De todas ellas cabe destacar:\r
\r
- [Mermaid Live editor](https://mermaid.live/) que usa una [sintaxis en modo texto](https://mermaid-js.github.io/mermaid/#/sequenceDiagram) para definir los diagramas.\r
- [WebSequenceDiagrams](https://www.websequencediagrams.com/): Más visual y también con una definición textual de los diagramas.\r
- [Visual Paradigm Online](https://online.visual-paradigm.com/drive/#diagramlist:proj=0&dashboard): Herramienta totalmente visual y con unos resultados más espectaculares.\r
\r
Estas herramientas son las que tenéis que usar en las actividades en las que se os pida definir un protocolo de comunicación cliente / servidor.\r
:::\r
\r
## 4.2.2. Cliente TCP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente será:\r
\r
1. Crear un objeto de la clase Socket, indicando host y puerto donde corre el servicio.\r
2. Obtener las referencias al stream de entrada y al de salida al socket.\r
3. Leer desde y escribir en el stream de acuerdo al protocolo del servicio. Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar el socket.\r
\r
\`\`\`java{12,14,17,36,38,51,52,54}\r
public class BasicClient {\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que está en la misma máquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket("localhost", 4444);\r
            // Obtenemos el canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexión");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenvía al servidor hasta que este\r
        // se despide con "Adios"\r
        try {\r
            while (true) {\r
                // Leo la entrada del usuario\r
                linea = stdIn.nextLine();\r
                // La envia al servidor por el OutputStream\r
                salida.println(linea);\r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Envía a la salida estándar la respuesta del servidor\r
                System.out.println("Respuesta servidor: " + linea);\r
                // Si es "Adios" es que finaliza la comunicación\r
                if (linea.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
\r
        // Libera recursos\r
        salida.close();\r
        entrada.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\r
\`\`\`\r
::: info Herramientas para simular clientes genéricos\r
Si sólo tenemos que desarrollar un servidor y no tenemos o no queremos hacer un cliente para las pruebas, tenemos varias herramientas que nos ayudan a hacer de clientes genéricos, útiles para una gran variedad de servidores, incluso para servidores estándar como FTP, HTTP, etc.\r
\r
La primera herramienta es una aplicación y un protocolo de nivel de aplicación de TCP/IP, es la herramienta \`Telnet\`.\r
\r
Esta herramienta suele venir instalada en los sistemas GNU/Linux y OS X. Sin embargo en los sistemas Windows viene deshabilitada por defecto.\r
\r
Os dejo un enlace al artículo de Xataka [Telnet: qué es y cómo activarlo en Windows 10](https://www.xataka.com/basics/telnet-que-como-activarlo-windows-10).\r
\r
Es importante que lo activéis tanto en clase como en el aula.\r
\r
La segunda herramienta es NetCat. Es una herramienta muy versátil y potente, ya que no sólo puede hacernos de cliente, sino que también puede servir como servidor.\r
\r
Como muchas otras herramientas, esta también viene instalada de serie en GNU/Linux y OS X, pero no en Windows. Su uso en los sistemas de Microsoft es algo más controvertido ya que el sistema la detecta como un virus y tenemos que habilitar su uso en el *Guardian* del SO.\r
\r
Os dejo también un enlace a este artículo de IONOS [¿Qué es Netcat y cómo funciona?](https://www.ionos.es/digitalguide/servidores/herramientas/netcat/)\r
:::\r
\r
### Streams para E/S en los sockets\r
\r
Si vemos ejemplos en Internet o en tutoriales, podemos observar que hay dos formas mayoritarias de enviar y recibir la información a través de los streams que proporciona un socket.\r
\r
![Basic Stream IO](../../media/unit4/basicIOStreams.png)\r
\r
En cualquier caso, a través de los streams enviamos bytes, que es la forma más básica de generar información, bien sea a través de la red o entre procesos.\r
\r
Como es complicado gestionar a nivel de bytes toda la información que queremos enviar o recibir, usamos \`Decorators\` o \`Wrappers\` para enviar tipos de datos de un nivel de abstracción mayor.\r
\r
En los temas anteriores, cuando hemos tenido que intercambiar información entre procesos, hemos estado usando BufferedReader y PrintWriter. Estas clases trabajan a nivel de Strings, y son muy útiles cuando lo que queremos intercambiar a través de los streams son cadenas de texto.\r
\r
> En los protocolos de comunicaciones, más del 90% de la información que se intercambia, a nivel de protocolo, es en formato texto.\r
\r
Sin embargo, puede haber ocasiones en las que nos interese trabajar con tipos de datos.\r
\r
\`DataInputStream\` y \`DataOutputStream\` proporcionan métodos para leer y escribir Strings y todos los tipos de datos primitivos de Java, incluyendo números y valores booleanos. \r
\r
![Basic Stream IO](../../media/unit4/streamWrappers.png)\r
\r
DataOutputStream codifica esos valores de forma independiente de la máquina y los envía al stream de más bajo nivel para que los gestione como bytes. DataInputStream hace lo contrario.\r
\r
Así, podemos trabajar con DataInputStream y DataOutputStream a partir de los streams que nos proporcionan los sockets\r
\r
\`\`\`java\r
// Código en el cliente\r
DataInputStream dis = new DataInputStream(socket.getInputStream());\r
dis.readDouble();\r
\r
// Código en el servidor\r
DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\r
dis.writeDouble(number);\r
\`\`\`\r
\r
Los métodos \`readUTF()\` and \`writeUTF()\` de DataInputStream y DataOutputStream leen y escriben un String de caracteres Unicode usando la codificación UTF-8.\r
\r
::: warning Elige un método y usa siempre el mismo\r
Es muy importante no mezclar diferentes wrappers en el mismo sistema. Aunque todos acaban utilizando el InputStream y el OutputStream, las codificaciones y la forma de enviar la información no es la misma.\r
\r
Por lo que, si usas DataInputStream en el cliente para leer, debes usar DataOutputStream en el servidor para enviar. Además de usar los métodos complementarios para la lectura y escritura, por ejemplo readInt / writeInt.\r
:::\r
\r
Información extraída de [Learning Java, 4th Edition - O'Reilly](https://www.oreilly.com/library/view/learning-java-4th/9781449372477/ch12s01.html)\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.3 Servidor TCP\r
\r
La forma de implementar un servidor será:\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_states.png)\r
\r
1. Crear un objeto de la clase ServerSocket para escuchar peticiones en el puerto asignado al servicio.\r
2. Esperar solicitudes de clientes\r
3. Cuando se produce una solicitud:\r
    - Aceptar la conexión obteniendo un objeto de la clase Socket\r
    - Obtener las referencias al stream de entrada y al de salida al socket anterior.\r
    - Leer datos del socket, procesarlos y enviar respuestas al cliente, escribiendo en el stream del socket.Para ello emplear alguna de las facilidades del paquete java.io.\r
4. Cerrar los streams.\r
5. Cerrar los sockets.\r
\r
\`\`\`java{9,23,26,29,36,40,50,51,52,53}\r
public class BasicServer {\r
\r
    public static final int PORT = 4444;\r
\r
    public static void main(String[] args) throws IOException {\r
        // Establece el puerto en el que escucha peticiones\r
        ServerSocket socketServidor = null;\r
        try {\r
            socketServidor = new ServerSocket(PORT);\r
        } catch (IOException e) {\r
            System.out.println("No puede escuchar en el puerto: " + PORT);\r
            System.exit(-1);\r
        }\r
\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        System.out.println("Escuchando: " + socketServidor);\r
        try {\r
            // Se bloquea hasta que recibe alguna petición de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexión aceptada: " + socketCliente);\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Hace eco de lo que le proporciona el cliente, hasta que recibe "Adios"\r
            while (true) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
                // Envía a la salida estándar el mensaje del cliente\r
                System.out.println("Cliente: " + str);\r
                // Le envía la respuesta al cliente por el OutputStream                \r
                salida.println(str);\r
                // Si es "Adios" es que finaliza la comunicación\r
                if (str.equals("Adios")) {\r
                    break;\r
                }\r
            }\r
\r
        } catch (IOException e) {\r
            System.out.println("IOException: " + e.getMessage());\r
        }\r
        salida.close();\r
        entrada.close();\r
        socketCliente.close();\r
        socketServidor.close();\r
    }\r
\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/monothread_server_sequence.png)\r
\r
El servidor monohilo se encarga de realizar las operaciones de E/S con el cliente. Hasta que no acaba no puede hacer otro \`accept\` y atender a otro cliente.\r
\r
::: warning Local Name Resolver (hosts file)\r
Deberías saber que DNS traduce nombre de dominio en direcciones IP. Pero, ¿sabes que hay un archivo en tu sistema que puede sobrescribir esas traducciones?\r
\r
Es el archivo \`hosts\` y nos permite mapear nombre de dominio a direcciones IP. Tu archivo HOSTS sólo afecta al comportamiento de tu equipo, por lo que podemos usarlo para crear direcciones personalizadas para IP de nuestra red, o bien para redireccionar / bloquear el acceso a determinados sitios web.\r
\r
Como puedes imaginar, cambiar de forma incorrecta o **maliciosa** el contenido del archivo hOSTS puede romper fácilmente el comportamiento de tu conexión a Internet, Así que la modificación del archivo no es trivial para los usuarios, algo que es de agradecer.\r
\r
- Windows\r
\r
El archivo HOSTS está almacenado como un fichero de texto plano en la carpeta del sistema de Windows.\r
\r
Abre el menú inicio y escribe "notepad".\r
\r
Pulsa con el botón derecho y selecciona la opción de "Ejecutar como administrador"\r
\r
En Notepad, ve a Archivo > Abrir y pega la siguiente ruta:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Ahora ya puedes editar y guardar los cambios en tu archivo HOSTS.\r
\r
Para mapear un dominio, añade una nueva línea siguiendo los ejemplos que hay en el archivo.\r
\r
- OS X & GNU/Linux\r
\r
El archivo está en /etc/hosts y debes editarlo con privilegios de administrador.\r
\r
\`\`\`bash\r
# Añadimos las siguientes entradas al archivo hosts\r
## En clase \r
##  - como cliente y servidor ponemos la IP de nuestro equipo.\r
##  - como profesor ponemos la IP del ordenador del profesor\r
## En casa (la dirección probablemente tenga el formato 192.168.X.X)\r
##  - como cliente, servidor y profesor ponemos la IP de nuestro equipo.\r
\r
# En nuestras actividades, para no tener que ir cambiando las direcciones IP, usaremos \r
# siempre estos nombres de dominio, así los programas funcionarán tanto en clase como\r
# en casa.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.2.4 Servidor multihilo\r
\r
Si queremos que un servidor pueda atender varias peticiones de forma simultanea, debemos usar hilos para dotarle de esa capacidad.\r
\r
El flujo básico ahora cambiaría para adaptarse a este formato\r
\r
\`\`\`\r
while (true) {\r
\r
    Aceptar la conexión obteniendo un objeto de la clase Socket;\r
\r
    Crear un thread para que se encargue de la comunicación con ese cliente, es decir, \r
    para que gestione el socket obtenido en el accept.;\r
}\r
\`\`\`\r
![Estados de un servidor multihilo](../../media/unit4/multithread_server_states.png)\r
\r
El servidor multihilo crea un nuevo hilo que se encarga de las operaciones de E/S con el cliente. Mientras tanto puede esperar la conexión de nuevos clientes con los que volverá a hacer lo mismo.\r
\r
El servidor multihilo se ayuda de una clase \`Worker\` que hereda de Thread, pudiendo así ejecutarse concurrentemente con el hilo principal.\r
\r
Esta clase \`Worker\` es la encargada de realizar toda la comunicación con el cliente y el servidor. Para poder hacerlo, en su constructor recibe el Socket que se crea cuando se recibe  la conexión de un cliente \`ServerSocket.accept()\`.\r
\r
\`\`\`java {6,20,24}\r
public static final int PORT = 4444;\r
public static void main(String[] args)  {\r
    // Establece el puerto en el que escucha peticiones\r
    ServerSocket socketServidor = null;\r
    try {\r
        socketServidor = new ServerSocket(PORT);\r
    } catch (IOException e) {\r
        System.out.println("No puede escuchar en el puerto: " + PORT);\r
        System.exit(-1);\r
    }\r
\r
    Socket socketCliente = null;\r
\r
    System.out.println("Escuchando: " + socketServidor);\r
    try {\r
        \r
        while (true) {\r
            // Se bloquea hasta que recibe alguna petición de un cliente\r
            // abriendo un socket para el cliente\r
            socketCliente = socketServidor.accept();\r
            System.out.println("Conexión aceptada: " + socketCliente);\r
            // Para seguir aceptando peticiones de otros clientes\r
            // se crea un nuevo hilo que se encargará de la comunicación con el cliente\r
            new Worker(socketCliente).start();\r
        }\r
                        \r
    ...\r
}    \r
\`\`\`\r
\r
Y esta sería una implementación estándar de un worker\r
\r
\`\`\`java{13,15,22,26}\r
public class Worker extends Thread {\r
\r
    private Socket socketCliente;\r
    private BufferedReader entrada = null;\r
    private PrintWriter salida = null;\r
\r
    ....\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(new InputStreamReader(socketCliente.getInputStream()));\r
            // Establece canal de salida\r
            salida = new PrintWriter(new BufferedWriter(new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Realizamos la comunicación entre servidor y cliente\r
            // **** ES LO QUE CAMBIA EN CADA EJERCICIO ****\r
\r
            // Hacemos una recepción de información desde el cliente\r
            String mensajeRecibido = entrada.readLine();\r
            System.out.println("<-- Cliente: " + mensajeRecibido);\r
            \r
            // Hacemos un envío al cliente\r
            String mensajeEnviado = "Mensaje enviado desde el servidor al cliente";\r
            salida.println(mensajeEnviado);\r
            System.out.println("--> Cliente: " + mensajeEnviado);\r
        }\r
        ....\r
}        \r
\`\`\`\r
\r
Quedando ahora la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor monohilo](../../media/unit4/multithread_server_sequence.png)\r
\r
<div class="pagebreak"> </div>\r
\r
::: info Ejecución de múltiples clientes desde línea de comandos\r
Para poder lanzar varias aplicaciones java a la vez, la forma más correcta de hacerlo es desde una terminal de comandos. Esto nos permite poder pasarle argumentos a todas las clases, no sólo a la que está marcada como *principal* en el proyecto.\r
\r
Aquí tenemos dos posibilidades, **ejecutar las clases individualmente**, tal y como hacemos desde el IDE o bien **lanzar las clases desde un archivo JAR**.\r
\r
En ambos casos, necesitamos haber compilado y construido el proyecto (*F11 ó Shift+F11 en Netbeans*).\r
\r
Ejecución de clases individuales\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener las clases compiladas.\r
- A continuación, al igual que hacíamos con los procesos, debemos ubicarnos en la carpeta \`build/classes\` del proyecto.\r
- Desde ahí, ejecutaremos\r
    > build/classes$ java psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuación del nombre de la clase son los parámetros que la clase recibirá en el args[] de su método main.\r
\r
    y para la clase o clases que no sean las principales\r
    > build/classes$ java psp.actividades.U4AX_ClaseSCliente localhost 5566\r
\r
    Si queremos lanzar más de un cliente, repetiremos el comando desde otra ventana de comandos.\r
\r
Lanzar las clases desde un archivo JAR\r
\r
- Lo primero, tal y como se ha indicado anteriormente, debemos tener el proyecto construido\r
- A continuación, y a diferencia del caso anterior, debemos ubicarnos en el directorio donde esté el archivo JAR. Si no lo hemos movido, estará en la carpeta \`dist\` del proyecto.\r
- Desde ahí, ejecutaremos, **para la clase principal del proyecto**\r
    > dist$ java -jar U4AX_ProyectoClienteServidor.jar 5566\r
\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseServidor 5566\r
\r
    los valores que ponemos a continuación del nombre de la clase son los parámetros que la clase recibirá en el args[] de su método main.\r
\r
    y para la clase o clases que no sean las principales\r
    > dist$ java -cp U4AX_ProyectoClienteServidor.jar psp.actividades.U4AX_ClaseCliente localhost 5566\r
\r
    Si queremos lanzar más de un cliente, repetiremos el comando desde otra ventana de comandos.\r
:::`]},{title:"4.3 Sockets UDP",headers:[{level:2,title:"4.3.1. Comunicación cliente/servidor con sockets UDP",slug:"_4-3-1-comunicacion-cliente-servidor-con-sockets-udp",link:"#_4-3-1-comunicacion-cliente-servidor-con-sockets-udp",children:[{level:3,title:"DatagramSocket",slug:"datagramsocket",link:"#datagramsocket",children:[]},{level:3,title:"DatagramPacket",slug:"datagrampacket",link:"#datagrampacket",children:[]},{level:3,title:"Programación de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.3.2. Cliente UDP",slug:"_4-3-2-cliente-udp",link:"#_4-3-2-cliente-udp",children:[]},{level:2,title:"4.3.3 Servidor UDP",slug:"_4-3-3-servidor-udp",link:"#_4-3-3-servidor-udp",children:[]},{level:2,title:"4.3.4 Multicast socket",slug:"_4-3-4-multicast-socket",link:"#_4-3-4-multicast-socket",children:[]}],path:"/es/unit4/sockets-udp.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.3 Sockets UDP\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.3 Sockets UDP" />\r
\r
# 4.3 Sockets UDP\r
\r
[[toc]]\r
\r
## 4.3.1. Comunicación cliente/servidor con sockets UDP\r
\r
Igual que en el apartado anterior, Oracle proporciona una guía son información básica sobre el uso de los Sockets UDP. De nuevo, todo lo que podemos ver en ese tutorial lo vamos a ir comentando y ampliando en este apartado del tema\r
\r
[Tutorial de Oracle: All about datagrams](https://docs.oracle.com/javase/tutorial/networking/datagrams/index.html)\r
\r
::: info UDP - Protocolo sin conexión\r
El protocolo de comunicaciones con \`datagramas\` UDP, es un protocolo sin conexión, es decir, cada vez que se envíen datagramas es necesario enviar el descriptor del socket local y la dirección del socket que debe recibir el datagrama. Como se puede ver, hay que enviar datos adicionales cada vez que se realice una comunicación.\r
\r
Se trata de un servicio de transporte sin conexión. Son más eficientes que TCP, pero no está garantizada la fiabilidad: los datos se envían y reciben en paquetes, cuya entrega no está garantizada; los paquetes pueden ser duplicados, perdidos o llegar en un orden diferente al que se envió.\r
:::\r
\r
La interfaz Java que da soporte a sockets TCP está constituida por las clases **DatagramPacket** y **DatagramSocket**.\r
\r
- DatagramSocket: es la clase utilizada para realizar el envío y la recepción de los datos. A diferencia de los sockets TCP, esta clase no es la encargada de gestionar las direcciones ni de realizar la conexión, sólo se encarga de transportar los datos del origen al destino.\r
\r
    Lo único que se hace es enviar los datos, mediante la creación de un socket y utilizando los métodos de envío y recepción apropiados.\r
\r
    Esta clase proporciona los métodos \`send\` y \`receive\`.\r
\r
- DatagramPackets: esta clase es la encargada de incluir la información que se quiere enviar/recibir y la información de direccionamiento, es decir, la dirección a la que se quiere enviar l información que contiene.\r
  \r
   DatagramPacket contiene la información relevante. Cuando se desea recibir un datagrama, éste deberá almacenarse bien en un buffer o un array de bytes. Y cuando preparamos un datagrama para ser enviado, el DatagramPacket no sólo debe tener la información, sino que además debe tener la dirección IP y el puerto de destino.\r
\r
::: warning Puertos duplicados UDP / TCP\r
Dado que la gestión de los puertos y el protocolo que se utiliza es diferente, podemos usar el mismo número de puerto para un servicio que use el protocolo TCP y otro servicio, en el mismo puerto, que use UDP.\r
\r
En realidad, un socket además de IP_origen, Puerto_origen, IP_destino, Puerto_destino, también incluye el protocolo usado, por eso un socket con el mismo origen y destino, es diferente y puede ser usado a al vez por UDP y TCP\r
\r
**Socket = [Protocolo (TCP/UDP) + IP_origen + Puerto_origen + IP_destino + Puerto_destino]**\r
:::\r
\r
### DatagramSocket\r
\r
Esta clase proporciona los siguiente métodos\r
\r
| Método | Descripción |\r
| --- | ----------- |\r
| public DatagramSocket () throws SocketException | Se encarga de construir un socket para datagramas y de conectarlo al primer puerto disponible. |\r
| public DatagramSocket (int port) throws SocketException | Ídem, pero con la salvedad de que permite especificar el número de puerto asociado. |\r
| public DatagramSocket (int port, InetAddress ip) throws SocketException | Permite especificar, además del puerto, la dirección local a la que se va a asociar el socket. |\r
| public int getLocalPort() | Retorna el número de puerto en el host local al que está conectado el socket. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Envía un DatagramPacket a través del socket. |\r
| **public setSoTimeout(int timeout)** | Permite establecer un tiempo de espera límite para que el método receive se quede bloqueado esperando a recibir una respuesta por parte del otro extremo. Si no reciben datos en el tiempo fijado se lanza la excepción \`InterruptedIOException\` |\r
\r
El DatagramSocket, cuando se utiliza en la parte receptora (la que vamos a llamar servidora) que ofrece el servicio para que los clientes se conecten, sólo va a indicar el puerto al que esos clientes deben enviar sus solicitudes. En el caso de los procesos que actúen como clientes, se usará el constructor sin parámetros para que sea el SO el que asigne un puerto libre.\r
\r
Por lo tanto, un mismo DatagramSocket al no incluir ninguna información de direccionamiento puede ser reutilizado para enviar y/o recibir datagramas a/desde diferentes destinos.\r
\r
### DatagramPacket\r
\r
La clase \`DatagramPacket\` como se ha indicado anteriormente, es un contenedor del mensaje y del destino de ese mensaje.\r
\r
![Datagram Packet](../../media/unit4/datagrampacket.svg)\r
\r
Esta clase proporciona los siguiente métodos\r
\r
| Método | Descripción |\r
| --- | ----------- |\r
| public DatagramPacket(byte ibuf[], int  ilength)  | Implementa un DatagramPacket para la **recepción** de paquetes de longitud ilength, siendo el valor de este parámetro menor o igual que ibuf.length. |\r
| public DatagramPacket(byte ibuf[], int ilength, InetAddress iaddr, int iport)  | Implementa un DatagramPacket para el **envío** de paquetes de longitud ilength al número de puerto especificado en el parámetro iport, del host especificado en la dirección de destino que se le pasa por medio del parámetro iaddr. |\r
| public InetAddress getAddress () | Retorna la dirección IP del host al cual se le envía el datagrama o del que el datagrama se recibió. |\r
| public byte[] getData() | Retorna los **datos a recibir** o a enviar. |\r
| public int getLength() | Retorna la longitud de los datos a enviar o a recibir. |\r
| public int getPort() | Retorna el número de puerto de la máquina remota a la que se le va a enviar el datagrama o del que se recibió. |\r
\r
Como se intuye de la descripción de los métodos, la forma de crear el datagrama va a depender de si queremos enviar o recibir la información, ya que en cada uno de estas acciones tendremos que indicar dónde van dirigidos esos datos (envío) o bien esa información ya vendrá incluida en el datagrama (recepción) y podremos acceder a ella a través de los métodos getter de la clase.\r
\r
Es importante hacer ver que la información debe enviarse como un array de bytes y que se recibe de la misma forma, por lo que tendremos que usar los métodos de String o de cualquiera de los otros tipos primitivos de Java para convertirlos a bytes.\r
\r
### Programación de aplicaciones Cliente y/o Servidor\r
\r
En el caso de aplicaciones UDP, el protocolo de comunicación no tiene sentido a nivel de capa de transporte, ya que sólo se envían y reciben mensajes y hablamos de un \`protocolo no orientado a conexión\`, por lo tanto no sirve para realizar confirmaciones o diálogos entre la parte servidora y cliente.\r
\r
La parte del protocolo se delega en una capa superior, que será la encargada de gestionar la comunicación a un nivel de abstracción mayor.\r
\r
De todas formas, la comunicación entre ambas partes debe seguir estando sincronizada en los que a envíos / respuestas se refiere para no dejar a la otra parte bloqueada en las lecturas.\r
\r
::: info Bloqueo de lecturas con timeout\r
Esta característica, también disponible para los sockets TCP, permite evitar un bloqueo infinito de un hilo a la espera de recibir datos del otro extremo del socket.\r
\r
Es de especial importancia en la gestión de las comunicaciones UDP ya que, como hemos dicho, no tienen porqué seguir un protocolo preestablecido a nivel de transporte.\r
\r
Con el método \`setSoTimeout\` de DatagramSocket podemos fijar un tiempo de espera máximo para la recepción de datos a través del socket.\r
:::\r
\r
## 4.3.2. Cliente UDP\r
\r
Si nos centramos en la parte de comunicaciones, la forma general de implementar un cliente será:\r
\r
1. El cliente creará un socket para comunicarse con el servidor. Para enviar datagramas necesita conocer su IP y el puerto por el que escucha.\r
2. Utilizará el método send() del socket para enviar la petición en forma de datagrama.\r
    - La información se envia en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
3. Permanece a la espera de recibir respuesta\r
4. El cliente recibe la respuesta del servidor mediante el método receive() del socket.\r
    - La información se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
5. Cerrar y liberar los recursos.\r
\r
\`\`\`java{10,14,17,20,28,31}\r
public class BasicUDP_Client {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // IP y puerto al que se envía el Datagrama\r
        InetAddress destino = InetAddress.getLocalHost();\r
        int port = 12345; \r
        \r
        // Buffer para recibir el datagrama\r
        byte[] buffer = new byte[1024];\r
        \r
        // El mensaje a enviar en el Datagrama se convierte a bytes\r
        String mensajeEnviado = "Enviando Saludos !!";\r
        buffer = mensajeEnviado.getBytes(); //codifico String a bytes\r
\r
        // Se preparara el DatagramPacket que se va a enviar\r
        DatagramPacket datagramaEnviado = new DatagramPacket(buffer, buffer.length, destino, port);\r
        // En este caso, especificamos un puerto, aunque podríamos dejarlo para\r
        // que el SO asigne uno libre\r
        DatagramSocket socket = new DatagramSocket(34567);\r
        \r
        System.out.println("Host destino : " + destino.getHostName());\r
        System.out.println("IP Destino : " + destino.getHostAddress());\r
        System.out.println("Puerto local del socket: " + socket.getLocalPort());\r
        System.out.println("Puerto al que envio: " + datagramaEnviado.getPort());\r
\r
        // Envío del Datagrama\r
        socket.send(datagramaEnviado);\r
        \r
        // Cierre y liberación de recursos       \r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.3 Servidor UDP\r
\r
En los sockets UDP no se establece conexión. A pesar de que cuando los programamos sí existen diferencias entre el servidor y el cliente, estas no son tan claras como con los sockets TCP. La funcionalidad y el código que diferencia a un servidor de un cliente está más diluido.\r
\r
> Podemos considerar servidor al que espera un mensaje y responde; y cliente al que inicia la comunicación.\r
\r
Tanto uno como otro si desean ponerse en contacto necesitan saber en qué ordenador y en qué puerto está escuchando el otro.\r
\r
1. El servidor crea un socket asociado a un puerto local para escuchar peticiones de clientes.\r
2. Permanece a la espera de recibir peticiones.\r
3. El servidor recibe las peticiones mediante el método receive() del socket.\r
    - La información se recibe en un objeto de tipo DatagramPacket\r
    - El DatagramPacket almacena el contenido del mensaje en un array de bytes\r
4. En el datagrama recibido va incluido además del mensaje, el puerto y la IP del cliente emisor de la petición; lo que le permite al servidor conocer la dirección del emisor del datagrama. Utilizando el método send() del socket puede enviar la respuesta al cliente emisor.\r
5. El servidor permanece a la espera de recibir más peticiones.\r
6. Cerrar y liberar los recursos.\r
\r
\`\`\`java{6,10,18,20,21,33}\r
public class BasicUDP_Server {\r
\r
    public static void main(String[] argv) throws Exception {\r
\r
        // Buffer para recibir el datagrama\r
        byte[] bufer = new byte[1024];\r
\r
        // El Socket del servidor se asocia a un puerto para que los clientes\r
        // puedan enviar peticiones.\r
        DatagramSocket socket = new DatagramSocket(12345);\r
\r
        // Se espera la llegada de un DATAGRAMA\r
        // Al igual que con TCP, esta llamada a receive es bloqueante\r
        // y es la que tiene que marcar la sincronización entre lecturas y \r
        // escrituras de las app cliente / servidor\r
        System.out.println("Esperando Datagrama ................");\r
        // Se crea el objeto que almacenará el mensaje enviado por el cliente\r
        DatagramPacket datagramaRecibido = new DatagramPacket(bufer, bufer.length);\r
        // Se espera el mensaje y se le pasa el datagrama para que lo almacene ahí\r
        socket.receive(datagramaRecibido);\r
        String mensajeRecibido = new String(datagramaRecibido.getData());\r
\r
        //Información recibida\r
        System.out.println("Número de Bytes recibidos: " + datagramaRecibido.getLength());\r
        System.out.println("Contenido del Paquete    : " + mensajeRecibido.trim());\r
\r
        System.out.println("Puerto origen del mensaje: " + datagramaRecibido.getPort());\r
\r
        System.out.println("IP de origen             : " + datagramaRecibido.getAddress().getHostAddress());\r
        System.out.println("Puerto destino del mensaje:" + socket.getLocalPort());\r
\r
        // Liberamos los recursos\r
        socket.close(); \r
    }\r
}\r
\`\`\`\r
\r
Quedando la secuencia de acciones entre el cliente y el servidor de la siguiente manera\r
\r
![Estados de un servidor UDP](../../media/unit4/udp_process.png)\r
\r
Veamos ahora un ejemplo completo de C/S UDP\r
\r
\`\`\`java\r
public class BasicUDP_Client2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // FLUJO PARA ENTRADA ESTANDAR\r
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\r
\r
        DatagramSocket clientSocket = new DatagramSocket();\r
        byte[] enviados = new byte[1024];\r
        byte[] recibidos = new byte[1024];\r
\r
        // DATOS DEL SERVIDOR al que enviar mensaje\r
        InetAddress IPServidor = InetAddress.getLocalHost();// localhost\r
        int puerto = 9876; // puerto por el que escucha\r
\r
        // INTRODUCIR DATOS POR TECLADO\r
        System.out.print("Introduce mensaje: ");\r
        String cadena = in.readLine();\r
        enviados = cadena.getBytes();\r
\r
        // ENVIANDO DATAGRAMA AL SERVIDOR\r
        System.out.println("Enviando " + enviados.length + " bytes al servidor.");\r
        DatagramPacket envio = new DatagramPacket(enviados, enviados.length, IPServidor, puerto);\r
        clientSocket.send(envio);\r
\r
        // RECIBIENDO DATAGRAMA DEL SERVIDOR\r
        DatagramPacket recibo = new DatagramPacket(recibidos, recibidos.length);\r
        System.out.println("Esperando datagrama....");\r
        clientSocket.receive(recibo);\r
        String mayuscula = new String(recibo.getData());\r
\r
        // OBTENIENDO INFORMACIÓN DEL DATAGRAMA\r
        InetAddress IPOrigen = recibo.getAddress();\r
        int puertoOrigen = recibo.getPort();\r
        System.out.println("\\tProcedente de: " + IPOrigen + ":" + puertoOrigen);\r
        System.out.println("\\tDatos: " + mayuscula.trim());\r
\r
        //cerrar socket\r
        clientSocket.close();\r
\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class BasicUDP_Server2 {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Puerto por el que escucha el servidor: 9876\r
        DatagramSocket serverSocket = new DatagramSocket(9876);\r
        byte[] recibidos = new byte[1024];\r
        byte[] enviados = new byte[1024];\r
        String cadena;\r
\r
        while (true) {\r
            System.out.println("Esperando datagrama.....");\r
\r
            //RECIBO DATAGRAMA\r
            recibidos = new byte[1024];\r
            DatagramPacket paqRecibido = new DatagramPacket(recibidos, recibidos.length);\r
            serverSocket.receive(paqRecibido);\r
            cadena = new String(paqRecibido.getData());\r
\r
            //DIRECCION ORIGEN\r
            InetAddress IPOrigen = paqRecibido.getAddress();\r
            int puerto = paqRecibido.getPort();\r
            System.out.println("\\tOrigen: " + IPOrigen + ":" + puerto);\r
            System.out.println("\\tMensaje recibido: " + cadena.trim());\r
\r
            //CONVERTIR CADENA A MAYÚSCULA\r
            String mayuscula = cadena.trim().toUpperCase();\r
            enviados = mayuscula.getBytes();\r
\r
            //ENVIO DATAGRAMA AL CLIENTE\r
            DatagramPacket paqEnviado = new DatagramPacket(enviados, enviados.length, IPOrigen, puerto);\r
            serverSocket.send(paqEnviado);\r
\r
            // Condición de finalización\r
            if (cadena.trim().equals("*")) {\r
                break;\r
            }\r
\r
        }//Fin de while\r
\r
        serverSocket.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
<div class="pagebreak"> </div>\r
\r
## 4.3.4 Multicast socket\r
\r
La clase MulticastSocket es útil para enviar paquetes a múltiples destinos simultáneamente.\r
\r
Para poder recibir estos paquetes es necesario establecer un grupo multicast, que es un grupo de direcciones IP que comparten el mismo número de puerto.\r
\r
Cuando se envía un mensaje a un grupo de multicast, todos los que pertenezcan a ese grupo recibirán el mensaje.\r
\r
La pertenencia al grupo es transparente al emisor, es decir, el emisor no conoce el número de miembros del grupo ni sus direcciones IP.\r
\r
::: info Grupo multicast\r
\r
Un grupo multicast se especifica mediante una dirección IP de clase D y un número de puerto UDP estándar.\r
\r
Las direcciones desde la 224.0.0.0 a la 239.255.255.255 están destinadas para ser direcciones de multicast.\r
\r
La dirección 224.0.0.0 está reservada y no debe ser utilizada.\r
:::\r
\r
Los métodos que proporciona la clase MulticastSocket son\r
\r
| Método | Descripción |\r
| --- | ----------- |\r
|  MulticastSocket() throws IOException  | Construye un socket multicast dejando al SO que asigne un puerto libre. |\r
|  MulticastSocket(int port) throws IOException  | Construye un socket multicast y lo conecta al puerto local especificado. |\r
| public void **receive** (DatagramPacket p) throws IOException | Recibe un DatagramPacket del socket, y llena el buffer con los datos que recibe. |\r
| public void **send** (DatagramPacket p) throws IOException | Envía un DatagramPacket a través del socket. |\r
| joinGroup( InetAddress multicastAddress) | Permite al socket unirse al grupo de multicast. A partir de ese momento podrá recibir los mensajes que se envían a esa dirección. Un MulticastSocket puede estar unido a más de un grupo multicast. |\r
| leaveGroup( InetAddress multicastAddress) | Permite al socket abandonar el grupo de multicast |\r
\r
Y a continuación presentamos el esquema de llamadas seguido por un **servidor multicast**\r
\r
1. Se crea el socket multicast. No hace falta especificar puerto\r
    > MulticastSocket ms = new MulticastSocket();\r
\r
2. Se define el puerto multicast\r
    > int Puerto = 12345;\r
\r
3. Se crea el grupo multicast\r
    > InetAddress grupo = InetAddress.getByName(“225.0.0.1”);\r
\r
4. Se crea el datagrama\r
    > DatagramPacket paquete = new DatagramPacket(msg.getBytes(), msg.length(), grupo, Puerto);\r
\r
5. Se envía el paquete al grupo\r
    > ms.send(paquete);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
y el esquema de llamadas seguido por un **cliente multicast**\r
\r
1. Se crea un socket multicast en el puerto establecido\r
    > MulticastSocket ms = new MulticastSocket(12345);\r
\r
2. Se configura la IP del grupo al que nos conectaremos\r
    > InetAddress grupo = InetAddress.getByName(“225.0.0.1”);\r
\r
3. Se une al grupo\r
    > ms.joinGroup(grupo);\r
\r
4. Recibe el paquete del servidor multicast\r
\r
    > byte[] buf = new byte[1000];\r
DatagramPacket recibido = new DatagramPacket(buf, buf.length);\r
ms.receive(recibido);\r
\r
5. Salimos del grupo multicast:\r
    > ms.leaveGroup(grupo);\r
\r
6. Se cierra el socket\r
    > ms.close();\r
\r
Y ahora lo vemos todo junto con un ejemplo\r
\r
\`\`\`java\r
public class U4_BasicMulticastServer {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        // Enviamos la información introducida por teclado hasta que se envíe un *        \r
        Scanner in = new Scanner(System.in);\r
\r
        //Se crea el socket multicast.\r
        MulticastSocket ms = new MulticastSocket();\r
        // Se escoge un puerto para el server\r
        int puerto = 12345;\r
        // Se escoge una dirección para el grupo\r
        InetAddress grupoMulticast = InetAddress.getByName("225.0.0.1");\r
\r
        String cadena = "";\r
        while (!cadena.trim().equals("*")) {\r
\r
            System.out.print("Datos a enviar al grupo: ");\r
            cadena = in.nextLine();\r
\r
            // Enviamos el mensaje a todos los clientes que se hayan unido al grupo\r
            DatagramPacket paquete = new DatagramPacket(cadena.getBytes(), cadena.length(), grupoMulticast, puerto);\r
            ms.send(paquete);\r
        }\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
\`\`\`java\r
public class U4_BasicMulticastClient {\r
\r
    public static void main(String args[]) throws Exception {\r
\r
        //Se crea el socket multicast\r
        // El puerto debe ser el mismo en todos los clientes, ya que el \r
        // servidor multicast envía la información a la IP multicast y a un puerto\r
        int puerto = 12345;//Puerto multicast\r
        MulticastSocket ms = new MulticastSocket(puerto);\r
\r
        //Nos unimos al grupo multicast\r
        InetAddress grupo = InetAddress.getByName("225.0.0.1");\r
        ms.joinGroup(grupo);\r
        String msg = "";\r
\r
        while (!msg.trim().equals("*")) {\r
            // El buffer se crea dentro del bucle para que se sobrescriba \r
            // con cada nuevo mensaje\r
            byte[] buf = new byte[1000];\r
            DatagramPacket paquete = new DatagramPacket(buf, buf.length);\r
            //Recibe el paquete del servidor multicast\r
            ms.receive(paquete);\r
            msg = new String(paquete.getData());\r
            System.out.println("Recibo: " + msg.trim());\r
        }\r
\r
        // Abandonamos grupo\r
        ms.leaveGroup(grupo);\r
\r
        // Cerramos recursos\r
        ms.close();\r
        System.out.println("Socket cerrado...");\r
    }\r
}\r
\`\`\`\r
\r
::: info mezcla de sockets en una app\r
Ya hemos visto todo el abanico de posibilidades que tenemos para comunicar dos procesos en red.\r
\r
A partir de este momento, en nuestras aplicaciones no sólo tenemos que elegir uno de ellos, sino que podemos tener varios sockets, de diferente tipo, para comunicar los clientes y los servidores.\r
\r
Se trata ahora de analizar en qué situación es más conveniente un tipo que otro y usarlo. Podemos ayudarnos de la creación de hilos que estén "especializados" en el envío y/o recepción de información de un socket, permitiendo que se intercambien varios mensajes a la vez.\r
:::\r
`]},{title:"4.4 Protocolos con estado",headers:[{level:2,title:"4.4.1. Protocolos con y sin estado",slug:"_4-4-1-protocolos-con-y-sin-estado",link:"#_4-4-1-protocolos-con-y-sin-estado",children:[{level:3,title:"Protocolos sin estado",slug:"protocolos-sin-estado",link:"#protocolos-sin-estado",children:[]},{level:3,title:"Protocolos con estado",slug:"protocolos-con-estado",link:"#protocolos-con-estado",children:[]}]},{level:2,title:"4.4.2 Programación de servidores basados en estados",slug:"_4-4-2-programacion-de-servidores-basados-en-estados",link:"#_4-4-2-programacion-de-servidores-basados-en-estados",children:[{level:3,title:"Programación de aplicaciones Cliente y/o Servidor",slug:"programacion-de-aplicaciones-cliente-y-o-servidor",link:"#programacion-de-aplicaciones-cliente-y-o-servidor",children:[]}]},{level:2,title:"4.4.3. Ejemplo de servidor con estados",slug:"_4-4-3-ejemplo-de-servidor-con-estados",link:"#_4-4-3-ejemplo-de-servidor-con-estados",children:[{level:3,title:"Ejemplo del Worker que implementa el protocolo",slug:"ejemplo-del-worker-que-implementa-el-protocolo",link:"#ejemplo-del-worker-que-implementa-el-protocolo",children:[]}]},{level:2,title:"4.4.4. Ejemplo de cliente con estados",slug:"_4-4-4-ejemplo-de-cliente-con-estados",link:"#_4-4-4-ejemplo-de-cliente-con-estados",children:[{level:3,title:'Ejemplo de cliente "genérico" que implementa el protocolo',slug:"ejemplo-de-cliente-generico-que-implementa-el-protocolo",link:"#ejemplo-de-cliente-generico-que-implementa-el-protocolo",children:[]}]}],path:"/es/unit4/stateful-protocols.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.4 Protocolos con estado\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.4 Protocolos con estado" />\r
\r
# 4.4 Protocolos con estado\r
\r
[[toc]]\r
\r
## 4.4.1. Protocolos con y sin estado\r
\r
Como ya hemos comentado anteriormente, un protocolo, aplicado al mundo de las comunicaciones informáticas, es un conjunto de reglas que especifican la manera en la que se realiza la comunicación entre dos interlocutores.\r
\r
Este conjunto de reglas establece el formato de los mensajes que se intercambian \`(texto, binario, JSON, XML, CSV, ...)\`, las acciones que cada uno de los extremos de la comunicación deben realizar en cada momento \`(envío o recepción)\` y, lo que nos ocupa en este apartado del tema, si las acciones dependen de acciones anteriores o no.\r
\r
### Protocolos sin estado\r
\r
En informática, un protocolo sin estado es un protocolo de comunicaciones que trata cada petición como una transacción independiente que no tiene relación con cualquier solicitud anterior, de modo que la comunicación se compone de pares independientes de solicitud y respuesta.\r
[Wikipedia: Protocolo sin estado](https://es.wikipedia.org/wiki/Protocolo_sin_estado)\r
\r
El ejemplo más conocido de protocolo sin estado es HTTP.1​ El protocolo no proporciona medio alguno de almacenamiento de datos de un usuario entre las peticiones, dejando esta tarea a niveles superiores y haciendo necesario el reenvío de información de manera continua para simular un funcionamiento con estado (cookies, cabeceras, etc.).\r
\r
### Protocolos con estado\r
\r
Un protocolo sin estado no requiere que el servidor retenga información de la sesión o de estado acerca de los intercambios de información durante la realización de múltiples peticiones. En contraste, un protocolo que requiere el mantenimiento del **estado interno en el servidor** se conoce como un **protocolo con estado**.\r
\r
Por lo tanto, un estado es una configuración en un programa o máquina que depende de los estados anteriores y que determina el funcionamiento del sistema, en función de la entrada recibida y del estado actual en el que se encuentre el sistema.\r
\r
Poniendo una analogía, podemos tomar una solicitud a la administración, donde debemos realizar varios pasos hasta resolver la solicitud.\r
\r
1. En primer lugar se rellena una instancia con los datos y se envía al departamento correspondiente.\r
2. Ese departamento comprobará la instancia recibida y contestará solicitando información adicional o confirmando que la solicitud se ha recibido correctamente.\r
3. En un proceso posterior, se solicita un pago de tasas al usuario.\r
4. El usuario tiene que realizar el pago de tasas y enviar el justificante.\r
5. Tras cotejar toda la información, se le solicita al usuario que aporte los documentos originales.\r
6. El usuario se persona para mostrar la documentación original\r
7. Finalmente se resuelve la solicitud informando al usuario el resultado de la misma.\r
\r
Esto, que puede ser un procedimiento normal, refleja claramente un proceso en el que se siguen una serie de pasos y cuyo orden no se puede cambiar.\r
\r
Por ejemplo, no tendría sentido hacer el pago de las tasas (paso 4) sin antes haber presentado la solicitud (paso 1) o sin haber recibido la confirmación de que la solicitud está completa.\r
\r
Esto mismo pasa con algunos protocolos de comunicación.\r
\r
## 4.4.2 Programación de servidores basados en estados\r
\r
Hay toda una teoría matemática, \`la teoría de grafos\`, desarrollada en torno a esto, junto con un modelo computacional, \`los autómatas finitos\`, que estudian y optimizan el desarrollo de aplicaciones basadas en estados.\r
\r
La teoría de grafos es una rama de las matemáticas y las ciencias de la computación que estudia las propiedades de los grafos\r
\r
La teoría de grafos tiene sus fundamentos en las \`matemáticas discretas\` y de las \`matemáticas aplicadas\`. Esta teoría requiere de diferentes conceptos de diversas áreas como **combinatoria, álgebra, probabilidad, geometría de polígonos, aritmética y topología**. Actualmente ha tenido mayor influencia en el campo de la informática, las ciencias de la computación y telecomunicaciones. Debido a la gran cantidad de aplicaciones en la optimización de recorridos, procesos, flujos y algoritmos de búsquedas, entre otros\r
\r
Un autómata finito o máquina de estado finito es un modelo computacional que toma decisiones de computación de forma automática sobre una entrada para producir una salida.\r
\r
Este modelo está conformado por un alfabeto, un conjunto de estados finito, una función de transición, un estado inicial y un conjunto de estados finales.\r
\r
La finalidad de los autómatas finitos, entre otras, es la de reconocer lenguajes regulares, que corresponden a los lenguajes formales más simples según la Jerarquía de Chomsky.\r
\r
### Programación de aplicaciones Cliente y/o Servidor\r
\r
Como en todos los casos que hemos estudiado con anterioridad, el protocolo es la pieza común entre los clientes y los servidores.\r
\r
Nuestros clientes podrán estar bien o mal programados, de hecho muchos de nuestros clientes son interactivos, por lo que podemos alterar el orden de los comandos a nuestro antojo, no siendo esto ningún problema.\r
\r
Debe ser el servidor el que tenga el control del proceso, el que asegure la integridad del sistema y de los datos, por lo tanto va a ser en la parte del servidor donde tengamos que realizar las modificaciones para adaptarlo al control y gestión de los estados.\r
\r
Esto no quita que los clientes deban seguir \`sincronizados\` con el servidor para evitar situaciones de interbloqueo, ya que de una forma u otra el cliente siempre debe seguir el protocolo, aunque no los estados tal y como hemos dicho.\r
\r
## 4.4.3. Ejemplo de servidor con estados\r
\r
Vamos a ver qué pasos debemos seguir para controlar los estados en el servidor y cómo adaptar un cliente.\r
\r
El ejemplo que vamos a utilizar es el de la actividad  \`U4A03_ProtocoloSaludo\`. Primero vamos a aclarar cómo debe funcionar este protocolo.\r
\r
Si el cliente está bien programado, el intercambio de información entre Cliente y Servidor se realiza en tres pasos\r
\r
1. Cliente envía "Hi Server!"\r
2. Servidor responde "Hi Client!"\r
3. Cliente responde "By Server!"\r
\r
Ante un funcionamiento normal, este protocolo es bastante fácil de implementar. Sin embargo,\r
\r
- ¿Qué pasa si el cliente envía "By Server!" como primer mensaje?\r
- ¿Qué debe responder el servidor si no recibe el mensaje que está esperando?\r
- ¿Qué debe hacer el cliente si no recibe el mensaje que está esperando?\r
\r
Estas son las circunstancias a las que debemos responder con los estados del protocolo, indicando en cada caso qué debe hacer cada una de las partes. Todo dependerá de la funcionalidad que esté implementando el protocolo.\r
\r
Cada caso es diferente, por ejemplo, si es importante hacer los tres pasos en orden, ante cualquier fallo se debe volver a empezar (un borrado en una BD, una autenticación de tres vías). Si por el contrario, los dos primeros pasos se tienen que realizar de forma conjunta, pero el tercero es independiente, si el incumplimiento del protocolo se produce en ese momento, no es necesario que se repitan los dos primeros pasos, sino que sólo será necesario repetir el último.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Estado Hi\\nEsperando al saludo\r
    Bye: Estado Bye\\nEsperando la despedida\r
    [*] -> Hi\r
    Hi -> Hi : Mensaje incorrecto\\nSe envía error al cliente\r
    Hi -> Bye : Se ha recibido el mensaje correcto\\nSe envía respuesta al cliente\r
    note left of Hi : Permanecemos en este estado\\nhasta que se reciba el mensaje correcto\r
    Bye -> Hi : Mensaje incorrecto\\nSe envía error al cliente\r
    Bye -> [*] : Se ha recibido el mensaje correcto\\nSe cierra la conexión con el cliente\r
-->\r
\r
### Ejemplo del Worker que implementa el protocolo\r
\r
\`\`\`java{12,17,34,50,61,71}\r
public class U4A03_SaludoWorker extends Thread {\r
\r
    Socket socketCliente;\r
    BufferedReader entrada;\r
    PrintWriter salida;\r
\r
    private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\r
    U4A03_SaludoWorker(Socket socketCliente) {\r
        this.socketCliente = socketCliente;\r
        // Inicializamos el valor del estado al estado inicial\r
        estado = Estados.HI;\r
    }\r
\r
    @Override\r
    public void run() {\r
        try {\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
\r
            // Recibe lo que envía el cliente hasta que el mensaje sea\r
            // END OF TRANSMISSION\r
            while (estado != Estados.END) {\r
                // Recibe la solicitud del cliente por el InputStream\r
                String str = entrada.readLine();\r
\r
                // Comprobamos si se ha cerrado el extremo cliente del socket\r
                // Y damos por concluida la comunicación.\r
                if (str == null) {\r
                    estado = Estados.END;\r
                } else {\r
                    // Mostramos la información recibida por consola\r
                    System.out.println("CLIENTE > " + str);\r
                }\r
\r
                // Controlamos la respuesta en función del mensaje recibido y \r
                // el estado actual\r
                switch (estado) {\r
                    case HI:\r
                        if (messages[0].equals(str)) {\r
                            // Enviamos respuesta al cliente\r
                            salida.println(messages[1]);\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.BYE;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                        }\r
                        break;\r
                    case BYE:\r
                        if (messages[2].equals(str)) {\r
                            // Cambiamos el estado del protocolo\r
                            estado = Estados.END;\r
                        } else {\r
                            // Enviamos error al cliente\r
                            salida.println(messages[3]);\r
                            estado = Estados.HI;\r
                        }\r
                        break;\r
                    case END:\r
                        // No sería necesario contemplarlo en este caso\r
                        // Pero sí en otros en los que se tenga que enviar \r
                        // algún mensaje antes de salir.\r
                        break;\r
                }\r
            }\r
        } catch (IOException e) {\r
            System.out.println("Error de comunicación con el cliente");\r
        } catch (Exception e) {\r
            System.out.println(e.getLocalizedMessage());\r
            e.printStackTrace();\r
        } finally {\r
            try {\r
                entrada.close();\r
                System.out.println("Conexión cerrada: " + socketCliente);\r
                socketCliente.close();\r
            } catch (IOException e) {\r
                System.out.println("Error inesperado cerrando los recursos");\r
            }\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El código corresponde al worker de un servidor multihilo. Analicemos ahora el código por partes\r
\r
Es recomendable usar propiedades para guardar los mensajes que queramos comparar y tener un ENuM para definir los estados. Los \`enum\` en Java permiten ser usados en los bloques switch-case.\r
\r
La propiedad **estado** va a ser el punto central que controle el flujo de ejecución del servidor.\r
\r
\`\`\`java:no-line-numbers {6}\r
private final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public enum Estados {\r
        HI, BYE, END;\r
    }\r
    Estados estado;\r
\`\`\`\r
\r
En el constructor, además de todas las propiedades, inicializamos el estado, asignándole el valor del estado inicial.\r
\r
\`\`\`java:no-line-numbers{4}\r
U4A03_SaludoWorker(Socket socketCliente) {\r
    this.socketCliente = socketCliente;\r
    // Inicializamos el valor del estado al estado inicial\r
    estado = Estados.HI;\r
}\r
\`\`\`\r
\r
El servidor estará ejecutándose hasta que se alcance el estado final\r
\r
\`\`\`java:no-line-numbers\r
// Recibe lo que envía el cliente hasta que el mensaje sea\r
// END OF TRANSMISSION\r
while (estado != Estados.END) {\r
\`\`\`\r
\r
En este ejemplo, el intercambio de información con el cliente se hace uno a uno, es decir se recibe un mensaje y se envía una respuesta, pero no tiene porqué ser así, se pueden recibir varios mensajes y no enviar respuesta, o cualquier combinación de envío respuesta que nos imaginemos.\r
\r
El código que sigue e un control para saber si el cliente ha cerrado el socket, así evitamos tener excepciones de tipo NullPointerException o dejar al servidor en un bucle infinito. Forzamos la salida cambiando el estado del protocolo.\r
\r
\`\`\`java:no-line-numbers{4}\r
// Comprobamos si se ha cerrado el extremo cliente del socket\r
// Y damos por concluida la comunicación.\r
if (str == null) {\r
    estado = Estados.END;\r
} else {\r
    // Mostramos la información recibida por consola\r
    System.out.println("CLIENTE > " + str);\r
}\r
\`\`\`\r
\r
Este es el código que implementa el diagrama de estados que he diseñado para esta actividad.\r
Fijaos que el servidor tiene que realizar una comprobación para cada línea que sale de un estado. En este caso al ser sólo dos líneas, sirve con un if-else, pero puede ser un número mayor de opciones.\r
\r
Además, una de las opciones tiene un comportamiento totalmente diferente al resto, ya que **cuando se recibe el mensaje final, el protocolo no dice que enviemos una respuesta al cliente**.\r
\r
Esto \`debemos controlarlo en el cliente\`, porque si lo programamos de forma que envíe un mensaje y espere una respuesta, puede quedarse bloqueado en la lectura. Aprovechando que este es el último mensaje, más adelante veremos cómo se ha solventado en el cliente.y las opciones que tenemos para evitar posibles bloqueos como este.\r
\r
\`\`\`java:no-line-numbers{16}\r
// Controlamos la respuesta en función del mensaje recibido y \r
// el estado actual\r
switch (estado) {\r
    case HI:\r
        if (messages[0].equals(str)) {\r
            // Enviamos respuesta al cliente\r
            salida.println(messages[1]);\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.BYE;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
        }\r
        break;\r
    case BYE:\r
        if (messages[2].equals(str)) {\r
            // Cambiamos el estado del protocolo\r
            estado = Estados.END;\r
        } else {\r
            // Enviamos error al cliente\r
            salida.println(messages[3]);\r
            estado = Estados.HI;\r
        }\r
        break;\r
    case END:\r
        // No sería necesario contemplarlo en este caso\r
        // Pero sí en otros en los que se tenga que enviar \r
        // algún mensaje antes de salir.\r
        break;\r
}\r
\`\`\`\r
\r
## 4.4.4. Ejemplo de cliente con estados\r
\r
Aunque un cliente interactivo como los que usamos para las pruebas no deberían cambiar su funcionalidad, sí hay que hacer pequeños ajustes para adaptar su funcionamiento a las posibles respuestas y errores que envía el servidor.\r
\r
![Diagrama de estados U4A03_ProtocoloSaludo](../../media/unit4/client_sample_state_protocol.png)\r
\r
<!-- \r
stateDiagram-v2\r
    direction LR\r
    Hi: Envío mensaje\r
    Bye: Recibo mensaje\r
    [*] -> Hi\r
    Hi -> Bye : Se envía un mensaje\\nSe espera la respuesta del servidor\r
    Bye -> Hi : Se muestra la respuesta del servidor\r
    note left of Hi : Se envían mensajes\\nmientras el servidor mantenga\\nla conexión abierta   \r
    Hi -> [*] : Se ha detectado el cierre\\nde la conexión con el servidor\r
-->\r
\r
Como ya hemos dicho en el código del servidor, si implementamos el protocolo como un cliente de envío-respuesta, hay un caso en el que no debemos esperar una respuesta. Este es el caso de la salida, en la que se envía un mensaje pero no esperamos respuesta por parte del servidor.\r
\r
Se puede pensar en poner una condición de salida para cuando el cliente envía el último mensaje, pero no podemos asegurar que ese mensaje cerrará la comunicación, porque dependerá del estado en el que se encuentre el servidor.\r
\r
### Ejemplo de cliente "genérico" que implementa el protocolo\r
\r
\`\`\`java{39,41}\r
public class U4A03_SaludoClient {\r
\r
    private static final String[] messages = {"Hi Server!", "Hi Client!", "Bye Server!", "Error. Unknown or unexpected command"};\r
\r
    public static void main(String[] args) throws IOException {\r
        Socket socketCliente = null;\r
        BufferedReader entrada = null;\r
        PrintWriter salida = null;\r
\r
        // Creamos un socket en el lado cliente, enlazado con un\r
        // servidor que está en la misma máquina que el cliente\r
        // y que escucha en el puerto 4444\r
        try {\r
            socketCliente = new Socket(args[0], Integer.parseInt(args[1]));\r
\r
            // Establece canal de entrada\r
            entrada = new BufferedReader(\r
                    new InputStreamReader(socketCliente.getInputStream()));\r
\r
            // Obtenemos el canal de salida\r
            salida = new PrintWriter(\r
                    new BufferedWriter(\r
                            new OutputStreamWriter(socketCliente.getOutputStream())), true);\r
        } catch (IOException e) {\r
            System.err.println("No puede establecer canales de E/S para la conexión");\r
            System.exit(-1);\r
        }\r
        Scanner stdIn = new Scanner(System.in);\r
\r
        String linea;\r
\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenvía al servidor hasta que se envía \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
            // Recibe la respuesta del servidor por el InputStream\r
            linea = entrada.readLine();\r
            if (linea == null) {\r
                // Comprobamos si se ha cerrado el extremo servidor del socket\r
                // Y damos por concluida la comunicación.\r
                break;\r
            } else {\r
                // Envía a la salida estándar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            }\r
        } while (true);\r
\r
        // Libera recursos\r
        salida.close();\r
        stdIn.close();\r
        socketCliente.close();\r
    }\r
}\r
\`\`\`\r
\r
El código corresponde a un cliente interactivo genérico, que va enviando mensajes y esperando la respuesta de los mismos sin hacer ningún tipo de control sobre lo que se envía o lo que recibe.\r
\r
Analicemos algunos aspectos del código del cliente\r
\r
La parte que sigue es equivalente a la que hemos usado en el servidor. No modificamos el flujo envío-recepción, pero sí que comprobamos si el lado del servidor ha cerrado el socket (ha realizado todo el protocolo correctamente) para decidir que el cliente finalice su ejecución.\r
\r
\`\`\`java:no-line-numbers{3}\r
// Recibe la respuesta del servidor por el InputStream\r
linea = entrada.readLine();\r
if (linea == null) {\r
    // Comprobamos si se ha cerrado el extremo servidor del socket\r
    // Y damos por concluida la comunicación.\r
    break;\r
} else {\r
    // Envía a la salida estándar la respuesta del servidor\r
    System.out.println("SERVIDOR > " + linea);\r
}\r
} while (true);\r
\`\`\`\r
\r
::: warning Lectura con timeout\r
Otra manera distinta de hacer lo mismo es usando lecturas con timeout.\r
\r
En este ejemplo podríamos haber comprobado si el mensaje enviado es el mensaje de finalización. Es ese caso, si todo ha ido bien, no deberíamos esperar una respuesta por parte del server, pero si ha habido algún error, sí debemos realizar una lectura del socket.\r
\r
Usando este código\r
\r
\`\`\`java\r
        // El programa cliente no analiza los mensajes enviados por el\r
        // usuario, simplemente los reenvía al servidor hasta que se envía \r
        // el mensaje final del protocolo\r
        do {\r
            // Leo la entrada del usuario\r
            linea = stdIn.nextLine();\r
            // La envia al servidor por el OutputStream\r
            salida.println(linea);\r
\r
            // Si enviamos el mensaje de salida, no hacemos una lectura indefinida\r
            if (linea.equals(messages[2])) {\r
                socketCliente.setSoTimeout(100);\r
            } else {\r
                socketCliente.setSoTimeout(0);\r
            }\r
\r
            try { \r
                // Recibe la respuesta del servidor por el InputStream\r
                linea = entrada.readLine();\r
                // Envía a la salida estándar la respuesta del servidor\r
                System.out.println("SERVIDOR > " + linea);\r
            } catch (SocketTimeoutException ste) {\r
                // Pasado el timeout no se ha recibido una respuesta\r
                // Podemos suponer que el server no envía respuesta\r
                // Eso indica que el protocolo se ha completado\r
                // Damos por concluida la comunicación.\r
                break;\r
            }            \r
        } while (true);\r
\`\`\`\r
\r
fijamos un tiempo de espera pasado el cual se producirá una \`SocketTimeoutException\` indicando que no se ha leído nada del socket. Si por el contrario se lee información del socket, esta se muestra por la consola.\r
\r
En este caso en concreto, esta solución no funciona porque el servidor ya ha cerrado el socket. Esto sería útil cuando tengamos que hacer una \`lectura opcional\` en mitad de un protocolo, y serviría tanto para un cliente como para un servidor.\r
:::\r
`]},{title:"4.1 Pila de protocolos TCP IP",headers:[{level:2,title:"4.1.1. Las capas del modelo TCP/IP",slug:"_4-1-1-las-capas-del-modelo-tcp-ip",link:"#_4-1-1-las-capas-del-modelo-tcp-ip",children:[]},{level:2,title:"4.1.2. Direcciones y puertos - Sockets",slug:"_4-1-2-direcciones-y-puertos-sockets",link:"#_4-1-2-direcciones-y-puertos-sockets",children:[{level:3,title:"Direcciones IP",slug:"direcciones-ip",link:"#direcciones-ip",children:[]},{level:3,title:"Puertos",slug:"puertos",link:"#puertos",children:[]},{level:3,title:"Sockets",slug:"sockets",link:"#sockets",children:[]}]},{level:2,title:"4.1.3 TCP vs UDP",slug:"_4-1-3-tcp-vs-udp",link:"#_4-1-3-tcp-vs-udp",children:[]}],path:"/es/unit4/tcp-ip.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.1 Pila de protocolos TCP IP\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.1 Pila de protocolos TCP IP" />\r
\r
# 4.1 Pila de protocolos TCP IP\r
\r
[[toc]]\r
\r
## 4.1.1. Las capas del modelo TCP/IP\r
\r
La pila de protocolos TCP/IP, o los protocolos de internet, son un conjunto de \`protocolos de comunicación\` usados en la red Internet o en redes similares.\r
\r
TCP/IP son los protocolos más usados a nivel mundial. Son protocolos abiertos y por ese motivo permiten la comunicación entre máquinas usando diferentes plataformas de hardware y software. Estos protocolos funcionan tanto en redes de área extensa (WAN) como en redes de área local (LAN).\r
\r
La pila de protocolos TCP/IP es, como hemos dicho, un conjunto de protocolos que reciben su nombre de los dos protocolos más importantes \`Protocolo de Control de la Transmission(TCP)\` and the \`Protocolo de Internet(IP)\`. Además de estos protocolos, la pila TCP/IP incluye muchos otros protocolos de más alto nivel que facilitan la comunicación con aplicaciones como el email, transferencia de archivos, servidores web, etc.\r
\r
::: info Documentos RFC\r
Cada protocolo de Internet, junto con sus correcciones y modificaciones posteriores, está descrito en un documento conocido como \`Request For Comments (RFC)\`.\r
\r
Aquí se puede consultar la lista de los RFCs disponibles: [http://www.ietf.org/rfc.html](http://www.ietf.org/rfc.html).\r
:::\r
\r
Recibe el nombre de **pila** o **stack** porque está diseñado como una jerarquía de capas en las que cada capa da soporte a la capa que tiene por encima y utiliza los servicios de la capa que tiene por debajo. Cada capa está encargada de resolver un subconjunto de los problemas específicos que encontramos cuando queremos realizar una comunicación de datos entre equipos en una red. \r
\r
El modelo TCP/IP está dividido en cuatro capas. De más bajo nivel a más alto tenemos la capa de enlace de datos (Link), la capa de red (internet), la capa de transporte y la capa de aplicación, tal y como podemos ver en la siguiente imagen.\r
\r
![TCP/IP real communication flow](../../media/unit4/1-ip-real-communication-flow.gif)\r
\r
- La **capa de enlace** proporciona la comunicación entre dos interfaces o tarjetas de red dentro de una misma red local, con conexión directa o a través de uno o varios switches.\r
- La **capa de red** proporciona comunicación entre dos interfaces de red o hosts. Estos hosts pueden estar en la misma red o en redes diferentes, siempre que estén interconectadas por uno o más routers. A cada interfaz de red se le asigna una dirección IP que identifica al equipo de forma unívoca. El protocolo IP es el más importante de esta capa y probablemente sea el más importante de toda la pila de protocolos.\r
- La **capa de transporte** se encarga de proporcionar una comunicación punto a punto, permitiendo manejar múltiples transferencias de información de forma simultanea. El protocolo principal de esta capa es el protocolo \`TCP\`, que se encarga de proporcionar un servicio confiable y orientado a conexión. \`UDP\` por su parte proporciona un servicio más eficaz y rápido, pero lo hace de forma no fiable y no orientado a conexión.\r
- La **capa de aplicación** proporciona servicios específicos de transmisión fiable para un tipo determinado de aplicación (transferencia de archivos, correo electrónico, gestión de red, configuración de red, etc.). Esta capa se encuentra unas veces dentro de las aplicaciones cliente que usamos para acceder a estos servicios y en otras ocasiones como servicios del propio SO. El interfaz entre los protocolos de la capa de aplicación y los protocolos de la capa de transporte se definen como \`puertos \` y \`sockets\`.\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.1-ip-protocols.png)\r
\r
## 4.1.2. Direcciones y puertos - Sockets\r
\r
### Direcciones IP\r
\r
Cada host o equipo que está en una red TCP/IP tiene asignada na dirección IP única consistente en un número de red y un número de host. El número de red sirve para identificar la red en la que se encuentran los hosts. El número de host sirve para identificar a un host dentro de una red.\r
\r
Las direcciones Ipv4 son direcciones de 32-bits. La dirección IP se agrupa en cuatro octetos o bytes (grupos de 8 bits) y se representan usando el valor en notación decimal de cada uno de los bytes, separados por puntos. El valor mínimo para cada octeto es 0 y el valor máximo es 255.\r
\r
> 192.168.0.100\r
>\r
> 127.0.0.1\r
>\r
> 10.1.100.1\r
\r
Las direcciones IPv6 está formadas por 64-bits para la dirección de red o prefijo de red, y otros 64 bits para el número de host. Las direcciones IPv6 se escriben como 8 grupos de 4 dígitos hexadecimales separados por el caracter ':'. Un grupo que sólo tiene ceros puede ser omitido. Los ceros iniciales también se pueden omitir\r
\r
Todas estas direcciones serían equivalentes. Se les han aplicado diferentes reglas de reducción\r
\r
> 2001:0db8:0000:0000:0000:0000:1428:57ab\r
>\r
> 2001:0db8:0000:0000:0000::1428:57ab\r
>\r
> 2001:0db8:0:0:0:0:1428:57ab\r
>\r
> 2001:0db8:0:0::1428:57ab\r
>\r
> 2001:0db8::1428:57ab\r
>\r
> 2001:db8::1428:57ab\r
\r
![Routing](../../media/unit4/data_transfer.gif)\r
\r
### Puertos\r
\r
Cuando una aplicación que se est´ejecutando en un equipo quiere comunicarse con otra aplicación de otro equipo, se identifica a sí misma con un número de 16 bits, que denominamos \`puerto\`. Ese identificador es usado por los protocolos de la capa de transporte (TCP or UDP) para entregar los mensajes a la aplicación correcta dentro del equipo.\r
\r
Los puertos van de 0 a 65535, y se agrupan en tres rangos\r
\r
| Grupo de puertos                      | Rango de puertos    | Descripción                                                    |\r
| ------------------------------- | ------------- | -------------------------------------------------------------- |\r
| Puertos bien conocidos o puertos del sistema | 0 - 1023      | Los usan los protocolos estándar y los servicios del SO |\r
| Puertos registrados | 1024- 49151   | Reservados por empresas y organizaciones para sus propios servicios |\r
| Puertos efímeros | 49152 - 65535 | De libre disposición y uso para aplicaciones cliente y servidor |\r
\r
Los servidores de protocolos estándar como Telnet y FTP usan uno o más de estos puertos bien conocidos. La mayoría de los servidores sólo utilizan un puerto aunque hay otros, como FTP, que usan dos. El uso de un puerto específico permite a las aplicaciones cliente el poder comunicarse con el servidor sin tener que enviar una petición previa para determinar qué puerto se está usando.\r
\r
> Por ejemplo, las peticiones HTTP se envían por defecto al puerto 80 del servidor..\r
\r
Las aplicaciones cliente (navegadores, clientes de correo, etc) no necesitan usar uno de los puertos bien conocidos ya que son los que inician la comunicación. A los procesos cliente se les asigna un número de puerto de forma dinámica por parte del SO. Ese número está incluido en todos los datagramas que intercambia con el servidor, por lo tanto el servidor tiene acceso a esa información.\r
\r
### Sockets\r
\r
Un \`socket\` es básicamente un punto final de conexión en una comunicación entre proceso y está formado por una combinación unica de  **dirección IP, puerto y protocolo de transporte (normalmente TCP)**.\r
\r
Cuando una aplicación cliente quiere comunicarse con un servidor, el SO crea el socket que usará el cliente para recibir la información del servidor. lA combinación única de Protocolo + puerto + IP permite que este extremo de la comunicación sea accesible desde el servidor, de manera inequívoca y asegura que los datos los recibe el proceso que los solicitó.\r
\r
El servidor tiene su propio socket par comunicarse con el cliente, y una conexión establecida entre el cliente y el servidor usando los dos extremos (los dos sockets cliente <--> servidor. Las aplicaciones intercambian información escribiendo o leyendo en los sockets que han creado..\r
\r
La conexión usada por un cliente está formada por dos sockets, uno en el lado del cliente y otro en el lado des servidor. Por lo tanto, la conexión puede identificarse con una tupla formada por cuatro número: la dirección IP de origen, la dirección IP de destino, el puerto de origen y el puerto de destino.\r
\r
Esto permite que múltiples aplicaciones cliente ejecutándose en máquinas diferentes puedan conectarse al mismo socket de destino en el servidor. Tampoco hay confusión de a qué equipo se debe enviar un datagram de respuesta, incluso si el puerto de origen y destino es el mismo.\r
\r
Usando sockets también es posible tener varias aplicaciones cliente corriendo en el mismo equipo y conectándose al mismo servidor (varias pestañas de un navegador). Los datagramas de respuesta enviados por el servidor al cliente contienen la información del socket en el lado del client, la cual incluye el puerto asignado individualmente a cada uno de los clientes, no pudiendo haber confusión sobre a qué proceso entregar la respuesta.\r
\r
![TCP/IP logical communication flow](../../media/unit4/2-ip-logical-communication-flow.gif)\r
\r
En una red, la comunicación real se realiza de una capa a la siguiente o a la anterior. Sin embargo, las aplicaciones de cada capa realizan una abstracción de las capas inferiores y ven su flujo de comunicación como una comunicación directa con la capa equivalente en el otro extremo de la conexión.\r
\r
En la pila de protocolos TCP/IP se manejan diferentes elementos de información en cada nivel (frames, packets, datagramas, streams, messages, ...).\r
\r
![TCP/IP logical communication flow](../../media/unit4/4.0-The-TCP-IP-UDP-IP-Stack_Q640.jpg)\r
\r
Como ya se ha citando anteriormente, los sockets son el puente entre la capa de transporte y la capa de aplicación. Este es el punto donde vamos a trabajar y desarrollar nuestras aplicaciones en este tema, ofreciendo servicios a los protocolos de la capa superior, la capa de aplicación.\r
\r
## 4.1.3 TCP vs UDP\r
\r
El protocolo TCP que es el más utilizado en la navegación cotidiana. Es el más habitual por tratarse de un protocolo de transporte ‘orientado a conexión’. Esto quiere decir que el protocolo TCP está diseñado no solo para transmitir una determinada información entre un dispositivo y otro, sino también para verificar la correcta recepción de la información transmitida entre un dispositivo y otro, o, dicho de otro modo, es un protocolo para manejar conexiones de extremo a extremo.\r
\r
El protocolo TCP establece una conexión entre el dispositivo emisor y el dispositivo receptor y verifica de forma continua la emisión y recepción de la información entre ambos. El protocolo TCP consigue esta verificación dividiendo los flujos de bytes en segmentos ordenados con un número de secuencia antes de transmitirlos a través del protocolo IP. Este número de secuencia es verificado por el dispositivo receptor y, en caso de que falte alguno de los segmentos, el protocolo TCP vuelve a solicitar su envío a través del protocolo IP, hasta que el mensaje llega en su totalidad al dispositivo receptor. Gracias a su fiabilidad, el protocolo TCP da soporte a los protocolos HTTP, SMTP, SSH y FTP.\r
\r
El protocolo TCP ofrece los siguientes servicios :\r
\r
- Comunicación Full duplex: los dos extremos pueden transmitir simultaneamente\r
- Timing: Utiliza temporizadores para asegurar que los datos se transmiten de forma síncrona\r
- Secuenciación: Los bloques se transmiten con un número de secuencia para que puedan ser reensamblados en el destino, en orden correcto, antes de pasarlos al protocolo de la capa de aplicación.\r
- Control de flujo: Se encarga de gestionar el congestión y adaptar la velocidad de envío / recepción de bloques.\r
- Gestión de errores: Usa comprobaciones checksum para detectar posibles errores en la transmisión de los datos y gestionar dichos errores.\r
\r
![TCP/IP logical communication flow](../../media/unit4/5-Graphic-UDP-Vs-TCP.png)\r
\r
El protocolo UDP funciona de manera similar al protocolo TCP, pero no es un protocolo de transporte orientado a conexión. Esto quiere decir que el protocolo UDP no verifica la recepción de los datos transmitidos entre un dispositivo y otro. Por esto, se articula en un nivel de capa inferior al protocolo TCP, con lo que el sistema de verificación de la recepción de los datos debe implementarse en las capas superiores.\r
\r
La principal ventaja del protocolo UDP consiste en su velocidad. Al prescindir de un sistema de verificación de ida y vuelta entre el dispositivo emisor y el dispositivo receptor, el protocolo UDP permite una velocidad de transferencia superior a la del protocolo TCP. Por esto, el protocolo UDP es el más utilizado por los servicios de transmisión de voz o vídeo en streaming, donde la velocidad de la transmisión es más importante que una posible pérdida de datos puntual.\r
\r
Cabe destacar su uso especializado para transmisiones de tipo multicast y broadcast.\r
\r
![TCP/IP logical communication flow](../../media/unit4/tcp_vs_udp.png)\r
`]},{title:"5.2 Cliente FTP",headers:[{level:2,title:"5.2.1 Apache Common Net FTP",slug:"_5-2-1-apache-common-net-ftp",link:"#_5-2-1-apache-common-net-ftp",children:[]},{level:2,title:"5.2.2 Servidor FTP",slug:"_5-2-2-servidor-ftp",link:"#_5-2-2-servidor-ftp",children:[]},{level:2,title:"5.2.3 Cliente FTP",slug:"_5-2-3-cliente-ftp",link:"#_5-2-3-cliente-ftp",children:[{level:3,title:"5.2.3.1 Conectar y autenticar",slug:"_5-2-3-1-conectar-y-autenticar",link:"#_5-2-3-1-conectar-y-autenticar",children:[]},{level:3,title:"5.2.3.2 Cambio de directorios",slug:"_5-2-3-2-cambio-de-directorios",link:"#_5-2-3-2-cambio-de-directorios",children:[]},{level:3,title:"5.2.3.3 Enviar archivos al servidor",slug:"_5-2-3-3-enviar-archivos-al-servidor",link:"#_5-2-3-3-enviar-archivos-al-servidor",children:[]},{level:3,title:"5.2.3.4 Descargar archivos del servidor",slug:"_5-2-3-4-descargar-archivos-del-servidor",link:"#_5-2-3-4-descargar-archivos-del-servidor",children:[]},{level:3,title:"5.2.3.5 Otras acciones",slug:"_5-2-3-5-otras-acciones",link:"#_5-2-3-5-otras-acciones",children:[]}]}],path:"/es/unit5/ftp.html",pathLocale:"/es/",extraFields:[`---\r
title: 5.2 Cliente FTP\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.2 Cliente FTP" />\r
\r
# 5.2 Cliente FTP\r
\r
[[toc]]\r
\r
## 5.2.1 Apache Common Net FTP\r
\r
La librería Apache Commons Net™ implementa el lado de muchos protocolos básicos de Internet.\r
\r
El propósito de la biblioteca es proporcionar acceso a protocolos fundamentales, no abstracciones de alto nivel. Por lo tanto, algunos de los diseños violan los principios de diseño orientado a objetos.\r
\r
Nuestra filosofía es hacer que la funcionalidad global de un protocolo sea accesible (por ejemplo, TFTP envía archivo y recibe archivo) cuando sea posible, pero también proporcionar acceso a los protocolos fundamentales cuando corresponda para que el programador pueda construir sus propias implementaciones personalizadas (por ejemplo, las clases de paquetes TFTP y los métodos de envío y recepción de paquetes TFTP están expuestos).\r
\r
::: tip Librería Apache Commons NET™\r
\r
Los protocolos soportados incluyen:\r
\r
- FTP/FTPS\r
- FTP over HTTP (experimental)\r
- NNTP\r
- SMTP(S)\r
- POP3(S)\r
- IMAP(S)\r
- Telnet\r
- TFTP\r
- Finger\r
- Whois\r
- rexec/rcmd/rlogin\r
- Time (rdate) and Daytime\r
- Echo\r
- Discard\r
- NTP/SNTP\r
:::\r
\r
En Java, de forma nativa, es posible realizar transferencias de archivos utilizando este protocolo, pero es extremadamente difícil hacerlo. La librería Apache Commons Net proporciona clases y utilidades para realizar cualquier operación sobre un servidor FTP o FTPS desde un cliente Java.\r
\r
Esta librería se puede descargar desde la página web de apache.org a través del siguiente enlace: https://commons.apache.org/proper/commons-net/\r
\r
## 5.2.2 Servidor FTP\r
\r
El servidor FTP es un programa que se ejecuta en un ordenador y permite que otros ordenadores se conecten a él y transfieran archivos utilizando el protocolo FTP.\r
\r
Para realizar las pruebas vamos a utilizar el servidor FTP FileZilla, que se puede descargar desde la [página web de Filezilla](https://filezilla-project.org/download.php?type=server).\r
\r
La instalación es muy sencilla, simplemente hay que seguir los pasos del asistente de instalación. Una vez instalado, tendremos que configurar el servidor, para ello tendremos que abrir el programa FileZilla Server Interface, que estará en el menú de inicio de Windows.\r
\r
![FileZilla Server Interface](../../media/unit5/FileZilla-Server-Interface.png)\r
\r
Una vez instalado el servidor, tendremos que configurarlo. Para ello, tendremos que abrir el programa FileZilla Server Interface, que estará en el menú de inicio de Windows y abrir el menú Server y seleccionar la opción "Configure".\r
\r
A continuación, en la sección Users, tendremos que crear un usuario, para ello tendremos que hacer clic en el botón "Add" y rellenar los campos con los datos del usuario que queremos crear. A continuación, cambiaremos el tipo de autenticación a "Require a password to login" e introduciremos la contraseña que queremos asignar al usuario.\r
\r
A continuación, en la sección Mounting Points, tendremos que añadir un nuevo punto de montaje, para ello tendremos que hacer clic en el botón "Add" y rellenar los campos con los datos del punto de montaje que queremos crear. En el campo "Native path" tendremos que seleccionar el directorio que queremos compartir.\r
\r
::: tip Rutas Virtuales vs Rutas Nativas\r
Las rutas virtuales se utilizan para asignar un directorio en el servidor a un directorio virtual. Esto le permite crear una estructura de directorios virtuales que es diferente de la estructura de directorios real en el servidor. Por ejemplo, puede asignar el directorio "C:\\Mis Documentos" al directorio virtual "/Documentos". Cuando un cliente se conecta al servidor y cambia al directorio "/Documentos", el cliente estará realmente en el directorio "C:\\Mis Documentos" del servidor.\r
:::\r
\r
Una vez que hayamos creado el usuario y el punto de montaje, tendremos que hacer clic en el botón "OK" para guardar los cambios.\r
\r
## 5.2.3 Cliente FTP\r
\r
Las clases y métodos principales del paquete org.apache.commons.net.ftp se muestran a continuación.\r
\r
### 5.2.3.1 Conectar y autenticar\r
\r
\`\`\`java\r
public class ApacheFTPClient {\r
\r
    private String server;\r
    private int port;\r
    private String user;\r
    private String password;\r
    private FTPClient ftp;\r
\r
    public ApacheFTPClient(String server, int port, String user, String password) {\r
        this.server = server;\r
        this.port = port;\r
        this.user = user;\r
        this.password = password;\r
    }\r
\r
    void open() throws IOException {\r
        ftp = new FTPClient();\r
\r
        ftp.connect(server, port);\r
        int reply = ftp.getReplyCode();\r
        if (!FTPReply.isPositiveCompletion(reply)) {\r
            ftp.disconnect();\r
            throw new IOException("Exception in connecting to FTP Server");\r
        }\r
\r
        ftp.login(user, password);\r
    }\r
\r
    void close() throws IOException {\r
        ftp.disconnect();\r
    }\r
\r
    public static void main(String[] args) throws IOException {\r
        ApacheFTPClient client = new ApacheFTPClient("localhost", 21, "alumnodam", "psp");\r
        client.open();\r
        client.close();\r
    }\r
}\r
\`\`\`\r
\r
En el ejemplo anterior podemos ver cómo conectarnos a un servidor FTP utilizando la librería Apache Commons Net.\r
\r
1. Para ello, tendremos que crear una instancia de la clase **FTPClient** y llamar al método connect, pasando como parámetros el servidor y el puerto al que queremos conectarnos.\r
1. A continuación, tendremos que comprobar que la conexión se ha establecido correctamente, para ello tendremos que llamar al método *getReplyCode* y comprobar que el valor devuelto por este método es positivo.\r
1. Por último, tendremos que llamar al método login, pasando como parámetros el usuario y la contraseña con la que queremos iniciar sesión.\r
\r
### 5.2.3.2 Cambio de directorios\r
\r
En el protocolo FTP, el directorio local es el directorio en el ordenador del cliente y el directorio remoto es el directorio en el servidor. Tanto el directorio local como el remoto se llaman directorios de trabajo y ambos se pueden cambiar con el método **changeWorkingDirectory** para los archivos remotos y los métodos **File** para establecer el origen de los archivos locales.\r
\r
Para mostrar el directorio de trabajo actual, podemos utilizar el método **printWorkingDirectory** y para mostrar el contenido del directorio de trabajo actual, podemos utilizar el método **listFiles** o el método **listNames**.\r
\r
\`\`\`java\r
    // Obtener el directorio de trabajo remoto actual\r
    String workingDirectory = ftp.printWorkingDirectory();\r
    \r
    // Mostrar el contenido del directorio de trabajo remoto actual\r
    for (String name : ftp.listNames()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Cambiar el directorio de trabajo remoto actual\r
    ftp.changeWorkingDirectory(fileName)\r
\`\`\`\r
\r
Para mostrar el directorio de trabajo local actual, tenemos que gestionarlo con la clase File y sus métodos. También podemos confiar en la clase System y sus métodos como estudiamos en la unidad de gestión de procesos.\r
\r
\`\`\`java\r
    // Obtener el directorio de trabajo local actual\r
    String workingDirectory = System.getProperty("user.dir");\r
    \r
    // Mostrar el contenido del directorio de trabajo local actual\r
    File file = new File(workingDirectory);\r
    for (String name : file.list()) {\r
            System.out.println(name);\r
    }\r
    \r
    // Cambiar el directorio de trabajo local actual\r
    System.setProperty("user.dir", fileName);\r
\`\`\`\r
\r
### 5.2.3.3 Enviar archivos al servidor\r
\r
En FTP los archivos se pueden cargar de dos formas diferentes:\r
\r
Modo ASCII: el archivo se carga como texto, con las terminaciones de línea convertidas al estándar de red.\r
\r
\`\`\`java\r
    public boolean sendTextFile(String fileName) throws FileNotFoundException, IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        InputStream input = new FileInputStream(file);\r
        boolean upload = ftp.storeFile(fileRemote, input);\r
        input.close();\r
        return upload;\r
    }\r
\`\`\`\r
\r
Modo binario: el archivo se carga tal cual, sin ninguna conversión.\r
\r
\`\`\`java\r
    public boolean sendBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to upload\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        InputStream input = new FileInputStream(file);\r
        OutputStream output = ftp.storeFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        input.close();\r
        output.close();\r
        boolean upload = ftp.completePendingCommand();\r
        \r
        return upload;\r
    }\r
\`\`\`\r
\r
### 5.2.3.4 Descargar archivos del servidor\r
\r
Como con la carga, los archivos se pueden descargar de dos formas diferentes:\r
\r
Modo ASCII: el archivo se descarga como texto, con las terminaciones de línea convertidas al estándar local.\r
\r
\`\`\`java\r
    public boolean getTextFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.ASCII_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
        OutputStream output = new FileOutputStream(file);\r
        boolean download = ftp.retrieveFile(fileRemote, output);\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
Modo binario: el archivo se descarga tal cual, sin ninguna conversión.\r
\r
\`\`\`java\r
    public boolean getBinaryFile(String fileName) throws IOException {\r
        ftp.setFileType(FTP.BINARY_FILE_TYPE);\r
        // The getLocalWorkingDirectory() it's a custom method (not from the Apache Commons library) \r
        // that returns the path to the local file we want to download\r
        File file = new File(getLocalWorkingDirectory() + "/" + fileName);\r
        // The file name in the server can be different from the local file name\r
        String fileRemote = fileName;\r
\r
        OutputStream output = new FileOutputStream(file);\r
        InputStream input = ftp.retrieveFileStream(fileRemote);\r
        byte[] bytesIn = new byte[4096];\r
        int read = 0;\r
\r
        while ((read = input.read(bytesIn)) != -1) {\r
            output.write(bytesIn, 0, read);\r
        }\r
\r
        boolean download = ftp.completePendingCommand();\r
        input.close();\r
        output.close();\r
        return download;\r
    }\r
\`\`\`\r
\r
### 5.2.3.5 Otras acciones\r
\r
Otras acciones que se pueden realizar sobre el servidor FTP son:\r
\r
Mostrar información de los archivos y propiedades de los archivos\r
\r
\`\`\`java\r
    public void showFileInfo(String fileName) throws IOException {\r
        FTPFile[] files = ftp.listFiles(fileName);\r
        for (FTPFile file : files) {\r
            System.out.println(file.getName());\r
            System.out.println(file.getTimestamp().getTime());\r
            System.out.println(file.getSize());\r
            if (f.getType() == FTPFile.FILE_TYPE) {\r
                tipo = "File";\r
            }\r
            if (f.getType() == FTPFile.DIRECTORY_TYPE) {\r
                tipo = "Folder";\r
            }\r
        }\r
    }    \r
\`\`\`\r
\r
Añadir y eliminar directorios FTP remotos\r
\r
\`\`\`java\r
    public void addRemoteDirectory(String directory) throws IOException {\r
        ftp.makeDirectory(directory);\r
    }\r
\r
    public void removeRemoteDirectory(String directory) throws IOException {\r
        ftp.removeDirectory(directory);\r
    }\r
\`\`\`\r
\r
Crear y eliminar archivos FTP remotos\r
\r
\`\`\`java\r
    public void addRemoteFile(String fileName) throws IOException {\r
        ftp.storeFile(fileName, new ByteArrayInputStream(new byte[0]));\r
    }\r
\r
    public void removeRemoteFile(String fileName) throws IOException {\r
        ftp.deleteFile(fileName);\r
    }\r
\`\`\`\r
\r
Renombrar archivos y directorios FTP remotos\r
\r
\`\`\`java\r
    public void renameRemoteFile(String oldName, String newName) throws IOException {\r
        ftp.rename(oldName, newName);\r
    }\r
\`\`\`\r
`]},{title:"5.4 Anexo I - Configuraciones GMail",headers:[{level:2,title:"5.4.1 Excepciones comunes al usar el correo de Gmail",slug:"_5-4-1-excepciones-comunes-al-usar-el-correo-de-gmail",link:"#_5-4-1-excepciones-comunes-al-usar-el-correo-de-gmail",children:[{level:3,title:"5.4.1.1 Verificación en dos pasos",slug:"_5-4-1-1-verificacion-en-dos-pasos",link:"#_5-4-1-1-verificacion-en-dos-pasos",children:[]},{level:3,title:"5.4.1.2 Aplicaciones menos seguras",slug:"_5-4-1-2-aplicaciones-menos-seguras",link:"#_5-4-1-2-aplicaciones-menos-seguras",children:[]}]}],path:"/es/unit5/gmail_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 5.4 Anexo I - Configuraciones GMail\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.4 Anexo I - Configuraciones GMail" />\r
\r
# 5.4 Anexo I - Configuraciones GMail\r
\r
[[toc]]\r
\r
## 5.4.1 Excepciones comunes al usar el correo de Gmail\r
\r
Al enviar un correo electrónico con cualquiera de los métodos anteriores, es posible que aparezcan las siguientes excepciones, incluso si las credenciales de Gmail son correctas.\r
\r
:::danger Seguridad de Google\r
Es importante comprobar la seguridad de tu cuenta. Cambia la siguiente configuración solo si estás absolutamente seguro de lo que estás haciendo.\r
\r
No compartas ninguna de las contraseñas porque tu cuenta se puede usar sin tu permiso.\r
:::\r
\r
### 5.4.1.1 Verificación en dos pasos\r
\r
\`\`\`java\r
Error while trying to send mail: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 534-5.7.9 Application-specific password required. Learn more at\r
534 5.7.9  https://support.google.com/mail/?p=InvalidSecondFactor r10-20020a05600c458a00b003d35acb0fd7sm14828087wmo.34 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
La excepción (jakarta.mail.AuthenticationFailedException) habla de la contraseña específica de la aplicación requerida. Esto se debe a que su cuenta de Gmail está configurada para la verificación de 2 pasos, por lo que su contraseña directa de Gmail no funcionará aquí debido a razones de seguridad. Para rectificar esto, debe seguir los pasos a continuación.\r
\r
1. Inicia sesión con tu cuenta de Google\r
2. Vaya a su cuenta de Google o simplemente haga clic en el enlace [Configuración de seguridad de la cuenta de Google](https://myaccount.google.com/?pli=1)\r
![Configuración de Google](../../media/unit5/Google-Settings-1.1.png)\r
3. Haga clic en Seguridad en el menú de la izquierda.\r
4. Desplácese un poco hacia abajo para llegar a la sección "Iniciar sesión en Google", probablemente la 3ª sección desde la parte superior.\r
5. Aquí puede ver que la verificación en 2 pasos está activada.\r
![Configuración de Google](../../media/unit5/Google-Settings-1.2.png)\r
6. Haga clic en Contraseñas de aplicaciones justo debajo de ella. Google le pedirá que vuelva a introducir la contraseña.\r
7. En la siguiente pantalla, debe seleccionar la Aplicación y el Dispositivo.\r
8. En el menú desplegable "Seleccionar aplicación", simplemente seleccione Otro (Nombre personalizado).\r
9. Dé un nombre apropiado como "Web" y presione el botón Generar.\r
![Configuración de Google](../../media/unit5/Google-Settings-1.3.png)\r
10. Aparecerá una contraseña generada en la pantalla con una ventana emergente.\r
11. Guarde y use esta contraseña para todo su código de correo Java.\r
\r
### 5.4.1.2 Aplicaciones menos seguras\r
\r
\`\`\`java\r
Error while trying to send mail: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
jakarta.mail.AuthenticationFailedException: 535-5.7.8 Username and Password not accepted. Learn more at\r
535 5.7.8  https://support.google.com/mail/?p=BadCredentials o9-20020a05600c510900b003c6f8d30e40sm15602278wms.31 - gsmtp\r
\r
    at com.sun.mail.smtp.SMTPTransport$Authenticator.authenticate(SMTPTransport.java:947)\r
    at com.sun.mail.smtp.SMTPTransport.authenticate(SMTPTransport.java:858)\r
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:762)\r
    at jakarta.mail.Service.connect(Service.java:364)\r
    at jakarta.mail.Service.connect(Service.java:222)\r
    at jakarta.mail.Service.connect(Service.java:171)\r
    at jakarta.mail.Transport.send0(Transport.java:230)\r
    at jakarta.mail.Transport.send(Transport.java:100)\r
    ...\r
\`\`\`\r
\r
1. Inicia sesión con tu cuenta de Google\r
1. Vaya a su cuenta de Google o simplemente haga clic en el enlace [Configuración de aplicaciones menos seguras de Google](https://www.google.com/settings/security/) para avanzar hasta el paso 5.\r
![Configuración de Google](../../media/unit5/Google-Settings-1.1.png)\r
1. Haga clic en Seguridad en el menú de la izquierda.\r
1. Desplácese un poco hacia abajo para llegar a las "Aplicaciones menos seguras".\r
1. Lo encontrará desactivado. Ingrese a la sección para activarlo.\r
![Configuración de Google](../../media/unit5/Google-Settings-2.3.png)\r
1. Guarde y use la contraseña de su cuenta para todo su código de correo Java.\r
`]},{title:"5 Introducción",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit5/",pathLocale:"/es/",extraFields:[`---\r
title: 5 Introducción\r
---\r
\r
# Tema 5. Servicios en red\r
\r
Los servicios son programas auxiliares utilizados en un sistema para gestionar una colección de recursos y prestar su funcionalidad a los usuario y aplicaciones.\r
\r
El acceso a los servicios está formado por el conjunto de operaciones que ofrece, por ejemplo, un servicio de archivos ofrece operaciones de lectura, escritura y borrado de ficheros.\r
\r
Todos los servicios de Internet implementan una relación cliente-servidor. Existen multitud de librerías para trabajar con los servicios más comunes. En esta unidad nos vamos a centrar en el servicio FTP (transferencia de archivos), SMTP (envío de emails) y POP3/IMAP (lectura de emails).\r
\r
Además, hay otras aproximaciones, también basadas en la arquitectura cliente-servidor que permiten ofrecer acceso a los sistemas. Entre los más utilizados, está lo que se denomina API Rest, que no deja de ser un servicio sobre HTTP que permite interactuar con el backend de los sistemas, de forma independiente a la arquitectura y lenguajes utilizados en el frontend.\r
\r
Nosotros vamos a analizar en esta unidad otras aproximaciones como los sistemas de colas, basados en el protocolo MQ, o los sistemas serverless que ofrecen las principales plataformas de computación en la nube (Azure Functions, AWS Lambda y Google Cloud Functions).\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Utilizar librerías Java para usar los protocolos de aplicación más importantes de TCP/IP.\r
- Probar servicios de comunicación en red.\r
- Permitir operaciones en la nube de forma sencilla.\r
- Crear aplicaciones que permitan una comunicación asíncrona entre clientes y entre clientes y servidores.\r
`]},{title:"5.1 Correo",headers:[{level:2,title:"5.1.1 Jakarta Mail",slug:"_5-1-1-jakarta-mail",link:"#_5-1-1-jakarta-mail",children:[{level:3,title:"Uso de la librería",slug:"uso-de-la-libreria",link:"#uso-de-la-libreria",children:[]}]},{level:2,title:"5.1.2 Clases principales de la API Jakarta Mail",slug:"_5-1-2-clases-principales-de-la-api-jakarta-mail",link:"#_5-1-2-clases-principales-de-la-api-jakarta-mail",children:[{level:3,title:"jakarta.mail.Session",slug:"jakarta-mail-session",link:"#jakarta-mail-session",children:[]},{level:3,title:"jakarta.mail.Message",slug:"jakarta-mail-message",link:"#jakarta-mail-message",children:[]},{level:3,title:"jakarta.mail.Address",slug:"jakarta-mail-address",link:"#jakarta-mail-address",children:[]},{level:3,title:"jakarta.mail.Authenticator",slug:"jakarta-mail-authenticator",link:"#jakarta-mail-authenticator",children:[]},{level:3,title:"jakarta.mail.Transport",slug:"jakarta-mail-transport",link:"#jakarta-mail-transport",children:[]}]},{level:2,title:"5.1.3 Enviar correos electrónicos básicos en Jakarta Mail",slug:"_5-1-3-enviar-correos-electronicos-basicos-en-jakarta-mail",link:"#_5-1-3-enviar-correos-electronicos-basicos-en-jakarta-mail",children:[{level:3,title:"Preparación de la sesión",slug:"preparacion-de-la-sesion",link:"#preparacion-de-la-sesion",children:[]},{level:3,title:"Composición del mensaje (texto sin formato)",slug:"composicion-del-mensaje-texto-sin-formato",link:"#composicion-del-mensaje-texto-sin-formato",children:[]},{level:3,title:"Enviar mensaje",slug:"enviar-mensaje",link:"#enviar-mensaje",children:[]}]},{level:2,title:"5.1.4 Enviar mensajes HTML",slug:"_5-1-4-enviar-mensajes-html",link:"#_5-1-4-enviar-mensajes-html",children:[]},{level:2,title:"5.1.5 Enviar correo electrónico con archivos adjuntos",slug:"_5-1-5-enviar-correo-electronico-con-archivos-adjuntos",link:"#_5-1-5-enviar-correo-electronico-con-archivos-adjuntos",children:[]},{level:2,title:"5.1.6 Enviar correos electrónicos HTML con imágenes",slug:"_5-1-6-enviar-correos-electronicos-html-con-imagenes",link:"#_5-1-6-enviar-correos-electronicos-html-con-imagenes",children:[{level:3,title:"Insertando imágenes CID (Content-ID)",slug:"insertando-imagenes-cid-content-id",link:"#insertando-imagenes-cid-content-id",children:[]},{level:3,title:"Insertando imágenes en línea (Base64)",slug:"insertando-imagenes-en-linea-base64",link:"#insertando-imagenes-en-linea-base64",children:[]},{level:3,title:"Linked images",slug:"linked-images",link:"#linked-images",children:[]}]},{level:2,title:"5.1.7 Lectura de emails con Jakarta Mail",slug:"_5-1-7-lectura-de-emails-con-jakarta-mail",link:"#_5-1-7-lectura-de-emails-con-jakarta-mail",children:[]}],path:"/es/unit5/mail.html",pathLocale:"/es/",extraFields:[`---\r
title: 5.1 Correo\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="5.1 Correo" />\r
\r
# 5.1 Correo\r
\r
[[toc]]\r
\r
## 5.1.1 Jakarta Mail\r
\r
Al buscar en Internet tutoriales sobre el envío de correos electrónicos usando Java, existe una alta probabilidad de que cada uno mencione algo llamado \`Jakarta Mail\` o \`Java Mail\`.\r
\r
Durante mucho tiempo, Java Enterprise Edition (comúnmente conocido como Java EE), ha sido la plataforma de facto para desarrollar aplicaciones de misión crítica.\r
\r
Recientemente, con el fin de impulsar la creación de aplicaciones nativas de la nube, varios proveedores de software prominentes se unieron para transferir tecnologías Java EE a la Fundación Eclipse, que es una organización sin fines de lucro encargada de administrar las actividades de la comunidad de software de código abierto Eclipse.\r
\r
> **En consecuencia, Java EE ha sido renombrado a Jakarta EE.**\r
\r
A pesar del cambio de nombre, todas las clases principales y definiciones de propiedades siguen siendo las mismas tanto para Jakarta Mail como para JavaMail.\r
\r
::: tip Jakarta vs Java Mail\r
Para evitar confusiones, es importante tener en cuenta que JavaMail es solo el nombre anterior de Jakarta Mail y los dos representan el mismo software.\r
:::\r
\r
Entonces, Jakarta Mail, o JavaMail como a algunos todavía les gusta llamarlo, es una API para enviar y recibir correos electrónicos a través de **SMTP**, **POP3**, así como **IMAP** y es la opción más popular que también admite la autenticación TLS y SSL. Es independiente de la plataforma, independiente del protocolo e integrado en la plataforma Jakarta EE.\r
\r
También puede encontrar Jakarta Mail como un paquete opcional para su uso con la plataforma Java SE.\r
\r
\r
\r
### Uso de la librería\r
\r
>[JakartaMail API](https://jakarta.ee/specifications/mail/2.1/jakarta-mail-spec-2.1) es la especificación de la API de correo de Jakarta. La implementación de referencia de esta especificación se puede encontrar en el repositorio de GitHub [Jakarta Mail Specification](https://jakartaee.github.io/mail-api/).\r
\r
::: danger JavaMail API\r
Como su nombre indica, JavaMail API es una API, no una implementación. Por lo tanto, no puede usarlo directamente en su proyecto. En cambio, debe usar una implementación de la API de correo de Jakarta, como la implementación de referencia de la especificación de la API de correo de Jakarta.\r
:::\r
\r
También puede encontrar el archivo jakarta.mail-api-X.Y.Z.jar en el repositorio de Maven y agregarlo con dependencias \`Maven\`:\r
\r
\`\`\`xml:no-line-numbers\r
    <dependencies>\r
        <dependency>\r
            <groupId>org.eclipse.angus</groupId>\r
            <artifactId>angus-mail</artifactId>\r
            <version>2.0.2</version>\r
            <type>jar</type>\r
        </dependency>\r
        <dependency>\r
            <groupId>jakarta.mail</groupId>\r
            <artifactId>jakarta.mail-api</artifactId>\r
            <version>2.1.2</version>\r
            <type>jar</type>\r
        </dependency>\r
    </dependencies>\r
\`\`\`\r
\r
::: info Implementaciones de Jakarta Mail\r
En el ejemplo anterior hemos usado la implementación de Jakarta AngusMail, pero se pueden usar otras como la propia de Oracle, simplemente cambiando la dependencia.\r
\r
\`\`\`xml:no-line-numbers\r
        <dependency>\r
            <groupId>com.sun.mail</groupId>\r
            <artifactId>jakarta.mail</artifactId>\r
            <version>2.0.1</version>\r
        </dependency>        \r
\`\`\`\r
\r
Al ser una implementación del API propuesta por Jakarta, el código debería funcionar sin cambios.\r
:::\r
\r
## 5.1.2 Clases principales de la API Jakarta Mail\r
\r
La API de correo de Jakarta tiene una amplia gama de clases e interfaces que se pueden usar para enviar, leer y realizar otras acciones con mensajes de correo electrónico, al igual que en un sistema de correo típico.\r
\r
Aunque hay varios paquetes en el Proyecto de Correo de Jakarta, dos de los más utilizados son \`jakarta.mail\` y \`jakarta.mail.internet\`.\r
\r
El paquete **jakarta.mail** proporciona clases que modelan un sistema de correo y el paquete **jakarta.mail.internet** proporciona clases que se centran en los sistemas de correo de Internet.\r
\r
A continuación tenemos una descripción de las clases principales de cada uno de los paquetes:\r
\r
### jakarta.mail.Session\r
\r
La clase Session, que no tiene subclases, es la *clase de nivel superior de la API de correo de Jakarta*. Es un objeto multiproceso que actúa como fábrica de conexiones para la API de correo de Jakarta. además de recopilar las propiedades y los valores predeterminados de la API de correo, **es responsable de los ajustes de configuración y la autenticación**.\r
\r
Para obtener el objeto Session, puede llamar a cualquiera de los dos métodos siguientes:\r
\r
- getDefaultInstance(), que devuelve la sesión predeterminada\r
- getInstance(), que devuelve una nueva sesión\r
  \r
### jakarta.mail.Message\r
\r
La clase Message es una *clase abstracta* que modela un mensaje de correo electrónico; Sus subclases soportan las implementaciones reales. Por lo general, su \`subclase MimeMessage\` *(jakarta.mail.internet.MimeMessage)* se utiliza para preparar los detalles del mensaje de correo electrónico que se enviará. **Un MimeMessage es un mensaje de correo electrónico que utiliza el estilo de formato MIME (Multipurpose Internet Mail Extension)** definido en el RFC822.\r
\r
Estos son algunos de los métodos más utilizados de la clase MimeMessage:\r
|Método |Descripción |\r
|:---|:---|\r
|setFrom(Address addresses) | Se utiliza para establecer el campo de encabezado "De".|\r
|setRecipients(Message.RecipientType type, String addresses) | Se utiliza para establecer el tipo de destinatario indicado en las direcciones proporcionadas. Los posibles tipos de direcciones definidos son "Para" (Message.RecipientType.TO), "CC" (Message.RecipientType.CC) y "CCO" (Message.RecipientType.BCC).|\r
|setSubject(String subject) | Se utiliza para establecer el campo de encabezado del asunto del correo electrónico.|\r
|setText(String text) | Se utiliza para establecer la cadena proporcionada como contenido del correo electrónico, utilizando el tipo MIME de "texto / sin formato". |\r
|setContent(Object message, String contentType) |Se utiliza para establecer el contenido del correo electrónico y se puede utilizar con un tipo MIME que no sea "text/html".|\r
\r
### jakarta.mail.Address\r
\r
La clase Address es una *clase abstracta* que modela las direcciones (direcciones To y From) en un mensaje de correo electrónico; Sus subclases soportan las implementaciones reales. Por lo general, su \`subclase InternetAddress\`, que denota una dirección de correo electrónico de Internet, es la que mas se usa.\r
\r
### jakarta.mail.Authenticator\r
\r
La clase Authenticator es una *clase abstracta* que se utiliza para obtener autenticación para acceder a los recursos del servidor de correo, a menudo requiriendo la información del usuario. Por lo general, su \`subclase PasswordAuthentication\` es la que mas se usa.\r
\r
### jakarta.mail.Transport\r
\r
La clase Transport es una *clase abstracta* que utiliza el \`protocolo SMTP\` para enviar y transportar mensajes de correo electrónico.\r
\r
## 5.1.3 Enviar correos electrónicos básicos en Jakarta Mail\r
\r
Básicamente, estos son los pasos para enviar un email utilizando la API de correo de Jakarta:\r
\r
1. Configurar detalles del servidor SMTP utilizando un **objeto Java Properties**. Puede obtener detalles del servidor SMTP de su proveedor de servicios de correo electrónico.\r
1. Crear un objeto Session llamando al método getInstance(). Luego, pasar el \`nombre de usuario y contraseña de la cuenta\` a PasswordAuthentication. Al crear el objeto de sesión, siempre debe registrar el *Authenticator* con la sesión.\r
1. Una vez creado el objeto Session, el siguiente paso es crear el email que se enviará. Para ello, empezaremos pasando el objeto de sesión creado al constructor de clase MimeMessage.\r
1. A continuación, después de crear el objeto de mensaje, establecer los campos De, Para y Asunto del email.\r
1. Utilizar el método \`setText()\` para establecer el contenido del mensaje de correo electrónico.\r
1. Utilizar el objeto Transport para enviar el correo.\r
1. Agregue excepciones para recuperar los detalles de cualquier posible error al enviar el mensaje.\r
\r
### Preparación de la sesión\r
\r
El primer paso es obtener el objeto de sesión de correo. La clase *Session* es una clase singleton. Por lo tanto, no se puede crear directamente una instancia de la misma. Debemos llamar a uno de los métodos estáticos sobrecargados, generalmente \`getInstance()\`.\r
\r
::: info Archivos/Objetos Properties\r
Un archivo de propiedades es un archivo de texto que contiene pares clave-valor para los valores de configuración de un proyecto.\r
\r
Se pueden crear sobre la marcha como en los siguientes ejemplos, pero también se puede leer desde un archivo en el proyecto (esta es la forma preferida).\r
\r
Aquí puedes encontrar algunos enlaces para echar un vistazo a cómo usar y acceder a estos archivos\r
\r
- [Java Properties Files y como usarlos - Arquitectura Java](https://www.arquitecturajava.com/java-properties-files-y-como-usarlos/)\r
- [Getting started with Java properties  - Baeldung](https://www.baeldung.com/java-properties)\r
- [Properties class in Java - javaTpoint](https://www.javatpoint.com/properties-class-in-java)\r
\r
![http://www.instanceofjava.com/2018/01/how-to-read-values-from-properties-file.html](../../media/unit5/propertiesfile.png)\r
\r
En la imagen anterior puedes ver dónde colocar el archivo de propiedades en un proyecto 'Maven'.\r
:::\r
\r
\`\`\` java\r
// Prepare SMTP configuration into a Property object\r
final Properties prop = new Properties();\r
prop.put("mail.smtp.username", "usuario@gmail.com");\r
prop.put("mail.smtp.password", "passwordEmail");\r
prop.put("mail.smtp.host", "smtp.gmail.com");\r
prop.put("mail.smtp.port", "587");\r
prop.put("mail.smtp.auth", "true");\r
prop.put("mail.smtp.starttls.enable", "true"); // TLS\r
\r
// Create the Session with the user credentials\r
Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
    @Override\r
    protected PasswordAuthentication getPasswordAuthentication() {\r
        return new PasswordAuthentication(prop.getProperty("mail.smtp.username"), \r
                    prop.getProperty("mail.smtp.password"));\r
    }\r
});\r
\`\`\`\r
\r
En el código anterior, acabamos de crear el objeto Session con propiedades y el objeto Authenticator.\r
\r
Las propiedades son las siguientes.\r
\r
- mail.smtp.username – Nombre de usuario para acceder al servidor SMTP\r
- mail.smtp.password – Contraseña de acceso al servidor SMTP\r
- mail.smtp.host – Host del servidor SMTP\r
- mail.smtp.port – Puerto\r
- mail.smtp.auth – Se requiere autenticación.\r
- mail.smtp.starttls.enable – TLS habilitado o no.\r
\r
El Authenticator es una clase abstracta. Su objeto se crea proporcionando una implementación anónima del método \`getPasswordAuthentication()\`. La clase *PasswordAuthentication* se utiliza como marcador para almacenar credenciales de usuario.\r
\r
Este es un código de ejemplo para leer las propiedades de un archivo en el proyecto.\r
\r
\`\`\`java\r
    private void loadSMTPConfiguration() {\r
        try ( InputStream input = this.getClass().getResourceAsStream("/" + propertiesFile)) {\r
\r
            smtpConfiguration = new Properties();\r
            // load a properties file\r
            smtpConfiguration.load(input);\r
\r
            // get the property value and print it out\r
            smtpConfiguration.forEach((key, value) -> System.out.println("Key : " + key + ", Value : " + value));\r
\r
        } catch (IOException ex) {\r
            System.err.println("Cant open properties file: " + ex.getLocalizedMessage());\r
            ex.printStackTrace();\r
        }\r
    }    \r
\`\`\`\r
\r
El contenido del archivo de propiedades podría ser así\r
\r
\`\`\`txt\r
# Data to send emails from a GMAIL account\r
mail.from=cuenta@iesdoctorbalmis.com ó cuenta@gmail.com\r
mail.smtp.username=cuenta@iesdoctorbalmis.com\r
mail.smtp.password=***contraseña de la cuenta habilitando apps poco seguras o contraseña de app con 2FA***\r
\r
mail.smtp.host=smtp.gmail.com\r
mail.smtp.port=587\r
mail.smtp.auth=true\r
mail.smtp.starttls.enable=true\r
\`\`\`\r
\r
### Composición del mensaje (texto sin formato)\r
\r
A continuación, redactaremos el mensaje de correo electrónico. La clase jakarta.mail.Message representa un mensaje en Java mail API. Dado que es una clase abstracta, usaremos su clase de implementación concreta \`jakarta.mail.internet.MimeMessage\`. Java Mail API permite enviar correo en texto plano o en contenido HTML. Comencemos enviando un mensaje de texto sin formato.\r
\r
\`\`\`java{8}\r
// Prepare the MimeMessage\r
Message message = new MimeMessage(mailSession);\r
// Set From and subject email properties\r
message.setFrom(new InternetAddress("no-reply@gmail.com"));\r
message.setSubject("Sending Mail with pure Java Mail API ");\r
\r
// Set to, cc & bcc recipients        \r
InternetAddress[] toEmailAddresses = \r
        InternetAddress.parse("user1@gmail.com, user2@gmail.com");\r
InternetAddress[] ccEmailAddresses = \r
        InternetAddress.parse("user21@gmail.com, user22@gmail.com");\r
InternetAddress[] bccEmailAddresses = \r
        InternetAddress.parse("user31@gmail.com");\r
            \r
message.setRecipients(Message.RecipientType.TO,toEmailAddresses);\r
message.setRecipients(Message.RecipientType.CC,ccEmailAddresses);\r
message.setRecipients(Message.RecipientType.BCC,bccEmailAddresses);\r
\r
/* Mail body with plain Text */\r
message.setText("Hello User," \r
        + "\\n\\n If you read this, means mail sent with Java Mail API is successful");\r
\r
\`\`\`\r
\r
> **Para enviar un correo electrónico en texto sin formato, simplemente pasamos el texto en el método message.setText().**\r
\r
### Enviar mensaje\r
\r
Hasta ahora, hemos creado una sesión y redactado el mensaje. Ahora es el momento de enviar el mensaje a los destinatarios. Usaremos la clase jakarta.mail.Transport para hacerlo. La clase proporciona métodos \`send()\` sobrecargados.\r
\r
\`\`\`java\r
    // Send the configured message in the session\r
    Transport.send(message);\r
\`\`\`\r
\r
::: info Emails temporales\r
[YopMail](http://www.yopmail.com/en/) es un servicio de correo electrónico temporal que se puede utilizar para recibir correos electrónicos de forma anónima. No se requiere registro para usar el servicio. Puede usar cualquier dirección de correo electrónico de su elección para recibir correos electrónicos. El servicio es gratuito y se puede utilizar para recibir correos electrónicos de forma anónima. El servicio es gratuito y se puede utilizar para recibir correos electrónicos de forma anónima.\r
:::\r
\r
## 5.1.4 Enviar mensajes HTML\r
\r
En términos de usabilidad, el contenido HTML es muy superior al texto sin formato. Por lo tanto, la mayoría de las veces enviamos emails en formato HTML. Java Mail API admite el envío de correos electrónicos en formato HTML. Para enviar un correo electrónico con contenido HTML, debemos  reemplazar el método message.setText() con el siguiente código.\r
\r
\`\`\`java\r
...\r
message.setContent("Just discovered that Jakarta Mail is fun and easy to use", \r
"text/html");\r
...\r
\`\`\`\r
\r
> usaremos el método **setContent()** para establecer el contenido y especificar \`"text/html"\` en el segundo argumento, lo que indica que el mensaje tiene formato HTML.\r
\r
## 5.1.5 Enviar correo electrónico con archivos adjuntos\r
\r
Además de los pasos mencionados anteriormente, estos son los diferentes pasos involucrados en el uso de la API de correo de Jakarta para enviar archivos adjuntos de correo electrónico:\r
\r
1. Creamos una instancia del objeto \`MimeMultipart\` que se utilizará como envoltorio o *wrapper* para las distintas partes *MimeBodyPart*. **Un *MultiPart* actúa como un contenedor que guarda varias partes individuales**, y viene con métodos para obtener y configurar sus diversas subpartes.\r
1. Luego, establecemos la primera parte del objeto *Multipart* pasándole el mensaje real.\r
1. A continuación, establecemos la segunda y las siguientes parte del objeto *Multipart* agregando los datos adjuntos.\r
1. Incluimos el objeto *Multipart* en el mensaje a enviar.\r
1. Enviamos el mensaje\r
\r
![Estructura del mensaje MIME Multipart](../../media/unit5/e-mail_multipart_structure.png)\r
\r
\`\`\`java{2,5,9,12,16,19}\r
 // create an instance of multipart object\r
Multipart multipart = new MimeMultipart();\r
\r
// create the 1st message body part\r
MimeBodyPart messageBodyPart = new MimeBodyPart();\r
// Add a plain message (HTML can also be added with setContent)\r
messageBodyPart.setText("Please find the attachment sent using Jakarta Mail");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// 2nd. bodyPart with an attached file\r
messageBodyPart = new MimeBodyPart();\r
String filename = "C:/temp/file1.pdf";\r
messageBodyPart.attachFile(filename);\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(messageBodyPart);            \r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
## 5.1.6 Enviar correos electrónicos HTML con imágenes\r
\r
Para agregar una imagen a su correo electrónico HTML en Jakarta Mail, puede elegir cualquiera de las tres opciones comunes:\r
\r
- Insertando imágenes CID.\r
- Insertando imágenes en línea o codificación Base64.\r
- Enlazando imágenes.\r
  \r
### Insertando imágenes CID (Content-ID)\r
\r
Para insertar imágenes CID, debemos crear un mensaje \`MIME multipart/related\` usando el siguiente código:\r
\r
\`\`\`java{2,5,17}\r
// 1st part of the message. An HTML code with a CID referenced image\r
Multipart multipart = new MimeMultipart("related");\r
MimeBodyPart htmlPart = new MimeBodyPart();\r
//add reference to your image to the HTML body <img src="cid:some-image-cid" alt="img" />\r
String messageBody = "<p></p><img src=\\"cid:my-test-image-cid\\" alt=\\"embedded img\\" /></p>";\r
htmlPart.setText(messageBody, "utf-8", "html");\r
// Add the BodyPart to the Multipart object\r
multipart.addBodyPart(htmlPart);\r
\r
// 2nd part of the message. The image with special CID header markers\r
MimeBodyPart imgPart = new MimeBodyPart();\r
// imageFile is the file containing the image\r
imgPart.attachFile(imageFile);\r
// or, if the image is in a byte array in memory, use\r
// imgPart.setDataHandler(new DataHandler(\r
//      new ByteArrayDataSource(bytes, "image/whatever")));\r
imgPart.setContentID("<my-test-image-cid>");\r
// Add the multipart object to the message\r
multipart.addBodyPart(imgPart);\r
\r
// Add the multipart object to the message\r
message.setContent(multipart);\r
\r
// Send the message with multipart MIME objects\r
Transport.send(message);\r
\`\`\`\r
\r
### Insertando imágenes en línea (Base64)\r
\r
Para la inserción en línea o la codificación Base64, debe incluir los datos de imagen codificados en el cuerpo HTML de forma similar a esta:\r
\r
\`\`\`html\r
<img src="data:image/jpeg;base64,base64-encoded-data-here" />\r
\`\`\`\r
\r
::: warning tamaño del HTML\r
Cada dígito Base64 representa 6 bits de datos, por lo que el código generado para una imagen real será bastante grande.\r
\r
Como esto afecta el tamaño total del mensaje HTML, es mejor no usar imágenes grandes en línea.\r
:::\r
\r
Para codificar/decodificar una secuencia en Base 64 podemos usar la clase \`java.util.Base64\`\r
\r
 \`\`\`java\r
byte[] fileContent = new FileInputStream(imageFile).readAllBytes();\r
String base64EncodedData = Base64.getEncoder().encodeToString(fileContent);\r
 \`\`\`\r
\r
:::tip Codificación base64\r
Base64 es una buena opción para enviar datos binarios a través de protocolos de texto como HTTP, sin pérdida de información.\r
\r
Esta operación se puede aplicar a cualquier archivo binario. Es útil cuando necesitamos transferir contenido binario en formato JSON, por ejemplo desde la aplicación móvil al endpoint de conexión REST.\r
\r
[Image to Base64 String Conversion - Baeldung](https://www.baeldung.com/java-base64-image-string)\r
:::\r
\r
### Linked images\r
\r
Por último, tenemos imágenes vinculadas que son esencialmente imágenes alojadas en algún servidor externo al que luego crea un enlace.\r
Podemos hacerlo usando la etiqueta img en el cuerpo HTML de la siguiente manera.\r
\r
\`\`\`html\r
<img src="/wp-content/uploads/2018/11/blog/-illustration-email-embedding-images.png" alt="img" />\r
\`\`\`\r
\r
::: warning Debug Jakarta Mail\r
La depuración juega un papel fundamental en las pruebas de envío de correo electrónico.\r
\r
En Jakarta Mail, es bastante sencillo. Tan solo hay que establecer debug a true en las propiedades de configuración de la sesión:\r
\r
> props.put("mail.debug", "true");\r
\r
Como resultado, obtendremos una descripción paso a paso de cómo se ejecuta el código. Si aparece algún problema con el envío del mensaje, comprenderemos instantáneamente lo que ha sucedido y en qué paso.\r
:::\r
\r
## 5.1.7 Lectura de emails con Jakarta Mail\r
\r
El API de correo de Jakarta también proporciona soporte para leer correos electrónicos. Para leer correos electrónicos, debe usar la clase \`javax.mail.Store\`. La clase Store es una clase abstracta que modela un almacén de mensajes y su protocolo de acceso, y es una subclase de las clases \`POP3Store\` e \`IMAPStore\`.\r
\r
Leer correos electrónicos almacenados en un servidor IMAP consta de los siguientes pasos:\r
\r
- Creación de la sesión IMAP (Session), indicando el protocolo, el nombre del host, el puerto, si usa SSL y el servidor de autenticación asociado.\r
- Configuración y obtención del almacén (Store).\r
- Obtención de la conexión a través del almacén, indicando el identificador de la cuenta y la contraseña.\r
- Obtención de la carpeta a leer.\r
- Apertura de la carpeta.\r
- Obtención de los mensajes\r
- Procesamiento de mensajes\r
- Cierre de la carpeta y del almacén.\r
- Cierre de la sesión y de la conexión\r
\r
\`\`\`java\r
    // Prepare IMAP configuration into a Property object\r
    final Properties prop = new Properties();\r
    prop.put("mail.imap.host", "imap.gmail.com");\r
    prop.put("mail.imap.port", "993");\r
    prop.put("mail.imap.ssl.enable", "true");\r
    prop.put("mail.imap.auth", "true");\r
\r
    // Create the Session with the user credentials\r
    Session mailSession = Session.getInstance(prop, new jakarta.mail.Authenticator() {\r
        @Override\r
        protected PasswordAuthentication getPasswordAuthentication() {\r
            return new PasswordAuthentication(prop.getProperty("mail.imap.username"), \r
                        prop.getProperty("mail.imap.password"));\r
        }\r
    });\r
\r
    // Get the Store object and connect to the current host using the specified username and password.\r
    Store store = mailSession.getStore("imap");\r
    store.connect(prop.getProperty("mail.imap.host"), \r
            prop.getProperty("mail.imap.username"), \r
            prop.getProperty("mail.imap.password"));\r
\r
    // Get the folder and open it\r
    Folder folder = store.getFolder("INBOX");\r
    folder.open(Folder.READ_ONLY);\r
\r
    // Get the messages\r
    Message[] messages = folder.getMessages();\r
\r
    // Process the messages\r
    for (int i = 0; i < messages.length; i++) {\r
        Message message = messages[i];\r
        System.out.println("Message " + (i + 1));\r
        System.out.println("From: " + message.getFrom()[0]);\r
        System.out.println("Subject: " + message.getSubject());\r
        System.out.println("Sent Date: " + message.getSentDate());\r
        System.out.println("Text: " + message.getContent().toString());\r
    }\r
\r
    // Close the folder and store objects\r
    folder.close(false);\r
    store.close();\r
\`\`\`\r
`]},{title:"4.2 Clases auxiliares para direccionamiento",headers:[{level:2,title:"4.2.1. java.net.NetworkInterface",slug:"_4-2-1-java-net-networkinterface",link:"#_4-2-1-java-net-networkinterface",children:[]},{level:2,title:"4.2.2 java.net.InterfaceAddress",slug:"_4-2-2-java-net-interfaceaddress",link:"#_4-2-2-java-net-interfaceaddress",children:[]},{level:2,title:"4.2.3. java.net.InetAddress",slug:"_4-2-3-java-net-inetaddress",link:"#_4-2-3-java-net-inetaddress",children:[]},{level:2,title:"4.2.4 java.net.URL",slug:"_4-2-4-java-net-url",link:"#_4-2-4-java-net-url",children:[]},{level:2,title:"4.2.5 java.net.URLConnection",slug:"_4-2-5-java-net-urlconnection",link:"#_4-2-5-java-net-urlconnection",children:[]}],path:"/es/unit5/urls.html",pathLocale:"/es/",extraFields:[`---\r
title: 4.2 Clases auxiliares para direccionamiento\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="4.2 Clases auxiliares para direccionamiento" />\r
\r
# 4.2 Clases auxiliares para direccionamiento\r
\r
[[toc]]\r
\r
## 4.2.1. java.net.NetworkInterface\r
\r
Esta clase representa la interfaz de red, tanto software como hardware, su nombre, la lista de direcciones IP asignadas y toda la información relacionada. Se puede usar en los casos en que queramos usar específicamente una interfaz particular para transmitir nuestro paquete en un sistema con múltiples NIC.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/NetworkInterface.html)\r
\r
::: info ¿Qué es una interfaz de red?  \r
Se puede pensar en una interfaz de red como un punto en el que su computadora se conecta a la red. No es necesariamente una pieza de hardware, pero también se puede implementar en un software. Por ejemplo, una interfaz de bucle invertido que se utiliza con fines de prueba.\r
:::\r
\r
| Method                                                            | Description                                                                                                                                                                                                                        |\r
| ----------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public static Enumeration getNetworkInterfaces()                  | Devuelve todas las interfaces de red del sistema.                                                                                                                                                                                  |\r
| public List getInterfaceAddresses()                               | Devuelve una lista de todas las direcciones de interfaz en esta interfaz.                                                                                                                                                          |\r
| public Enumeration getInetAddresses()                             | Devuelve una enumeración de todas las Inetaddresses vinculadas a esta interfaz de red, si el administrador de seguridad lo permite.                                                                                                |\r
| public String getName()                                           | Devuelve el nombre de esta interfaz de red                                                                                                                                                                                         |\r
| public int getIndex()                                             | Devuelve el índice asignado a esta interfaz de red por el sistema. Los índices se pueden utilizar en lugar de nombres largos para hacer referencia a cualquier interfaz del dispositivo.                                           |\r
| public String getDisplayName()                                    | Este método devuelve el nombre de la interfaz de red en un formato de string legible.                                                                                                                                              |\r
| public static NetworkInterface getByName(String name)             | Busca y devuelve la interfaz de red con el nombre especificado, o nulo si no existe.                                                                                                                                               |\r
| public static NetworkInterface getByIndex(int index)              | Realiza una función similar a la función anterior con el índice utilizado como parámetro de búsqueda en lugar del nombre.                                                                                                          |\r
| public static NetworkInterface getByInetAddress(InetAddress addr) | Este método se usa ampliamente ya que devuelve la interfaz de red a la que está vinculada la dirección de red especificada. Si una InetAddress está vinculada a varias interfaces, se puede devolver cualquiera de las interfaces. |\r
| public boolean isUp()                                             | Devuelve un valor booleano que indica si esta interfaz de red está en funcionamiento.                                                                                                                                              |\r
\r
\`\`\`java\r
// Java program to illustrate various java.net.NetworkInterface class methods.\r
\r
public class NetworkInterfaceExample\r
{\r
    public static void main(String[] args) throws SocketException,\r
                                                UnknownHostException\r
    {\r
\r
        // getNetworkInterfaces() returns a list of all interfaces\r
        // present in the system.\r
        ArrayList<NetworkInterface> interfaces = Collections.list(\r
                                            NetworkInterface.getNetworkInterfaces());\r
\r
        System.out.println("Information about present Network Interfaces...\\n");\r
        for (NetworkInterface iface : interfaces)\r
        {\r
            // isUp() method used for checking whether the interface in process\r
            // is up and running or not.\r
            if (iface.isUp())\r
            {\r
                // getName() method\r
                System.out.println("Interface Name: " + iface.getName());\r
\r
                // getDisplayName() method\r
                System.out.println("Interface display name: " + iface.getDisplayName());\r
\r
                // getHardwareAddress() method\r
                System.out.println("Hardware Address: " +\r
                                Arrays.toString(iface.getHardwareAddress()));\r
\r
                // getParent() method\r
                System.out.println("Parent: " + iface.getParent());\r
\r
                // getIndex() method\r
                System.out.println("Index: " + iface.getIndex());\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInterface addresses: ");\r
\r
                // getInterfaceAddresses() method\r
                for (InterfaceAddress addr : iface.getInterfaceAddresses())\r
                {\r
                    System.out.println("\\t\\t" + addr.getAddress().toString());\r
                }\r
                // Interface addresses of the network interface\r
                System.out.println("\\tInetAddresses associated with this interface: ");\r
\r
                // getInetAddresses() method returns list of all\r
                // addresses currently bound to this interface\r
                Enumeration<InetAddress> en = iface.getInetAddresses();\r
                while (en.hasMoreElements())\r
                {\r
                    System.out.println("\\t\\t" + en.nextElement().toString());\r
                }\r
\r
                // getMTU() method\r
                System.out.println("\\tMTU: " + iface.getMTU());\r
\r
                // getSubInterfaces() method\r
                System.out.println("\\tSubinterfaces: " +\r
                                Collections.list(iface.getSubInterfaces()));\r
\r
                // isLoopback() method\r
                System.out.println("\\tis loopback: " + iface.isLoopback());\r
\r
                // isVirtual() method\r
                System.out.println("\\tis virtual: " + iface.isVirtual());\r
\r
                // isPointToPoint() method\r
                System.out.println("\\tis point to point: " + iface.isPointToPoint());\r
\r
                // supportsMulticast() method\r
                System.out.println("Supports Multicast: " + iface.supportsMulticast());\r
\r
            }\r
        }\r
\r
        // getByIndex() method returns network interface\r
        // with the specified index\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
\r
        // toString() method is used to display textual\r
        // information about this network interface\r
        System.out.println("Network interface 1: " + nif.toString());\r
\r
        // getByName() method returns network interface\r
        // with the specified name\r
        NetworkInterface nif2 = NetworkInterface.getByName("eth0");\r
        InetAddress ip = InetAddress.getByName("localhost");\r
\r
        // getbyInetAddress() method\r
        NetworkInterface nif3 = NetworkInterface.getByInetAddress(ip);\r
        System.out.println("\\nlocalhost associated with: " + nif3);\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.2 java.net.InterfaceAddress\r
\r
Esta clase representa una dirección de interfaz de red. Cada dispositivo que tiene una dirección IP tiene una dirección IP en la interfaz de red. De hecho, el comando ping no hace ping a un dispositivo, sino a la dirección de interfaz de los dispositivos.\r
\r
Java proporciona ciertos métodos para tratar con direcciones de interfaz que se pueden usar en lugares donde existe la necesidad de conocer la topología de la red, para la detección de fallas en una red, etc.\r
\r
Resumiendo, esta clase representa a una dirección IP, una máscara de red y una dirección broadcast (cuando la dirección es IPv4). Sólo representa una dirección IP address y una longitud de prefijo de red en el caso de direcciones IPv6.\r
\r
> [java.net.InterfaceAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InterfaceAddress.html)\r
\r
| Method                                | Description                                                                                                                                                                                                      |\r
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| public InetAddress getAddress()       | Devuelve una InetAddress para esta dirección                                                                                                                                                                     |\r
| public InetAddress getBroadcast()     | Devuelve InetAddress para la dirección de transmisión para esta dirección de interfaz. Como solo las direcciones IPv4 tienen direcciones de transmisión, se devolvería un valor nulo al usar una dirección IPv6. |\r
| public short getNetworkPrefixLength() | Devuelve la longitud del prefijo para esta dirección de interfaz, es decir, la máscara de subred para esta dirección.                                                                                            |\r
\r
\`\`\`java\r
// Java program to illustrate methods of java.net.InterfaceAddress class\r
\r
public class InterfaceaddressExample\r
{\r
    public static void main(String[] args) throws SocketException\r
    {\r
        // Modify according to your system\r
        NetworkInterface nif = NetworkInterface.getByIndex(1);\r
        List<InterfaceAddress> list = nif.getInterfaceAddresses();\r
\r
        for (InterfaceAddress iaddr : list)\r
        {\r
            // getAddress() method\r
            System.out.println("getAddress() : " + iaddr.getAddress());\r
\r
            // getBroadcast() method\r
            System.out.println("getBroadcast() : " + iaddr.getBroadcast());\r
\r
            // getNetworkPrefixLength() method\r
            System.out.println("PrefixLength : " + iaddr.getNetworkPrefixLength());\r
\r
            // hashCode() method\r
            System.out.println("Hashcode : " + iaddr.hashCode());\r
\r
            // toString() method\r
            System.out.println("toString() : " + iaddr.toString());\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
## 4.2.3. java.net.InetAddress\r
\r
La clase java.net.InetAddress proporciona métodos para obtener la dirección IP de cualquier nombre de host, por ejemplo example www.google.com, www.facebook.com, etc.\r
\r
> [java.net.InetAddress specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)\r
\r
La clase InetAddress se usa para encapsular tanto la dirección IP numérica como el nombre de dominio para esa dirección.\r
\r
Hay 2 tipos de direcciones:\r
\r
- Unicast: un identificador para una única interfaz.\r
- Multicast: un identificador para un conjunto de interfaces.\r
\r
::: warning Local Name Resolver (hosts file)\r
Deberías saber que DNS traduce nombre de dominio en direcciones IP. Pero, ?sabes que hay un archivo en tu sistema que puede sobrescribir esas traducciones?\r
\r
Es el archivo \`hosts\` y nos permite mapear nombre de dominio a direcciones IP. Tu archivo HOSTS sólo afecta al comportamiento de tu equipo, por lo que podemos usarlo para crear direcciones personalizadas para IP de nuestra red, o bien para redireccionar / bloquear el acceso a determinados sitios web.\r
\r
Como puedes imaginar, cambiar de forma incorrecta o **maliciosa** el contenido del archivo hOSTS puede romper fácilmente el comportamiento de tu conexión a Internet, Así que la modificación del archivo no es trivial para los usuarios, algo que es de agradecer.\r
\r
- Windows\r
\r
El archivo HOSTS está almacenado como un fichero de texto plano en la carpeta del sistema de Windows.\r
\r
Abre el menú inicio y escribe "notepad".\r
\r
Pulsa con el botón derecho y selecciona la opción de "Ejecutar como administrador"\r
\r
En Notepad, ve a Archivo > Abrir y pega la siguiente ruta:\r
\r
c:\\Windows\\System32\\Drivers\\etc\\hosts\r
\r
Ahora ya puedes editar y guardar los cambios en tu archivo HOSTS.\r
\r
Para mapear un dominio, añade una nueva línea siguiendo los ejemplos que hay en el archivo.\r
\r
- OS X & GNU/Linux\r
\r
El archivo está en /etc/hosts y debes editarlo con privilegios de administrador.\r
\r
\`\`\`bash\r
# Añadimos las siguientes entradas al archivo hosts\r
## En clase \r
##  - como cliente y servidor ponemos la IP de nuestro equipo.\r
##  - como profesor ponemos la IP del ordenador del profesor\r
## En casa \r
##  - como cliente, servidor y profesor ponemos la IP de nuestro equipo.\r
\r
# En nuestras actividades, para no tener que ir cambiando las direcciones IP, usaremos \r
# siempre estos nombres de dominio, así los programas funcionarán tanto en clase como\r
# en casa.\r
10.100.XX.1 cliente.psp\r
10.100.XX.1 servidor.psp \r
10.100.0.1 profesor.psp\r
\`\`\`\r
\r
:::\r
\r
| Method                                                                       | Description                                                                                                       |\r
| ---------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |\r
| public static InetAddress getByName(String host) throws UnknownHostException | Este método devuelve la instancia de InetAddress que contiene el nombre y la IP del host recibido como parámetro. |\r
| public static InetAddress getLocalHost() throws UnknownHostException         | Este método devuelve la instancia de InetAddress que contiene el nombre y la IP de LocalHost.                     |\r
| public String getHostName()                                                  | Este método devuelve el nombre de host para esta dirección IP.                                                    |\r
| public String getHostAddress()                                               | Este método obtiene la dirección IP en forma de string.                                                           |\r
| public boolean isReachable(int timeout)                                      | Este método prueba si esa dirección es accesible.                                                                 |\r
\r
\`\`\`java\r
\r
class InetAddressExample {\r
    public static void main(String[] args)\r
        throws UnknownHostException\r
    {\r
        // To get and print InetAddress of Local Host\r
        InetAddress address1 = InetAddress.getLocalHost();\r
        System.out.println("InetAddress of Local Host : "\r
                        + address1);\r
\r
        // To get and print InetAddress of Named Host\r
        InetAddress address2\r
            = InetAddress.getByName("45.22.30.39");\r
        System.out.println("InetAddress of Named Host : "\r
                        + address2);\r
\r
        // To get and print ALL InetAddresses of Named Host\r
        InetAddress address3[]\r
            = InetAddress.getAllByName("172.19.25.29");\r
        for (int i = 0; i < address3.length; i++) {\r
            System.out.println(\r
                "ALL InetAddresses of Named Host : "\r
                + address3[i]);\r
        }\r
\r
        // To get and print InetAddresses of\r
        // Host with specified IP Address\r
        byte IPAddress[] = { 125, 0, 0, 1 };\r
        InetAddress address4\r
            = InetAddress.getByAddress(IPAddress);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address : "\r
            + address4);\r
\r
        // To get and print InetAddresses of Host\r
        // with specified IP Address and hostname\r
        byte[] IPAddress2\r
            = { 105, 22, (byte)223, (byte)186 };\r
        InetAddress address5 = InetAddress.getByAddress(\r
            "gfg.com", IPAddress2);\r
        System.out.println(\r
            "InetAddresses of Host with specified IP Address and hostname : "\r
            + address5);\r
    }\r
}\r
\r
\`\`\`\r
\r
::: question Buscador de equipos (U4S4_HostSeeker)\r
Tu equipo está conectado a una LAN (Red de Área Local) y probablemente esté usando una dirección IP privada.\r
\r
Las direcciones pueden ser de clase C (192.168.X.Y), clase B (172.17.X.Y) o clase A (10.X.Y.Z). Eso depende principalmente de la máscara de red y del prefijo de red usado para la configuración del interfaz.\r
\r
Puedes comprobar esta configuración con los comandos **ifconfig** de OSX GNU/Linux o **ipconfig** de Windows..\r
\r
Escribe un programa que averigüe, dentro de nuestra red, qué hosts están activos en la red, es decir, qué hosts son "alcanzables" desde tu equipo usando uno de los interfaces disponibles.\r
\r
Primero vamos a hacerlo de forma sencilla. Escribe un programa que sabiendo la dirección de tu equipo y la longitud del prefijo, pruebe todas las posibles combinaciones.\r
\r
> Si nuestra IP es 192.168.0.50 y el prefijo es /24, esto indica que los primeros 24 bits de la dirección IP son el identificador de la red, y que los 8 últimos son para identificadores de hosts. Por lo que sólo tenemos que ir probando con los últimos 8 bits (el último dígito de la dirección) para detectar a otros equipos en la red. Esto nos da 254 posibilidades, ya que la 0 y la 255 no se usan para hosts.\r
>\r
> Si por el contrario, el prefijo fuese 16, tendríamos que ir cambiando los dos últimos números.\r
>\r
> 192.168.0.1 a 192.168.0.254, después 192.168.1.1 a 192.168.1.254, así hasta 192.168.255.1 a 192.168.255.254, es decir, tendría que usar un bucle anidado.\r
\r
La aplicación sólo debe mostrar la dirección IP de los equipos que sean alcanzables.\r
\r
**Optativo**: Una vez que tengas tu aplicación funcionando, intenta hacerla genérica y reutilizable para que funcione en cualquier red, obteniendo el prefijo de red y comprobando todas las posibles direcciones en la red en función del prefijo obtenido.\r
\r
En ambos casos la aplicación recibirá el nombre de una NIC como argumento y comprobará sólo las direcciones IP asignadas a esa interfaz.\r
\r
Podemos saber si una dirección es IPv4 o IPv6 usando el operador \`ìnstanceof\` con las subclases Inet4Address y Inet6Address.\r
:::\r
\r
::: details Código del ejemplo\r
\r
\`\`\`java\r
public class U4S4_HostSeeker {\r
\r
    private final int timeout = 10;\r
    private String interfaceName;\r
    private String ipAddress;\r
    private String networkMask;\r
\r
    private ArrayList<String> reachableIps = new ArrayList<>();\r
\r
    public static void main(String[] args)\r
            throws UnknownHostException, IOException {\r
\r
        U4S4_HostSeeker seeker = new U4S4_HostSeeker(args);\r
        System.out.println("Scanning...");\r
        seeker.processNetwork();\r
        seeker.listResults();\r
    }\r
\r
    public U4S4_HostSeeker(String[] args) throws SocketException, UnknownHostException {\r
        NetworkInterface networkCard = null;\r
\r
        switch (args.length) {\r
            case 1 -> {\r
                // Get the interface from the name\r
                interfaceName = args[0];\r
                                \r
                networkCard = NetworkInterface.getByName(interfaceName);\r
\r
                // Get the IP and the mask from the NetworkInterface\r
                List<InterfaceAddress> cardAddresses = networkCard.getInterfaceAddresses();\r
                for (InterfaceAddress ifAddr : cardAddresses) {\r
                    if (ifAddr.getAddress() instanceof Inet4Address) {\r
                        ipAddress = ifAddr.getAddress().getHostAddress();\r
                        networkMask = Integer.toString(ifAddr.getNetworkPrefixLength());\r
                    }\r
                }\r
\r
            }\r
            case 2 -> {\r
                // Get the IP and mask\r
                ipAddress = args[0];\r
                networkMask = args[1];\r
\r
                // Get the interface name from the assigned IP\r
                networkCard = NetworkInterface.getByInetAddress(InetAddress.getByName(ipAddress));\r
                interfaceName = networkCard.getName();\r
            }\r
            default -> {\r
                // In order to find the right interface name... run the app with no args\r
                NetworkInterface.networkInterfaces().forEach((t) -> {\r
                    try {\r
                        if (t.isUp())\r
                            System.out.println(t.getName() + " --> " + t.getDisplayName() + " : " + t.inetAddresses().findFirst().toString());\r
                    } catch (SocketException ex) {\r
                        Logger.getLogger(U4S4_HostSeeker.class.getName()).log(Level.SEVERE, null, ex);\r
                    }\r
                });\r
                \r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker IP maskLength");\r
                System.err.println("Sysntax error. Usage: U4S4_HostSeeker interfaceName");\r
                throw new AssertionError();\r
            }\r
        }\r
\r
    }\r
\r
    private void processNetwork() throws IOException {\r
        String baseAddress;\r
        String[] addressParts = ipAddress.split("\\\\.");\r
        switch (networkMask) {\r
            case "24" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + "." + addressParts[2] + ".";\r
                checkClassCNetwork(baseAddress);\r
\r
            }\r
            case "16" -> {\r
                baseAddress = addressParts[0] + "." + addressParts[1] + ".";\r
                checkClassBNetwork(baseAddress);\r
            }\r
            case "8" -> {\r
                baseAddress = addressParts[0] + ".";\r
                checkClassANetwork(baseAddress);\r
\r
            }\r
            default ->\r
                throw new AssertionError();\r
        }\r
    }\r
\r
    // Check for /24 networks \r
    private void checkClassCNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        System.out.println("Checking network " + baseAddress + "0...");\r
        for (int i = 1; i < 255; i++) {\r
            InetAddress tempIP = InetAddress.getByName(baseAddress + i);\r
            if (tempIP.isReachable(timeout)) {\r
                addReachableIp(tempIP.getHostAddress());\r
            }\r
        }\r
    }\r
\r
    // Check for /16 networks \r
    private void checkClassBNetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class C adresses: " + baseAddress + i + ".xxx");\r
            checkClassCNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    // Check for /8 networks \r
    private void checkClassANetwork(String baseAddress) throws UnknownHostException, IOException {\r
        for (int i = 0; i <= 255; i++) {\r
            System.out.println("Checking next 256 class B adresses: " + baseAddress + i + ".xxx");\r
            checkClassBNetwork(baseAddress + i + ".");\r
        }\r
    }\r
\r
    private /*synchronized*/ void addReachableIp(String ip) {\r
        reachableIps.add(ip);\r
    }\r
\r
    private void listResults() {\r
        System.out.println("Reachable IPs:");\r
        for (String ip : reachableIps) {\r
            System.out.println("--> " + ip);\r
        }\r
    }\r
}\r
\r
\`\`\`\r
\r
:::\r
\r
## 4.2.4 java.net.URL\r
\r
URL es un acrónimo de Localizador de recursos uniforme. Un recurso puede ser cualquier cosa, desde un simple archivo de texto hasta cualquier otro como imágenes, directorio de archivos, etc.\r
\r
> [java.net.URL specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html)\r
\r
Es un puntero para localizar recursos en www (World Wide Web), por ejemplo:\r
\r
> http://psp2dam.github.io/psp_pages/\r
\r
La URL tiene las siguientes partes:\r
\r
- **Protocolo**: en este caso el protocolo es HTTP, puede ser HTTPS en algunos casos\r
- **Nombre de host o IP**: el nombre de host representa la dirección de la máquina en la que se encuentra el recurso, en este caso, www.example.com\r
- **Número de puerto**: es un atributo opcional. Si no se especifica, devuelve -1. En el caso anterior, el número de puerto es 80. Si no se indica se usa el puerto usado por defecto por el protocolo indicado en el primer campo.\r
- **Nombre del recurso**: es el nombre de un recurso ubicado en el servidor dado que queremos ver (la carpeta /psp_pages). Dependiendo de la configuración del servidor, el nombre del archivo puede tener un valor por defecto. En el ejemplo sólo se ha indicado una ruta, por lo que se intentará devolver el archivo \`ìndex.html\` si se encuentra en esa carpeta.\r
\r
| Constructor                                              | Descripción                                                                                                                                                                       |\r
| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r
| URL(String spec)                                         | Este constructor crea un objeto de clase URL a partir de una representación de string dada                                                                                        |\r
| URL(String protocol, String host, int port, String file) | Este constructor crea un objeto de URL a partir del protocolo, host, número de puerto y archivo especificados.                                                                    |\r
| URL(String protocol, String host, String file)           | Este constructor crea un objeto de URL a partir del protocolo, el servidor y la ruta/archivo especificados.                                                                       |\r
| URL(URL context, String spec)                            | Este constructor crea una instancia de una URL analizando el src dado con el controlador especificado dentro de un contexto dado. Se usa cuando tenemos rutas relativas a una URL |\r
\r
Estos son los métodos mas importantes y utilizados de la clase de URL:\r
\r
| Método                                | Descripción                                                                                                                     |\r
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |\r
| public String getProtocol()           | Este método obtiene el nombre de protocolo de esta URL.                                                                         |\r
| public String getHost()               | Este método obtiene el nombre de host de esta URL, si corresponde.                                                              |\r
| public String getPort()               | Este método obtiene el número de puerto de esta URL.                                                                            |\r
| public String getFile()               | Este método obtiene la parte de la ruta de esta URL.                                                                            |\r
| public String getAuthority()          | Este método obtiene la parte de autoridad de esta URL.                                                                          |\r
| public String toString()              | Este método construye una representación de string de esta URL.                                                                 |\r
| public String getQuery()              | Este método obtiene la parte de consulta de esta URL.                                                                           |\r
| public String getDefaultPort()        | Este método obtiene el número de puerto predeterminado del protocolo asociado con esta URL.                                     |\r
| public URLConnection openConnection() | Este método devuelve una instancia de URLConnection que representa una conexión al objeto remoto al que hace referencia la URL. |\r
| public InputStream openStream()       | Este método abre una conexión a esta URL y devuelve un InputStream para leer desde esa conexión.                                |\r
| public boolean equals(Object obj)     | Este método compara la igualdad de esta URL con otro objeto.                                                                    |\r
| public Object getContent()            | Este método obtiene el contenido de esta URL.                                                                                   |\r
| public String getRef()                | Este método obtiene el ancla (también conocido como la «referencia») de esta URL.                                               |\r
| public URI toURI()                    | Este método devuelve un URI equivalente a esta URL.                                                                             |\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args) throws MalformedURLException{  \r
\r
    URL url=new URL("http://psp2dam.github.io/psp_pages");  \r
  \r
    System.out.println("Protocol: "+url.getProtocol());  \r
    System.out.println("Host Name: "+url.getHost());  \r
    System.out.println("Port Number: "+url.getPort());  \r
    System.out.println("File Name: "+url.getFile());  \r
}   \r
\`\`\`\r
\r
Vamos con otro ejemplo más completo de uso de los métodos de URL.\r
\r
\`\`\`java\r
//URLDemo.java  \r
public static void main(String[] args){    \r
    URL url=new URL("https://www.google.com/search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8");    \r
        \r
    System.out.println("Protocol: "+url.getProtocol());    \r
    System.out.println("Host Name: "+url.getHost());    \r
    System.out.println("Port Number: "+url.getPort());    \r
    System.out.println("Default Port Number: "+url.getDefaultPort());    \r
    System.out.println("Query String: "+url.getQuery());    \r
    System.out.println("Path: "+url.getPath());    \r
    System.out.println("File: "+url.getFile());      \r
}    \r
\`\`\`\r
\r
\`\`\`bash:no-line-numbers{3}\r
Protocol: https\r
Host Name: www.google.com\r
Port Number: -1\r
Default Port Number: 443\r
Query String: q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
Path: /search\r
File: /search?q=javatpoint&oq=javatpoint&sourceid=chrome&ie=UTF-8\r
\`\`\`\r
\r
## 4.2.5 java.net.URLConnection\r
\r
La clase URLConnection se utiliza para dos propósitos diferentes pero relacionados.\r
\r
- En primer lugar, proporciona más control sobre la interacción con un servidor (especialmente un servidor HTTP) que la clase URL.\r
- En segundo lugar, con una URLConnection podemos verificar el encabezado enviado por el servidor y responder en consecuencia, podemos configurar los campos de encabezado utilizados en las requests de los clientes. También podemos descargar archivos binarios usando URLConnection.\r
\r
La clase URLConnection representa un enlace entre la URL y la aplicación. Puede usarse para leer y escribir datos en el recurso señalado por la URL.\r
\r
> [java.net.URLConnection specification](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html)\r
\r
La clase URLConnection en Java es una clase abstracta que representa una conexión de un recurso según lo especificado por la URL correspondiente. Tiene dos subclases \`HttpURLConnection\` y \`JarURLConnection\` que se encargan de hacer la conexión entre el programa cliente y el recurso indicado en URL.\r
\r
La clase URLConnection proporciona una gran cantidad de métodos. Podemos mostrar el contenido de una página web usando el método \`getInputStream()\` , de un modo similar a como lo hacíamos con los procesos.\r
\r
| Método                                            | Descripción                                                                                                                             |\r
| ------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |\r
| void connect()                                    | Este método se utiliza para establecer una conexión con el recurso especificado por la URL, si dicha conexión aún no se ha establecido. |\r
| Object getContent()                               | Recupera el contenido de esta conexión URL.                                                                                             |\r
| String getContentEncoding()                       | Devuelve el valor del campo de encabezado de codificación de contenido.                                                                 |\r
| int getContentLength()                            | Devuelve el valor del campo de encabezado de longitud del contenido.                                                                    |\r
| long getContentLengthLong()                       | Devuelve el valor del campo de encabezado de longitud del contenido como long.                                                          |\r
| String getContentType()                           | Devuelve el valor del campo de encabezado de tipo de contenido.                                                                         |\r
| long getDate()                                    | Devuelve el valor del campo de encabezado de fecha.                                                                                     |\r
| boolean getDoInput()                              | Devuelve el valor del indicador doInput de esta URLConnection.                                                                          |\r
| boolean getDoInput()                              | Devuelve el valor del indicador doInput de esta URLConnection.                                                                          |\r
| String getHeaderField(int n)                      | obtiene el valor del enésimo campo de encabezado.                                                                                       |\r
| String getHeaderField(String name)                | Devuelve el valor del campo de encabezado con nombre.                                                                                   |\r
| String getHeaderFieldKey(int n)                   | obtiene el valor del enésimo campo de encabezado.                                                                                       |\r
| Map<String, List&lt;String&gt;> getHeaderFields() | Devuelve un mapa no modificable de los campos de encabezado.                                                                            |\r
| long getIfModifiedSince()                         | Devuelve el valor del campo ifModifiedSince de este objeto.                                                                             |\r
| InputStream getInputStream()                      | Devuelve un flujo de entrada que lee de esta conexión abierta                                                                           |\r
| long getLastModified()                            | Devuelve el valor del campo de encabezado modificado por última vez.                                                                    |\r
| OutputStream getOutputStream()                    | Devuelve un flujo de salida que escribe en esta conexión.                                                                               |\r
| URL getURL()                                      | Devuelve el valor del campo URL de este URLConnection.                                                                                  |\r
| void setDoInput(boolean doinput)                  | Establece el valor del campo doInput para esta URLConnection en el valor especificado.                                                  |\r
| void setDoOutput(boolean dooutput)                | Establece el valor del campo doOutput para esta URLConnection en el valor especificado.                                                 |\r
\r
::: info Cómo obtener un objeto de tipo URLConnection\r
El método openConnection() de la clase URL devuelve un objeto de tipo URLConnection.\r
:::\r
\r
\`\`\`java{11}\r
// URLConnectionExample\r
public static void main(String[] args) throws MalformedURLException, IOException{\r
\r
    // Creating an object of URL class\r
\r
    // Custom input URL is passed as an argument\r
    URL u = new URL("www.google.com");\r
\r
    // Creating an object of URLConnection class to\r
    // communicate between application and URL\r
    URLConnection urlconnect = u.openConnection();\r
\r
    // Creating an object of InputStream class\r
    // for our application streams to be read\r
    InputStream stream\r
        = urlconnect.getInputStream();\r
\r
    BufferedReader in =  \r
        new BufferedReader(\r
            new InputStreamReader(stream));\r
    // Till the time URL is being read\r
    String line;\r
    while ((line = in.readLine()) != null) {\r
\r
        // Continue printing the stream\r
        System.out.println(line);\r
    }\r
}\r
\`\`\`\r
\r
::: warning MalformedURLException\r
Si pruebas el código anterior, obtendrás una excepción de tipo \`MalformedURLException\`. \r
¿Qué deberías cambiar para que funcione correctamente?\r
:::\r
\r
::: question Descargar imágenes (U4S7_ImagesDownloader)\r
Crea una nueva aplicación que descargue imágenes de una URL.\r
\r
La URL de la imagen se debe pasar como argumento a la aplicación. La imagen descargada debe guardarse en una carpeta images, en la raíz del proyecto, con el mismo nombre que tuviese el recurso online.\r
:::\r
\r
::: details Código del ejemplo\r
\r
\`\`\`java\r
    // Code not visible yet\r
\`\`\`\r
\r
:::\r
`]},{title:"6.4 Encriptación asimétrica",headers:[{level:2,title:"6.4.1. Clave pública y clave privada",slug:"_6-4-1-clave-publica-y-clave-privada",link:"#_6-4-1-clave-publica-y-clave-privada",children:[]},{level:2,title:"6.4.2. Firma digital",slug:"_6-4-2-firma-digital",link:"#_6-4-2-firma-digital",children:[{level:3,title:"Integridad",slug:"integridad",link:"#integridad",children:[]},{level:3,title:"Autenticación y no repudio",slug:"autenticacion-y-no-repudio",link:"#autenticacion-y-no-repudio",children:[]}]},{level:2,title:"6.4.3 Certificados digitales",slug:"_6-4-3-certificados-digitales",link:"#_6-4-3-certificados-digitales",children:[{level:3,title:"Claves digitales",slug:"claves-digitales",link:"#claves-digitales",children:[]},{level:3,title:"Infraestructura de clave pública (PKI)",slug:"infraestructura-de-clave-publica-pki",link:"#infraestructura-de-clave-publica-pki",children:[]}]},{level:2,title:"6.4.4. Generación de pares de claves",slug:"_6-4-4-generacion-de-pares-de-claves",link:"#_6-4-4-generacion-de-pares-de-claves",children:[{level:3,title:"Tipos de ficheros para certificados digitales",slug:"tipos-de-ficheros-para-certificados-digitales",link:"#tipos-de-ficheros-para-certificados-digitales",children:[]},{level:3,title:"Generación de claves desde Java",slug:"generacion-de-claves-desde-java",link:"#generacion-de-claves-desde-java",children:[]}]},{level:2,title:"6.4.5. Cifrado y descifrado usando un par de claves",slug:"_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",link:"#_6-4-5-cifrado-y-descifrado-usando-un-par-de-claves",children:[]},{level:2,title:"6.2.3. Cifrado asimétrico con GnuPG",slug:"_6-2-3-cifrado-asimetrico-con-gnupg",link:"#_6-2-3-cifrado-asimetrico-con-gnupg",children:[]}],path:"/es/unit6/asymmetric-keys.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.4 Encriptación asimétrica\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.4 Encriptación asimétrica" />\r
\r
# 6.4 Encriptación asimétrica\r
\r
[[toc]]\r
\r
## 6.4.1. Clave pública y clave privada\r
\r
La criptografía asimétrica o **criptografía de clave pública** supuso una auténtica revolución en su momento. Permitía el intercambio seguro de información (confidencialidad, autenticación y no repudio) entre interlocutores que no compartían ningún secreto.\r
\r
Se creó en los años 70 a partir del trabajo de *Diffie y Hellman* por una parte y de *Rivest, Shamir y Adleman* por otra.\r
\r
Se basa en la existencia de un par de claves, una pública y otra privada, entre las cuales existe una relación matemática, de manera que es muy difícil obtener la clave privada a partir de la pública. Sin embargo, es muy sencillo obtener la clave pública a partir de la privada.\r
\r
::: info Algoritmo RSA\r
En la familia de algoritmos RSA (Rivest, Shamir y Adleman) la clave pública consiste en un número que es el producto de dos factores primos muy grandes (mayores que 10^100) y la clave privada se deriva de la factorización de dicho número, es decir, los dos factores primos.\r
\r
Requiere poco procesamiento multiplicar dos números primos tan grandes, pero requiere una cantidad enorme de cálculos encontrar la factorización del número.\r
:::\r
\r
A diferencia del cifrado simétrico, el el cifrado asimétrico se usan funciones diferentes para cifrar y descifrar los mensajes.\r
\r
- Para **encriptación** se usa la **clave pública**. Cualquiera puede tener acceso a la clave pública, mediante la cual, usando la función de cifrado, se encripta la información dirigida a un destinatario concreto (el propietario de la clave privada asociada).\r
- Para **desencriptación** se usa la **clave privada**, que debe mantenerse a buen recaudo ya que sólo con esa clave y la función de descifrado se puede desencriptar un mensaje cifrado con la clave pública correspondiente.\r
\r
Entre los algoritmos de cifrado asimétrico más utilizados se encuentran\r
\r
- Rivest Shamir Adleman (RSA). Basado en la factorización de números primos grandes.\r
- Digital Signature Standard (DSS), que incorpora Digital Signature Algorithm (DSA).\r
- Elliptical Curve Cryptography (ECC). Está basado en las matemáticas de las curvas elípticas\r
- the Diffie-Hellman exchange method.\r
- TLS/SSL protocol.\r
\r
![cifrado asimétrico](../../media/unit6/asymmetric-encryption-primitive.png)\r
\r
## 6.4.2. Firma digital\r
\r
Con la firma digital Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
![cifrado asimétrico](../../media/unit6/proceso-firma-digital.png)\r
\r
El proceso básico que se sigue para la firma electrónica es el siguiente:\r
\r
1. El usuario dispone de un documento electrónico (una hoja de cálculo, un pdf, una imagen, incluso un formulario en una página web) y de un **certificado** (clave pública y clave privada) que le pertenece y le identifica.\r
2. La aplicación o dispositivo digital utilizados para la firma realiza un **resumen del documento**. El resumen de un documento de gran tamaño puede llegar a ser tan solo de unas líneas. Este resumen es único y cualquier modificación del documento implica también una modificación del resumen.\r
3. La aplicación utiliza la clave privada para codificar el resumen.\r
4. La aplicación crea otro documento electrónico que contiene ese resumen codificado. Este nuevo documento es la firma electrónica.\r
\r
El resultado de todo este proceso es un documento electrónico obtenido a partir del documento original y de las claves del firmante. La firma electrónica, por tanto, es el mismo documento electrónico resultante.\r
\r
![verificación de firma digital](../../media/unit6/digital-signature-sign-verify.png)\r
\r
### Integridad\r
\r
Como estamos comparando funciones de resumen de un documento, se puede detectar de forma muy sencilla si el documento ha sufrido alguna modificación respecto al momento en el que se firmó, garantizando de esta forma la integridad de la información firmada.\r
\r
### Autenticación y no repudio\r
\r
Por las características de los algoritmos de cifrado se puede determinar, a partir del resumen cifrado con la clave privada, mediante el uso de la clave pública, que el mensaje recibido lo generó el propietario de la clave privada.\r
\r
Con esta característica se puede probar y demostrar que el mensaje lo firmó el emisor y no cualquier otra persona, garantizando por un lado la autoría y por otro evitando que el emisor niegue haber generado esa información.\r
\r
## 6.4.3 Certificados digitales\r
\r
Un certificado digital es un documento electrónico expedido por una **Autoridad de Certificación** e identifica a una persona (física o jurídica) con un par de claves.Tiene como misión validar y certificar que una firma electrónica se corresponde con una persona o entidad concreta.\r
\r
Contiene la información necesaria para firmar electrónicamente e identificar a su propietario con sus datos: nombre, NIF, algoritmo y claves de firma, fecha de expiración y organismo que lo expide.\r
\r
La Autoridad de Certificación da fe de que la firma electrónica se corresponde con un usuario concreto. Esa es la razón por la que los certificados están firmados, a su vez, por la Autoridad de Certificación.\r
\r
### Claves digitales\r
\r
En un certificado, las claves digitales son los elementos esenciales para la firma e identificación del firmante. Existen dos claves, la **clave privada** y **clave pública**, y trabajan de forma complementaria. *Lo que cifra o codifica una clave sólo lo puede descifrar o decodificar la otra*.\r
\r
La diferencia entre ellas es que la clave privada está pensada para que nunca salga del certificado y esté siempre bajo el control del firmante. En cambio, la clave pública se puede repartir o enviar a otros usuarios.\r
\r
En ocasiones, se habla de Certificado Privado para referirse al certificado que contiene la clave privada y la pública y del Certificado Público para referirse al certificado que sólo contiene la clave pública.\r
\r
::: info Creación de Certificados digitales\r
Obtener el Certificado Digital depende de si el certificado está contenido en una tarjeta, como el DNIe, o de si el certificado se guarda en un fichero software.\r
\r
En ambos procesos hay un paso que es la identificación del responsable o usuario del certificado, lo cual requiere que éste **se persone en las oficinas de una Autoridad de Registro**. Estas oficinas corroboran la identidad.\r
:::\r
\r
### Infraestructura de clave pública (PKI)\r
\r
Una infraestructura de clave pública (PKI) es una combinación de hardware, software, procedimientos de seguridad y marco legal que, en su conjunto, permite la ejecución con garantías de operaciones criptográficas, cumpliendo los requisitos de integridad, confidencialidad, autenticación y no repudio.\r
\r
Una PKI permite establecer y gestionar asociaciones entre claves públicas e identidades de personas y organizaciones.\r
\r
La cuestión entonces es determinar si un certificado es válido o de confianza, ol o que es lo mismo, si representa a la persona u organización que aparece como titular y propietario  del certificado.\r
\r
Para dar por válido un certificado digital su firma digital debe ser válida y su emisor debe ser un emisor de confianza. Por lo tanto, ahora queda determinar qué emisores son de confianza.\r
\r
::: warning Autenticidad de los certificados\r
Los certificados deben estar firmados por una AC por dos motivos\r
\r
1. Garantizar su integridad, de forma que cualquier intento de modificación del certificado lo invalide.\r
2. Identificar al creador del certificado digital. Todo el sistema está basado en una relación de confianza, en la que la AC que ha firmado el certificado es un emisor de confianza, normalmente instituciones públicas o privadas de reconocido prestigio\r
:::\r
\r
En nuestro sistema podemos ver y modificar qué entidades de certificación consideramos como seguras, es decir, que los certificados que éstas hayan firmado los tomaremos como válidos.\r
\r
[Autoridades de confianza para apps de Azure](https://docs.microsoft.com/es-es/exchange/trusted-root-certification-authorities-for-federation-trusts-exchange-2013-help)\r
\r
En Windows, si ejecutamos \`certmgr.msc\` podemos acceder a la configuración de certificados del sistema. En OSX lo podemos hacer con la aplicación \`Llavero\`.\r
\r
Para nuestra navegación, la información de qué certificados considera el navegador como seguros, depende de en qué AC confiemos (por defecto en la instalación vienen configurados los más comunes)\r
\r
[Ver certificados y AC en Chrome](https://www.adminfacil.es/como-ver-los-certificados-instalados-en-google-chrome/)\r
\r
::: danger Certificados autofirmados\r
**Hemos de tener en cuenta que, con herramientas como las que proporciona Java, SSH o GnuPG cualquiera puede generar un certificado digital con la información que quiera**\r
\r
Para las pruebas vamos a firmar nuestros propios certificados. Incluso dentro de una compañía podemos ejercer nosotros mismos como Autoridad de Certificación de Confianza, firmando nuestros certificados.\r
\r
Debemos preparar la configuración de nuestros sistemas para que **confíen** en esos certificados autofirmados, asumiendo el riesgo que esto conlleva.\r
:::\r
\r
## 6.4.4. Generación de pares de claves\r
\r
La generación y gestión de pares de claves implica dos aspectos fundamentales.\r
\r
Por un lado, tenemos la creación de las claves. Las claves las podemos haber descargado, generado con alguna de las utilidades disponibles para ellos o bien, como veremos a continuación, se pueden generar desde una aplicación, igual que hacemos con las claves simétricas.\r
\r
Por otro lado, tenemos la gestión del almacenamiento de las claves. Las claves no dejan de ser archivos, que podemos tratar como archivos especiales, pero que usualmente se almacenan en repositorios especiales, denominados \`keyrings\` a los que puede acceder una aplicación y desde los que gestionamos las relaciones de confianza.\r
\r
El JCA nos proporciona clases generadoras de claves. Estas clases se apoyan en buenos algoritmos de generación de números aleatorios para satisfacer unos requisitos mínimos de seguridad.\r
\r
::: info SecureRandom\r
La generación de números aleatorios juega un papel fundamental en la criptografía, siendo uno de los **Engine** que proporciona el JCA junto con un amplio grupo de algoritmos.\r
\r
La clase **SecureRandom** genera número aleatorios empleando alguno de los algoritmos disponibles y se puede utilizar un objeto de tipo SecureRandom para que los utilicen las clases generadoras de claves, tanto simétricas como asimétricas\r
:::\r
\r
### Tipos de ficheros para certificados digitales\r
\r
Hay varios tipos de ficheros que se utilizan para guardar certificados digitales siguiendo el estándar X.509. Generalmente uncertificado no contiene sólo la clave, sino que tiene información adicional.\r
\r
Esxiten dos posibles codificaciones para almacenar certificados X.509\r
\r
- der: Es una codificación binaria\r
- dem: Es una codificación en formato texto guardado en Base64 y tienen un encabezado y pie que delimita el contenido del certificado\r
\r
Veamos un ejemplo de certificado con codificación dem\r
\r
\`\`\`sh\r
-----BEGIN CERTIFICATE----- \r
MIIDijCCAvOgAwIBAgIJAKRvtQxONVZoMA0GCSqGSIb3DQEBBAUAMIGLMQswCQYD \r
VQQGEwJVUzETMBEGA1UECBMKQ2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxl \r
MSAwHgYDVQQKExdBcnViYSBXaXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFD \r
MSMwIQYDVQQDExpteXNlcnZlci5hcnViYW5ldHdvcmtzLmNvbTAeFw0wODA0MzAy \r
MzM3MDJaFw0xMDA0MzAyMzM3MDJaMIGLMQswCQYDVQQGEwJVUzETMBEGA1UECBMK \r
Q2FsaWZvcm5pYTESMBAGA1UEBxMJU3Vubnl2YWxlMSAwHgYDVQQKExdBcnViYSBX \r
aXJlbGVzcyBOZXR3b3JrczEMMAoGA1UECxMDVEFDMSMwIQYDVQQDExpteXNlcnZl \r
ci5hcnViYW5ldHdvcmtzLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA \r
zRwqc9prVXycGhHcsAjGPzC2MKU4DhXSr86Z89Jk8/cXEJBJ0C/NgdAqqDgxneUh \r
nVyxGxODa7BNGAWSagdCsKLrbkchr479E3xLfgdc3UzAJITLGCXGiQ66NwQDyM5I \r
G/xKYm4oqgyOE/lFTTkK0M8V0NmmJynyOCYC/AwQKjMCAwEAAaOB8zCB8DAdBgNV \r
HQ4EFgQUM5btT6IlPGkLTTPvFccTVURO1p0wgcAGA1UdIwSBuDCBtYAUM5btT6Il \r
PGkLTTPvFccTVURO1p2hgZGkgY4wgYsxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpD \r
YWxpZm9ybmlhMRIwEAYDVQQHEwlTdW5ueXZhbGUxIDAeBgNVBAoTF0FydWJhIFdp \r
cmVsZXNzIE5ldHdvcmtzMQwwCgYDVQQLEwNUQUMxIzAhBgNVBAMTGm15c2VydmVy \r
LmFydWJhbmV0d29ya3MuY29tggkApG+1DE41VmgwDAYDVR0TBAUwAwEB/zANBgkq \r
hkiG9w0BAQQFAAOBgQBp71WeF6dKvqUSO1JFsVhBeUesbEgx9+tx6eP328uL0oSC \r
fQ6EaiXZVbrQt+PMqG0F80+4wxVXug9EW5Ob9M/opaCGI+cgtpLCwSf6CjsmAcUc \r
b6EjG/l4HW2BztYJfx15pk51M49TYS7okDKWYRT10y65xcyQdfUKvfDC1k5P9Q== \r
-----END CERTIFICATE-----\r
\`\`\`\r
\r
Además de la codificación, tenemos formatos de fichero estándar para guardar los certificados usando una de las codificaciones anteriores\r
\r
- cer, crt, der: Contienen certificados X.509 estándares codificados como \`der\`\r
- p12: Realmente hace referencia a toda una familia de estándares asociados al algoritmo RSA y definen el formato de almacenamiento de distintos tipos de claves, los PKCS#n (PKCS#8, PKCS#12, etc). Pueden contener, además de los datos del certificado, una clave privada. Si contiene la clave privada, ésta estará protegida por una contraseña que será necesaria para acceder a la clave privada. [PKCS en Wikipedia](https://es.wikipedia.org/wiki/PKCS)\r
\r
### Generación de claves desde Java\r
\r
Usando las clases del JCA, estos son los pasos que debemos seguir para generar un par de claves desde código\r
\r
1. El primer paso para obtener un par de claves es obtener un objeto *keyPairGenerator* para el algoritmo que queramos utilizar.\r
2. A continuación se inicializa el generador del par de claves llamando a alguna de las versiones del método *initialize*. En nuestro caso indicaremos el tamaño de clave para el algoritmo seleccionado y un generador de números aleatorios.\r
3. El último paso es generar el par de claves y guardarlas en los objetos PrivateKey y PublicKey respectivamente.\r
4. A partir de ese momento ya se pueden usar las claves para cifrar, descifrar e incluso para firmar. Sin embargo, si queremos reutilizar estas claves, lo que tendremos que hacer será guardarlas en sendos archivos.\r
\r
A continuación podemos ver un ejemplo de generación de claves, almacenamiento de las claves en un fichero y visualización de la clave obtenida.\r
\r
\`\`\`java{14,15,18-20,39,52}\r
public class U6S4_1_GenerateRsaKeyPair {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            // Elijo un algoritmo de generación de números aleatorios de los denominados\r
            // altamente seguros para generar el par de claves\r
            SecureRandom algoritmoSeguro = SecureRandom.getInstanceStrong();\r
            // Preparo el generados de claves para usar el algortimo RSA\r
            KeyPairGenerator genParClaves = KeyPairGenerator.getInstance(algoritmoClaveAsimetrica);\r
            genParClaves.initialize(tamanoClaveAsimetrica, algoritmoSeguro);\r
\r
            // Creo el par de claves y lo guardo en objetos\r
            KeyPair parClaves = genParClaves.generateKeyPair();\r
            PublicKey clavePublica = parClaves.getPublic();\r
            PrivateKey clavePrivada = parClaves.getPrivate();\r
\r
            // Guardamos la clave pública en un archivo y la visualizamos\r
            // La clave se guarda con codificación DER y en formato X.509\r
            guardaClavePublicaX509(clavePublica);\r
            \r
            // Guardamos la clave privada en un archivo y la visualizamos\r
            // La clave se guarda con codificación DER y en formato PKCS#8\r
            guardaClavePrivadaPKCS8(clavePrivada);\r
            \r
\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algortimo en ningún Provider");\r
        }\r
\r
    }\r
\r
    private static void guardaClavePublicaX509(PublicKey clavePublica) {\r
        try (FileOutputStream publicKeyFile = new FileOutputStream(ficheroClavePublica)) {\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublica.getEncoded(), algoritmoClaveAsimetrica);\r
            publicKeyFile.write(clavePublica.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePublica.getEncoded(),\r
                    codificacionClavePublica.getFormat(), ficheroClavePublica);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave pública en " + ficheroClavePublica);\r
        }                \r
    }\r
\r
    private static void guardaClavePrivadaPKCS8(PrivateKey clavePrivada) {\r
        try (FileOutputStream privateKeyFile = new FileOutputStream(ficheroClavePrivada)) {\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivada.getEncoded(), algoritmoClaveAsimetrica);\r
            privateKeyFile.write(clavePrivada.getEncoded());\r
            \r
            // Visualizamos la clave por consola\r
            MostrarClaveBase64(codificacionClavePrivada.getEncoded(),\r
                    codificacionClavePrivada.getFormat(), ficheroClavePrivada);\r
        } catch (IOException ex) {\r
            System.out.println("Error almacenando la clave privada en " + ficheroClavePrivada);\r
        }        \r
    }\r
\r
    private static void MostrarClaveBase64(byte[] clave, String formatoClave, String ficheroClave) {\r
        System.out.println("Clave guardada en formato " + formatoClave \r
                + " en fichero " + ficheroClave);\r
        System.out.println(Base64.getEncoder().encodeToString(clave).replaceAll("(.{76})", "$1\\n"));\r
    }\r
}\r
\`\`\`\r
\r
Esta sería la salida proporcionada\r
\r
\`\`\`sh\r
Clave guardada en formato X.509 en fichero claves/clavepublica.der\r
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC4UFRgEIm3lFKO75QmqTPvkDs0fM6NUm2FHQcA\r
cQHawLx9/WKXh9xkx/xYZZcc4L2YQYcwTu4jfk889iGKGLn2Kh4ywBY+g8uZ6ljM5PT6f95dU6Zd\r
xATWOn1qsizBubf7kKhBL7xDnKU5do3XYzrSjme+9uIsgS7HQ7K0MbKrpQIDAQAB\r
\r
Clave guardada en formato PKCS#8 en fichero claves/claveprivada.pkcs8\r
MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBALhQVGAQibeUUo7vlCapM++QOzR8\r
zo1SbYUdBwBxAdrAvH39YpeH3GTH/FhllxzgvZhBhzBO7iN+Tzz2IYoYufYqHjLAFj6Dy5nqWMzk\r
9Pp/3l1Tpl3EBNY6fWqyLMG5t/uQqEEvvEOcpTl2jddjOtKOZ7724iyBLsdDsrQxsqulAgMBAAEC\r
gYA97xBLL4N3YqnTSgIYc6b2Cxs56e5mYppWrohZx5996GHuXCSzEn4mh2TuN0Tt+T78WJiazQsM\r
djceHv7qLqDd2kWn3IR0gX207KxwjG0I/sAP2z/i9NZ7DPL+FUv8lmeYUfDj8h3wkyhmBqn+tan1\r
0xIOcZUrr/yRhrjZLI1SCQJBAPEc4uWSbyBLHVC6SNga7XWNmwi8Mq4PZJdhW9RJWDxg9zOlC/HV\r
rV60ddbfW/ldIqCH33DUge5U5YhD6Mla/XMCQQDDsahcwTksp2bJowMTRgFHT094sihtSlQ7sgdI\r
uAemuMvBmVTHleFBWMqz1rAN6A/76yef3WK4I+nsmeCGa+yHAkEA7BR1kYT8q+kATi/n7TkIcoZx\r
W28yTD2kJ5jbWhNqgswKn5WmCWdH9qfJjddrbdEke3wuaoKYqeyURgUAJE+kQwJADhEsQBanrH0Q\r
F3h/VRhYKS8bUFrGKy0Hpw7iFSkda6+m/fCutnYgrhja4ViSaT2AQKSjwYsheIkkXJynFiKV6wJA\r
PUHXqlvfgPr4w2U+Ddq7h/gp59kO0uojGrEBO0B2wt3PuuSQlZlMN97Ly9QmB6LYRtw6woCZZZOD\r
ePqA7rf8IA==\r
\`\`\`\r
\r
En el ejemplo anterior en lugar de utilizar clases estándar para volcar el contenido binario de las claves a un archivo en formato raw, se utilizan clases codificadoras para generar ficheros binarios en formatos estándares, tanto para la clave pública como para la privada.\r
\r
Esto tiene la enorme ventaja de que se pueden utilizar las claves generadas con herramientas estándar como openssl. Además, facilita la tarea ya que las claves pública y privada para criptografía asimétrica son objetos compuestos.\r
\r
::: info Codificación Base64\r
Base64 es un grupo de esquemas de codificación de binario a texto que representa los datos binarios mediante una cadena.\r
\r
Los esquemas de codificación Base64 son comúnmente usados cuando se necesita codificar datos binarios para que sean almacenados y transferidos sobre un medio diseñado para tratar con datos textuales. Esto es para asegurar que los datos se mantienen intactos y sin modificaciones durante la transmisión.\r
\r
Los valores codificados en Base64 como texto se muestran en filas de 76 caracteres como máximo, para mejor legibilidad, y siguiendo convenciones habituales.\r
\r
Para verlos en pantalla se añade un salto de línea después de cada grupo de 76 caracteres usando  \`replaceAll("(.{76})", "$1\\n")\`.\r
:::\r
\r
Las claves que se han guardado con el programa tienen las siguientes características:\r
\r
- La clave pública se guarda en un fichero \`clavepublica.der\`, con el formato de la estructura *SubjectPublicKeyInfo* en formato *ASN.1* definido en el estándar *X.509*, y con codificación *DER (binaria)*. Para eso se ha utilizado la clase codificadora **X509EncodedKeySpec**.\r
- La clave privada se guarda en un fichero \`claveprivada.pkcs8\`, en formato *PKCS#8*, y con codificación *DER (binaria)*. Para eso se ha utilizado la clase codificadora **PKCS8EncodedKeySpec**.\r
\r
::: info Codificaciones por defecto\r
Las codificaciones usadas en el programa coinciden con las codificacione por defecto que usan las clases PrivateKey y PublicKey, como se puede ver en los valores proporcionados por los métodos getFormat() y getEncoded().\r
:::\r
\r
## 6.4.5. Cifrado y descifrado usando un par de claves\r
\r
Aunque ya hemos visto que las claves se pueden generar desde código, lo normal es que una vez hayamos generado un par de claves, estas se puedan reutilizar desde las aplicaciones para cifrar y descifrar información.\r
\r
Si hemos guardado las claves en archivos, el primer paso que tendremos que realizar es recuperar esas claves para poder realizar las operaciones criptográficas con ellas.\r
\r
::: question Prueba de claves online\r
Podemos probar las claves generadas con una herramienta online.\r
\r
[Online RSA tool](https://www.devglan.com/online-tools/rsa-encryption-decryption)\r
\r
Prueba a copiar el contenido (en Base64) de las claves pública y privada para hacer un cifrado y un descifrado de la información.\r
\r
También puedes probar a simular una firma digital, realizando el cifrado con la clave privada y el descifrado con la clave pública.\r
:::\r
\r
Veamos un ejemplo de cómo se hace todo este proceso en Java\r
\r
\`\`\`java{23-25,38-40,76-78,108-110}\r
public class U6S4_2_RsaKeyPairEncrypt {\r
\r
    private static final int tamanoClaveAsimetrica = 1024;\r
    private static final String algoritmoClaveAsimetrica = "RSA";\r
    private static final String ficheroClavePublica = "claves/clavepublica.der";\r
    private static final String ficheroClavePrivada = "claves/claveprivada.pkcs8";\r
\r
    public static void main(String[] args) {\r
        try {\r
            //////////////////////////////////////////////////\r
            // CIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave pública de un archivo\r
            PublicKey clavePublica = leerClavePublica(ficheroClavePublica);\r
\r
            // Preparamos la información que queremos cifrar\r
            String textoEnClaro = "Quiero cifrar este mensaje de prueba";\r
            byte[] mensajeEnClaro = textoEnClaro.getBytes("UTF-8");\r
            \r
            // Realizamos el proceso de cifrado con clave pública\r
            // Los pasos son exactamente los mismos que con el cifrado simétrico\r
            Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.ENCRYPT_MODE, clavePublica);\r
            byte[] mensajeCifrado = cifrado.doFinal(mensajeEnClaro);\r
            // Visualizamos el mensaje cifrado en modo texto\r
            MostrarMensajeBase64(mensajeCifrado);\r
            \r
            //////////////////////////////////////////////////\r
            // DESCIFRADO\r
            //////////////////////////////////////////////////\r
            \r
            // Leemos la clave privada de un archivo\r
            PrivateKey clavePrivada = leerClavePrivada(ficheroClavePrivada);\r
\r
            // Realizamos el proceso de descifrado con clave privada\r
            // Los pasos son exactamente los mismos que con el cifrado simétrico\r
            // Cipher cifrado = Cipher.getInstance(algoritmoClaveAsimetrica);\r
            cifrado.init(Cipher.DECRYPT_MODE, clavePrivada);\r
            byte[] mensajeDescifrado = cifrado.doFinal(mensajeCifrado);\r
            // Visualizamos el mensaje descifrado\r
            System.out.println("Texto descifrado:\\n" + new String(mensajeDescifrado, "UTF-8"));\r
                        \r
        } catch (UnsupportedEncodingException ex) {\r
            System.out.println("Codificación de caracteres UTF-8 no soportada");\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo " + algoritmoClaveAsimetrica + " en ningún Provider");\r
        } catch (NoSuchPaddingException ex) {\r
            System.err.println("El relleno especificado para el algoritmo no está permitido");\r
        } catch (InvalidKeyException ex) {\r
            System.err.println("Especificación de clave no válida");\r
        } catch (IllegalBlockSizeException ex) {\r
            System.err.println("Tamaño de bloque no válido");\r
        } catch (BadPaddingException ex) {\r
            System.err.println("Excepción con el relleno usado por el algoritmo");\r
        }\r
    }\r
\r
    private static PublicKey leerClavePublica(String ficheroClave) {\r
        byte[] clavePublicaEncoded;\r
\r
        // Leemos la información del archivo\r
        try (FileInputStream publicKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePublicaEncoded = publicKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave pública.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave pública.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes leídos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            X509EncodedKeySpec codificacionClavePublica = new X509EncodedKeySpec(clavePublicaEncoded);\r
            PublicKey clavePublica = keyFactory.generatePublic(codificacionClavePublica);\r
\r
            // Devolvemos la clave pública generada\r
            return clavePublica;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo " + algoritmoClaveAsimetrica + " en ningún Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
\r
    private static PrivateKey leerClavePrivada(String ficheroClave) {\r
        byte[] clavePrivadaEncoded;\r
\r
        // Leemos la información del archivo\r
        try (FileInputStream privateKeyFile = new FileInputStream(ficheroClave)) {\r
            clavePrivadaEncoded = privateKeyFile.readAllBytes();\r
        } catch (FileNotFoundException ex) {\r
            System.out.println("No se ha encontrado el archivo " + ficheroClave + " con la clave privada.");\r
            return null;\r
        } catch (IOException ex) {\r
            System.out.println("Se ha producido un error de E/S accediendo al archivo " + ficheroClave + " de la clave privada.");\r
            return null;\r
        }\r
\r
        // Generamos la clave a partir del array de bytes leídos\r
        KeyFactory keyFactory;\r
        try {\r
            keyFactory = KeyFactory.getInstance(algoritmoClaveAsimetrica);\r
            PKCS8EncodedKeySpec codificacionClavePrivada = new PKCS8EncodedKeySpec(clavePrivadaEncoded);\r
            PrivateKey clavePrivada = keyFactory.generatePrivate(codificacionClavePrivada);\r
\r
            // Devolvemos la clave pública generada\r
            return clavePrivada;\r
        } catch (NoSuchAlgorithmException ex) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo " + algoritmoClaveAsimetrica + " en ningún Provider");\r
            return null;\r
        } catch (InvalidKeySpecException ex) {\r
            Logger.getLogger(U6S6_RsaKeyPairEncrypt.class.getName()).log(Level.SEVERE, null, ex);\r
            return null;\r
        }\r
    }\r
    \r
    private static void MostrarMensajeBase64(byte[] mensajeCifrado) {\r
        System.out.println("Mensaje cifrado visualizado como texto en Base64:");                \r
        System.out.println(Base64.getEncoder().encodeToString(mensajeCifrado).replaceAll("(.{76})", "$1\\n"));\r
    }    \r
}\r
\`\`\`\r
\r
Y esta es la salida proporcionada\r
\r
\`\`\`sh\r
Mensaje cifrado visualizado como texto en Base64:\r
EV+7WrEf+4CYwckys9blk6DXnLHUm4i0k+4BIp3oNmPdo2skYY8bQsAhXToBx2gi/rMIK9wiJTH0\r
yg99jpyaLeUgtga8PxWx1plgvxohzO/lALkf5AFRUczZh8F5QvOXCi93v2ycZCZXq7QmZTopkEQh\r
ARSezD/1Al2UYPc2X68=\r
\r
Texto descifrado:\r
Quiero cifrar este mensaje de prueba\r
\`\`\`\r
\r
::: warning Cifrado siempre diferente, descifrado siempre igual\r
El resultado de cifrar un mensaje con la misma clave pública no siempre es igual, aunque al descifrar los mensajes con la clave privada siempre se obtiene el mensaje original.\r
\r
Esto es debido a que, para aumentar la variabilidad (**entropía**) del mensaje cifrado al mensaje que se cifra se le añade una parte aleatoria (**salt**) que se descarta cuando se descifra.\r
:::\r
\r
En el código podemos observar cómo los procesos para cargar la clave desde un archivo usan las mismas clases que cuando se generaron, siendo el código muy parecido.\r
\r
En cuanto al cifrado y descifrado se realiza con el *Engine Cipher* usando la misma secuencia de llamadas que con el cifrado simétrico.\r
\r
## 6.2.3. Cifrado asimétrico con GnuPG\r
\r
Con la suite GnuPG también podemos generar pares de claves y cifrar y descifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la información de los algoritmos disponibles para cada tipo de servicio. En concreto, de resúmenes, en mi versión instalada:\r
\r
Clave pública: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\r
:::\r
\r
Para generar las claves, ejecutamos los siguientes comandos\r
Debemos tener en cuenta que las claves generadas se añaden a nuestro anillo de claves (almacén de seguridad de claves en las que confiamos).\r
\r
\`\`\`bash\r
gpg --gen-key\r
gpg --list-keys \r
# El formato corto equivalente es gpg -k\r
gpg --list-secret-keys \r
# El formato corto equivalente es gpg -K\r
\r
#Extraer las claves públicas y privadas\r
# En un archivo binario\r
gpg --output tunombre.pub --export IDdeLaClavePública\r
# En un archivo ASCII\r
gpg --armor --output tunombre.asc --export IDdeLaClavePública\r
\r
gpg --export-secret-keys -a IDdeLaClavePública > tunombre.priv\r
\r
# Importar una clave pública\r
gpg --import clavepublica.asc\r
# Importar una clave privada\r
gpg --allow-secret-key-import --import claveprivada.priv\r
\`\`\`\r
\r
Para cifrar y descifrar un archivo con las claves generadas, ejecutamos los siguientes comandos\r
\r
\`\`\`bash\r
# Cifrar\r
gpg --output archivo.cifrado --encrypt --recipient IDdeLaClavePública archivo\r
# Descifrar\r
gpg --output archivo --decrypt archivo.cifrado\r
\`\`\`\r
`]},{title:"6.2 Funciones resumen",headers:[{level:2,title:"6.2.1. Funciones hash",slug:"_6-2-1-funciones-hash",link:"#_6-2-1-funciones-hash",children:[]},{level:2,title:"6.2.2. MessageDigest",slug:"_6-2-2-messagedigest",link:"#_6-2-2-messagedigest",children:[]},{level:2,title:"6.2.3. MessageDigest con GnuPG",slug:"_6-2-3-messagedigest-con-gnupg",link:"#_6-2-3-messagedigest-con-gnupg",children:[]}],path:"/es/unit6/hash-functions.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.2 Funciones resumen\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.2 Funciones resumen" />\r
\r
# 6.2 Funciones resumen\r
\r
[[toc]]\r
\r
## 6.2.1. Funciones hash\r
\r
Un *Message digest* o resumen de mensaje, más conocidos como **funciones hash**, es una marca digital de un bloque de datos. Existe un gran número de algoritmos diseñados para procesar esto resúmenes, los dos más conocidos son SHA-1 y MD5.\r
\r
De un resumen cabe destacar las siguientes características:\r
\r
- Para el mismo algoritmo, el resumen siempre tiene el mismo tamaño, independientemente del tamaño de los datos que se haya usado para generarlo.\r
- Es imposible recuperar la información original a partir de un resumen.\r
- El resumen no debe desvelar nada sobre los datos que se utilizaron para generarlo.\r
- Es computacionalmente inviable encontrar dos mensajes que tengan el mismo valor de resumen.  Matemáticamente es altamente improbable, pero no imposible.\r
- Un pequeño cambio en los datos resumidos genera un resumen completamente diferente.\r
\r
Los resúmenes se usan para generar identificadores únicos y confiables. A veces se les llama *checksum*, ya que sirven para comprobar si una descarga se ha realizado correctamente, generando su resumen y comparándolo con el que generó el archivo original.\r
\r
::: warning Un hash no sirve para cifrar\r
Es importante destacar que, debido a que es imposible obtener los datos que generaron un resumen a partir del propio resumen, el resumen no se puede usar para cifrar información.\r
\r
Por el contrario, es un mecanismo que se usa para comparar. Su uso más extendido es con las contraseñas, ya que en las bases de datos se guarda un resumen en vez de la contraseña en claro. De esta forma, cuando se recibe una contraseña se genera su resumen y se compara con el valor almacenado.\r
:::\r
\r
## 6.2.2. MessageDigest\r
\r
La clase *MessageDigest* permite a las aplicaciones implementar algoritmos de resumen criptográficamente seguros como SHA-256 o SHA-512\r
\r
Para generar un hash con JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *MesageDigest* con el método estático *getInstance()* de la misma clase, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. Se añaden datos con el método *update()*. Se puede añadir un byte o un array de bytes. Este método se puede invocar varias veces para ir añadiendo nuevos datos.\r
3. Se obtiene el valor de hash con el método *digest()*.\r
4. Si se quisiera calcular un nuevo hash, se invocaría el método *reset()* para volver a empezar el proceso.\r
\r
A continuación podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S2_MessageDigest {\r
\r
    public static void main(String[] args) {\r
        String plaintext = "Esto es un texto plano.";\r
        try {\r
            // Obtenemos un ENGINE que implementa el algoritmo especificado\r
            // Se puede indicar cualquier algoritmo disponible en el sistema\r
            // SHA-224, SHA-512, SHA-256, SHA3-224, ...\r
            MessageDigest m = MessageDigest.getInstance("SHA-256");\r
\r
            // Opcional - Reinicia el objeto para un nuevo uso \r
            // Por si queremos poner este código en un bucle y procesar más\r
            // de un mensaje\r
            m.reset();\r
\r
            // Realiza el resumen de los datos pasados por parámetro\r
            // Si queremos procesar la información poco a poco, \r
            // debemos ir llamando al método update para cada bloque de datos\r
            m.update(plaintext.getBytes());\r
\r
            // Completa el cálculo del valor del hash y devuelve el resumen\r
            byte[] digest = m.digest();\r
\r
            // Mensaje de resumen\r
            System.out.println("Resumen (raw data): " + new String(digest));\r
\r
            // Mensaje en formato hexadecimal\r
            System.out.println("Resumen (hex data): " + toHexadecimal(digest));\r
            \r
            \r
            // Información del proceso\r
            System.out.println("=> Algoritmo: " + m.getAlgorithm() + ", Provider: " + m.getProvider().getName() + " " + m.getProvider().getVersionStr());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.err.println("No se ha encontrado la implementación del algoritmo MD5 en ningún Provider");\r
        }\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
}\r
\`\`\`\r
\r
y esta sería la salida proporcionada\r
\r
\`\`\`sh\r
Resumen (raw data): �Y�"�3\x1B��\`b����bs?;������~E\r
Resumen (hex data): FB59D31122913314111B92CD60628ED7E7DE62733F3B10DEDAF303AAABE57E45\r
=> Algoritmo: SHA-256, Provider: SUN 11\r
\`\`\`\r
\r
## 6.2.3. MessageDigest con GnuPG\r
\r
Con la suite GnuPG podemos generar resúmenes de archivos utilizando los algoritmos que nos proporciona la suite.\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la información de los algoritmos disponibles para cada tipo de servicio. En concreto, de resúmenes, en mi versión instalada:\r
\r
Resumen: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\r
:::\r
\r
Para generar un resumen de un archivo, ejecutamos el comando de la siguiente forma\r
\r
\`\`\`sh\r
gpg --print-md SHA256 filename.ext\r
\`\`\``]},{title:"6 Introducción",headers:[{level:2,title:"Objetivos",slug:"objetivos",link:"#objetivos",children:[]}],path:"/es/unit6/",pathLocale:"/es/",extraFields:[`---\r
title: 6 Introducción\r
---\r
\r
# Tema 6. Técnicas de programación segura\r
\r
El término criptografía es un derivado de la palabra griega *kryptos* que significa oculto y *grafos* que significa escritura. El objetivo de la criptografía es ocultar el significado de un mensaje mediante el cifrado o codificación del mensaje.\r
\r
De todas las técnicas de programación segura, nosotros vamos a estudiar en este tema\r
\r
- Las funciones de resumen (Hash)\r
- El **cifrado simétrico** o de clave oculta\r
- El **cifrado asimétrico** o de clave privada\r
\r
También estudiaremos cómo usar canales seguros de comunicación para nuestras aplicaciones, mediante el uso de sockets seguros empleando SSL/TLS.\r
\r
Además, veremos una herramienta de seguridad que incorpora Java, las políticas de seguridad.\r
\r
## Objetivos\r
\r
Objetivos de esta unidad:\r
\r
- Identificar principios y prácticas de programación segura.\r
- Analizar técnicas y prácticas criptográficas.\r
- Definir políticas de seguridad.\r
- Emplear algoritmos criptográficos.\r
- Utilizar sockets seguros para la transmisión de información.\r
- Estudiar el funcionamiento de TLS/SSL sobre el protocolo TCP\r
- Conocer herramientas de uso genérico en la criptografía\r
`]},{title:"6.5 Comunicaciones seguras en Java",headers:[{level:2,title:"6.5.1. Protocolo SSL (Secure Sockets Layer)",slug:"_6-5-1-protocolo-ssl-secure-sockets-layer",link:"#_6-5-1-protocolo-ssl-secure-sockets-layer",children:[]},{level:2,title:"6.5.2. JSSE",slug:"_6-5-2-jsse",link:"#_6-5-2-jsse",children:[{level:3,title:"SSLSocket y SSLServerSocket",slug:"sslsocket-y-sslserversocket",link:"#sslsocket-y-sslserversocket",children:[]},{level:3,title:"keytool: certificados, confianza y almacenes de claves",slug:"keytool-certificados-confianza-y-almacenes-de-claves",link:"#keytool-certificados-confianza-y-almacenes-de-claves",children:[]}]},{level:2,title:"6.5.3. Servidor y Cliente SSL",slug:"_6-5-3-servidor-y-cliente-ssl",link:"#_6-5-3-servidor-y-cliente-ssl",children:[]}],path:"/es/unit6/jsse.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.5 Comunicaciones seguras en Java\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.5 Comunicaciones seguras en Java" />\r
\r
# 6.5 Comunicaciones seguras en Java\r
\r
[[toc]]\r
\r
## 6.5.1. Protocolo SSL (Secure Sockets Layer)\r
\r
SSL es el protocolo habitualmente usado para encriptar la comunicación cliente-servidor. Casi todo el tráfico de la red puede encriptarse con SSL: POP, IMAP, telnet, FTP, etc, pero es especialmente interesante para dotar de seguridad al protocolo HTTP, es decir como base del HTTPS.\r
\r
La implementación de SSL es una extensión de los sockets que permite establecer un canal (stream) de comunicación. Dicha comunicación se inicia con un **handshake** durante el cual, el cliente y el servidor construyen una session-key (clave simétrica encriptada con par de claves asimétricas) compartida para verificar su identidad mutua.\r
\r
## 6.5.2. JSSE\r
\r
JSSE (Java Secure Socket Extension) es un conjunto de paquetes que permiten el desarrollo de aplicaciones seguras en Internet. Proporciona un marco y una implementación para Java de los protocolos SSL y TSL e incluye funcionalidad de\r
\r
- encriptación de datos\r
- autenticación de servidores\r
- integridad de mensajes\r
- autenticación de clientes\r
\r
Con JSSE, los programadores  pueden ofrecer intercambio seguro de datos entre un cliente y un servidor que ejecuta un protocolo de aplicación, tales como HTTP, Telnet o FTP, a través de TCP/IP.\r
\r
Las clases de JSSE se encuentran en los paquetes javax.net y javax.net.ssl.\r
\r
### SSLSocket y SSLServerSocket\r
\r
Las clases SSLSocket y SSLServerSocket representan sockets seguros y son derivadas de las ya conocidas Socket y ServerSocket respectivamente.\r
\r
JSSE tiene dos clases SSLServerSocketFactory y SSLSocketFactory para la creación de sockets seguros. No tienen constructor, se obtienen a través del método estático getDefault().\r
\r
Para obtener un socket servidor seguro o *SSLServerSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
SSLServerSocket servidorSSL = (SSLServerSocket) = sfact.createServerSocket(puerto);\r
\`\`\`\r
\r
El método **createServerSocket(int puerto)** devuelve un socket de servidor enlazado al puerto especificado.\r
\r
Para crear un *SSLSocket*:\r
\r
\`\`\`java:no-line-numbers\r
SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
SSLSocket Cliente = (SSLSocket) sfact.createSocket(Host, puerto);\r
\`\`\`\r
\r
El método createSocket (String host, int puerto) crea un socket y lo conecta con el host y el puerto especificados.\r
\r
### keytool: certificados, confianza y almacenes de claves\r
\r
Cuando dos socket SSL, uno cliente y otro servidor, intentan establecer conexión, tienen que "presentarse" el uno al otro y comprobar que el otro es de confianza. Si todo va bien y uno confía en el otro, la conexión se establece, en caso contrario, no se establece.\r
\r
Para establecer esa confianza se debe crear un certificado en el servidor y añadirlo a los certificados de confianza del cliente.\r
\r
- El servidor debe tener su propio certificado. Si no lo tenemos, se puede generar primero una pareja de claves con la herramienta **keytool**, que viene incluida en el JDK de Java. La herramienta guardará la pareja de claves en un almacén (el cual tiene su propia clave).\r
- Después generaremos un certificado a partir de esa pareja.\r
- El código del servidor necesitará indicar el fichero donde se almacenan las claves y la clave para acceder a ese almacén.\r
- El cliente necesitará indicar que confía en el certificado del servidor. Dicho certificado del servidor puede estar guardado (por ejemplo) en el almacén de claves del cliente.\r
\r
::: info Seguridad mutua\r
Aunque no suele hacerse también podría hacerse a la inversa y obligar al cliente a tener un certificado que el servidor pudiera importar, lo que aumentaría la seguridad.\r
:::\r
\r
Vamos a ver cómo realizar estas operaciones previas con la herramienta **keytool**\r
\r
Primero las acciones a realizar en el servidor\r
\r
\`\`\`sh:no-line-numbers\r
# El servidor genera una pareja de claves que se almacena en un\r
# fichero llamado "clavesservidor". Dentro del fichero se indica\r
# un alias para poder referirnos a esa clave fácilmente\r
# keytool -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -genkey -keyalg RSA -alias servidor -keystore ClavesServidor -storepass 12345678\r
What is your first and last name?\r
  [Unknown]:  Vicente Martinez\r
What is the name of your organizational unit?\r
  [Unknown]:  Dpto. Informatica\r
What is the name of your organization?\r
  [Unknown]:  IES Doctor Balmis\r
What is the name of your City or Locality?\r
  [Unknown]:  Alicante\r
What is the name of your State or Province?\r
  [Unknown]:  Alicante\r
What is the two-letter country code for this unit?\r
  [Unknown]:  ES\r
Is CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES correct?\r
  [no]: yes\r
\r
# El servidor genera su "certificado", es decir un fichero que\r
# de alguna forma indica quien es él. El certificado se almacena\r
# en un fichero llamado clavesservidor y a partir de él queremos\r
# generar el certificado de un alias creado previamente con nombre servidor\r
# keytool -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -exportcert -alias servidor -file servidor.cer -keystore ClavesServidor\r
Enter keystore password:\r
Certificate stored in file <servidor.cer>\r
\`\`\`\r
\r
En la carpeta donde hemos ejecutado el comando keytool, se ha creado el almacén de claves en un fichero llamado **ClavesServidor** y el certificado exportado en el archivo **servidor.cer**\r
\r
y a continuación las que habría que realizar en el cliente para generar el almacén de confianza que, en nuestro caso contenga el mismo certificado que hemos exportado del servidor.\r
\r
\`\`\`sh:no-line-numbers\r
# Se importa el certificado del servidor indicando que pertenece a\r
# la lista de certificados confiables.\r
# keytool -importcert -trustcacerts -alias servidor -file servidor.cer -keystore clavescliente  -storepass 87654321\r
"C:/Program Files/Java/jdk-11.0.11/bin/keytool.exe" -importcert -trustcacerts -alias servidor -file servidor.cer -keystore CertificadosConfianzaCliente -storepass 87654321\r
Owner: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Issuer: CN=Vicente Martinez, OU=Dpto. Informatica, O=IES Doctor Balmis, L=Alicante, ST=Alicante, C=ES\r
Serial number: 4eb6f2a5\r
Valid from: Mon Jan 24 00:20:24 CET 2022 until: Sun Apr 24 01:20:24 CEST 2022\r
Certificate fingerprints:\r
         SHA1: DD:A2:75:4C:1C:BC:39:60:BE:B1:20:67:E1:5C:45:8C:48:B5:1F:54\r
         SHA256: 82:C8:56:C2:DB:DE:8C:73:A9:21:C6:7D:DE:1F:39:4F:79:CC:5F:D5:10:BC:61:DA:E3:EE:E1:1D:21:EA:D2:33\r
Signature algorithm name: SHA256withRSA\r
Subject Public Key Algorithm: 2048-bit RSA key\r
Version: 3\r
\r
Extensions:\r
\r
#1: ObjectId: 2.5.29.14 Criticality=false\r
SubjectKeyIdentifier [\r
KeyIdentifier [\r
0000: 16 AE 35 7C 58 97 B1 95   91 9B FA 6C 2A 80 D2 90  ..5.X......l*...\r
0010: 1C 50 7F C0                                        .P..\r
]\r
]\r
\r
Trust this certificate? [no]:  yes\r
Certificate was added to keystore\r
\`\`\`\r
\r
En esta ocasión también se crea, en la carpeta donde se ha ejecutado el comando keytool, un fichero **CertificadosConfianzaCliente** con el/los certificados de confianza para el cliente.\r
\r
## 6.5.3. Servidor y Cliente SSL\r
\r
En le siguiente ejemplo podemos observar como la inicialización del ServerSocket es diferente, pero a partir de que se llama al método accept y, en este caso se obtiene una instancia de tipo SSLSocket, el resto del código es igual que con la clase Socket.\r
\r
\`\`\`java{5,16,17,24}\r
public class U6S5_SSLServer {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteConectado = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante código, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicación\r
        // System.setProperty("javax.net.ssl.keyStore", System.getProperty("user.dir") + "\\\\ClavesServidor");\r
        // System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
        \r
        // Inicialización del ServerSocket SSL\r
        int puerto = 6000;\r
        SSLServerSocketFactory sfact = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\r
        SSLServerSocket servidorSSL = (SSLServerSocket) sfact.createServerSocket(puerto);\r
\r
        for (int i = 1; i < 5; i++) {\r
\r
            System.out.println("Esperando al cliente " + i);\r
\r
            // Se espera la conexión de un cliente con accept\r
            clienteConectado = (SSLSocket) servidorSSL.accept();\r
            // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
            // el código del ejemplo\r
            flujoEntrada = new DataInputStream(clienteConectado.getInputStream());\r
            flujoSalida = new DataOutputStream(clienteConectado.getOutputStream());\r
\r
            // El cliente envía un mensaje\r
            System.out.println("Recibiendo del CLIENTE: " + i + " \\n\\t" + flujoEntrada.readUTF());\r
\r
            // El Servidor responde con un saludo\r
            flujoSalida.writeUTF("Saludos al cliente del servidor");\r
        }\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteConectado.close();\r
        servidorSSL.close();\r
    }\r
}\r
\`\`\`\r
\r
En el cliente el proceso es el mismo, tras la llamada al método createSocket, obtenemos una instancia de SSLSocket que utilizamos igual que si fuese un Socket.\r
\r
\`\`\`java{5,12,13,19,20}\r
public class U6S5_SSLClient {\r
\r
    public static void main(String[] arg) throws IOException {\r
\r
        SSLSocket clienteSSL = null;\r
        DataInputStream flujoEntrada = null; //FLUJO DE ENTRADA DE CLIENTE\r
        DataOutputStream flujoSalida = null; //FLUJO DE SALIDA AL CLIENTE\r
\r
        // Las propiedades se pueden especificar mediante código, o bien mediante\r
        // argumentos de la JVM en la llamada a la aplicación\r
        // System.setProperty("javax.net.ssl.trustStore", System.getProperty("user.dir") + "/CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
        System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
        // Inicialización del ServerSocket SSL\r
        int puerto = 6000;\r
        String host = "localhost";\r
\r
        System.out.println("Programa Cliente iniciado....");\r
        SSLSocketFactory sfact = (SSLSocketFactory) SSLSocketFactory.getDefault();\r
        clienteSSL = (SSLSocket) sfact.createSocket(host, puerto);\r
\r
        // Trabajamos do DataInputStream y DataOutputStream para simplificar\r
        // el código del ejemplo\r
        flujoSalida = new DataOutputStream(clienteSSL.getOutputStream());\r
        flujoEntrada = new DataInputStream(clienteSSL.getInputStream());\r
\r
        // Envío un saludo al servidor\r
        flujoSalida.writeUTF("Saludos al SERVIDOR DESDE EL CLIENTE");\r
\r
        // El Servidor responde con un mensaje\r
        System.out.println("Recibiendo del SERVIDOR: \\n\\t" + flujoEntrada.readUTF());\r
\r
        // CERRAR STREAMS Y SOCKETS\r
        flujoEntrada.close();\r
        flujoSalida.close();\r
        clienteSSL.close();\r
    }\r
\r
    void mostrarInformacionSesionSSL(SSLSocket cliente) throws SSLPeerUnverifiedException {\r
\r
        //------------------------------------------------------------------------------\r
        //Ejemplo de la múltiple información sobre la sesión SSL\r
        // que se puede obtener a partir \r
        SSLSession session = ((SSLSocket) cliente).getSession();\r
        System.out.println("Host: " + session.getPeerHost());\r
        System.out.println("Cifrado: " + session.getCipherSuite());\r
        System.out.println("Protocolo: " + session.getProtocol());\r
\r
        System.out.println("IDentificador:" + new BigInteger(session.getId()));\r
\r
        System.out.println("Creación de la sesión: " + session.getCreationTime());\r
\r
        X509Certificate certificate = (X509Certificate) session.getPeerCertificates()[0];\r
        System.out.println("Propietario: " + certificate.getSubjectDN());\r
        System.out.println("Algoritmo: " + certificate.getSigAlgName());\r
        System.out.println("Tipo: " + certificate.getType());\r
        System.out.println("Emisor: " + certificate.getIssuerDN());\r
        System.out.println("Número Serie: " + certificate.getSerialNumber());\r
        //-----------------------------------------------------------------------------\r
    }\r
}\r
\`\`\`\r
\r
Si ejecutamos el cliente y el servidor directamente, obtendremos el siguiente error\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Exception in thread "main" javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure\r
\`\`\`\r
\r
Para ejecutar el programa servidor es necesario indicar el certificado que se utilizará. \r
\r
Lo podemos indicar a la hora de ejecutar el programa, añadiendo a la línea de comandos\r
\r
\`\`\` sh\r
 java -Djavax.net.ssl.keyStore=ClavesServidor -Djavax.net.ssl.keyStorePassword=12345678\r
\`\`\`\r
\r
y en el programa cliente es necesario indicar la ubicación de los certificados de confianza\r
\r
\`\`\` sh\r
java -Djavax.net.ssl.trustStore=CertificadosConfianzaCliente -Djavax.net.ssl.trustStorePassword=87654321\r
\`\`\`\r
\r
o bien, en las opciones de ejecución del IDE\r
\r
![Netbeans: Opciones de la JVM](../../media/unit6/VM_Options.png)\r
\r
::: info Parámetros de JVM o código\r
En el código anterior hay unas líneas comentadas que especifican cómo podemos configurar el valor de las propiedades desde código mediante el uso del método System.setProperty(String propiedad, String valor).\r
\r
En el programa servidor incluiríamos las siguientes líneas:\r
\r
System.setProperty("javax.net.ssl.keyStore", "ClavesServidor");\r
System.setProperty("javax.net.ssl.keyStorePassword", "12345678");\r
\r
Y en el programa cliente serían estas:\r
\r
System.setProperty("javax.net.ssl.trustStore", "CertificadosConfianzaCliente");\r
System.setProperty("javax.net.ssl.trustStorePassword", "87654321");\r
\r
Además del nombre, podemos indicar la ruta donde se encuentran los almacenes, recordando que NO ES RECOMENDABLE el uso de barras invertidas para indicar rutas.\r
:::\r
\r
Una vez hechos los cambios, bien en las opciones de la JVM o bien en el código de las aplicaciones, la salida que obtendremos será esta\r
\r
<CodeGroup>\r
<CodeGroupItem title="Servidor" active>\r
\r
\`\`\`sh:no-line-numbers\r
Esperando al cliente 1\r
Recibiendo del CLIENTE: 1 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 2\r
Recibiendo del CLIENTE: 2 \r
	Saludos al SERVIDOR DESDE EL CLIENTE\r
Esperando al cliente 3\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
<CodeGroupItem title="Cliente">\r
\r
\`\`\`sh:no-line-numbers\r
Programa Cliente iniciado....\r
Recibiendo del SERVIDOR: \r
	Saludos al cliente del servidor\r
\`\`\`\r
\r
</CodeGroupItem>\r
\r
</CodeGroup>\r
\r
::: warning Default trusted certificates\r
Whenever Java attempts to connect to another application over SSL (e.g.: HTTPS, IMAPS, LDAPS), it will only be able to connect to that application if it can trust it. The way trust is handled in the Java world is that you have a keystore (typically $JAVA_HOME/lib/security/cacerts), also known as the truststore. This contains a list of all known Certificate Authority (CA) certificates, and Java will only trust certificates that are signed by one of those CAs or public certificates that exist within that keystore.\r
\r
If -Djavax.net.ssl.trustStore has been configured, it will override the location of the default truststore, which will need to be checked.\r
:::`]},{title:"6.6 Anexo I - Librería de registro Log4Java2",headers:[{level:2,title:"6.6.1 Registros o logs",slug:"_6-6-1-registros-o-logs",link:"#_6-6-1-registros-o-logs",children:[]},{level:2,title:"6.6.2. Configuración automática de Log4j2",slug:"_6-6-2-configuracion-automatica-de-log4j2",link:"#_6-6-2-configuracion-automatica-de-log4j2",children:[]},{level:2,title:"6.6.3. Niveles de registro",slug:"_6-6-3-niveles-de-registro",link:"#_6-6-3-niveles-de-registro",children:[]},{level:2,title:"6.6.4. Ejemplo de uso de Log4j2",slug:"_6-6-4-ejemplo-de-uso-de-log4j2",link:"#_6-6-4-ejemplo-de-uso-de-log4j2",children:[]},{level:2,title:"6.6.5. Configuración de Log4j2",slug:"_6-6-5-configuracion-de-log4j2",link:"#_6-6-5-configuracion-de-log4j2",children:[]},{level:2,title:"6.6.6 Appenders",slug:"_6-6-6-appenders",link:"#_6-6-6-appenders",children:[]},{level:2,title:"6.6.7. Loggers",slug:"_6-6-7-loggers",link:"#_6-6-7-loggers",children:[]},{level:2,title:"6.6.8. Layouts",slug:"_6-6-8-layouts",link:"#_6-6-8-layouts",children:[]},{level:2,title:"6.6.9. Actividades",slug:"_6-6-9-actividades",link:"#_6-6-9-actividades",children:[]},{level:2,title:"6.6.10. Bibliografía",slug:"_6-6-10-bibliografia",link:"#_6-6-10-bibliografia",children:[]}],path:"/es/unit6/log4j_annex.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.6 Anexo I - Librería de registro Log4Java2\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.6 Anexo I - Librería de registro Log4Java2" />\r
\r
# 6.6 Anexo I - Log4Java2 - Gestor de logs\r
\r
[[toc]]\r
\r
## 6.6.1 Registros o logs\r
\r
El registro es el proceso de escribir mensajes de registro en cualquier archivo, base de datos, consola, etc. para mantener un registro de eventos que ocurren en un sistema. El registro es una parte esencial de cualquier aplicación para depurar y monitorear el sistema.\r
\r
El software con suficiente registro y monitorización le permitirá detectar posibles incidentes cuando su código se despliegue en un entorno de producción. \`Log4j\` se utiliza para gestionar el registro de información en una aplicación.\r
\r
Además, en términos de seguridad, el registro es una parte esencial de cualquier aplicación. Si su aplicación se ve comprometida, el registro le ayudará a rastrear el origen de un ataque, accesos indebidos, accesos no autorizados y a tomar medidas para evitar que vuelva a ocurrir.\r
\r
Hasta ahora hemos usado la instrucción SOP \`System.out.println()\` para imprimir mensaje de registro. Este sistema tiene algunas desventajas:\r
\r
- Podemos imprimir mensajes de registro solo en la consola. Por lo tanto, cuando se cierre la consola, perderemos -dos los registros.\r
- No podemos almacenar mensajes de registro en ningún lugar permanente. Estos mensajes se imprimirán uno por uno en la consola porque es un entorno de un solo hilo.\r
- No podemos configurar diferentes niveles de registro como INFO, DEBUG, ERROR, etc.\r
- No podemos configurar el formato de registro, como la fecha, la hora, el nombre de la clase, el nombre del método y que se aplique a todos los mensajes de registro.\r
- No podemos configurar el destino de registro, como la consola, el archivo, la base de datos, etc.\r
\r
Para solventar estos problemas, se utiliza el framework Log4j. Log4j es un framework de código abierto proporcionado por Apache solo para proyectos de Java.\r
\r
!!! note Versiones Log4j2\r
    Log4j es un sistema de registro donde la API (llamada Log4j API) y su implementación (llamada Log4j Core) están separadas claramente la una de la otra.\r
\r
    Esto permite que la API de Log4j proporcione una interfaz que sea fácil de usar de una manera correcta y a prueba de futuro. Consulta las páginas de [API de Java](https://logging.apache.org/log4j/2.x/manual/api.html), [API de Kotlin](https://logging.apache.org/log4j/kotlin/index.html) y [API de Scala](https://logging.apache.org/log4j/scala/latest/) para obtener más información.\r
\r
    \r
Para usar Log4j2 en nuestro código solo necesitamos agregar las siguientes [librerías / dependencias](https://logging.apache.org/log4j/2.x/download.html) en nuestro proyecto:\r
\r
\`\`\`bash\r
log4j-api-<version>.jar\r
log4j-core-<version>.jar\r
\`\`\`\r
\r
## 6.6.2. Configuración automática de Log4j2\r
\r
Podemos configurar Log4j2 con nuestra aplicación utilizando un archivo de configuración escrito en formato XML, JSON, YAML o propiedades. También podemos hacerlo mediante código pero, por ahora, nos vamos a centrar en la configuración utilizando archivos de configuración.\r
\r
Log4j tiene la capacidad de configurarse automáticamente durante la inicialización. Tiene un orden para buscar el archivo de configuración en la aplicación. Log4j proporcionará una configuración predeterminada si no puede localizar un archivo de configuración.\r
\r
## 6.6.3. Niveles de registro\r
\r
Los niveles de registro son un mecanismo para categorizar los registros. Los niveles se utilizan para identificar la gravedad de un evento. Podemos configurar fácilmente los niveles para especificar qué detalles de registro queremos ver. Log4j proporciona los siguientes niveles:\r
\r
1. ALL: Para registrar todos los eventos.\r
2. TRACE: Un mensaje de depuración detallado, que captura típicamente el flujo a través de la aplicación.\r
3. DEBUG: Un evento de depuración general.\r
4. INFO: Un evento con fines informativos.\r
5. WARN: Un evento que podría posiblemente llevar a un error.\r
6. ERROR: Un error en la aplicación, posiblemente recuperable.\r
7. FATAL: Un error grave que impedirá que la aplicación continúe.\r
8. OFF: No se registrarán eventos.\r
\r
Log4j sigue el siguiente orden:\r
\r
> ALL < TRACE < DEBUG < INFO < WARN < ERROR < FATAL\r
\r
Si especificamos el nivel de registro como INFO, se registrarán todos los eventos INFO, WARN, ERROR y FATAL. Si especificamos el nivel de registro como WARN, se registrarán todos los eventos WARN, ERROR y FATAL. En términos simples, se considerarán todos los niveles por debajo del nivel especificado, incluido el nivel especificado.\r
\r
## 6.6.4. Ejemplo de uso de Log4j2\r
\r
\`\`\`java\r
package psp.examples.u06.log4j2;\r
\r
import org.apache.logging.log4j.LogManager;\r
import org.apache.logging.log4j.Logger;\r
\r
public class ModuleA {\r
\r
    private static final Logger logger = LogManager.getLogger();\r
    \r
    // Log messages\r
    public static void main(String[] args) {\r
        logger.debug("It is a debug logger.");\r
        logger.error("It is an error logger.");\r
        logger.fatal("It is a fatal logger.");\r
        logger.info("It is a info logger.");\r
        logger.trace("It is a trace logger.");\r
        logger.warn("It is a warn logger.");\r
    }\r
}\r
\`\`\`\r
\r
La salida obtenida será la siguiente:\r
\r
\`\`\`bash\r
11:14:47.469 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\r
11:14:47.471 [main] FATAL psp.examples.u06.log4j2.ModuleA - It is a fatal logger.\r
\`\`\`\r
\r
Aunque hemos usado todos los niveles, en la consola solo vemos dos niveles. En realidad, cuando no proporcionamos ningún archivo de configuración, por defecto Log4j utiliza una configuración predeterminada. La configuración predeterminada, proporcionada en la clase DefaultConfiguration, configurará:\r
\r
- Un **\`ConsoleAppender\`** para el logger por defecto, es decir, los registros se imprimirán en la consola.\r
- Un **\`PatternLayout\`** configurado con el patrón:\r
  " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n " asociado al ConsoleAppender\r
\r
!!! tip Nivel de registro por defecto\r
    Por defecto, Log4j asigna el logger raíz al nivel Level.ERROR y esos logs se imprimirán en la consola estándar.\r
\r
!!! info Patrón por defecto\r
    Vamos a entender el formato de patrón en el que se imprimen los logs. Dado que no hemos pasado ningún archivo de configuración, utiliza el formato por defecto que se muestra a continuación.\r
\r
    > " %d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n "\r
\r
    - \`%d{HH:mm:ss.SSS}\` is execution timestamp i.e. 18:07:15.984\r
    - \`[%t]\` is thread name i.e. [main] \r
    - \`%-5level\` is level name i.e. ERROR\r
    - \`%logger{36}\` is logger name which we are creating as first step i.e. psp.examples.u06.log4j2\r
    - \`%msg%n\` is message i.e. “ It is an error logger ” followed by a new line character.\r
\r
## 6.6.5. Configuración de Log4j2\r
\r
Para configurar Log4j2, necesitamos un archivo de configuración. Log4j2 admite la configuración en formato XML, JSON, YAML y propiedades.\r
\r
Log4j2 tiene una arquitectura de registro bastante compleja, sin embargo la mayoría de los usuarios solo requieren estos elementos:\r
\r
- **Loggers**: Son el punto de entrada del pipeline de registro, que se utiliza directamente en el código. Su configuración debe especificar qué nivel de mensajes registran y a qué \`*appenders*\` envían los mensajes. Los cubriremos mientras configuramos los \`*loggers*\`.\r
- **Appenders**: Son el punto de salida del pipeline de registro. Deciden a qué recurso (consola, archivo, base de datos o similar) se envía el evento de registro. Los más comunes son el \`*console appender*\` y el \`*file appender*\`.\r
- **Layouts**: Indican a los \`*appenders*\` cómo formatear el evento de registro: texto, JSON, XML o similar. Los más comunes son \`*Pattern Layout*\` y \`*JSON Template Layout*\`.\r
\r
A continuación se muestra un ejemplo de configuración en formato XML.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuración, hemos configurado un \`ConsoleAppender\` que imprimirá los mensajes de registro en la consola. Hemos configurado el nivel de registro raíz como \`error\`, por lo que solo se imprimirán los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscará los archivos de configuración en el siguiente orden:\r
\r
1. Primero comprobará si se ha especificado un archivo de configuración en la propiedad del sistema \`log4j.configurationFile\`. Si no se ha especificado, buscará los archivos de configuración en el siguiente orden:\r
2. Si no encuentra la propiedad del sistema buscará los archivos de configuración en el \`classpath\` en el siguiente orden:\r
\r
   - \`log4j2-test.xml\`\r
   - \`log4j2-test.json\`\r
   - \`log4j2-test.yaml\`\r
   - \`log4j2-test.yml\`\r
   - \`log4j2-test.properties\`\r
   - \`log4j2.xml\`\r
   - \`log4j2.json\`\r
   - \`log4j2.yaml\`\r
   - \`log4j2.yml\`\r
   - \`log4j2.properties\`\r
\r
Se puede ampliar la información en la [documentación oficial de Log4j2](https://logging.apache.org/log4j/2.x/manual/configuration.html).\r
\r
## 6.6.6 Appenders\r
\r
> [Documentación Appenders](https://logging.apache.org/log4j/2.x/manual/appenders.html)\r
\r
Podemos especificar destinos para mantener los registros de eventos. Podemos querer imprimir esos registros en la consola o en cualquier archivo externo. Los \`appenders\` suelen ser responsables de escribir los datos de eventos en el destino objetivo. Podemos usar varios *appenders* en una misma configuración.\r
\r
Los \`appenders\` más comunes son:\r
\r
- **ConsoleAppender**: Imprime los mensajes de registro en la consola.\r
- **FileAppender**: Imprime los mensajes de registro en un archivo.\r
- **RollingFileAppender**: Imprime los mensajes de registro en un archivo y crea un nuevo archivo cuando el tamaño del -chivo alcanza un límite.\r
- **DBAppender**: Imprime los mensajes de registro en una base de datos.\r
- **SMTPAppender**: Envía los mensajes de registro por correo electrónico.\r
- **SocketAppender**: Envía los mensajes de registro a un servidor remoto.\r
- **SyslogAppender**: Envía los mensajes de registro a un servidor Syslog.\r
- **JMSAppender**: Envía los mensajes de registro a un servidor JMS.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration xmlns="https://logging.apache.org/xml/ns"\r
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\r
               xsi:schemaLocation="\r
                   https://logging.apache.org/xml/ns\r
                   https://logging.apache.org/xml/ns/log4j-config-2.xsd">\r
  <Appenders>\r
    <Console name="CONSOLE">\r
      <PatternLayout pattern="%p - %m%n"/>\r
    </Console>\r
    <File name="MAIN" fileName="logs/main.log">\r
      <JsonTemplateLayout/>\r
    </File>\r
    <File name="DEBUG_LOG" fileName="logs/debug.log">\r
      <PatternLayout pattern="%d [%t] %p %c - %m%n"/>\r
    </File>\r
  </Appenders>\r
  <Loggers>\r
    <Root level="INFO">\r
      <AppenderRef ref="CONSOLE" level="WARN"/>\r
      <AppenderRef ref="MAIN"/>\r
    </Root>\r
    <Logger name="org.example" level="DEBUG">\r
      <AppenderRef ref="DEBUG_LOG"/>\r
    </Logger>\r
  </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En el ejemplo anterior se han configurado tres \`appenders\`:\r
\r
- Un \`ConsoleAppender\` llamado CONSOLE con un \`PatternLayout\`.\r
  En este caso la salida se mostrará en la consola y se imprimirá el nivel de log y el mensaje. Por ejemplo, \`INFO - It is an info logger\`.\r
- Un \`FileAppender\` llamado MAIN con un \`JsonTemplateLayout\`.\r
  En este caso la salida se escribirá en el archivo \`logs/main.log\` en formato JSON. Por ejemplo, \`{"level":"INFO","message":"It is an info logger"}\`.\r
- Un \`FileAppender\` llamado DEBUG_LOG con un \`PatternLayout\`.\r
    En este caso la salida se escribirá en el archivo \`logs/debug.log\` con el formato de fecha, hilo, nivel de log, clase y mensaje. Por ejemplo, \`2021-09-15 11:14:47,471 [main] ERROR psp.examples.u06.log4j2.ModuleA - It is an error logger.\`\r
\r
## 6.6.7. Loggers\r
\r
> [Documentación Loggers](https://logging.apache.org/log4j/2.x/manual/configuration.html#configuring-loggers)\r
\r
Los \`loggers\` se utilizan directamente en el código para registrar mensajes.\r
\r
Los \`loggers\` se configuran en el archivo de configuración de Log4j2. y se pueden configurar para enviar mensajes de registro a uno o varios \`appenders\`.\r
\r
En el ejemplo anterior, se han configurado dos \`loggers\`:\r
\r
- Un \`logger\` raíz con nivel de log INFO y dos \`appenders\` asociados: CONSOLE y MAIN.\r
  En este caso, los mensajes de log con nivel INFO o superior se enviarán al \`appender\` MAIN, es decir, al archivo \`logs/main.log\`.\r
  Los mensajes de log con nivel WARN o superior se enviarán también al \`appender\` CONSOLE, es decir, a la consola.\r
- Un \`logger\` con nombre \`org.example\` con nivel de log DEBUG y un \`appender\` asociado: DEBUG_LOG.\r
  En este caso, los mensajes de log con nivel DEBUG o superior se enviarán al \`appender\` DEBUG_LOG.\r
\r
!!! question Un mismo mensaje, diferentes salidas\r
    Fíjate en la siguiente tabla con los mensajes que se enviarían a cada \`appender\` en función del nivel de log, del \`logger\` que lo genere y de los \`appenders\`.\r
\r
    | Logger name | Log event level | Appenders |\r
    |-------------|-----------------|-----------|\r
    | org.example.foo | WARN | CONSOLE, MAIN, DEBUG_LOG |\r
    | org.example.foo | DEBUG | MAIN, DEBUG_LOG |\r
    | org.example.foo | TRACE | none |\r
    | com.example | WARN | CONSOLE, MAIN |\r
    | com.example | INFO | MAIN |\r
    | com.example | DEBUG | none |\r
\r
    Si un logger no tiene un nivel de log configurado se heredará el nivel de log del logger padre. Si no se ha configurado ningún nivel de log, se heredará el nivel de log del logger raíz.\r
\r
## 6.6.8. Layouts\r
\r
> [Documentación Layouts](https://logging.apache.org/log4j/2.x/manual/layouts.html)\r
\r
Los \`layouts\` se utilizan para dar formato a los mensajes de log. Log4j2 proporciona varios \`layouts\` predefinidos que se pueden utilizar para dar formato a los mensajes de log.\r
\r
Los \`layouts\` más comunes son:\r
\r
- **PatternLayout**: Es el \`layout\` más comúnmente utilizado. Permite configurar el formato de los mensajes de log utilizando un patrón.\r
- **JsonTemplateLayout**: Es un \`layout\` que genera mensajes de log en formato JSON.\r
- **YamlLayout**: Es un \`layout\` que genera mensajes de log en formato YAML.\r
- **HtmlLayout**: Es un \`layout\` que genera mensajes de log en formato HTML.\r
- **CsvLogLayout**: Es un \`layout\` que genera mensajes de log en formato CSV.\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} – %msg%n"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
En este archivo de configuración, hemos configurado un \`ConsoleAppender\` que imprimirá los mensajes de registro en la consola. Hemos configurado el nivel de registro raíz como \`error\`, por lo que solo se imprimirán los mensajes de registro de nivel \`error\` o superior.\r
\r
Log4j2 buscará los archivos de configuración en el siguiente orden:\r
\r
Un ejemplo de configuración de Log4j2 con un \`JsonTemplateLayout\` sería el siguiente:\r
\r
\`\`\`xml\r
<?xml version="1.0" encoding="UTF-8"?>\r
<Configuration status="WARN">\r
    <Appenders>\r
        <Console name="Console" target="SYSTEM_OUT">\r
            <JsonTemplateLayout eventTemplateUri="classpath:log4j2/templates/JsonEventLayout.json"/>\r
        </Console>\r
    </Appenders>\r
    <Loggers>\r
        <Root level="error">\r
            <AppenderRef ref="Console"/>\r
        </Root>\r
    </Loggers>\r
</Configuration>\r
\`\`\`\r
\r
Donde un posible contenido para el archivo \`JsonEventLayout.json\` podría ser el siguiente:\r
\r
\`\`\`json\r
{\r
  "timeMillis": "\${timeMillis}",\r
  "thread": "\${thread}",\r
  "level": "\${level}",\r
  "loggerName": "\${loggerName}",\r
  "message": "\${message}",\r
  "thrown": "\${thrown}"\r
}\r
\`\`\`\r
\r
## 6.6.9. Actividades\r
\r
Puedes probar a realizar las siguientes actividades para practicar con Log4j2:\r
\r
1. Escribe un programa simple utilizando Log4j2 que imprima TODOS los niveles de error en la consola.\r
2. Utilizando el programa del ejercicio 1, genera un archivo de configuración manual para imprimir los errores FATALES en SYSTEM_ERR y el resto de los niveles de error en SYSTEM_OUT. (Añade comentarios en el XML con \`<!--Tu comentario-->\`)\r
3. Utilizando el programa del ejercicio 1, genera un archivo de configuración manual en el que los errores FATALES vayan a un archivo de texto, los errores de nivel ERROR aparezcan en rojo en la consola (SYSTEM_ERR) y el resto aparezcan en la consola normal (SYSTEM_OUT).\r
4. Utilizando el archivo anterior (ejercicio 3) cambia el Patrón de Salida para que lo primero que aparezca en la línea de LOG sean tus iniciales.\r
\r
!!! tip Guardar los registros en una base de datos\r
    Log4j2 también permite guardar los registros en una base de datos.\r
    Investiga cómo se puede hacer y realiza un ejemplo de cómo guardar los registros en una base de datos MySQL.\r
\r
## 6.6.10. Bibliografía\r
\r
- [Log4j2 - Documentación oficial](https://logging.apache.org/log4j/2.x/)\r
- [Tutorial de 7 partes de MakeSeleniumEasy sobre Log4j2](http://makeseleniumeasy.com/2021/03/11/log4j2-tutorial-1-introduction-to-apache-log4j2/)\r
- [Log4j2 - Tutorialspoint](https://www.tutorialspoint.com/log4j/log4j_logging_files.htm)\r
`]},{title:"6.1 Seguridad",headers:[{level:2,title:"6.1.1. Seguridad digital",slug:"_6-1-1-seguridad-digital",link:"#_6-1-1-seguridad-digital",children:[]},{level:2,title:"6.1.2. Seguridad en Java",slug:"_6-1-2-seguridad-en-java",link:"#_6-1-2-seguridad-en-java",children:[{level:3,title:"JCA: Engines, algoritmos y proveedores",slug:"jca-engines-algoritmos-y-proveedores",link:"#jca-engines-algoritmos-y-proveedores",children:[]}]},{level:2,title:"6.1.3. Proveedores",slug:"_6-1-3-proveedores",link:"#_6-1-3-proveedores",children:[]},{level:2,title:"6.1.4. Engines",slug:"_6-1-4-engines",link:"#_6-1-4-engines",children:[{level:3,title:"6.1.5. Algoritmos",slug:"_6-1-5-algoritmos",link:"#_6-1-5-algoritmos",children:[]}]}],path:"/es/unit6/security.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.1 Seguridad \r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.1 Seguridad" />\r
\r
# 6.1 Seguridad\r
\r
[[toc]]\r
\r
## 6.1.1. Seguridad digital\r
\r
Los aspectos fundamentales de la seguridad en las comunicaciones digitales son los siguientes\r
\r
- **Integridad**: Permite asegurar que los datos que recibe un receptor son idénticos a los que ha enviado el emisor. Es decir, no se ha modificado en ningún punto intermedio en **el canal, que como sabemos, es un canal compartido y por tanto, inseguro**. Las modificaciones pueden ser causadas por fallos en la transmisión a través del canal o bien por una acción intencionada de un tercero.\r
- **Confidencialidad**: Nos asegura que los datos transmitidos son inteligibles sólo para el receptor del mensaje. Por las características del medio no podemos evitar que el mensaje llegue a otros destinatarios, pero lo que sí podemos evitar es que estos puedan ver el contenido original del mensaje. Esto se consigue cifrando el mensaje.\r
- **Autenticación**: Permite asegurar al receptor de un mensaje que el emisor del mensaje es quien dice ser y no cualquier otro. Esto se consigue con los certificados y la firma digital.\r
- **No repudio**: Es una consecuencia de la característica anterior, ya que un receptor puede demostrar que el mensaje fue enviado por un emisor de forma inequívoca.\r
\r
## 6.1.2. Seguridad en Java\r
\r
[oracle Security Developers Guide](https://docs.oracle.com/en/java/javase/11/security/java-cryptography-architecture-jca-reference-guide.html)\r
\r
Desde el punto de vista de la seguridad, el conjunto de clases de seguridad distribuidas con el SDK de Java 2 pueden dividirse en dos subconjuntos:\r
\r
- Clases relacionadas con el control de acceso y la gestión de permisos.\r
- Clases relacionadas con la Criptografía.\r
\r
Java incluye APIs de acceso a funciones criptográficas de propósito general, conocidas como la **Arquitectura Criptográfica de Java o Java Cryptography Architecture (JCA)** y la **Extension Criptográfica de Java o Java Cryptography Extension (JCE)**.\r
\r
El JCA está formado por las clases básicas relacionadas con criptografía distribuidas con el JDK y el soporte para la encriptación lo proporciona el paquete de extensión JCE.\r
\r
Java también incluye un conjunto de paquetes para la comunicación segura en Internet, conocidos como la **Extensión de Sockets Seguros de Java o Java Secure Socket Extension (JSSE)**. Implementa una versión Java de los protocolos SSL y TLS, además incluye funcionalidades como cifrado de datos, autenticación del servidor, integridad de mensajes y autenticación del cliente.\r
\r
Por último Java incluye una interfaz que permite a las aplicaciones Java acceder a servicios de control de autenticación y acceso, el **Servicio de Autentificación y Autorización de Java o Java Authentication and Authorization Service (JAAS)**. Puede usarse con dos fines: la autenticación de usuarios para conocer quién está ejecutando código Java; y la autorización de usuarios para garantizar que quién lo ejecuta tiene los permisos necesarios para hacerlo.\r
\r
### JCA: Engines, algoritmos y proveedores\r
\r
Java tiene una Arquitectura de Proveedores, que permite que coexistan multiples implementaciones de algoritmos criptográficos (es decir multiples implementaciones del JCE). La plataforma Java 2 extiende substancialmente la JCA, entre otras cosas se ha mejorado la infraestructura de gestión de certificados para soportar los certificados X.509 V3.\r
\r
Para comprender el funcionamiento del JCA tenemos que definir algunos términos básicos:\r
\r
#### Engine\r
\r
En el contexto del JCA utilizamos el término motor (engine) para referirnos a una representación abstracta de un servicio criptográfico que no tiene una implementación concreta. Un servicio criptográfico siempre está asociado con un algoritmo o tipo de algoritmo y puede tener alguna de las siguientes funciones:\r
\r
- Proporcionar operaciones criptográficas (como las empleadas en el firmado y el resumen de mensajes)- Generar o proporcionar el material criptográfico (claves o parámetros) necesario para realizar las operaciones.\r
- Generar objetos (almacenes de claves o certificados) que agrupen claves criptográficas de modo seguro.\r
\r
#### Algoritmo\r
\r
Un algoritmo es una implementación de un motor. Por ejemplo, el algoritmo MD5 es una implementación del motor de algoritmos de resumen de mensajes. La implementación interna puede variar dependiendo del código que proporcione la clase MD5.\r
\r
#### Proveedor\r
\r
Un proveedor es el encargado de proporcionar la implementación de uno o varios algoritmos al programador (es decir, darle acceso a una implementación interna concreta de los algoritmos).\r
\r
## 6.1.3. Proveedores\r
\r
La JCA define el concepto de proveedor mediante la clase Provider del paquete java.security. Se trata de una clase abstracta que debe ser redefinida por clases proveedor específicas.\r
\r
El constructor de una clase proveedor ajusta los valores de varias propiedades que necesita el API de seguridad de Java para localizar los algoritmos u otras facilidades implementadas por el proveedor.\r
\r
La clase Provider tiene métodos para acceder al nombre del proveedor, el número de versión y otras informaciones sobre las implementaciones de los algoritmos para la generación, conversión y gestión de claves y la generación de firmas y resúmenes.\r
\r
Si un programador desea saber los proveedores disponibles puede emplear los métodos\r
\r
- getProvider("nombre") para saber si un proveedor concreto está instalado\r
- getProviders() que retorna un vector de cadenas con los nombres de los proveedores\r
\r
::: info Archivo java.security\r
%JAVA_HOME%/conf/security/java.security es el archivo que contiene la información de la configuración de seguridad que utilizan las clases de la JCA.\r
\r
Ahí están declarados todos los proveedores y algoritmos que están disponibles, así como el orden en el que las clases los buscarán.\r
:::\r
\r
Para entender como funcionan los proveedores daremos un ejemplo. Supongamos que un programa necesita una implementación del algoritmo MD5. Para obtenerla el programador necesita crear una instancia del mismo y lo hará escribiendo la siguiente línea de código:\r
\r
\`\`\`java\r
MessageDigest m = MessageDigest.getInstance("MD5");\r
\`\`\`\r
\r
Internamente, el método getInstance() solicita a la clase java.security.Security que le proporcione el objeto solicitado. Como no se ha especificado proveedor la clase Security consulta a todos los proveedores disponibles, solicitando una implementación del algoritmo "MD5", hasta que encuentra una o se queda sin proveedores. La consulta se realiza según la lista de proveedores del archivo java.security, que por defecto sólo contiene la entrada:\r
\r
Security.provider.1=sun.security.provider.Sun\r
\r
## 6.1.4. Engines\r
\r
En el JDK el JCA define las siguientes clases Engine\r
\r
| Clase JCA | Función |\r
|---|---|\r
|java.security.MessageDigest | Calculo de resumen de mensajes (hash).|\r
|java.security.Signature| Firma de datos y verificación firmas.|\r
|java.security.KeyPairGenerator | Generar pares de claves (pública y privada) para un algoritmo.|\r
|java.security.KeyFactory| Convertir claves de formato criptográfico, especificaciones de claves y viceversa|\r
|java.security.certificate.CertificateFactory| Crear certificados de clave pública y listas de revocación(CRLs).|\r
|java.security.KeyStore | Crear y gestionar un almacén de claves (keystore).|\r
|java.security.AlgorithmParameters | Gestionar los parámetros de un algoritmo, incluyendo codificación y descodificación.|\r
|java.security.AlgorithmParameterGenerator | Generar un conjunto de parámetros para un algoritmo.|\r
|java.security.SecureRandom | Generar números aleatorios o pseudo aleatorios.|\r
\r
Para instanciar una clase motor se debe invocar el método estático *getInstance()*, si se le pasa un nombre de algoritmo se intentará obtener una implementación de algún proveedor.\r
\r
### 6.1.5. Algoritmos\r
\r
Al igual que pasa con las herramientas de línea de comandos, debemos saber qué algoritmos están disponibles para su uso por las aplicaciones en nuestra máquina virtual.\r
\r
El siguiente programa nos permite saber que proveedores y algoritmos tenemos instalados en nuestro sistema.\r
\r
Además, si lo invocamos con la opción -l nos dirá que algoritmos implementan (leyendo las propiedades del proveedor)\r
\r
Toda la información mostrada se extrae del archivo *java.security*\r
\r
\`\`\`java\r
class U6S1_1_InfoProveedoresJCA {\r
\r
    public static void main(String[] args) {\r
        boolean listarProps = false;\r
        if (args.length > 0 && args[0].equals("-l")) {\r
            listarProps = true;\r
        }\r
        System.out.println("------------------------------------");\r
        System.out.println("Proveedores instalados en su sistema");\r
        System.out.println("------------------------------------");\r
        int i = 0;\r
        for (Provider proveedor: Security.getProviders()) {\r
            System.out.println("Núm. proveedor : " + (i + 1));\r
            System.out.println("Nombre         : " + proveedor.getName());\r
            System.out.println("Versión        : " + proveedor.getVersion());\r
            System.out.println("Información    :\\n  " + proveedor.getInfo());\r
            System.out.println("Propiedades    :");\r
            if (listarProps) {\r
                Enumeration propiedades = proveedor.propertyNames();\r
                while (propiedades.hasMoreElements()) {\r
                    String clave = (String) propiedades.nextElement();\r
                    String valor = proveedor.getProperty(clave);\r
                    System.out.println("  " + clave + " = " + valor);\r
                }\r
            }\r
            System.out.println("------------------------------------");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
El siguiente programa nos permite comprobar las propiedades de los algoritmos disponibles en nuestro sistema.\r
\r
\`\`\`java\r
class U6_S1_2_ProbarAlgoritmosJCA {\r
\r
    public static void main(String[] args) {\r
        if (args.length != 1) {\r
            System.out.println("Uso: java ProbarAlgoritmosJCA <algoritmo>");\r
            System.exit(1);\r
        }\r
        try {\r
            MessageDigest md = MessageDigest.getInstance(args[0]);\r
            System.out.println("Algoritmo: " + md.getAlgorithm());\r
            System.out.println("Proveedor: " + md.getProvider().getName());\r
            System.out.println("Info     : " + md.toString());\r
            System.out.println("Tamaño   : " + md.getDigestLength());\r
            System.out.println("Bloque   : " + md.getBlockSize());\r
            System.out.println("Entrada  : " + md.getInputSize());\r
            System.out.println("Salida   : " + md.getOutputSize());\r
            System.out.println("Implement: " + md.getClass().getName());\r
        } catch (NoSuchAlgorithmException e) {\r
            System.out.println("Algoritmo no disponible");\r
        }\r
    }\r
}\r
\`\`\`\r
\r
\r
`]},{title:"6.3 Encriptación simétrica",headers:[{level:2,title:"6.3.1. Clave secreta",slug:"_6-3-1-clave-secreta",link:"#_6-3-1-clave-secreta",children:[]},{level:2,title:"6.3.2. Cipher",slug:"_6-3-2-cipher",link:"#_6-3-2-cipher",children:[{level:3,title:"Transformaciones básicas en Java",slug:"transformaciones-basicas-en-java",link:"#transformaciones-basicas-en-java",children:[]}]},{level:2,title:"6.3.3. Clases stream para cifrado y descifrado simétrico",slug:"_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",link:"#_6-3-3-clases-stream-para-cifrado-y-descifrado-simetrico",children:[]},{level:2,title:"6.3.4. Cifrado simétrico con GnuPG",slug:"_6-3-4-cifrado-simetrico-con-gnupg",link:"#_6-3-4-cifrado-simetrico-con-gnupg",children:[]}],path:"/es/unit6/symmetric-key.html",pathLocale:"/es/",extraFields:[`---\r
title: 6.3 Encriptación simétrica\r
# Frontmatter para guardar imágenes generadas por MDE\r
#markdown: \r
# image_dir: /docs/.vuepress/public/media\r
#export_on_save:\r
# markdown: true\r
---\r
\r
<DownloadPDF-component />\r
\r
<DocumentCover-component titulo="6.3 Encriptación simétrica" />\r
\r
# 6.3 Encriptación simétrica\r
\r
[[toc]]\r
\r
## 6.3.1. Clave secreta\r
\r
Ahora nos interesa no sólo verificar la integridad de la información intercambiada, sino también mantener su privacidad, es decir, que no sea "comprensible" durante la transmisión, intercambio o almacenamiento. \r
\r
Tenemos un conjunto de algoritmos denominados de **clave simétrica** (también conocidos como de clave secreta) en los que, mediante la aplicación de una clave conocida tanto por el emisos como por el receptor, la información se **encripta o cifra** de forma que sólo pueda ser **desencriptada o descifrada** utilizando el mismo algoritmo y la misma clave.\r
\r
::: info El código Enigma\r
Como ejemplo de sistema simétrico está Enigma. Este fue un sistema empleado por Alemania durante la Segunda Guerra Mundial, en el que las claves se distribuían a diario en forma de libros de códigos. \r
\r
Cada día, un operador de radio, receptor o transmisor, consultaba su copia del libro de códigos para encontrar la clave del día. Todo el tráfico enviado por ondas de radio durante aquel día era cifrado y descifrado usando las claves del día.\r
\r
Inglaterra usó máquinas para descifrar las claves durante aquella guerra y aunque el citado sistema alemán, Enigma, estaba provisto de un amplio abanico de claves, los ingleses diseñaron máquinas de cómputo especializado, los Bombes, para comprobar las claves de modo mecánico hasta que la clave del día era encontrada. \r
\r
Esto significaba que algunas veces encontraban la clave del día pocas horas después de que ésta fuera puesta en uso, pero también que otros días no podían encontrar la clave correcta. \r
\r
Los Bombes no fueron máquinas de cómputo general, sino las precursoras de los ordenadores (computadoras) actuales.\r
:::\r
\r
Entre los algoritmos de cifrado simétrico más utilizados se encuentran\r
\r
- DES\r
- 3DES o Tiple DES\r
- RC5\r
- AES\r
- Blowfish\r
- IDEA\r
\r
![cifrado simétrico](../../media/unit6/symmetric-encryption-primitive.png)\r
\r
## 6.3.2. Cipher\r
\r
Para cifrar y descifrar un mensaje necesitamos una clave y escoger el tipo de cifrado que queremos. En JCA se procede de la siguiente forma:\r
\r
1. Se crea un objeto de la clase *SecretKey* a partir de un KeyGenerator obtenido con el método estático *getInstance()*, especificando el nombre del algoritmo. Opcionalmente, se puede especificar el nombre del proveedor.\r
2. Así podemos utilizar una clave prefijada o incluso una clave aleatoria de tipo OTP (One Time Password) ya que cada vez que ejecutemos el programa la clave será diferente.\r
3. Se crea un objeto de tipo Cipher indicando qué algoritmo vamos a usar. Y después, con el método *init()* se indica qué vamos a hacer (cifrar/descifrar) y con qué clave.\r
4. Se añaden datos con el método *update()*. Se puede añadir un byte o un array de bytes. Este método se puede invocar varias veces para ir añadiendo nuevos datos.\r
5. Se obtiene el valor cifrado con el método *doFinal()*.\r
6. Si se quisiera descifrar, sólo hay que volver a invocar al método *init()* indicando en este caso que queremos descifrar.\r
\r
A continuación podemos ver un ejemplo\r
\r
\`\`\`java\r
public class U6S3_1_SecretKeyEncrypt {\r
\r
    public static void main(String[] args) {\r
        SecretKey claveSecreta = null;\r
        \r
        try {\r
\r
            //Generamos clave secreta\r
            // Podemos crear una nueva clave\r
            claveSecreta = getNewKey();\r
            // O bien usar una clave guardada en algún almacén, fichero, etc.\r
            claveSecreta = getKeyFromData();\r
\r
            System.out.println("Clave usada: " + claveSecreta.getFormat());\r
            //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
            Cipher c = Cipher.getInstance("DESede"); // AES/ECB/PKCS5Padding\r
            // Configuramos el modo de CIFRADO\r
            c.init(Cipher.ENCRYPT_MODE, claveSecreta);\r
\r
            // Aquí leemos la información que queremos cifrar\r
            // Puede ser una cadena o leerla de un archivo\r
            byte[] textoPlano = "Texto que queremos cifrar para la prueba".getBytes();\r
            \r
            // Si queremos ir cifrando poco a poco, vamos haciendo llamadas\r
            // al método update\r
            // c.update(textoPlano);\r
            // Se realiza el proceso final de cifrado de la información\r
            byte[] textoCifrado = c.doFinal(textoPlano);\r
            System.out.println("Texto cifrado con clave secreta (raw):\\n" + new String(textoCifrado));\r
            System.out.println("Texto cifrado con clave secreta (hex):\\n" + toHexadecimal(textoCifrado));\r
                        \r
            \r
            // El proceso de descifrado es equivalente\r
            // Cambiamos el modo de ENCRYPT a DECRYPT\r
            // Usamos la misma clave\r
            // Pasamos el texto cifrado para obtener el original\r
            c.init(Cipher.DECRYPT_MODE, claveSecreta);\r
            byte[] textoOriginal = c.doFinal(textoCifrado);\r
            //Leemos bloques de bytes del fichero y lo vamos escribiendo ya cifrado en el fichero de salida\r
            System.out.println("Texto descifrado:\\n" + new String(textoOriginal));\r
            \r
        } catch (Exception e) {\r
            e.printStackTrace();\r
        }\r
    }\r
\r
    static SecretKey getNewKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
    \r
            KeyGenerator kg = KeyGenerator.getInstance("DESede");\r
            kg.init(112);\r
            SecretKey clave = kg.generateKey();\r
            \r
            return clave;\r
    }\r
\r
    static SecretKey getNewRandomKey() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // Clave obtenida usando un generador de número aleatorios seguro\r
        KeyGenerator genClaves = KeyGenerator.getInstance("DESede");\r
        // Utilizamos un algoritmo de generación de aleatorios        \r
        SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");\r
        genClaves.init(srand);\r
        \r
        SecretKey clave = genClaves.generateKey();\r
        System.out.println("Formato de clave: " + clave.getFormat());\r
        \r
        /*\r
        SecretKeyFactory keySpecFactory = SecretKeyFactory.getInstance("DESede");\r
        DESedeKeySpec keySpec = (DESedeKeySpec) keySpecFactory.getKeySpec(clave, DESedeKeySpec.class);\r
        byte[] valorClave = keySpec.getKey();\r
        */\r
        \r
        return clave;\r
    }\r
    \r
    static SecretKey getKeyFromData() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        SecretKeySpec keySpec = new SecretKeySpec (valorClave, "DESede");\r
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("DESede");\r
        SecretKey clave = keyFactory.generateSecret(keySpec);\r
        \r
        return clave;\r
    }\r
\r
    static Key getKeyFromData2() throws InvalidKeySpecException, NoSuchAlgorithmException {\r
        // La clave se puede obtener desde un fichero o cualquier otra fuente\r
        byte valorClave[] = "12345678123456781234567812345678".getBytes();\r
        Key clave = new SecretKeySpec(valorClave, "AES");\r
\r
        return clave;\r
    }\r
\r
    static String toHexadecimal(byte[] hash) {\r
        String hex = "";\r
        for (int i = 0; i < hash.length; i++) {\r
            String h = Integer.toHexString(hash[i] & 0xFF);\r
            if (h.length() == 1) {\r
                hex += "0";\r
            }\r
            hex += h;\r
        }\r
        return hex.toUpperCase();\r
    }\r
    \r
}\r
\`\`\`\r
\r
y esta sería la salida proporcionada\r
\r
\`\`\`sh\r
Texto cifrado con clave secreta:\r
D0A61CD14B5844AD98B2C7BA795B327ACA0795B658C6F93EC6E1586A246BE71AC180B574207E8C4FFEB959B7D4642FCB\r
Texto descifrado:\r
Texto que queremos cifrar para la prueba\r
\`\`\`\r
\r
Hay que tener en cuenta que en el ejemplo la clave se está usando primero para cifrar y luego para descifrar. Si esto lo hacemos en programas separados, los programas que quieran comunicarse deberán tener acceso a la clave.\r
\r
Lo que se suele hacer es almacenar la clave en un archivo y, cuando se necesita para cifrar o descifrar, se lee con un método similar al método *getKeyFromData()* del ejemplo anterior.\r
\r
### Transformaciones básicas en Java\r
\r
En la siguiente tabla tenemos los algoritmos, modos y tipos de relleno, junto con la longitud de clave empleada, de los algoritmos de cifrado simétrico m'as comunes.\r
\r
|Transformación (algoritmo/modo/relleno)|Key Size|\r
|---|---|\r
|AES/CBC/NoPadding|128|\r
|AES/CBC/PKCS5Padding|128|\r
|AES/ECB/NoPadding|128|\r
|AES/ECB/PKCS5Padding|128|\r
|DES/CBC/NoPadding|56|\r
|DES/CBC/PKCS5Padding|56|\r
|DES/ECB/NoPadding|56|\r
|DES/ECB/PKCS5Padding|56|\r
|DESede/CBC/NoPadding|168|\r
|DESede/CBC/PKCS5Padding|168|\r
|DESede/ECB/NoPadding|168|\r
|DESede/ECB/PKCS5Padding|168|\r
|RSA/ECB/PKCS1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-1AndMGF1Padding|1024, 2048|\r
|RSA/ECB/OAEPWithSHA-256AndMGF1Padding|1024, 2048|\r
\r
\r
## 6.3.3. Clases stream para cifrado y descifrado simétrico\r
\r
Existen dos clases stream que permiten cifrar y descifrar directamente. Pertenecen al paquete *java.crypto* pero por lo demás funcionan exactamente igual que las clases Stream del paquete *java.io*, de las que además son clases descendientes y y tienen constructores que permiten crear streams encriptados sobre un InputStream y un OutputStream.\r
\r
| Clase |Ejemplo |\r
| --- | --- |\r
| CipherInputStream | CipherInputStream (InputStream is, Cipher c) |\r
| CipherOutputStream | CipherOutputStream (OutputStream os, Cipher c) |\r
\r
Por lo tanto, cuando tenemos que leer o escribir información, podemos añadir un envoltorio más al wrapper que utilizamos habitualmente y esto nos permite que tanto las lecturas como las escrituras se hagan cifradas, usando el algoritmo y la clave definidos para el objeto Cipher.\r
\r
El uso más común es para leer o escribir en archivos en los que, de igual forma, cambiando el wrapper nos permite leer o escribir la información de forma cifrada/descifrada.\r
\r
::: warning Tamaño de bloque\r
Muchos de los algoritmos de cifrado simétrico trabajan con bloques de datos, por lo que no debemos intentar cifrar o descifrar más información de la que permite el tamaño de bloque.\r
\r
La clase Cipher tiene un método **getBlockSize()** que nos devuelve el tamaño de bloque que permite el algoritmo configurado en su método **init()**.\r
:::\r
\r
Veamos un ejemplo de cómo quedaría el wrapper\r
\r
\`\`\`java\r
public class U6S3_2_StreamCrypto {\r
\r
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\r
        File file;\r
        String filePath = "a.txt";\r
\r
        file = new File(filePath);\r
\r
        //Se define el objeto Cipher (Algoritmo/modo/relleno)\r
        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding"); //DESede\r
        // Configuramos el modo de CIFRADO\r
        byte[] valorClave = "12345678123456781234567812345678".getBytes();\r
\r
        // CIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.ENCRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (OutputStream outputStream = new BufferedOutputStream(\r
                new CipherOutputStream(new FileOutputStream(file), c))) {\r
            for (int i = 0; i < 10; i++) {\r
                outputStream.write(new String("Hello World\\n").getBytes());\r
            }\r
\r
        }\r
\r
        // DESCIFRADO DEL STREAM (fichero a.txt)\r
        c.init(Cipher.DECRYPT_MODE,\r
                new SecretKeySpec(valorClave, "AES"));\r
\r
        try (InputStream inputStream = new BufferedInputStream(\r
                new CipherInputStream(new FileInputStream(file), c))) {\r
\r
            System.out.println("Contenido del fichero (descifrado):\\n" + new String(inputStream.readAllBytes()));\r
        }\r
\r
    }\r
}\r
\`\`\`\r
\r
## 6.3.4. Cifrado simétrico con GnuPG\r
\r
Con la suite GnuPG también podemos cifrar el contenido de los archivos usando diferentes algoritmos\r
\r
::: info Algoritmos disponibles para GnuPG\r
Para ver la lista de algoritmos disponibles tenemos que mostrar la ayuda del comando\r
\r
> gpg --help\r
\r
y en la parte superior observamos la información de los algoritmos disponibles para cada tipo de servicio. En concreto, de resúmenes, en mi versión instalada:\r
\r
Cifrado: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\r
         CAMELLIA128, CAMELLIA192, CAMELLIA256\r
:::\r
\r
Para cifrar y descifrar un archivo, ejecutamos los siguientes comandos\r
\r
\`\`\`sh\r
gpg --symmetric --cipher-algo 3DES filename.ext\r
gpg --decrypt filename.ext.gpg\r
\`\`\`\r
\r
Vemos que para el cifrado nos solicita una clave y que con el parámetro *--cipher-algo* indicamos qué algoritmo de encriptación queremos utilizar.\r
\r
El cifrado genera un archivo filename.ext.gpg.\r
\r
Para el descifrado, no hace falta indicar el algoritmo, aunque se puede volver a usar el parámetro *--cipher-algo* y la clave se queda en una cache de GnuPG durante un tiempo, por lo que no siempre la solicita.\r
`]},{title:"",headers:[],path:"/404.html",pathLocale:"/",extraFields:[""]}],mg=fe(ug),pg=()=>mg,hg=({searchIndex:e,routeLocale:r,query:n,maxSuggestions:a})=>{const o=N(()=>e.value.filter(t=>t.pathLocale===r.value));return N(()=>{const t=n.value.trim().toLowerCase();if(!t)return[];const s=[],l=(i,c)=>{ds(t,[c.title])&&s.push({link:`${i.path}#${c.slug}`,title:i.title,header:c.title});for(const d of c.children){if(s.length>=a.value)return;l(i,d)}};for(const i of o.value){if(s.length>=a.value)break;if(ds(t,[i.title,...i.extraFields])){s.push({link:i.path,title:i.title});continue}for(const c of i.headers){if(s.length>=a.value)break;l(i,c)}}return s})},gg=e=>{const r=fe(0);return{focusIndex:r,focusNext:()=>{r.value<e.value.length-1?r.value+=1:r.value=0},focusPrev:()=>{r.value>0?r.value-=1:r.value=e.value.length-1}}},fg=ue({name:"SearchBox",props:{locales:{type:Object,required:!1,default:()=>({})},hotKeys:{type:Array,required:!1,default:()=>[]},maxSuggestions:{type:Number,required:!1,default:5}},setup(e){const{locales:r,hotKeys:n,maxSuggestions:a}=qa(e),o=$r(),t=bn(),s=pg(),l=fe(null),i=fe(!1),c=fe(""),d=N(()=>r.value[t.value]??{}),u=hg({searchIndex:s,routeLocale:t,query:c,maxSuggestions:a}),{focusIndex:m,focusNext:f,focusPrev:w}=gg(u);dg({input:l,hotKeys:n});const P=N(()=>i.value&&!!u.value.length),k=()=>{P.value&&w()},v=()=>{P.value&&f()},S=x=>{if(!P.value)return;const A=u.value[x];A&&o.push(A.link).then(()=>{c.value="",m.value=0})};return()=>ce("form",{class:"search-box",role:"search"},[ce("input",{ref:l,type:"search",placeholder:d.value.placeholder,autocomplete:"off",spellcheck:!1,value:c.value,onFocus:()=>i.value=!0,onBlur:()=>i.value=!1,onInput:x=>c.value=x.target.value,onKeydown:x=>{switch(x.key){case"ArrowUp":{k();break}case"ArrowDown":{v();break}case"Enter":{x.preventDefault(),S(m.value);break}}}}),P.value&&ce("ul",{class:"suggestions",onMouseleave:()=>m.value=-1},u.value.map(({link:x,title:A,header:G},Z)=>ce("li",{class:["suggestion",{focus:m.value===Z}],onMouseenter:()=>m.value=Z,onMousedown:()=>S(Z)},ce("a",{href:x,onClick:M=>M.preventDefault()},[ce("span",{class:"page-title"},A),G&&ce("span",{class:"page-header"},`> ${G}`)]))))])}});const vg={"/en/":{placeholder:"Search"},"/es/":{placeholder:"Buscar"}},bg=["s","/"],yg=5,Sg=wr({enhance({app:e}){e.component("SearchBox",r=>ce(fg,{locales:vg,hotKeys:bg,maxSuggestions:yg,...r}))}});const wg={};function Pg(){const e=fe(!1);return Do()&&He(()=>{e.value=!0}),e}function Eg(e){return Pg(),N(()=>!!e())}const kg=()=>Eg(()=>typeof window<"u"&&window.navigator&&"userAgent"in window.navigator),Cg=()=>{const e=kg();return N(()=>e.value&&/\b(?:Android|iPhone)/i.test(navigator.userAgent))},jg=e=>{const r=bn();return N(()=>e[r.value])},qg=250,Ig=3e3,Ag={"/en/":{copy:"Copy code",copied:"Copied",hint:"Copied successfully"},"/es/":{copy:"Copiar código",copied:"Copiado",hint:"Copiado con éxito"},"/":{copy:"Copy code",copied:"Copied",hint:"Copied successfully"}},xg=!1,Tg=['.theme-default-content div[class*="language-"] pre'],us=!1,Xa=new Map,_g=()=>{const{copy:e}=Mm({legacy:!0}),r=jg(Ag),n=_r(),a=Cg(),o=l=>{if(!l.hasAttribute("copy-code-registered")){const i=document.createElement("button");i.type="button",i.classList.add("copy-code-button"),i.innerHTML='<div class="copy-icon" />',i.setAttribute("aria-label",r.value.copy),i.setAttribute("data-copied",r.value.copied),l.parentElement&&l.parentElement.insertBefore(i,l),l.setAttribute("copy-code-registered","")}},t=()=>Hn().then(()=>new Promise(l=>{setTimeout(()=>{Tg.forEach(i=>{document.querySelectorAll(i).forEach(o)}),l()},qg)})),s=(l,i,c)=>{let{innerText:d=""}=i;/language-(shellscript|shell|bash|sh|zsh)/.test(l.classList.toString())&&(d=d.replace(/^ *(\$|>) /gm,"")),e(d).then(()=>{c.classList.add("copied"),clearTimeout(Xa.get(c));const u=setTimeout(()=>{c.classList.remove("copied"),c.blur(),Xa.delete(c)},Ig);Xa.set(c,u)})};He(()=>{(!a.value||us)&&t(),Pa("click",l=>{const i=l.target;if(i.matches('div[class*="language-"] > button.copy')){const c=i.parentElement,d=i.nextElementSibling;d&&s(c,d,i)}else if(i.matches('div[class*="language-"] div.copy-icon')){const c=i.parentElement,d=c.parentElement,u=c.nextElementSibling;u&&s(d,u,c)}}),er(()=>n.value.path,()=>{(!a.value||us)&&t()})})};var Lg=wr({setup:()=>{_g()}});const sa=[Qu,rm,tm,cm,hm,Gh,Vh,tg,Sg,wg,Lg],Rg=[["v-8daa1a0e","/",{title:""},["/README.md"]],["v-705d1b76","/test_page.html",{title:"PSP"},[":md"]],["v-2d0a870d","/en/",{title:"PSP - Documentation Site"},["/en/README.md"]],["v-2d0a87a8","/es/",{title:"PSP - Página  de documentación"},["/es/README.md"]],["v-5aa74f15","/en/unit1/concurrency.html",{title:"1.2 Concurrency"},[":md"]],["v-b73e5022","/en/unit1/",{title:"1 Introduction"},["/en/unit1/index.md"]],["v-4b0532d0","/en/unit1/operatingsystem.html",{title:"1.3 Processes in the OS"},[":md"]],["v-3f423939","/en/unit1/process.html",{title:"1.1 Processes, programs, threads"},[":md"]],["v-0532b77b","/en/unit2/console_annex.html",{title:"2.4 Annex I - System properties and console programming"},[":md"]],["v-8100edac","/en/unit2/curl_annex.html",{title:"2.5 Annex II - Curl"},[":md"]],["v-b73e4fe4","/en/unit2/",{title:"2 Introduction"},["/en/unit2/index.md"]],["v-74406b7a","/en/unit2/iostreams.html",{title:"2.3 Handling Process Streams"},[":md"]],["v-ecf5776a","/en/unit2/ipc.html",{title:"2.1 Interprocess communication"},[":md"]],["v-348bab3f","/en/unit2/processbuilder.html",{title:"2.2 Process management in Java - ProcessBuilder and Process"},[":md"]],["v-1daecb0f","/en/unit2/runtime.html",{title:"2.1 Running processes in Java with Runtime"},[":md"]],["v-5bb12cb4","/en/unit3/alternatives.html",{title:"3.4 Alternative synchronization techniques"},[":md"]],["v-10f2297a","/en/unit3/arraylist_annex.html",{title:"3.6 Annex II - ArrayList cheat sheet by students"},[":md"]],["v-737de6d4","/en/unit3/debugger_annex.html",{title:"3.5 Annex I - Debugging multithread apps in Netbeans"},[":md"]],["v-3714d943","/en/unit3/hashmap_annex.html",{title:"3.7 Annex III - HashMap cheat sheet by students"},[":md"]],["v-b73e4fa6","/en/unit3/",{title:"3 Introduction"},["/en/unit3/index.md"]],["v-30e3afd6","/en/unit3/producer-consumer.html",{title:"3.3 Producer-Consumer model"},[":md"]],["v-27271e62","/en/unit3/runnable.html",{title:"3.1 Java classes for threads"},[":md"]],["v-1dbfca26","/en/unit3/synchronization.html",{title:"3.2 Threads synchronization and communication"},[":md"]],["v-b73e4f68","/en/unit4/",{title:"4 Introduction"},["/en/unit4/index.md"]],["v-14f705b1","/en/unit4/sockets-tcp.html",{title:"4.2 TCP Sockets"},[":md"]],["v-9c83245e","/en/unit4/sockets-udp.html",{title:"4.3 UDP Sockets"},[":md"]],["v-17f557b3","/en/unit4/stateful-protocols.html",{title:"4.4 Stateful protocols"},[":md"]],["v-de8e734c","/en/unit4/tcp-ip.html",{title:"4.1 TCP IP protocol stack"},[":md"]],["v-1885fe22","/en/unit5/ftp.html",{title:"5.2 FTP Client"},[":md"]],["v-71b551b1","/en/unit5/gmail_annex.html",{title:"5.4 Annex I - GMail configurations"},[":md"]],["v-b73e4f2a","/en/unit5/",{title:"5 Introduction"},["/en/unit5/index.md"]],["v-44aca577","/en/unit5/mail.html",{title:"5.1 Mail"},[":md"]],["v-7768b66a","/en/unit5/urls.html",{title:"5.3 Auxiliary classes for networking"},[":md"]],["v-6e11e1d8","/en/unit6/asymmetric-keys.html",{title:"6.4 Encriptación asimétrica"},[":md"]],["v-4e4467f3","/en/unit6/hash-functions.html",{title:"6.2 Hash functions"},[":md"]],["v-b73e4eec","/en/unit6/",{title:"6 Introduction"},["/en/unit6/index.md"]],["v-6fa59714","/en/unit6/jsse.html",{title:"6.5 Comunicaciones seguras en Java"},[":md"]],["v-2c8673f4","/en/unit6/log4j_annex.html",{title:"6.6 Anexo I - Logs library Log4Java2"},[":md"]],["v-2e9c294f","/en/unit6/security.html",{title:"6.1 Security"},[":md"]],["v-0b29848c","/en/unit6/symmetric-key.html",{title:"6.3 Encriptación simétrica"},[":md"]],["v-46af1970","/es/unit1/concurrency.html",{title:"1.2 Concurrencia"},[":md"]],["v-a8728f6c","/es/unit1/",{title:"1 Introducción"},["/es/unit1/index.md"]],["v-e2dae91a","/es/unit1/operatingsystem.html",{title:"1.3 Procesos en el SO"},[":md"]],["v-75292dd8","/es/unit1/process.html",{title:"1.1 Procesos, programas, hilos"},[":md"]],["v-0e715716","/es/unit2/console_annex.html",{title:"2.4 Anexo I - Propiedades del sistema y programación en consola"},[":md"]],["v-3277876f","/es/unit2/curl_annex.html",{title:"2.5 Anexo II - Curl"},[":md"]],["v-a8728f2e","/es/unit2/",{title:"2 Introducción"},["/es/unit2/index.md"]],["v-14dd1095","/es/unit2/iostreams.html",{title:"2.3 Gestión de la E-S de un proceso"},[":md"]],["v-1d42ccb4","/es/unit2/ipc.html",{title:"2.1 Comunicación entre procesos"},[":md"]],["v-5320ff04","/es/unit2/processbuilder.html",{title:"2.2 Gestión de procesos en Java - ProcessBuilder y Process"},[":md"]],["v-b8500a2c","/es/unit2/runtime.html",{title:"2.1 Creación de procesos en Java con Runtime"},[":md"]],["v-6718eaab","/es/unit3/alternatives.html",{title:"3.4 Mecanismos alternativos de sincronización"},[":md"]],["v-75f16356","/es/unit3/arraylist_annex.html",{title:"3.6 Anexo II - ArrayList hoja de referencia de los alumnos"},[":md"]],["v-36533f4a","/es/unit3/debugger_annex.html",{title:"3.5 Anexo I - Debugging aplicaciones multihilo en Netbeans"},[":md"]],["v-405378de","/es/unit3/hashmap_annex.html",{title:"3.7 Anexo III - HashMap hoja de referencia de los alumnos"},[":md"]],["v-a8728ef0","/es/unit3/",{title:"3 Introducción"},["/es/unit3/index.md"]],["v-2a24fba0","/es/unit3/producer-consumer.html",{title:"3.3 Modelo productor-consumidor"},[":md"]],["v-2b693c54","/es/unit3/runnable.html",{title:"3.1. Clases Java para la gestión de hilos"},[":md"]],["v-5c5621fe","/es/unit3/synchronization.html",{title:"3.2 Sincronización y comunicación de hilos"},[":md"]],["v-a8728eb2","/es/unit4/",{title:"4 Introducción"},["/es/unit4/index.md"]],["v-00fed00c","/es/unit4/sockets-tcp.html",{title:"4.2 Sockets TCP"},[":md"]],["v-c4738fa8","/es/unit4/sockets-udp.html",{title:"4.3 Sockets UDP"},[":md"]],["v-fefd7e10","/es/unit4/stateful-protocols.html",{title:"4.4 Protocolos con estado"},[":md"]],["v-d5e6a1c2","/es/unit4/tcp-ip.html",{title:"4.1 Pila de protocolos TCP IP"},[":md"]],["v-ff415906","/es/unit5/ftp.html",{title:"5.2 Cliente FTP"},[":md"]],["v-5dbd1c0c","/es/unit5/gmail_annex.html",{title:"5.4 Anexo I - Configuraciones GMail"},[":md"]],["v-a8728e74","/es/unit5/",{title:"5 Introducción"},["/es/unit5/index.md"]],["v-50040908","/es/unit5/mail.html",{title:"5.1 Correo"},[":md"]],["v-0aba0c6f","/es/unit5/urls.html",{title:"4.2 Clases auxiliares para direccionamiento"},[":md"]],["v-222706b3","/es/unit6/asymmetric-keys.html",{title:"6.4 Encriptación asimétrica"},[":md"]],["v-6cd9bbb8","/es/unit6/hash-functions.html",{title:"6.2 Funciones resumen"},[":md"]],["v-a8728e36","/es/unit6/",{title:"6 Introducción"},["/es/unit6/index.md"]],["v-02f6ed19","/es/unit6/jsse.html",{title:"6.5 Comunicaciones seguras en Java"},[":md"]],["v-188e3e4f","/es/unit6/log4j_annex.html",{title:"6.6 Anexo I - Librería de registro Log4Java2"},[":md"]],["v-6d98f4d4","/es/unit6/security.html",{title:"6.1 Seguridad"},[":md"]],["v-03a9dd55","/es/unit6/symmetric-key.html",{title:"6.3 Encriptación simétrica"},[":md"]],["v-3706649a","/404.html",{title:""},[]]];var ms=ue({name:"Vuepress",setup(){const e=Nd();return()=>ce(e.value)}}),Dg=()=>Rg.reduce((e,[r,n,a,o])=>(e.push({name:r,path:n,component:ms,meta:a},{path:n.endsWith("/")?n+"index.html":n.substring(0,n.length-5),redirect:n},...o.map(t=>({path:t===":md"?n.substring(0,n.length-5)+".md":t,redirect:n}))),e),[{name:"404",path:"/:catchAll(.*)",component:ms}]),Mg=lu,Og=()=>{const e=Wu({history:Mg(ci("/psp_pages/")),routes:Dg(),scrollBehavior:(r,n,a)=>a||(r.hash?{el:r.hash}:{top:0})});return e.beforeResolve(async(r,n)=>{var a;(r.path!==n.path||n===hr)&&([r.meta._data]=await Promise.all([pr.resolvePageData(r.name),(a=mi[r.name])==null?void 0:a.__asyncLoader()]))}),e},zg=e=>{e.component("ClientOnly",Fo),e.component("Content",Jd)},Ng=(e,r,n)=>{const a=os(()=>r.currentRoute.value.path),o=os(()=>pr.resolveRouteLocale(nn.value.locales,a.value)),t=Pm(a,()=>r.currentRoute.value.meta._data),s=N(()=>pr.resolveLayouts(n)),l=N(()=>pr.resolveSiteLocaleData(nn.value,o.value)),i=N(()=>pr.resolvePageFrontmatter(t.value)),c=N(()=>pr.resolvePageHeadTitle(t.value,l.value)),d=N(()=>pr.resolvePageHead(c.value,i.value,l.value)),u=N(()=>pr.resolvePageLang(t.value,l.value)),m=N(()=>pr.resolvePageLayout(t.value,s.value));return e.provide(Rd,s),e.provide(pi,t),e.provide(hi,i),e.provide(Od,c),e.provide(gi,d),e.provide(fi,u),e.provide(vi,m),e.provide(zo,o),e.provide(yi,l),Object.defineProperties(e.config.globalProperties,{$frontmatter:{get:()=>i.value},$head:{get:()=>d.value},$headTitle:{get:()=>c.value},$lang:{get:()=>u.value},$page:{get:()=>t.value},$routeLocale:{get:()=>o.value},$site:{get:()=>nn.value},$siteLocale:{get:()=>l.value},$withBase:{get:()=>Bo}}),{layouts:s,pageData:t,pageFrontmatter:i,pageHead:d,pageHeadTitle:c,pageLang:u,pageLayout:m,routeLocale:o,siteData:nn,siteLocaleData:l}},Fg=()=>{const e=Md(),r=zd(),n=fe([]),a=()=>{e.value.forEach(t=>{const s=Bg(t);s&&n.value.push(s)})},o=()=>{document.documentElement.lang=r.value,n.value.forEach(t=>{t.parentNode===document.head&&document.head.removeChild(t)}),n.value.splice(0,n.value.length),e.value.forEach(t=>{const s=Ug(t);s!==null&&(document.head.appendChild(s),n.value.push(s))})};Vr(Bd,o),He(()=>{a(),o(),er(()=>e.value,o)})},Bg=([e,r,n=""])=>{const a=Object.entries(r).map(([l,i])=>ve(i)?`[${l}=${JSON.stringify(i)}]`:i===!0?`[${l}]`:"").join(""),o=`head > ${e}${a}`;return Array.from(document.querySelectorAll(o)).find(l=>l.innerText===n)||null},Ug=([e,r,n])=>{if(!ve(e))return null;const a=document.createElement(e);return Oo(r)&&Object.entries(r).forEach(([o,t])=>{ve(t)?a.setAttribute(o,t):t===!0&&a.setAttribute(o,"")}),ve(n)&&a.appendChild(document.createTextNode(n)),a},Hg=jd,Jg=async()=>{var n;const e=Hg({name:"VuepressApp",setup(){var a;Fg();for(const o of sa)(a=o.setup)==null||a.call(o);return()=>[ce(Ti),...sa.flatMap(({rootComponents:o=[]})=>o.map(t=>ce(t)))]}}),r=Og();zg(e),Ng(e,r,sa);for(const a of sa)await((n=a.enhance)==null?void 0:n.call(a,{app:e,router:r,siteData:nn}));return e.use(r),{app:e,router:r}};Jg().then(({app:e,router:r})=>{r.isReady().then(()=>{e.mount("#app")})});export{Ce as _,he as a,Mr as b,ee as c,Jg as createVueApp,ne as d,je as e,Bc as f,U as o,yr as r,_e as t,Me as w};
